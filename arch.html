<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pandare.arch API documentation</title>
<meta name="description" content="This module contains architecture-specific code â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<!-- Bootstrap core CSS -->
<!--
<link href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css" rel="stylesheet">
-->
<!-- hand-crafted bootstrap navbar -->
<style>
.bg-light {
background-color: #f8f9fa!important;
}
.navbar {
position: relative;
display: -ms-flexbox;
display: flex;
-ms-flex-wrap: wrap;
flex-wrap: wrap;
-ms-flex-align: center;
align-items: center;
-ms-flex-pack: justify;
justify-content: space-between;
padding: .5rem 1rem;
}
.navbar-expand-lg {
-ms-flex-direction: row;
flex-direction: row;
-ms-flex-wrap: nowrap;
flex-wrap: nowrap;
-ms-flex-pack: start;
justify-content: flex-start;
}
navbar-light .navbar-brand {
color: rgba(0,0,0,.9);
}
.navbar-brand {
display: inline-block;
padding-top: .3125rem;
padding-bottom: .3125rem;
margin-right: 1rem;
font-size: 1.25rem;
line-height: inherit;
white-space: nowrap;
}
.navbar-nav {
display: -ms-flexbox;
display: flex;
-ms-flex-direction: column;
flex-direction: column;
padding-left: 0;
margin-bottom: 0;
list-style: none;
}
.navbar-expand-lg .navbar-nav {
-ms-flex-direction: row;
flex-direction: row;
}
.mr-auto {
margin-right: auto!important;
}
.navbar-expand-lg .navbar-collapse {
display: -ms-flexbox!important;
display: flex!important;
}
.navbar-collapse {
-ms-flex-preferred-size: 100%;
flex-basis: 100%;
-ms-flex-align: center;
align-items: center;
}
.navbar-light .navbar-brand {
color: rgba(0,0,0,.9);
}
.navbar a {
color: #007bff;
text-decoration: none;
background-color: transparent;
-webkit-text-decoration-skip: objects;
}
.navbar-expand-lg .navbar-nav .nav-link {
padding-right: .5rem;
padding-left: .5rem;
}
.navbar .navbar-nav {
margin: 0;
font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
font-size: 1rem;
font-weight: 400;
line-height: 1.5;
color: #212529;
}
.navbar-light .navbar-nav .active>.nav-link, .navbar-light .navbar-nav .nav-link.active, .navbar-light .navbar-nav .nav-link.show, .navbar-light .navbar-nav .show>.nav-link {
color: rgba(0,0,0,.9);
}
.navbar-light .navbar-nav .nav-link {
color: rgba(0,0,0,.5);
}
.nav-link {
display: block;
padding: .5rem 1rem;
}
</style>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-light">
<a class="navbar-brand" href="/">PANDA.re</a>
<div class="collapse navbar-collapse" id="navbarSupportedContent">
<ul class="navbar-nav mr-auto">
<li class="nav-item">
<a class="nav-link" href="//panda.re/">Home</a>
</li>
<li class="nav-item">
<a class="nav-link" target="_new" href="https://github.com/panda-re/panda">Github</a>
</li>
<li class="nav-item ">
<a class="nav-link" href="//panda.re/blog/">Blog</a>
</li>
<li class="nav-item ">
<a class="nav-link active" href="//docs.panda.re">Python Docs</a>
</li>
<li class="nav-item ">
<a class="nav-link" href="//panda.re/invite.php">Slack</a>
</li>
<!-- No resources tab here because we don't have real bootstrap -->
</div>
</nav>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pandare.arch</code></h1>
</header>
<section id="section-intro">
<p>This module contains architecture-specific code.</p>
<p>When the <code><a title="pandare.panda" href="panda.html">pandare.panda</a></code> class is initialized, it will automatically
initialize a PandaArch class for the specified architecture in the variable
<code>panda.arch</code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
This module contains architecture-specific code.

When the `pandare.panda` class is initialized, it will automatically
initialize a PandaArch class for the specified architecture in the variable
`panda.arch`.

&#39;&#39;&#39;
import binascii
import struct
from .utils import telescope

class PandaArch():
    &#39;&#39;&#39;
    Base class for architecture-specific implementations for PANDA-supported architectures
    &#39;&#39;&#39;
    def __init__(self, panda):
        &#39;&#39;&#39;
        Initialize a PANDA-supported architecture and hold a handle on the PANDA object
        &#39;&#39;&#39;
        self.panda = panda

        self.reg_sp      = None # Stack pointer register ID if stored in a register
        self.reg_pc      = None # PC register ID if stored in a register
        self.reg_retaddr = None # Register ID that contains return address
        self.reg_retval  = None # convention: register name that contains return val
        self.call_conventions = None # convention: [&#39;reg_for_arg0&#39;, &#39;reg_for_arg1&#39;,...]
        self.registers = {}
        &#39;&#39;&#39;
        Mapping of register names to indices into the appropriate CPUState array
        &#39;&#39;&#39;

    def _determine_bits(self):
        &#39;&#39;&#39;
        Determine bits and endianness for the panda object&#39;s architecture
        &#39;&#39;&#39;
        bits = None
        endianness = None # String &#39;little&#39; or &#39;big&#39;
        if self.panda.arch_name == &#34;i386&#34;:
            bits = 32
            endianness = &#34;little&#34;
        elif self.panda.arch_name == &#34;x86_64&#34;:
            bits = 64
            endianness = &#34;little&#34;
        elif self.panda.arch_name == &#34;arm&#34;:
            endianness = &#34;little&#34; # XXX add support for arm BE?
            bits = 32
        elif self.panda.arch_name == &#34;aarch64&#34;:
            bits = 64
            endianness = &#34;little&#34; # XXX add support for arm BE?
        elif self.panda.arch_name == &#34;ppc&#34;:
            bits = 32
            endianness = &#34;big&#34;
        elif self.panda.arch_name == &#34;mips&#34;:
            bits = 32
            endianness = &#34;big&#34;
        elif self.panda.arch_name == &#34;mipsel&#34;:
            bits = 32
            endianness = &#34;little&#34;
        elif self.panda.arch_name == &#34;mips64&#34;:
            bits = 64
            endianness = &#34;big&#34;

        assert (bits is not None), f&#34;Missing num_bits logic for {self.panda.arch_name}&#34;
        assert (endianness is not None), f&#34;Missing endianness logic for {self.panda.arch_name}&#34;
        register_size = int(bits/8)
        return bits, endianness, register_size

    def get_reg(self, cpu, reg):
        &#39;&#39;&#39;
        Return value in a `reg` which is either a register name or index (e.g., &#34;R0&#34; or 0)
        &#39;&#39;&#39;
        if isinstance(reg, str):
            reg = reg.upper()
            if reg == &#39;PC&#39;:
                return self.get_pc(cpu)
            if reg not in self.registers.keys():
                raise ValueError(f&#34;Invalid register name {reg}&#34;)
            else:
                reg = self.registers[reg]

        return self._get_reg_val(cpu, reg)

    def _get_reg_val(self, cpu, idx):
        &#39;&#39;&#39;
        Virtual method. Must be implemented for each architecture to return contents of register specified by idx.
        &#39;&#39;&#39;
        raise NotImplementedError()

    def set_reg(self, cpu, reg, val):
        &#39;&#39;&#39;
        Set register `reg` to a value where `reg` is either a register name or index (e.g., &#34;R0&#34; or 0)
        &#39;&#39;&#39;
        if isinstance(reg, str):
            reg = reg.upper()
            if reg not in self.registers.keys():
                raise ValueError(f&#34;Invalid register name {reg}&#34;)
            else:
                reg = self.registers[reg]
        elif not isinstance(reg, int):
            raise ValueError(f&#34;Can&#39;t set register {reg}&#34;)

        return self._set_reg_val(cpu, reg, val)

    def _set_reg_val(self, cpu, idx, val):
        &#39;&#39;&#39;
        Virtual method. Must be implemented for each architecture to return contents of register specified by idx.
        &#39;&#39;&#39;
        raise NotImplementedError()

    def get_pc(self, cpu):
        &#39;&#39;&#39;
        Returns the current program counter. Must be overloaded if self.reg_pc is None
        &#39;&#39;&#39;
        if self.reg_pc:
            return self.get_reg(cpu, self.reg_pc)
        else:
            raise RuntimeError(f&#34;get_pc unsupported for {self.panda.arch_name}&#34;)

    def _get_arg_loc(self, idx, convention):
        &#39;&#39;&#39;
        return the name of the argument [idx] for the given arch with calling [convention]
        &#39;&#39;&#39;

        if self.call_conventions and convention in self.call_conventions:
            if idx &lt; len(self.call_conventions[convention]):
                return self.call_conventions[convention][idx]
            raise NotImplementedError(f&#34;Unsupported argument number {idx}&#34;)
        raise NotImplementedError(f&#34;Unsupported convention {convention} for {type(self)}&#34;)

    def _get_ret_val_reg(self, cpu, convention):
        if self.reg_retval and convention in self.reg_retval:
            return self.reg_retval[convention]
        raise NotImplementedError(f&#34;Unsupported get_retval for architecture {type(self)} {convention}&#34;)


    def set_arg(self, cpu, idx, val, convention=&#39;default&#39;):
        &#39;&#39;&#39;
        Set arg [idx] to [val] for given calling convention.

        Note for syscalls we define arg[0] as syscall number and then 1-index the actual args
        &#39;&#39;&#39;
        argloc = self._get_arg_loc(idx, convention)

        if self._is_stack_loc(argloc):
            return self._write_stack(cpu, argloc, val)
        else:
            return self.set_reg(cpu, argloc, val)

    def get_arg(self, cpu, idx, convention=&#39;default&#39;):
        &#39;&#39;&#39;
        Return arg [idx] for given calling convention. This only works right as the guest
        is calling or has called a function before register values are clobbered.

        If arg[idx] should be stack-based, name it stack_0, stack_1... this allows mixed
        conventions where some args are in registers and others are on the stack (i.e.,
        mips32 syscalls).

        When doing a stack-based read, this function may raise a ValueError if the memory
        read fails (i.e., paged out, invalid address).

        Note for syscalls we define arg[0] as syscall number and then 1-index the actual args
        &#39;&#39;&#39;
        
        argloc = self._get_arg_loc(idx, convention)

        if self._is_stack_loc(argloc):
            return self._read_stack(cpu, argloc)
        else:
            return self.get_reg(cpu, argloc)

    @staticmethod
    def _is_stack_loc(argloc):
        &#39;&#39;&#39;
        Given a name returned by self._get_arg_loc
        check if it&#39;s the name of a stack offset
        &#39;&#39;&#39;
        return argloc.startswith(&#34;stack_&#34;)

    def _write_stack(self, cpu, argloc, val):
        &#39;&#39;&#39;
        Given a name like stack_X, calculate where
        the X-th value on the stack is, then write val
        to that location

        May raise a ValueError if the memory write fails
        &#39;&#39;&#39;

        if isinstance(val, int):
            # Encode as word-size with endianness
            bits, endianness, reg_sz = self._determine_bits()
            val = val.to_bytes(reg_sz, byteorder=endianness)

        if not isinstance(val, bytes):
            raise ValueError(&#34;_write_stack needs an int or bytes&#34;)


        # Stack based - get stack base, calculate offset, then try to read it
        assert(self._is_stack_loc(argloc)), f&#34;Can&#39;t get stack offset of {argloc}&#34;

        stack_idx = int(argloc.split(&#34;stack_&#34;)[1])
        stack_base = self.get_reg(cpu, self.reg_sp)
        offset = reg_sz * (stack_idx+1)
        self.panda.virtual_memory_write(cpu, stack_base + offset, val)

    def _read_stack(self, cpu, argloc):
        &#39;&#39;&#39;
        Given a name like stack_X, calculate where
        the X-th value on the stack is, then read it out of
        memory and return it.

        May raise a ValueError if the memory read fails
        &#39;&#39;&#39;
        # Stack based - get stack base, calculate offset, then try to read it
        assert(self._is_stack_loc(argloc)), f&#34;Can&#39;t get stack offset of {argloc}&#34;

        stack_idx = int(argloc.split(&#34;stack_&#34;)[1])
        stack_base = self.get_reg(cpu, self.reg_sp)
        arg_sz = self.panda.bits // 8
        offset = arg_sz * (stack_idx+1)
        return self.panda.virtual_memory_read(cpu, stack_base + offset, arg_sz, fmt=&#39;int&#39;)

    def set_retval(self, cpu, val, convention=&#39;default&#39;, failure=False):
        &#39;&#39;&#39;
        Set return val to [val] for given calling convention. This only works
        right after a function call has returned, otherwise the register will contain
        a different value.

        If the given architecture returns failure/success in a second register (i.e., the A3
        register for mips), set that according to the failure flag.

        Note the failure argument only used by subclasses that overload this function. It&#39;s provided
        in the signature here so it can be set by a caller without regard for the guest architecture.
        &#39;&#39;&#39;
        reg = self._get_ret_val_reg(cpu, convention)
        return self.set_reg(cpu, reg, val)

    def get_retval(self, cpu, convention=&#39;default&#39;):
        &#39;&#39;&#39;
        Set return val to [val] for given calling convention. This only works
        right after a function call has returned, otherwise the register will contain
        a different value.

        Return value from syscalls is signed
        &#39;&#39;&#39;
        reg = self._get_ret_val_reg(cpu, convention)
        rv = self.get_reg(cpu, reg)

        if convention == &#39;syscall&#39;:
            rv = self.panda.from_unsigned_guest(rv)
        return rv


    def set_pc(self, cpu, val):
        &#39;&#39;&#39;
        Set the program counter. Must be overloaded if self.reg_pc is None
        &#39;&#39;&#39;
        if self.reg_pc:
            return self.set_reg(cpu, self.reg_pc, val)
        else:
            raise RuntimeError(f&#34;set_pc unsupported for {self.panda.arch_name}&#34;)

    def dump_regs(self, cpu):
        &#39;&#39;&#39;
        Print (telescoping) each register and its values
        &#39;&#39;&#39;
        print(f&#34;PC: {self.get_pc(cpu):x}&#34;)

        for (regname, reg) in self.registers.items():
            val = self.get_reg(cpu, reg)
            print(&#34;{}: 0x{:x}&#34;.format(regname, val), end=&#34;\t&#34;)
            telescope(self.panda, cpu, val)

    def dump_stack(self, cpu, words=8):
        &#39;&#39;&#39;
        Print (telescoping) most recent `words` words on the stack (from stack pointer to stack pointer + `words`*word_size)
        &#39;&#39;&#39;

        base_reg_s = &#34;SP&#34;
        base_reg_val = self.get_reg(cpu, self.reg_sp)
        if base_reg_val == 0:
            print(&#34;[WARNING: no stack pointer]&#34;)
            return
        word_size = int(self.panda.bits/8)

        _, endianness, _ = self._determine_bits()

        for word_idx in range(words):
            try:
                val_b = self.panda.virtual_memory_read(cpu, base_reg_val+word_idx*word_size, word_size)
                val = int.from_bytes(val_b, byteorder=endianness)
                print(&#34;[{}+0x{:0&gt;2x}] == 0x{:0&lt;8x}]: 0x{:0&lt;8x}&#34;.format(base_reg_s, word_idx*word_size, base_reg_val+word_idx*word_size, val), end=&#34;\t&#34;)
                telescope(self.panda, cpu, val)
            except ValueError:
                print(&#34;[{}+0x{:0&gt;2x}] == [memory read error]&#34;.format(base_reg_s, word_idx*word_size))

    def dump_state(self, cpu):
        &#34;&#34;&#34;
        Print registers and stack
        &#34;&#34;&#34;
        self.dump_regs(cpu)
        self.dump_stack(cpu)

    def get_args(self, cpu, num, convention=&#39;default&#39;):
        return [self.get_arg(cpu,i, convention) for i in range(num)]

class ArmArch(PandaArch):
    &#39;&#39;&#39;
    Register names and accessors for ARM
    &#39;&#39;&#39;
    def __init__(self, panda):
        PandaArch.__init__(self, panda)
        regnames = [&#34;R0&#34;, &#34;R1&#34;, &#34;R2&#34;, &#34;R3&#34;, &#34;R4&#34;, &#34;R5&#34;, &#34;R6&#34;, &#34;R7&#34;,
                    &#34;R8&#34;, &#34;R9&#34;, &#34;R10&#34;, &#34;R11&#34;, &#34;R12&#34;, &#34;SP&#34;, &#34;LR&#34;, &#34;IP&#34;]
        self.registers = {regnames[idx]: idx for idx in range(len(regnames)) }
        &#34;&#34;&#34;Register array for ARM&#34;&#34;&#34;

        self.reg_sp      = regnames.index(&#34;SP&#34;)
        self.reg_pc      = regnames.index(&#34;IP&#34;)
        self.reg_retaddr = regnames.index(&#34;LR&#34;)

        self.reg_sp = regnames.index(&#34;SP&#34;)
        self.reg_retaddr = regnames.index(&#34;LR&#34;)
        self.call_conventions = {&#34;arm32&#34;:         [&#34;R0&#34;, &#34;R1&#34;, &#34;R2&#34;, &#34;R3&#34;],
                                 &#34;syscall&#34;: [&#34;R7&#34;, &#34;R0&#34;, &#34;R1&#34;, &#34;R2&#34;, &#34;R3&#34;, &#34;R4&#34;, &#34;R5&#34;], # EABI
                                 }
        self.call_conventions[&#39;default&#39;] = self.call_conventions[&#39;arm32&#39;]
        self.call_conventions[&#39;linux_kernel&#39;] = self.call_conventions[&#39;arm32&#39;]

        self.reg_retval = {&#34;default&#34;:    &#34;R0&#34;,
                           &#34;syscall&#34;:    &#34;R0&#34;,
                           &#34;linux_kernel&#34;:    &#34;R0&#34;}
        self.reg_pc = regnames.index(&#34;IP&#34;)

    def _get_reg_val(self, cpu, reg):
        &#39;&#39;&#39;
        Return an arm register
        &#39;&#39;&#39;
        return cpu.env_ptr.regs[reg]

    def _set_reg_val(self, cpu, reg, val):
        &#39;&#39;&#39;
        Set an arm register
        &#39;&#39;&#39;
        cpu.env_ptr.regs[reg] = val

    def get_return_value(self, cpu):
        &#39;&#39;&#39;
        .. Deprecated:: use get_retval
        &#39;&#39;&#39;
        return self.get_retval(cpu)

    def get_return_address(self, cpu):
        &#39;&#39;&#39;
        Looks up where ret will go
        &#39;&#39;&#39;
        return self.get_reg(cpu, &#34;LR&#34;) &amp; 0xFFFF_FFFE

class Aarch64Arch(PandaArch):
    &#39;&#39;&#39;
    Register names and accessors for ARM64 (Aarch64)
    &#39;&#39;&#39;
    def __init__(self, panda):
        PandaArch.__init__(self, panda)

        regnames = [&#34;X0&#34;,  &#34;X1&#34;,  &#34;X2&#34;,  &#34;X3&#34;,  &#34;X4&#34;,  &#34;X5&#34;, &#34;X6&#34;, &#34;X7&#34;,
                    &#34;XR&#34;,  &#34;X9&#34;,  &#34;X10&#34;, &#34;X11&#34;, &#34;X12&#34;, &#34;X13&#34;, &#34;X14&#34;,
                    &#34;X15&#34;, &#34;IP0&#34;, &#34;IP1&#34;, &#34;PR&#34;, &#34;X19&#34;, &#34;X20&#34;, &#34;X21&#34;,
                    &#34;X22&#34;, &#34;X23&#34;, &#34;X24&#34;, &#34;X25&#34;, &#34;X26&#34;, &#34;X27&#34;, &#34;X27&#34;,
                    &#34;X28&#34;, &#34;FP&#34;, &#34;LR&#34;, &#34;SP&#34;]

        self.reg_sp = regnames.index(&#34;SP&#34;)

        self.registers = {regnames[idx]: idx for idx in range(len(regnames)) }
        &#34;&#34;&#34;Register array for ARM&#34;&#34;&#34;

        self.reg_sp = regnames.index(&#34;SP&#34;)
        self.reg_retaddr = regnames.index(&#34;LR&#34;)

        self.call_conventions = {&#34;arm64&#34;:         [&#34;X0&#34;, &#34;X1&#34;, &#34;X2&#34;, &#34;X3&#34;, &#34;X4&#34;, &#34;X5&#34;, &#34;X6&#34;, &#34;X7&#34;],
                                 &#34;syscall&#34;: [&#34;XR&#34;, &#34;X0&#34;, &#34;X1&#34;, &#34;X2&#34;, &#34;X3&#34;, &#34;X4&#34;, &#34;X5&#34;, &#34;X6&#34;, &#34;X7&#34;]}
        self.call_conventions[&#39;default&#39;] = self.call_conventions[&#39;arm64&#39;]
        self.call_conventions[&#39;linux_kernel&#39;] = self.call_conventions[&#39;arm64&#39;]

        self.reg_retval = {&#34;default&#34;:    &#34;X0&#34;,
                           &#34;syscall&#34;:    &#34;X0&#34;,
                           &#34;linux_kernel&#34;:    &#34;X0&#34;}

    def get_pc(self, cpu):
        &#39;&#39;&#39;
        Overloaded function to get aarch64 program counter.
        Note the PC is not stored in a general purpose register.
        &#39;&#39;&#39;
        return cpu.env_ptr.pc

    def set_pc(self, cpu, val):
        &#39;&#39;&#39;
        Overloaded function set AArch64 program counter
        &#39;&#39;&#39;
        cpu.env_ptr.pc = val

    def _get_reg_val(self, cpu, reg):
        &#39;&#39;&#39;
        Return an aarch64 register
        &#39;&#39;&#39;

        if reg == 32:
            print(&#34;WARNING: unsupported get sp for aarch64&#34;)
            return 0
        else:
            return cpu.env_ptr.xregs[reg]

    def _set_reg_val(self, cpu, reg, val):
        &#39;&#39;&#39;
        Set an aarch64 register
        &#39;&#39;&#39;
        cpu.env_ptr.xregs[reg] = val

    def get_return_value(self, cpu):
        &#39;&#39;&#39;
        .. Deprecated:: use get_retval
        &#39;&#39;&#39;
        return self.get_retval(cpu)

    def get_return_address(self, cpu):
        &#39;&#39;&#39;
        Looks up where ret will go
        &#39;&#39;&#39;
        return self.get_reg(cpu, &#34;LR&#34;)

class MipsArch(PandaArch):
    &#39;&#39;&#39;
    Register names and accessors for 32-bit MIPS
    &#39;&#39;&#39;

    # Registers are:
    &#39;&#39;&#39;
    Register Number     Conventional Name       Usage
    $0          $zero   Hard-wired to 0
    $1          $at     Reserved for pseudo-instructions
    $2 - $3     $v0, $v1        Return values from functions
    $4 - $7     $a0 - $a3       Arguments to functions - not preserved by subprograms
    $8 - $15    $t0 - $t7       Temporary data, not preserved by subprograms
    $16 - $23   $s0 - $s7       Saved registers, preserved by subprograms
    $24 - $25   $t8 - $t9       More temporary registers, not preserved by subprograms
    $26 - $27   $k0 - $k1       Reserved for kernel. Do not use.
    $28         $gp     Global Area Pointer (base of global data segment)
    $29         $sp     Stack Pointer
    $30         $fp     Frame Pointer
    $31         $ra     Return Address
    &#39;&#39;&#39;

    def __init__(self, panda):
        super().__init__(panda)
        regnames = [&#39;ZERO&#39;, &#39;AT&#39;, &#39;V0&#39;, &#39;V1&#39;, &#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;,
                    &#39;T0&#39;, &#39;T1&#39;, &#39;T2&#39;, &#39;T3&#39;, &#39;T4&#39;, &#39;T5&#39;, &#39;T6&#39;, &#39;T7&#39;,
                    &#39;S0&#39;, &#39;S1&#39;, &#39;S2&#39;, &#39;S3&#39;, &#39;S4&#39;, &#39;S5&#39;, &#39;S6&#39;, &#39;S7&#39;,
                    &#39;T8&#39;, &#39;T9&#39;, &#39;K0&#39;, &#39;K1&#39;, &#39;GP&#39;, &#39;SP&#39;, &#39;FP&#39;, &#39;RA&#39;]

        self.reg_sp = regnames.index(&#39;SP&#39;)
        self.reg_retaddr = regnames.index(&#39;RA&#39;)
        # Default syscall/args are for mips o32
        self.call_conventions = {&#34;mips&#34;:          [&#34;A0&#34;, &#34;A1&#34;, &#34;A2&#34;, &#34;A3&#34;],
                &#34;syscall&#34;: [&#34;V0&#34;, &#34;A0&#34;, &#34;A1&#34;, &#34;A2&#34;, &#34;A3&#34;, &#34;stack_3&#34;, &#34;stack_4&#34;, &#34;stack_5&#34;, &#34;stack_6&#34;]} # XXX: Note it&#39;s not 0-indexed for stack args, I guess the syscall pushes stuff too
        self.call_conventions[&#39;default&#39;] = self.call_conventions[&#39;mips&#39;]
        self.call_conventions[&#39;linux_kernel&#39;] = self.call_conventions[&#39;mips&#39;]

        self.reg_retval =  {&#34;default&#34;:    &#34;V0&#34;,
                            &#34;syscall&#34;:    &#39;V0&#39;,
                            &#34;linux_kernel&#34;:    &#39;V0&#39;}


        # note names must be stored uppercase for get/set reg to work case-insensitively
        self.registers = {regnames[idx].upper(): idx for idx in range(len(regnames)) }
        self.registers[&#39;R30&#39;] = 30

    def get_reg(self, cpu, reg):
        &#39;&#39;&#39;
        Overloaded function for a few mips specific registers
        &#39;&#39;&#39;

        if isinstance(reg, str):
            env = cpu.env_ptr
            reg = reg.upper()
            if reg == &#39;HI&#39;:
                return env.CP0_EntryHi
            elif reg == &#39;LO&#39;:
                return env.CP0_EntryLo0
            elif reg.startswith(&#39;F&#39;) and reg[1:].isnumeric():
                num = int(reg[1:])
                _, endianness, _ = self._determine_bits()
                return int.from_bytes(bytes(env.fpus[0].fpr[num]), byteorder=endianness)
            elif reg == &#39;FCCR&#39;:
                return env.fpus[0].fcr0
            elif reg == &#39;DSPCONTROL&#39;:
                return env.active_tc.DSPControl
            elif reg == &#39;CP0_STATUS&#39;:
                return env.CP0_Status


        return super().get_reg(cpu, reg)

    def get_pc(self, cpu):
        &#39;&#39;&#39;
        Overloaded function to return the MIPS current program counter
        &#39;&#39;&#39;
        return cpu.env_ptr.active_tc.PC

    def set_pc(self, cpu, val):
        &#39;&#39;&#39;
        Overloaded function set the MIPS program counter
        &#39;&#39;&#39;
        cpu.env_ptr.active_tc.PC = val

    def get_retval(self, cpu, convention=&#39;default&#39;):
        &#39;&#39;&#39;
        Overloaded to incorporate error data from A3 register for syscalls.

        If A3 is 1 and convention is syscall, *negate* the return value.
        This matches behavior of other architecures (where -ERRNO is returned
        on error)
        &#39;&#39;&#39;

        flip = 1
        if convention == &#39;syscall&#39; and self.get_reg(cpu, &#34;A3&#34;) == 1:
            flip = -1

        return flip * super().get_retval(cpu)


    def _get_reg_val(self, cpu, reg):
        &#39;&#39;&#39;
        Return a mips register
        &#39;&#39;&#39;
        return cpu.env_ptr.active_tc.gpr[reg]

    def _set_reg_val(self, cpu, reg, val):
        &#39;&#39;&#39;
        Set a mips register
        &#39;&#39;&#39;
        cpu.env_ptr.active_tc.gpr[reg] = val

    def get_return_value(self, cpu, convention=&#39;default&#39;):
        &#39;&#39;&#39;
        .. Deprecated:: use get_retval
        &#39;&#39;&#39;
        return self.get_retval(cpu)

    def get_call_return(self, cpu):
        &#39;&#39;&#39;
        .. Deprecated:: use get_return_address
        &#39;&#39;&#39;
        return self.get_return_address(cpu)

    def get_return_address(self,cpu):
        &#39;&#39;&#39;
        looks up where ret will go
        &#39;&#39;&#39;
        return self.get_reg(cpu, &#34;RA&#34;)

    def set_retval(self, cpu, val, convention=&#39;default&#39;, failure=False):
        &#39;&#39;&#39;
        Overloaded function so when convention is syscall, user can control
        the A3 register (which indicates syscall success/failure) in addition
        to the syscall return value.

        When convention == &#39;syscall&#39;, failure = False means A3 will bet set to 0.
        Otherwise, it will be set to 1

        &#39;&#39;&#39;
        if convention == &#39;syscall&#39;:
            # Set A3 register to indicate syscall success/failure
            self.set_reg(cpu, &#39;a3&#39;, failure)

            # If caller is trying to indicate error by setting a negative retval
            # for a syscall, just make it positive with A3=1
            if failure and self.panda.from_unsigned_guest(val) &lt; 0:
                val = -1 * self.panda.from_unsigned_guest(val)

        return super().set_retval(cpu, val, convention)

class Mips64Arch(MipsArch):
    &#39;&#39;&#39;
    Register names and accessors for MIPS64. Inherits from MipsArch for everything
    except the register name and call conventions.
    &#39;&#39;&#39;

    def __init__(self, panda):
        super().__init__(panda)
        regnames = [&#34;zero&#34;, &#34;at&#34;,   &#34;v0&#34;,   &#34;v1&#34;,   &#34;a0&#34;,   &#34;a1&#34;,   &#34;a2&#34;,   &#34;a3&#34;,
                    &#34;a4&#34;,   &#34;a5&#34;,   &#34;a6&#34;,   &#34;a7&#34;,   &#34;t0&#34;,   &#34;t1&#34;,   &#34;t2&#34;,   &#34;t3&#34;,
                    &#34;s0&#34;,   &#34;s1&#34;,   &#34;s2&#34;,   &#34;s3&#34;,   &#34;s4&#34;,   &#34;s5&#34;,   &#34;s6&#34;,   &#34;s7&#34;,
                    &#34;t8&#34;,   &#34;t9&#34;,   &#34;k0&#34;,   &#34;k1&#34;,   &#34;gp&#34;,   &#34;sp&#34;,   &#34;s8&#34;,   &#34;ra&#34;]

        self.reg_sp = regnames.index(&#39;sp&#39;)
        self.reg_retaddr = regnames.index(&#34;ra&#34;)
        # Default syscall/args are for mips 64/n32 - note the registers are different than 32
        self.call_conventions = {&#34;mips&#34;:          [&#34;A0&#34;, &#34;A1&#34;, &#34;A2&#34;, &#34;A3&#34;], # XXX Unsure?
                                 &#34;syscall&#34;: [&#34;V0&#34;, &#34;A0&#34;, &#34;A1&#34;, &#34;A2&#34;, &#34;A3&#34;, &#34;A4&#34;, &#34;A5&#34;]}
        self.call_conventions[&#39;default&#39;] = self.call_conventions[&#39;mips&#39;]
        self.call_conventions[&#39;linux_kernel&#39;] = self.call_conventions[&#39;mips&#39;]

        self.reg_retval =  {&#34;default&#34;:    &#34;V0&#34;,
                            &#34;syscall&#34;:    &#39;V0&#39;}


        # note names must be stored uppercase for get/set reg to work case-insensitively
        self.registers = {regnames[idx].upper(): idx for idx in range(len(regnames)) }

class X86Arch(PandaArch):
    &#39;&#39;&#39;
    Register names and accessors for x86
    &#39;&#39;&#39;

    def __init__(self, panda):
        super().__init__(panda)
        regnames = [&#39;EAX&#39;, &#39;ECX&#39;, &#39;EDX&#39;, &#39;EBX&#39;, &#39;ESP&#39;, &#39;EBP&#39;, &#39;ESI&#39;, &#39;EDI&#39;]
        # XXX Note order is A C D B, because that&#39;s how qemu does it . See target/i386/cpu.h

        # Note we don&#39;t set self.call_conventions because stack-based arg get/set is
        # not yet supported
        self.reg_retval = {&#34;default&#34;:    &#34;EAX&#34;,
                           &#34;syscall&#34;:    &#34;EAX&#34;,
                           &#34;linux_kernel&#34;:    &#34;EAX&#34;}

        self.call_conventions = {&#34;cdecl&#34;: [f&#34;stack_{x}&#34; for x in range(20)], # 20: arbitrary but big
                                 &#34;syscall&#34;: [&#34;EAX&#34;, &#34;EBX&#34;, &#34;ECX&#34;, &#34;EDX&#34;, &#34;ESI&#34;, &#34;EDI&#34;, &#34;EBP&#34;],
                                 &#34;linux_kernel&#34;: [&#34;EAX&#34;, &#34;EDX&#34;, &#34;ECX&#34;, &#34;stack_3&#34;, &#34;stack_4&#34;, &#34;stack_5&#34;, &#34;stack_6&#34;]}
        self.call_conventions[&#39;default&#39;] = self.call_conventions[&#39;cdecl&#39;]

        self.reg_sp = regnames.index(&#39;ESP&#39;)
        self.registers = {regnames[idx]: idx for idx in range(len(regnames)) }


    def get_pc(self, cpu):
        &#39;&#39;&#39;
        Overloaded function to return the x86 current program counter
        &#39;&#39;&#39;
        return cpu.env_ptr.eip

    def set_pc(self, cpu, val):
        &#39;&#39;&#39;
        Overloaded function to set the x86 program counter
        &#39;&#39;&#39;
        cpu.env_ptr.eip = val

    def _get_reg_val(self, cpu, reg):
        &#39;&#39;&#39;
        Return an x86 register
        &#39;&#39;&#39;
        return cpu.env_ptr.regs[reg]

    def _set_reg_val(self, cpu, reg, val):
        &#39;&#39;&#39;
        Set an x86 register
        &#39;&#39;&#39;
        cpu.env_ptr.regs[reg] = val

    def get_return_value(self, cpu):
        &#39;&#39;&#39;
        .. Deprecated:: use get_retval
        &#39;&#39;&#39;
        return self.get_retval(cpu)

    def get_return_address(self,cpu):
        &#39;&#39;&#39;
        looks up where ret will go
        &#39;&#39;&#39;
        esp = self.get_reg(cpu,&#34;ESP&#34;)
        return self.panda.virtual_memory_read(cpu,esp,4,fmt=&#39;int&#39;)

class X86_64Arch(PandaArch):
    &#39;&#39;&#39;
    Register names and accessors for x86_64
    &#39;&#39;&#39;

    def __init__(self, panda):
        super().__init__(panda)
        # The only place I could find the R_ names is in tcg/i386/tcg-target.h:50
        regnames = [&#39;RAX&#39;, &#39;RCX&#39;, &#39;RDX&#39;, &#39;RBX&#39;, &#39;RSP&#39;, &#39;RBP&#39;, &#39;RSI&#39;, &#39;RDI&#39;,
                    &#39;R8&#39;, &#39;R9&#39;, &#39;R10&#39;, &#39;R11&#39;, &#39;R12&#39;, &#39;R13&#39;, &#39;R14&#39;, &#39;R15&#39;]
        # XXX Note order is A C D B, because that&#39;s how qemu does it

        self.call_conventions = {&#39;sysv&#39;:           [&#39;RDI&#39;, &#39;RSI&#39;, &#39;RDX&#39;, &#39;RCX&#39;, &#39;R8&#39;, &#39;R9&#39;],
                                 &#39;syscall&#39;: [&#39;RAX&#39;, &#39;RDI&#39;, &#39;RSI&#39;, &#39;RDX&#39;, &#39;R10&#39;, &#39;R8&#39;, &#39;R9&#39;]}

        self.call_conventions[&#39;default&#39;] = self.call_conventions[&#39;sysv&#39;]
        self.call_conventions[&#39;linux_kernel&#39;] = self.call_conventions[&#39;sysv&#39;]

        self.reg_sp = regnames.index(&#39;RSP&#39;)
        self.reg_retval = {&#39;sysv&#39;: &#39;RAX&#39;,
                           &#39;syscall&#39;: &#39;RAX&#39;,
                           &#39;linux_kernel&#39;: &#39;RAX&#39;}
        self.reg_retval[&#39;default&#39;] = self.reg_retval[&#39;sysv&#39;]

        self.registers = {regnames[idx]: idx for idx in range(len(regnames)) }

        # Internal state to support some of the weird x86-64 registers
        self.reg_names_general = [&#39;EAX&#39;, &#39;ECX&#39;, &#39;EDX&#39;, &#39;EBX&#39;, &#39;ESP&#39;, &#39;EBP&#39;, &#39;ESI&#39;, &#39;EDI&#39;]
        self.reg_names_short = [&#39;AX&#39;, &#39;CX&#39;, &#39;DX&#39;, &#39;BX&#39;, &#39;SP&#39;, &#39;BP&#39;, &#39;SI&#39;, &#39;DI&#39;]
        self.reg_names_byte = [&#39;AL&#39;, &#39;CL&#39;, &#39;DL&#39;, &#39;BL&#39;, &#39;AH&#39;, &#39;CH&#39;, &#39;DH&#39;, &#39;BH&#39;]
        self.seg_names = [&#39;ES&#39;, &#39;CS&#39;, &#39;SS&#39;, &#39;DS&#39;, &#39;FS&#39;, &#39;GS&#39;]

    def _get_segment_register(self, env, seg_name):
        seg_idx = self.seg_names.index(seg_name)
        return env.segs[seg_idx].base

    def _get_general_purpose_register(self, env, reg_name, mask):
        return env.regs[self.reg_names_general.index(reg_name)] &amp; mask

    def _set_segment_register(self, env, seg_name, value):
        seg_idx = self.seg_names.index(seg_name)
        env.segs[seg_idx].base = value

    def _set_general_purpose_register(self, env, reg_name, value, mask):
        reg_idx = self.reg_names_general.index(reg_name)
        env.regs[reg_idx] = (env.regs[reg_idx] &amp; ~mask) | (value &amp; mask)

    def get_pc(self, cpu):
        &#39;&#39;&#39;
        Overloaded function to return the x86_64 current program counter
        &#39;&#39;&#39;
        return cpu.env_ptr.eip

    def get_retval(self, cpu, convention=&#39;default&#39;):
        &#39;&#39;&#39;
        Overloaded to support FreeBSD syscall ABI
        In that ABI, if eflags carry bit is set, an error has occured. To standardize
        pandare.arch returns across architectures/ABIs, we indicate a failure by returnning
        -ERRNO.
        &#39;&#39;&#39;

        error_flip = False
        if convention == &#39;syscall&#39; and self.panda.get_os_family() == &#39;OS_FREEBSD&#39; and \
                self.panda.libpanda.cpu_cc_compute_all(cpu.env_ptr, 1) &amp; 1 == 1:
            error_flip = True

        return super().get_retval(cpu, convention) * (-1 if error_flip else 1)

    def set_pc(self, cpu, val):
        &#39;&#39;&#39;
        Overloaded function to set the x86_64 program counter
        &#39;&#39;&#39;
        cpu.env_ptr.eip = val

    def _get_reg_val(self, cpu, reg):
        &#39;&#39;&#39;
        Return an x86_64 register
        &#39;&#39;&#39;
        return cpu.env_ptr.regs[reg]

    def _set_reg_val(self, cpu, reg, val):
        &#39;&#39;&#39;
        Set an x86_64 register
        &#39;&#39;&#39;
        cpu.env_ptr.regs[reg] = val

    def get_return_value(self, cpu):
        &#39;&#39;&#39;
        .. Deprecated:: use get_retval
        &#39;&#39;&#39;
        return self.get_retval(cpu)

    def get_return_address(self, cpu):
        &#39;&#39;&#39;
        looks up where ret will go
        &#39;&#39;&#39;
        esp = self.get_reg(cpu, &#34;RSP&#34;)
        return self.panda.virtual_memory_read(cpu, esp, 8, fmt=&#39;int&#39;)

    def get_reg(self, cpu, reg):
        &#39;&#39;&#39;
        X86_64 has a bunch of different ways to access registers. We support
        the regular names, the 32 and 16 bit varations (e.g., EAX, AX, AL),
        segment registers, and D/W/B style accesses to R8-R15
        &#39;&#39;&#39;
        if isinstance(reg, int):
            # If reg is an int, it should be an offset into our register array
            return self._get_reg_val(cpu, reg)

        reg = reg.upper()
        env = cpu.env_ptr
        if reg in self.seg_names:
            return self._get_segment_register(env, reg)
        elif reg in [&#39;RIP&#39;, &#39;PC&#39;, &#39;EIP&#39;]:
            pc = self.get_pc(cpu) # changes reg to &#39;IP&#39; and re-calls this
            if reg == &#39;EIP&#39;:
                pc &amp;= 0xFFFFFFFF
            return pc
        elif reg.startswith(&#39;XMM&#39;):
            raw_arr = env.xmm_regs[int(reg[3:].rstrip(&#39;HLQX&#39;))]
            _, endianness, _ = self._determine_bits()

            if reg.endswith(&#39;lq&#39;):
                value_bytes = raw_arr[0:8] # Lower 64 bits
            elif reg.endswith(&#39;hq&#39;):
                value_bytes = raw_arr[8:16] # Higher 64 bits
            elif reg.endswith(&#39;hx&#39;):
                value_bytes = raw_arr[4:8] # Higher 32 bits of the lower 64 bits
            else:
                value_bytes = raw_arr[0:16] # Full 128 bits
            return int.from_bytes(bytes(value_bytes), byteorder=endianness)

        elif reg.startswith(&#39;MM&#39;):
            raise ValueError(&#34;MM registers unsupported&#34;)
        elif reg.startswith(&#39;YMM&#39;):
            raise ValueError(&#34;YMM registers unsupported&#34;)
        elif reg.startswith(&#39;CR&#39;):
            return env.cr[int(reg[2:])]
        elif reg.startswith(&#39;R&#39;) and any([reg.endswith(x) for x in &#39;DWB&#39;]) and reg.strip(&#39;RDWB&#39;).isnumeric():
            # R8-R15 can be accessed with D (double word), W (word) and B (byte)
            # to select the lowest 32-bits, the lowest 16 bits, or the lowest 8 bits.
            reg_idx = int(reg.strip(&#39;RDWB&#39;)) - 8
            reg_suffix = reg[-1]
            mask = {&#39;D&#39;: 0xFFFFFFFF,
                    &#39;W&#39;: 0xFFFF,
                    &#39;B&#39;: 0xFF}[reg_suffix]
            return env.regs[reg_idx] &amp; mask
        elif reg in self.reg_names_general:
            return self._get_general_purpose_register(env, reg, 0xFFFFFFFF)
        elif reg in self.reg_names_short:
            return env.regs[self.reg_names_short.index(reg)] &amp; 0xFFFF
        elif reg in self.reg_names_byte:
            reg_idx = self.reg_names_byte.index(reg)
            if reg_idx &gt; 3:
                reg_idx -= 4
                return (env.regs[reg_idx] &gt;&gt; 8) &amp; 0xFF
            else:
                return env.regs[reg_idx] &amp; 0xFF
        else:
            return super().get_reg(cpu, reg)

    def set_reg(self, cpu, reg, val):
        reg = reg.upper()
        env = cpu.env_ptr

        if reg in [&#39;ES&#39;, &#39;CS&#39;, &#39;SS&#39;, &#39;DS&#39;, &#39;FS&#39;, &#39;GS&#39;]:
            self._set_segment_register(env, reg, val)
        elif reg in [&#39;RIP&#39;, &#39;PC&#39;]:
            return self.set_pc(cpu, val) # changes reg to &#39;IP&#39; and re-calls this
        elif reg.startswith(&#39;XMM&#39;):
            #env.xmm_regs[int(reg[3:])] = val
            raise NotImplementedError(&#34;XMM registers unsupported&#34;)
        elif reg.startswith(&#39;MM&#39;):
            raise NotImplementedError(&#34;MM registers unsupported&#34;)
        elif reg.startswith(&#39;YMM&#39;):
            raise NotImplementedError(&#34;YMM registers unsupported&#34;)
        elif reg.startswith(&#39;CR&#39;):
            env.cr[int(reg[2:])] = val
        elif reg.startswith(&#39;R&#39;) and any([reg.endswith(x) for x in &#39;DWB&#39;]):
            # R8-R15 can be accessed with D (double word), W (word) and B (byte)
            # to select the lowest 32-bits, the lowest 16 bits, or the lowest 8 bits.
            reg_idx = int(reg.strip(&#39;RDWB&#39;)) - 8
            reg_suffix = reg[-1]
            mask = {&#39;D&#39;: 0xFFFFFFFF,
                    &#39;W&#39;: 0xFFFF,
                    &#39;B&#39;: 0xFF}[reg_suffix]
            env.regs[reg_idx] &amp; mask
            env.regs[reg_idx] = (env.regs[reg_idx] &amp; ~mask) | (val &amp; mask)
        elif reg in self.reg_names_general:
            self._set_general_purpose_register(env, reg, val, 0xFFFFFFFF)
        elif reg in self.reg_names_short:
            self._set_general_purpose_register(env, reg, val, 0xFFFF)
        elif reg in self.reg_names_byte:
            reg_idx = self.reg_names_byte.index(reg)
            mask = 0xFF &lt;&lt; (8 * (reg_idx &gt; 3))
            reg_idx %= 4
            self._set_general_purpose_register(env, reg, val, mask)
        else:
            super().set_reg(cpu, reg, val)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pandare.arch.Aarch64Arch"><code class="flex name class">
<span>class <span class="ident">Aarch64Arch</span></span>
<span>(</span><span>panda)</span>
</code></dt>
<dd>
<div class="desc"><p>Register names and accessors for ARM64 (Aarch64)</p>
<p>Initialize a PANDA-supported architecture and hold a handle on the PANDA object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Aarch64Arch(PandaArch):
    &#39;&#39;&#39;
    Register names and accessors for ARM64 (Aarch64)
    &#39;&#39;&#39;
    def __init__(self, panda):
        PandaArch.__init__(self, panda)

        regnames = [&#34;X0&#34;,  &#34;X1&#34;,  &#34;X2&#34;,  &#34;X3&#34;,  &#34;X4&#34;,  &#34;X5&#34;, &#34;X6&#34;, &#34;X7&#34;,
                    &#34;XR&#34;,  &#34;X9&#34;,  &#34;X10&#34;, &#34;X11&#34;, &#34;X12&#34;, &#34;X13&#34;, &#34;X14&#34;,
                    &#34;X15&#34;, &#34;IP0&#34;, &#34;IP1&#34;, &#34;PR&#34;, &#34;X19&#34;, &#34;X20&#34;, &#34;X21&#34;,
                    &#34;X22&#34;, &#34;X23&#34;, &#34;X24&#34;, &#34;X25&#34;, &#34;X26&#34;, &#34;X27&#34;, &#34;X27&#34;,
                    &#34;X28&#34;, &#34;FP&#34;, &#34;LR&#34;, &#34;SP&#34;]

        self.reg_sp = regnames.index(&#34;SP&#34;)

        self.registers = {regnames[idx]: idx for idx in range(len(regnames)) }
        &#34;&#34;&#34;Register array for ARM&#34;&#34;&#34;

        self.reg_sp = regnames.index(&#34;SP&#34;)
        self.reg_retaddr = regnames.index(&#34;LR&#34;)

        self.call_conventions = {&#34;arm64&#34;:         [&#34;X0&#34;, &#34;X1&#34;, &#34;X2&#34;, &#34;X3&#34;, &#34;X4&#34;, &#34;X5&#34;, &#34;X6&#34;, &#34;X7&#34;],
                                 &#34;syscall&#34;: [&#34;XR&#34;, &#34;X0&#34;, &#34;X1&#34;, &#34;X2&#34;, &#34;X3&#34;, &#34;X4&#34;, &#34;X5&#34;, &#34;X6&#34;, &#34;X7&#34;]}
        self.call_conventions[&#39;default&#39;] = self.call_conventions[&#39;arm64&#39;]
        self.call_conventions[&#39;linux_kernel&#39;] = self.call_conventions[&#39;arm64&#39;]

        self.reg_retval = {&#34;default&#34;:    &#34;X0&#34;,
                           &#34;syscall&#34;:    &#34;X0&#34;,
                           &#34;linux_kernel&#34;:    &#34;X0&#34;}

    def get_pc(self, cpu):
        &#39;&#39;&#39;
        Overloaded function to get aarch64 program counter.
        Note the PC is not stored in a general purpose register.
        &#39;&#39;&#39;
        return cpu.env_ptr.pc

    def set_pc(self, cpu, val):
        &#39;&#39;&#39;
        Overloaded function set AArch64 program counter
        &#39;&#39;&#39;
        cpu.env_ptr.pc = val

    def _get_reg_val(self, cpu, reg):
        &#39;&#39;&#39;
        Return an aarch64 register
        &#39;&#39;&#39;

        if reg == 32:
            print(&#34;WARNING: unsupported get sp for aarch64&#34;)
            return 0
        else:
            return cpu.env_ptr.xregs[reg]

    def _set_reg_val(self, cpu, reg, val):
        &#39;&#39;&#39;
        Set an aarch64 register
        &#39;&#39;&#39;
        cpu.env_ptr.xregs[reg] = val

    def get_return_value(self, cpu):
        &#39;&#39;&#39;
        .. Deprecated:: use get_retval
        &#39;&#39;&#39;
        return self.get_retval(cpu)

    def get_return_address(self, cpu):
        &#39;&#39;&#39;
        Looks up where ret will go
        &#39;&#39;&#39;
        return self.get_reg(cpu, &#34;LR&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.arch.PandaArch" href="#pandare.arch.PandaArch">PandaArch</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.arch.Aarch64Arch.get_pc"><code class="name flex">
<span>def <span class="ident">get_pc</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Overloaded function to get aarch64 program counter.
Note the PC is not stored in a general purpose register.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pc(self, cpu):
    &#39;&#39;&#39;
    Overloaded function to get aarch64 program counter.
    Note the PC is not stored in a general purpose register.
    &#39;&#39;&#39;
    return cpu.env_ptr.pc</code></pre>
</details>
</dd>
<dt id="pandare.arch.Aarch64Arch.get_return_address"><code class="name flex">
<span>def <span class="ident">get_return_address</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Looks up where ret will go</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_return_address(self, cpu):
    &#39;&#39;&#39;
    Looks up where ret will go
    &#39;&#39;&#39;
    return self.get_reg(cpu, &#34;LR&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.arch.Aarch64Arch.get_return_value"><code class="name flex">
<span>def <span class="ident">get_return_value</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><div class="admonition deprecated">
<p class="admonition-title">Deprecated:&ensp;use get_retval</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_return_value(self, cpu):
    &#39;&#39;&#39;
    .. Deprecated:: use get_retval
    &#39;&#39;&#39;
    return self.get_retval(cpu)</code></pre>
</details>
</dd>
<dt id="pandare.arch.Aarch64Arch.set_pc"><code class="name flex">
<span>def <span class="ident">set_pc</span></span>(<span>self, cpu, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Overloaded function set AArch64 program counter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pc(self, cpu, val):
    &#39;&#39;&#39;
    Overloaded function set AArch64 program counter
    &#39;&#39;&#39;
    cpu.env_ptr.pc = val</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pandare.arch.PandaArch" href="#pandare.arch.PandaArch">PandaArch</a></b></code>:
<ul class="hlist">
<li><code><a title="pandare.arch.PandaArch.dump_regs" href="#pandare.arch.PandaArch.dump_regs">dump_regs</a></code></li>
<li><code><a title="pandare.arch.PandaArch.dump_stack" href="#pandare.arch.PandaArch.dump_stack">dump_stack</a></code></li>
<li><code><a title="pandare.arch.PandaArch.dump_state" href="#pandare.arch.PandaArch.dump_state">dump_state</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_arg" href="#pandare.arch.PandaArch.get_arg">get_arg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_reg" href="#pandare.arch.PandaArch.get_reg">get_reg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_retval" href="#pandare.arch.PandaArch.get_retval">get_retval</a></code></li>
<li><code><a title="pandare.arch.PandaArch.registers" href="#pandare.arch.PandaArch.registers">registers</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_arg" href="#pandare.arch.PandaArch.set_arg">set_arg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_reg" href="#pandare.arch.PandaArch.set_reg">set_reg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_retval" href="#pandare.arch.PandaArch.set_retval">set_retval</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pandare.arch.ArmArch"><code class="flex name class">
<span>class <span class="ident">ArmArch</span></span>
<span>(</span><span>panda)</span>
</code></dt>
<dd>
<div class="desc"><p>Register names and accessors for ARM</p>
<p>Initialize a PANDA-supported architecture and hold a handle on the PANDA object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArmArch(PandaArch):
    &#39;&#39;&#39;
    Register names and accessors for ARM
    &#39;&#39;&#39;
    def __init__(self, panda):
        PandaArch.__init__(self, panda)
        regnames = [&#34;R0&#34;, &#34;R1&#34;, &#34;R2&#34;, &#34;R3&#34;, &#34;R4&#34;, &#34;R5&#34;, &#34;R6&#34;, &#34;R7&#34;,
                    &#34;R8&#34;, &#34;R9&#34;, &#34;R10&#34;, &#34;R11&#34;, &#34;R12&#34;, &#34;SP&#34;, &#34;LR&#34;, &#34;IP&#34;]
        self.registers = {regnames[idx]: idx for idx in range(len(regnames)) }
        &#34;&#34;&#34;Register array for ARM&#34;&#34;&#34;

        self.reg_sp      = regnames.index(&#34;SP&#34;)
        self.reg_pc      = regnames.index(&#34;IP&#34;)
        self.reg_retaddr = regnames.index(&#34;LR&#34;)

        self.reg_sp = regnames.index(&#34;SP&#34;)
        self.reg_retaddr = regnames.index(&#34;LR&#34;)
        self.call_conventions = {&#34;arm32&#34;:         [&#34;R0&#34;, &#34;R1&#34;, &#34;R2&#34;, &#34;R3&#34;],
                                 &#34;syscall&#34;: [&#34;R7&#34;, &#34;R0&#34;, &#34;R1&#34;, &#34;R2&#34;, &#34;R3&#34;, &#34;R4&#34;, &#34;R5&#34;], # EABI
                                 }
        self.call_conventions[&#39;default&#39;] = self.call_conventions[&#39;arm32&#39;]
        self.call_conventions[&#39;linux_kernel&#39;] = self.call_conventions[&#39;arm32&#39;]

        self.reg_retval = {&#34;default&#34;:    &#34;R0&#34;,
                           &#34;syscall&#34;:    &#34;R0&#34;,
                           &#34;linux_kernel&#34;:    &#34;R0&#34;}
        self.reg_pc = regnames.index(&#34;IP&#34;)

    def _get_reg_val(self, cpu, reg):
        &#39;&#39;&#39;
        Return an arm register
        &#39;&#39;&#39;
        return cpu.env_ptr.regs[reg]

    def _set_reg_val(self, cpu, reg, val):
        &#39;&#39;&#39;
        Set an arm register
        &#39;&#39;&#39;
        cpu.env_ptr.regs[reg] = val

    def get_return_value(self, cpu):
        &#39;&#39;&#39;
        .. Deprecated:: use get_retval
        &#39;&#39;&#39;
        return self.get_retval(cpu)

    def get_return_address(self, cpu):
        &#39;&#39;&#39;
        Looks up where ret will go
        &#39;&#39;&#39;
        return self.get_reg(cpu, &#34;LR&#34;) &amp; 0xFFFF_FFFE</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.arch.PandaArch" href="#pandare.arch.PandaArch">PandaArch</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.arch.ArmArch.get_return_address"><code class="name flex">
<span>def <span class="ident">get_return_address</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Looks up where ret will go</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_return_address(self, cpu):
    &#39;&#39;&#39;
    Looks up where ret will go
    &#39;&#39;&#39;
    return self.get_reg(cpu, &#34;LR&#34;) &amp; 0xFFFF_FFFE</code></pre>
</details>
</dd>
<dt id="pandare.arch.ArmArch.get_return_value"><code class="name flex">
<span>def <span class="ident">get_return_value</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><div class="admonition deprecated">
<p class="admonition-title">Deprecated:&ensp;use get_retval</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_return_value(self, cpu):
    &#39;&#39;&#39;
    .. Deprecated:: use get_retval
    &#39;&#39;&#39;
    return self.get_retval(cpu)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pandare.arch.PandaArch" href="#pandare.arch.PandaArch">PandaArch</a></b></code>:
<ul class="hlist">
<li><code><a title="pandare.arch.PandaArch.dump_regs" href="#pandare.arch.PandaArch.dump_regs">dump_regs</a></code></li>
<li><code><a title="pandare.arch.PandaArch.dump_stack" href="#pandare.arch.PandaArch.dump_stack">dump_stack</a></code></li>
<li><code><a title="pandare.arch.PandaArch.dump_state" href="#pandare.arch.PandaArch.dump_state">dump_state</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_arg" href="#pandare.arch.PandaArch.get_arg">get_arg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_pc" href="#pandare.arch.PandaArch.get_pc">get_pc</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_reg" href="#pandare.arch.PandaArch.get_reg">get_reg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_retval" href="#pandare.arch.PandaArch.get_retval">get_retval</a></code></li>
<li><code><a title="pandare.arch.PandaArch.registers" href="#pandare.arch.PandaArch.registers">registers</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_arg" href="#pandare.arch.PandaArch.set_arg">set_arg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_pc" href="#pandare.arch.PandaArch.set_pc">set_pc</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_reg" href="#pandare.arch.PandaArch.set_reg">set_reg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_retval" href="#pandare.arch.PandaArch.set_retval">set_retval</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pandare.arch.Mips64Arch"><code class="flex name class">
<span>class <span class="ident">Mips64Arch</span></span>
<span>(</span><span>panda)</span>
</code></dt>
<dd>
<div class="desc"><p>Register names and accessors for MIPS64. Inherits from MipsArch for everything
except the register name and call conventions.</p>
<p>Initialize a PANDA-supported architecture and hold a handle on the PANDA object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mips64Arch(MipsArch):
    &#39;&#39;&#39;
    Register names and accessors for MIPS64. Inherits from MipsArch for everything
    except the register name and call conventions.
    &#39;&#39;&#39;

    def __init__(self, panda):
        super().__init__(panda)
        regnames = [&#34;zero&#34;, &#34;at&#34;,   &#34;v0&#34;,   &#34;v1&#34;,   &#34;a0&#34;,   &#34;a1&#34;,   &#34;a2&#34;,   &#34;a3&#34;,
                    &#34;a4&#34;,   &#34;a5&#34;,   &#34;a6&#34;,   &#34;a7&#34;,   &#34;t0&#34;,   &#34;t1&#34;,   &#34;t2&#34;,   &#34;t3&#34;,
                    &#34;s0&#34;,   &#34;s1&#34;,   &#34;s2&#34;,   &#34;s3&#34;,   &#34;s4&#34;,   &#34;s5&#34;,   &#34;s6&#34;,   &#34;s7&#34;,
                    &#34;t8&#34;,   &#34;t9&#34;,   &#34;k0&#34;,   &#34;k1&#34;,   &#34;gp&#34;,   &#34;sp&#34;,   &#34;s8&#34;,   &#34;ra&#34;]

        self.reg_sp = regnames.index(&#39;sp&#39;)
        self.reg_retaddr = regnames.index(&#34;ra&#34;)
        # Default syscall/args are for mips 64/n32 - note the registers are different than 32
        self.call_conventions = {&#34;mips&#34;:          [&#34;A0&#34;, &#34;A1&#34;, &#34;A2&#34;, &#34;A3&#34;], # XXX Unsure?
                                 &#34;syscall&#34;: [&#34;V0&#34;, &#34;A0&#34;, &#34;A1&#34;, &#34;A2&#34;, &#34;A3&#34;, &#34;A4&#34;, &#34;A5&#34;]}
        self.call_conventions[&#39;default&#39;] = self.call_conventions[&#39;mips&#39;]
        self.call_conventions[&#39;linux_kernel&#39;] = self.call_conventions[&#39;mips&#39;]

        self.reg_retval =  {&#34;default&#34;:    &#34;V0&#34;,
                            &#34;syscall&#34;:    &#39;V0&#39;}


        # note names must be stored uppercase for get/set reg to work case-insensitively
        self.registers = {regnames[idx].upper(): idx for idx in range(len(regnames)) }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.arch.MipsArch" href="#pandare.arch.MipsArch">MipsArch</a></li>
<li><a title="pandare.arch.PandaArch" href="#pandare.arch.PandaArch">PandaArch</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pandare.arch.MipsArch" href="#pandare.arch.MipsArch">MipsArch</a></b></code>:
<ul class="hlist">
<li><code><a title="pandare.arch.MipsArch.dump_regs" href="#pandare.arch.PandaArch.dump_regs">dump_regs</a></code></li>
<li><code><a title="pandare.arch.MipsArch.dump_stack" href="#pandare.arch.PandaArch.dump_stack">dump_stack</a></code></li>
<li><code><a title="pandare.arch.MipsArch.dump_state" href="#pandare.arch.PandaArch.dump_state">dump_state</a></code></li>
<li><code><a title="pandare.arch.MipsArch.get_arg" href="#pandare.arch.PandaArch.get_arg">get_arg</a></code></li>
<li><code><a title="pandare.arch.MipsArch.get_call_return" href="#pandare.arch.MipsArch.get_call_return">get_call_return</a></code></li>
<li><code><a title="pandare.arch.MipsArch.get_pc" href="#pandare.arch.MipsArch.get_pc">get_pc</a></code></li>
<li><code><a title="pandare.arch.MipsArch.get_reg" href="#pandare.arch.MipsArch.get_reg">get_reg</a></code></li>
<li><code><a title="pandare.arch.MipsArch.get_return_address" href="#pandare.arch.MipsArch.get_return_address">get_return_address</a></code></li>
<li><code><a title="pandare.arch.MipsArch.get_return_value" href="#pandare.arch.MipsArch.get_return_value">get_return_value</a></code></li>
<li><code><a title="pandare.arch.MipsArch.get_retval" href="#pandare.arch.MipsArch.get_retval">get_retval</a></code></li>
<li><code><a title="pandare.arch.MipsArch.registers" href="#pandare.arch.PandaArch.registers">registers</a></code></li>
<li><code><a title="pandare.arch.MipsArch.set_arg" href="#pandare.arch.PandaArch.set_arg">set_arg</a></code></li>
<li><code><a title="pandare.arch.MipsArch.set_pc" href="#pandare.arch.MipsArch.set_pc">set_pc</a></code></li>
<li><code><a title="pandare.arch.MipsArch.set_reg" href="#pandare.arch.PandaArch.set_reg">set_reg</a></code></li>
<li><code><a title="pandare.arch.MipsArch.set_retval" href="#pandare.arch.MipsArch.set_retval">set_retval</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pandare.arch.MipsArch"><code class="flex name class">
<span>class <span class="ident">MipsArch</span></span>
<span>(</span><span>panda)</span>
</code></dt>
<dd>
<div class="desc"><p>Register names and accessors for 32-bit MIPS</p>
<p>Initialize a PANDA-supported architecture and hold a handle on the PANDA object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MipsArch(PandaArch):
    &#39;&#39;&#39;
    Register names and accessors for 32-bit MIPS
    &#39;&#39;&#39;

    # Registers are:
    &#39;&#39;&#39;
    Register Number     Conventional Name       Usage
    $0          $zero   Hard-wired to 0
    $1          $at     Reserved for pseudo-instructions
    $2 - $3     $v0, $v1        Return values from functions
    $4 - $7     $a0 - $a3       Arguments to functions - not preserved by subprograms
    $8 - $15    $t0 - $t7       Temporary data, not preserved by subprograms
    $16 - $23   $s0 - $s7       Saved registers, preserved by subprograms
    $24 - $25   $t8 - $t9       More temporary registers, not preserved by subprograms
    $26 - $27   $k0 - $k1       Reserved for kernel. Do not use.
    $28         $gp     Global Area Pointer (base of global data segment)
    $29         $sp     Stack Pointer
    $30         $fp     Frame Pointer
    $31         $ra     Return Address
    &#39;&#39;&#39;

    def __init__(self, panda):
        super().__init__(panda)
        regnames = [&#39;ZERO&#39;, &#39;AT&#39;, &#39;V0&#39;, &#39;V1&#39;, &#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;,
                    &#39;T0&#39;, &#39;T1&#39;, &#39;T2&#39;, &#39;T3&#39;, &#39;T4&#39;, &#39;T5&#39;, &#39;T6&#39;, &#39;T7&#39;,
                    &#39;S0&#39;, &#39;S1&#39;, &#39;S2&#39;, &#39;S3&#39;, &#39;S4&#39;, &#39;S5&#39;, &#39;S6&#39;, &#39;S7&#39;,
                    &#39;T8&#39;, &#39;T9&#39;, &#39;K0&#39;, &#39;K1&#39;, &#39;GP&#39;, &#39;SP&#39;, &#39;FP&#39;, &#39;RA&#39;]

        self.reg_sp = regnames.index(&#39;SP&#39;)
        self.reg_retaddr = regnames.index(&#39;RA&#39;)
        # Default syscall/args are for mips o32
        self.call_conventions = {&#34;mips&#34;:          [&#34;A0&#34;, &#34;A1&#34;, &#34;A2&#34;, &#34;A3&#34;],
                &#34;syscall&#34;: [&#34;V0&#34;, &#34;A0&#34;, &#34;A1&#34;, &#34;A2&#34;, &#34;A3&#34;, &#34;stack_3&#34;, &#34;stack_4&#34;, &#34;stack_5&#34;, &#34;stack_6&#34;]} # XXX: Note it&#39;s not 0-indexed for stack args, I guess the syscall pushes stuff too
        self.call_conventions[&#39;default&#39;] = self.call_conventions[&#39;mips&#39;]
        self.call_conventions[&#39;linux_kernel&#39;] = self.call_conventions[&#39;mips&#39;]

        self.reg_retval =  {&#34;default&#34;:    &#34;V0&#34;,
                            &#34;syscall&#34;:    &#39;V0&#39;,
                            &#34;linux_kernel&#34;:    &#39;V0&#39;}


        # note names must be stored uppercase for get/set reg to work case-insensitively
        self.registers = {regnames[idx].upper(): idx for idx in range(len(regnames)) }
        self.registers[&#39;R30&#39;] = 30

    def get_reg(self, cpu, reg):
        &#39;&#39;&#39;
        Overloaded function for a few mips specific registers
        &#39;&#39;&#39;

        if isinstance(reg, str):
            env = cpu.env_ptr
            reg = reg.upper()
            if reg == &#39;HI&#39;:
                return env.CP0_EntryHi
            elif reg == &#39;LO&#39;:
                return env.CP0_EntryLo0
            elif reg.startswith(&#39;F&#39;) and reg[1:].isnumeric():
                num = int(reg[1:])
                _, endianness, _ = self._determine_bits()
                return int.from_bytes(bytes(env.fpus[0].fpr[num]), byteorder=endianness)
            elif reg == &#39;FCCR&#39;:
                return env.fpus[0].fcr0
            elif reg == &#39;DSPCONTROL&#39;:
                return env.active_tc.DSPControl
            elif reg == &#39;CP0_STATUS&#39;:
                return env.CP0_Status


        return super().get_reg(cpu, reg)

    def get_pc(self, cpu):
        &#39;&#39;&#39;
        Overloaded function to return the MIPS current program counter
        &#39;&#39;&#39;
        return cpu.env_ptr.active_tc.PC

    def set_pc(self, cpu, val):
        &#39;&#39;&#39;
        Overloaded function set the MIPS program counter
        &#39;&#39;&#39;
        cpu.env_ptr.active_tc.PC = val

    def get_retval(self, cpu, convention=&#39;default&#39;):
        &#39;&#39;&#39;
        Overloaded to incorporate error data from A3 register for syscalls.

        If A3 is 1 and convention is syscall, *negate* the return value.
        This matches behavior of other architecures (where -ERRNO is returned
        on error)
        &#39;&#39;&#39;

        flip = 1
        if convention == &#39;syscall&#39; and self.get_reg(cpu, &#34;A3&#34;) == 1:
            flip = -1

        return flip * super().get_retval(cpu)


    def _get_reg_val(self, cpu, reg):
        &#39;&#39;&#39;
        Return a mips register
        &#39;&#39;&#39;
        return cpu.env_ptr.active_tc.gpr[reg]

    def _set_reg_val(self, cpu, reg, val):
        &#39;&#39;&#39;
        Set a mips register
        &#39;&#39;&#39;
        cpu.env_ptr.active_tc.gpr[reg] = val

    def get_return_value(self, cpu, convention=&#39;default&#39;):
        &#39;&#39;&#39;
        .. Deprecated:: use get_retval
        &#39;&#39;&#39;
        return self.get_retval(cpu)

    def get_call_return(self, cpu):
        &#39;&#39;&#39;
        .. Deprecated:: use get_return_address
        &#39;&#39;&#39;
        return self.get_return_address(cpu)

    def get_return_address(self,cpu):
        &#39;&#39;&#39;
        looks up where ret will go
        &#39;&#39;&#39;
        return self.get_reg(cpu, &#34;RA&#34;)

    def set_retval(self, cpu, val, convention=&#39;default&#39;, failure=False):
        &#39;&#39;&#39;
        Overloaded function so when convention is syscall, user can control
        the A3 register (which indicates syscall success/failure) in addition
        to the syscall return value.

        When convention == &#39;syscall&#39;, failure = False means A3 will bet set to 0.
        Otherwise, it will be set to 1

        &#39;&#39;&#39;
        if convention == &#39;syscall&#39;:
            # Set A3 register to indicate syscall success/failure
            self.set_reg(cpu, &#39;a3&#39;, failure)

            # If caller is trying to indicate error by setting a negative retval
            # for a syscall, just make it positive with A3=1
            if failure and self.panda.from_unsigned_guest(val) &lt; 0:
                val = -1 * self.panda.from_unsigned_guest(val)

        return super().set_retval(cpu, val, convention)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.arch.PandaArch" href="#pandare.arch.PandaArch">PandaArch</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pandare.arch.Mips64Arch" href="#pandare.arch.Mips64Arch">Mips64Arch</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.arch.MipsArch.get_call_return"><code class="name flex">
<span>def <span class="ident">get_call_return</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><div class="admonition deprecated">
<p class="admonition-title">Deprecated:&ensp;use get_return_address</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_call_return(self, cpu):
    &#39;&#39;&#39;
    .. Deprecated:: use get_return_address
    &#39;&#39;&#39;
    return self.get_return_address(cpu)</code></pre>
</details>
</dd>
<dt id="pandare.arch.MipsArch.get_pc"><code class="name flex">
<span>def <span class="ident">get_pc</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Overloaded function to return the MIPS current program counter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pc(self, cpu):
    &#39;&#39;&#39;
    Overloaded function to return the MIPS current program counter
    &#39;&#39;&#39;
    return cpu.env_ptr.active_tc.PC</code></pre>
</details>
</dd>
<dt id="pandare.arch.MipsArch.get_reg"><code class="name flex">
<span>def <span class="ident">get_reg</span></span>(<span>self, cpu, reg)</span>
</code></dt>
<dd>
<div class="desc"><p>Overloaded function for a few mips specific registers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reg(self, cpu, reg):
    &#39;&#39;&#39;
    Overloaded function for a few mips specific registers
    &#39;&#39;&#39;

    if isinstance(reg, str):
        env = cpu.env_ptr
        reg = reg.upper()
        if reg == &#39;HI&#39;:
            return env.CP0_EntryHi
        elif reg == &#39;LO&#39;:
            return env.CP0_EntryLo0
        elif reg.startswith(&#39;F&#39;) and reg[1:].isnumeric():
            num = int(reg[1:])
            _, endianness, _ = self._determine_bits()
            return int.from_bytes(bytes(env.fpus[0].fpr[num]), byteorder=endianness)
        elif reg == &#39;FCCR&#39;:
            return env.fpus[0].fcr0
        elif reg == &#39;DSPCONTROL&#39;:
            return env.active_tc.DSPControl
        elif reg == &#39;CP0_STATUS&#39;:
            return env.CP0_Status


    return super().get_reg(cpu, reg)</code></pre>
</details>
</dd>
<dt id="pandare.arch.MipsArch.get_return_address"><code class="name flex">
<span>def <span class="ident">get_return_address</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>looks up where ret will go</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_return_address(self,cpu):
    &#39;&#39;&#39;
    looks up where ret will go
    &#39;&#39;&#39;
    return self.get_reg(cpu, &#34;RA&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.arch.MipsArch.get_return_value"><code class="name flex">
<span>def <span class="ident">get_return_value</span></span>(<span>self, cpu, convention='default')</span>
</code></dt>
<dd>
<div class="desc"><div class="admonition deprecated">
<p class="admonition-title">Deprecated:&ensp;use get_retval</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_return_value(self, cpu, convention=&#39;default&#39;):
    &#39;&#39;&#39;
    .. Deprecated:: use get_retval
    &#39;&#39;&#39;
    return self.get_retval(cpu)</code></pre>
</details>
</dd>
<dt id="pandare.arch.MipsArch.get_retval"><code class="name flex">
<span>def <span class="ident">get_retval</span></span>(<span>self, cpu, convention='default')</span>
</code></dt>
<dd>
<div class="desc"><p>Overloaded to incorporate error data from A3 register for syscalls.</p>
<p>If A3 is 1 and convention is syscall, <em>negate</em> the return value.
This matches behavior of other architecures (where -ERRNO is returned
on error)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_retval(self, cpu, convention=&#39;default&#39;):
    &#39;&#39;&#39;
    Overloaded to incorporate error data from A3 register for syscalls.

    If A3 is 1 and convention is syscall, *negate* the return value.
    This matches behavior of other architecures (where -ERRNO is returned
    on error)
    &#39;&#39;&#39;

    flip = 1
    if convention == &#39;syscall&#39; and self.get_reg(cpu, &#34;A3&#34;) == 1:
        flip = -1

    return flip * super().get_retval(cpu)</code></pre>
</details>
</dd>
<dt id="pandare.arch.MipsArch.set_pc"><code class="name flex">
<span>def <span class="ident">set_pc</span></span>(<span>self, cpu, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Overloaded function set the MIPS program counter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pc(self, cpu, val):
    &#39;&#39;&#39;
    Overloaded function set the MIPS program counter
    &#39;&#39;&#39;
    cpu.env_ptr.active_tc.PC = val</code></pre>
</details>
</dd>
<dt id="pandare.arch.MipsArch.set_retval"><code class="name flex">
<span>def <span class="ident">set_retval</span></span>(<span>self, cpu, val, convention='default', failure=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Overloaded function so when convention is syscall, user can control
the A3 register (which indicates syscall success/failure) in addition
to the syscall return value.</p>
<p>When convention == 'syscall', failure = False means A3 will bet set to 0.
Otherwise, it will be set to 1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_retval(self, cpu, val, convention=&#39;default&#39;, failure=False):
    &#39;&#39;&#39;
    Overloaded function so when convention is syscall, user can control
    the A3 register (which indicates syscall success/failure) in addition
    to the syscall return value.

    When convention == &#39;syscall&#39;, failure = False means A3 will bet set to 0.
    Otherwise, it will be set to 1

    &#39;&#39;&#39;
    if convention == &#39;syscall&#39;:
        # Set A3 register to indicate syscall success/failure
        self.set_reg(cpu, &#39;a3&#39;, failure)

        # If caller is trying to indicate error by setting a negative retval
        # for a syscall, just make it positive with A3=1
        if failure and self.panda.from_unsigned_guest(val) &lt; 0:
            val = -1 * self.panda.from_unsigned_guest(val)

    return super().set_retval(cpu, val, convention)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pandare.arch.PandaArch" href="#pandare.arch.PandaArch">PandaArch</a></b></code>:
<ul class="hlist">
<li><code><a title="pandare.arch.PandaArch.dump_regs" href="#pandare.arch.PandaArch.dump_regs">dump_regs</a></code></li>
<li><code><a title="pandare.arch.PandaArch.dump_stack" href="#pandare.arch.PandaArch.dump_stack">dump_stack</a></code></li>
<li><code><a title="pandare.arch.PandaArch.dump_state" href="#pandare.arch.PandaArch.dump_state">dump_state</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_arg" href="#pandare.arch.PandaArch.get_arg">get_arg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.registers" href="#pandare.arch.PandaArch.registers">registers</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_arg" href="#pandare.arch.PandaArch.set_arg">set_arg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_reg" href="#pandare.arch.PandaArch.set_reg">set_reg</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pandare.arch.PandaArch"><code class="flex name class">
<span>class <span class="ident">PandaArch</span></span>
<span>(</span><span>panda)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for architecture-specific implementations for PANDA-supported architectures</p>
<p>Initialize a PANDA-supported architecture and hold a handle on the PANDA object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PandaArch():
    &#39;&#39;&#39;
    Base class for architecture-specific implementations for PANDA-supported architectures
    &#39;&#39;&#39;
    def __init__(self, panda):
        &#39;&#39;&#39;
        Initialize a PANDA-supported architecture and hold a handle on the PANDA object
        &#39;&#39;&#39;
        self.panda = panda

        self.reg_sp      = None # Stack pointer register ID if stored in a register
        self.reg_pc      = None # PC register ID if stored in a register
        self.reg_retaddr = None # Register ID that contains return address
        self.reg_retval  = None # convention: register name that contains return val
        self.call_conventions = None # convention: [&#39;reg_for_arg0&#39;, &#39;reg_for_arg1&#39;,...]
        self.registers = {}
        &#39;&#39;&#39;
        Mapping of register names to indices into the appropriate CPUState array
        &#39;&#39;&#39;

    def _determine_bits(self):
        &#39;&#39;&#39;
        Determine bits and endianness for the panda object&#39;s architecture
        &#39;&#39;&#39;
        bits = None
        endianness = None # String &#39;little&#39; or &#39;big&#39;
        if self.panda.arch_name == &#34;i386&#34;:
            bits = 32
            endianness = &#34;little&#34;
        elif self.panda.arch_name == &#34;x86_64&#34;:
            bits = 64
            endianness = &#34;little&#34;
        elif self.panda.arch_name == &#34;arm&#34;:
            endianness = &#34;little&#34; # XXX add support for arm BE?
            bits = 32
        elif self.panda.arch_name == &#34;aarch64&#34;:
            bits = 64
            endianness = &#34;little&#34; # XXX add support for arm BE?
        elif self.panda.arch_name == &#34;ppc&#34;:
            bits = 32
            endianness = &#34;big&#34;
        elif self.panda.arch_name == &#34;mips&#34;:
            bits = 32
            endianness = &#34;big&#34;
        elif self.panda.arch_name == &#34;mipsel&#34;:
            bits = 32
            endianness = &#34;little&#34;
        elif self.panda.arch_name == &#34;mips64&#34;:
            bits = 64
            endianness = &#34;big&#34;

        assert (bits is not None), f&#34;Missing num_bits logic for {self.panda.arch_name}&#34;
        assert (endianness is not None), f&#34;Missing endianness logic for {self.panda.arch_name}&#34;
        register_size = int(bits/8)
        return bits, endianness, register_size

    def get_reg(self, cpu, reg):
        &#39;&#39;&#39;
        Return value in a `reg` which is either a register name or index (e.g., &#34;R0&#34; or 0)
        &#39;&#39;&#39;
        if isinstance(reg, str):
            reg = reg.upper()
            if reg == &#39;PC&#39;:
                return self.get_pc(cpu)
            if reg not in self.registers.keys():
                raise ValueError(f&#34;Invalid register name {reg}&#34;)
            else:
                reg = self.registers[reg]

        return self._get_reg_val(cpu, reg)

    def _get_reg_val(self, cpu, idx):
        &#39;&#39;&#39;
        Virtual method. Must be implemented for each architecture to return contents of register specified by idx.
        &#39;&#39;&#39;
        raise NotImplementedError()

    def set_reg(self, cpu, reg, val):
        &#39;&#39;&#39;
        Set register `reg` to a value where `reg` is either a register name or index (e.g., &#34;R0&#34; or 0)
        &#39;&#39;&#39;
        if isinstance(reg, str):
            reg = reg.upper()
            if reg not in self.registers.keys():
                raise ValueError(f&#34;Invalid register name {reg}&#34;)
            else:
                reg = self.registers[reg]
        elif not isinstance(reg, int):
            raise ValueError(f&#34;Can&#39;t set register {reg}&#34;)

        return self._set_reg_val(cpu, reg, val)

    def _set_reg_val(self, cpu, idx, val):
        &#39;&#39;&#39;
        Virtual method. Must be implemented for each architecture to return contents of register specified by idx.
        &#39;&#39;&#39;
        raise NotImplementedError()

    def get_pc(self, cpu):
        &#39;&#39;&#39;
        Returns the current program counter. Must be overloaded if self.reg_pc is None
        &#39;&#39;&#39;
        if self.reg_pc:
            return self.get_reg(cpu, self.reg_pc)
        else:
            raise RuntimeError(f&#34;get_pc unsupported for {self.panda.arch_name}&#34;)

    def _get_arg_loc(self, idx, convention):
        &#39;&#39;&#39;
        return the name of the argument [idx] for the given arch with calling [convention]
        &#39;&#39;&#39;

        if self.call_conventions and convention in self.call_conventions:
            if idx &lt; len(self.call_conventions[convention]):
                return self.call_conventions[convention][idx]
            raise NotImplementedError(f&#34;Unsupported argument number {idx}&#34;)
        raise NotImplementedError(f&#34;Unsupported convention {convention} for {type(self)}&#34;)

    def _get_ret_val_reg(self, cpu, convention):
        if self.reg_retval and convention in self.reg_retval:
            return self.reg_retval[convention]
        raise NotImplementedError(f&#34;Unsupported get_retval for architecture {type(self)} {convention}&#34;)


    def set_arg(self, cpu, idx, val, convention=&#39;default&#39;):
        &#39;&#39;&#39;
        Set arg [idx] to [val] for given calling convention.

        Note for syscalls we define arg[0] as syscall number and then 1-index the actual args
        &#39;&#39;&#39;
        argloc = self._get_arg_loc(idx, convention)

        if self._is_stack_loc(argloc):
            return self._write_stack(cpu, argloc, val)
        else:
            return self.set_reg(cpu, argloc, val)

    def get_arg(self, cpu, idx, convention=&#39;default&#39;):
        &#39;&#39;&#39;
        Return arg [idx] for given calling convention. This only works right as the guest
        is calling or has called a function before register values are clobbered.

        If arg[idx] should be stack-based, name it stack_0, stack_1... this allows mixed
        conventions where some args are in registers and others are on the stack (i.e.,
        mips32 syscalls).

        When doing a stack-based read, this function may raise a ValueError if the memory
        read fails (i.e., paged out, invalid address).

        Note for syscalls we define arg[0] as syscall number and then 1-index the actual args
        &#39;&#39;&#39;
        
        argloc = self._get_arg_loc(idx, convention)

        if self._is_stack_loc(argloc):
            return self._read_stack(cpu, argloc)
        else:
            return self.get_reg(cpu, argloc)

    @staticmethod
    def _is_stack_loc(argloc):
        &#39;&#39;&#39;
        Given a name returned by self._get_arg_loc
        check if it&#39;s the name of a stack offset
        &#39;&#39;&#39;
        return argloc.startswith(&#34;stack_&#34;)

    def _write_stack(self, cpu, argloc, val):
        &#39;&#39;&#39;
        Given a name like stack_X, calculate where
        the X-th value on the stack is, then write val
        to that location

        May raise a ValueError if the memory write fails
        &#39;&#39;&#39;

        if isinstance(val, int):
            # Encode as word-size with endianness
            bits, endianness, reg_sz = self._determine_bits()
            val = val.to_bytes(reg_sz, byteorder=endianness)

        if not isinstance(val, bytes):
            raise ValueError(&#34;_write_stack needs an int or bytes&#34;)


        # Stack based - get stack base, calculate offset, then try to read it
        assert(self._is_stack_loc(argloc)), f&#34;Can&#39;t get stack offset of {argloc}&#34;

        stack_idx = int(argloc.split(&#34;stack_&#34;)[1])
        stack_base = self.get_reg(cpu, self.reg_sp)
        offset = reg_sz * (stack_idx+1)
        self.panda.virtual_memory_write(cpu, stack_base + offset, val)

    def _read_stack(self, cpu, argloc):
        &#39;&#39;&#39;
        Given a name like stack_X, calculate where
        the X-th value on the stack is, then read it out of
        memory and return it.

        May raise a ValueError if the memory read fails
        &#39;&#39;&#39;
        # Stack based - get stack base, calculate offset, then try to read it
        assert(self._is_stack_loc(argloc)), f&#34;Can&#39;t get stack offset of {argloc}&#34;

        stack_idx = int(argloc.split(&#34;stack_&#34;)[1])
        stack_base = self.get_reg(cpu, self.reg_sp)
        arg_sz = self.panda.bits // 8
        offset = arg_sz * (stack_idx+1)
        return self.panda.virtual_memory_read(cpu, stack_base + offset, arg_sz, fmt=&#39;int&#39;)

    def set_retval(self, cpu, val, convention=&#39;default&#39;, failure=False):
        &#39;&#39;&#39;
        Set return val to [val] for given calling convention. This only works
        right after a function call has returned, otherwise the register will contain
        a different value.

        If the given architecture returns failure/success in a second register (i.e., the A3
        register for mips), set that according to the failure flag.

        Note the failure argument only used by subclasses that overload this function. It&#39;s provided
        in the signature here so it can be set by a caller without regard for the guest architecture.
        &#39;&#39;&#39;
        reg = self._get_ret_val_reg(cpu, convention)
        return self.set_reg(cpu, reg, val)

    def get_retval(self, cpu, convention=&#39;default&#39;):
        &#39;&#39;&#39;
        Set return val to [val] for given calling convention. This only works
        right after a function call has returned, otherwise the register will contain
        a different value.

        Return value from syscalls is signed
        &#39;&#39;&#39;
        reg = self._get_ret_val_reg(cpu, convention)
        rv = self.get_reg(cpu, reg)

        if convention == &#39;syscall&#39;:
            rv = self.panda.from_unsigned_guest(rv)
        return rv


    def set_pc(self, cpu, val):
        &#39;&#39;&#39;
        Set the program counter. Must be overloaded if self.reg_pc is None
        &#39;&#39;&#39;
        if self.reg_pc:
            return self.set_reg(cpu, self.reg_pc, val)
        else:
            raise RuntimeError(f&#34;set_pc unsupported for {self.panda.arch_name}&#34;)

    def dump_regs(self, cpu):
        &#39;&#39;&#39;
        Print (telescoping) each register and its values
        &#39;&#39;&#39;
        print(f&#34;PC: {self.get_pc(cpu):x}&#34;)

        for (regname, reg) in self.registers.items():
            val = self.get_reg(cpu, reg)
            print(&#34;{}: 0x{:x}&#34;.format(regname, val), end=&#34;\t&#34;)
            telescope(self.panda, cpu, val)

    def dump_stack(self, cpu, words=8):
        &#39;&#39;&#39;
        Print (telescoping) most recent `words` words on the stack (from stack pointer to stack pointer + `words`*word_size)
        &#39;&#39;&#39;

        base_reg_s = &#34;SP&#34;
        base_reg_val = self.get_reg(cpu, self.reg_sp)
        if base_reg_val == 0:
            print(&#34;[WARNING: no stack pointer]&#34;)
            return
        word_size = int(self.panda.bits/8)

        _, endianness, _ = self._determine_bits()

        for word_idx in range(words):
            try:
                val_b = self.panda.virtual_memory_read(cpu, base_reg_val+word_idx*word_size, word_size)
                val = int.from_bytes(val_b, byteorder=endianness)
                print(&#34;[{}+0x{:0&gt;2x}] == 0x{:0&lt;8x}]: 0x{:0&lt;8x}&#34;.format(base_reg_s, word_idx*word_size, base_reg_val+word_idx*word_size, val), end=&#34;\t&#34;)
                telescope(self.panda, cpu, val)
            except ValueError:
                print(&#34;[{}+0x{:0&gt;2x}] == [memory read error]&#34;.format(base_reg_s, word_idx*word_size))

    def dump_state(self, cpu):
        &#34;&#34;&#34;
        Print registers and stack
        &#34;&#34;&#34;
        self.dump_regs(cpu)
        self.dump_stack(cpu)

    def get_args(self, cpu, num, convention=&#39;default&#39;):
        return [self.get_arg(cpu,i, convention) for i in range(num)]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pandare.arch.Aarch64Arch" href="#pandare.arch.Aarch64Arch">Aarch64Arch</a></li>
<li><a title="pandare.arch.ArmArch" href="#pandare.arch.ArmArch">ArmArch</a></li>
<li><a title="pandare.arch.MipsArch" href="#pandare.arch.MipsArch">MipsArch</a></li>
<li><a title="pandare.arch.X86Arch" href="#pandare.arch.X86Arch">X86Arch</a></li>
<li><a title="pandare.arch.X86_64Arch" href="#pandare.arch.X86_64Arch">X86_64Arch</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pandare.arch.PandaArch.registers"><code class="name">var <span class="ident">registers</span></code></dt>
<dd>
<div class="desc"><p>Mapping of register names to indices into the appropriate CPUState array</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pandare.arch.PandaArch.dump_regs"><code class="name flex">
<span>def <span class="ident">dump_regs</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Print (telescoping) each register and its values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_regs(self, cpu):
    &#39;&#39;&#39;
    Print (telescoping) each register and its values
    &#39;&#39;&#39;
    print(f&#34;PC: {self.get_pc(cpu):x}&#34;)

    for (regname, reg) in self.registers.items():
        val = self.get_reg(cpu, reg)
        print(&#34;{}: 0x{:x}&#34;.format(regname, val), end=&#34;\t&#34;)
        telescope(self.panda, cpu, val)</code></pre>
</details>
</dd>
<dt id="pandare.arch.PandaArch.dump_stack"><code class="name flex">
<span>def <span class="ident">dump_stack</span></span>(<span>self, cpu, words=8)</span>
</code></dt>
<dd>
<div class="desc"><p>Print (telescoping) most recent <code>words</code> words on the stack (from stack pointer to stack pointer + <code>words</code>*word_size)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_stack(self, cpu, words=8):
    &#39;&#39;&#39;
    Print (telescoping) most recent `words` words on the stack (from stack pointer to stack pointer + `words`*word_size)
    &#39;&#39;&#39;

    base_reg_s = &#34;SP&#34;
    base_reg_val = self.get_reg(cpu, self.reg_sp)
    if base_reg_val == 0:
        print(&#34;[WARNING: no stack pointer]&#34;)
        return
    word_size = int(self.panda.bits/8)

    _, endianness, _ = self._determine_bits()

    for word_idx in range(words):
        try:
            val_b = self.panda.virtual_memory_read(cpu, base_reg_val+word_idx*word_size, word_size)
            val = int.from_bytes(val_b, byteorder=endianness)
            print(&#34;[{}+0x{:0&gt;2x}] == 0x{:0&lt;8x}]: 0x{:0&lt;8x}&#34;.format(base_reg_s, word_idx*word_size, base_reg_val+word_idx*word_size, val), end=&#34;\t&#34;)
            telescope(self.panda, cpu, val)
        except ValueError:
            print(&#34;[{}+0x{:0&gt;2x}] == [memory read error]&#34;.format(base_reg_s, word_idx*word_size))</code></pre>
</details>
</dd>
<dt id="pandare.arch.PandaArch.dump_state"><code class="name flex">
<span>def <span class="ident">dump_state</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Print registers and stack</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_state(self, cpu):
    &#34;&#34;&#34;
    Print registers and stack
    &#34;&#34;&#34;
    self.dump_regs(cpu)
    self.dump_stack(cpu)</code></pre>
</details>
</dd>
<dt id="pandare.arch.PandaArch.get_arg"><code class="name flex">
<span>def <span class="ident">get_arg</span></span>(<span>self, cpu, idx, convention='default')</span>
</code></dt>
<dd>
<div class="desc"><p>Return arg [idx] for given calling convention. This only works right as the guest
is calling or has called a function before register values are clobbered.</p>
<p>If arg[idx] should be stack-based, name it stack_0, stack_1&hellip; this allows mixed
conventions where some args are in registers and others are on the stack (i.e.,
mips32 syscalls).</p>
<p>When doing a stack-based read, this function may raise a ValueError if the memory
read fails (i.e., paged out, invalid address).</p>
<p>Note for syscalls we define arg[0] as syscall number and then 1-index the actual args</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_arg(self, cpu, idx, convention=&#39;default&#39;):
    &#39;&#39;&#39;
    Return arg [idx] for given calling convention. This only works right as the guest
    is calling or has called a function before register values are clobbered.

    If arg[idx] should be stack-based, name it stack_0, stack_1... this allows mixed
    conventions where some args are in registers and others are on the stack (i.e.,
    mips32 syscalls).

    When doing a stack-based read, this function may raise a ValueError if the memory
    read fails (i.e., paged out, invalid address).

    Note for syscalls we define arg[0] as syscall number and then 1-index the actual args
    &#39;&#39;&#39;
    
    argloc = self._get_arg_loc(idx, convention)

    if self._is_stack_loc(argloc):
        return self._read_stack(cpu, argloc)
    else:
        return self.get_reg(cpu, argloc)</code></pre>
</details>
</dd>
<dt id="pandare.arch.PandaArch.get_args"><code class="name flex">
<span>def <span class="ident">get_args</span></span>(<span>self, cpu, num, convention='default')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_args(self, cpu, num, convention=&#39;default&#39;):
    return [self.get_arg(cpu,i, convention) for i in range(num)]</code></pre>
</details>
</dd>
<dt id="pandare.arch.PandaArch.get_pc"><code class="name flex">
<span>def <span class="ident">get_pc</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current program counter. Must be overloaded if self.reg_pc is None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pc(self, cpu):
    &#39;&#39;&#39;
    Returns the current program counter. Must be overloaded if self.reg_pc is None
    &#39;&#39;&#39;
    if self.reg_pc:
        return self.get_reg(cpu, self.reg_pc)
    else:
        raise RuntimeError(f&#34;get_pc unsupported for {self.panda.arch_name}&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.arch.PandaArch.get_reg"><code class="name flex">
<span>def <span class="ident">get_reg</span></span>(<span>self, cpu, reg)</span>
</code></dt>
<dd>
<div class="desc"><p>Return value in a <code>reg</code> which is either a register name or index (e.g., "R0" or 0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reg(self, cpu, reg):
    &#39;&#39;&#39;
    Return value in a `reg` which is either a register name or index (e.g., &#34;R0&#34; or 0)
    &#39;&#39;&#39;
    if isinstance(reg, str):
        reg = reg.upper()
        if reg == &#39;PC&#39;:
            return self.get_pc(cpu)
        if reg not in self.registers.keys():
            raise ValueError(f&#34;Invalid register name {reg}&#34;)
        else:
            reg = self.registers[reg]

    return self._get_reg_val(cpu, reg)</code></pre>
</details>
</dd>
<dt id="pandare.arch.PandaArch.get_retval"><code class="name flex">
<span>def <span class="ident">get_retval</span></span>(<span>self, cpu, convention='default')</span>
</code></dt>
<dd>
<div class="desc"><p>Set return val to [val] for given calling convention. This only works
right after a function call has returned, otherwise the register will contain
a different value.</p>
<p>Return value from syscalls is signed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_retval(self, cpu, convention=&#39;default&#39;):
    &#39;&#39;&#39;
    Set return val to [val] for given calling convention. This only works
    right after a function call has returned, otherwise the register will contain
    a different value.

    Return value from syscalls is signed
    &#39;&#39;&#39;
    reg = self._get_ret_val_reg(cpu, convention)
    rv = self.get_reg(cpu, reg)

    if convention == &#39;syscall&#39;:
        rv = self.panda.from_unsigned_guest(rv)
    return rv</code></pre>
</details>
</dd>
<dt id="pandare.arch.PandaArch.set_arg"><code class="name flex">
<span>def <span class="ident">set_arg</span></span>(<span>self, cpu, idx, val, convention='default')</span>
</code></dt>
<dd>
<div class="desc"><p>Set arg [idx] to [val] for given calling convention.</p>
<p>Note for syscalls we define arg[0] as syscall number and then 1-index the actual args</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_arg(self, cpu, idx, val, convention=&#39;default&#39;):
    &#39;&#39;&#39;
    Set arg [idx] to [val] for given calling convention.

    Note for syscalls we define arg[0] as syscall number and then 1-index the actual args
    &#39;&#39;&#39;
    argloc = self._get_arg_loc(idx, convention)

    if self._is_stack_loc(argloc):
        return self._write_stack(cpu, argloc, val)
    else:
        return self.set_reg(cpu, argloc, val)</code></pre>
</details>
</dd>
<dt id="pandare.arch.PandaArch.set_pc"><code class="name flex">
<span>def <span class="ident">set_pc</span></span>(<span>self, cpu, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the program counter. Must be overloaded if self.reg_pc is None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pc(self, cpu, val):
    &#39;&#39;&#39;
    Set the program counter. Must be overloaded if self.reg_pc is None
    &#39;&#39;&#39;
    if self.reg_pc:
        return self.set_reg(cpu, self.reg_pc, val)
    else:
        raise RuntimeError(f&#34;set_pc unsupported for {self.panda.arch_name}&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.arch.PandaArch.set_reg"><code class="name flex">
<span>def <span class="ident">set_reg</span></span>(<span>self, cpu, reg, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Set register <code>reg</code> to a value where <code>reg</code> is either a register name or index (e.g., "R0" or 0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_reg(self, cpu, reg, val):
    &#39;&#39;&#39;
    Set register `reg` to a value where `reg` is either a register name or index (e.g., &#34;R0&#34; or 0)
    &#39;&#39;&#39;
    if isinstance(reg, str):
        reg = reg.upper()
        if reg not in self.registers.keys():
            raise ValueError(f&#34;Invalid register name {reg}&#34;)
        else:
            reg = self.registers[reg]
    elif not isinstance(reg, int):
        raise ValueError(f&#34;Can&#39;t set register {reg}&#34;)

    return self._set_reg_val(cpu, reg, val)</code></pre>
</details>
</dd>
<dt id="pandare.arch.PandaArch.set_retval"><code class="name flex">
<span>def <span class="ident">set_retval</span></span>(<span>self, cpu, val, convention='default', failure=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Set return val to [val] for given calling convention. This only works
right after a function call has returned, otherwise the register will contain
a different value.</p>
<p>If the given architecture returns failure/success in a second register (i.e., the A3
register for mips), set that according to the failure flag.</p>
<p>Note the failure argument only used by subclasses that overload this function. It's provided
in the signature here so it can be set by a caller without regard for the guest architecture.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_retval(self, cpu, val, convention=&#39;default&#39;, failure=False):
    &#39;&#39;&#39;
    Set return val to [val] for given calling convention. This only works
    right after a function call has returned, otherwise the register will contain
    a different value.

    If the given architecture returns failure/success in a second register (i.e., the A3
    register for mips), set that according to the failure flag.

    Note the failure argument only used by subclasses that overload this function. It&#39;s provided
    in the signature here so it can be set by a caller without regard for the guest architecture.
    &#39;&#39;&#39;
    reg = self._get_ret_val_reg(cpu, convention)
    return self.set_reg(cpu, reg, val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.arch.X86Arch"><code class="flex name class">
<span>class <span class="ident">X86Arch</span></span>
<span>(</span><span>panda)</span>
</code></dt>
<dd>
<div class="desc"><p>Register names and accessors for x86</p>
<p>Initialize a PANDA-supported architecture and hold a handle on the PANDA object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class X86Arch(PandaArch):
    &#39;&#39;&#39;
    Register names and accessors for x86
    &#39;&#39;&#39;

    def __init__(self, panda):
        super().__init__(panda)
        regnames = [&#39;EAX&#39;, &#39;ECX&#39;, &#39;EDX&#39;, &#39;EBX&#39;, &#39;ESP&#39;, &#39;EBP&#39;, &#39;ESI&#39;, &#39;EDI&#39;]
        # XXX Note order is A C D B, because that&#39;s how qemu does it . See target/i386/cpu.h

        # Note we don&#39;t set self.call_conventions because stack-based arg get/set is
        # not yet supported
        self.reg_retval = {&#34;default&#34;:    &#34;EAX&#34;,
                           &#34;syscall&#34;:    &#34;EAX&#34;,
                           &#34;linux_kernel&#34;:    &#34;EAX&#34;}

        self.call_conventions = {&#34;cdecl&#34;: [f&#34;stack_{x}&#34; for x in range(20)], # 20: arbitrary but big
                                 &#34;syscall&#34;: [&#34;EAX&#34;, &#34;EBX&#34;, &#34;ECX&#34;, &#34;EDX&#34;, &#34;ESI&#34;, &#34;EDI&#34;, &#34;EBP&#34;],
                                 &#34;linux_kernel&#34;: [&#34;EAX&#34;, &#34;EDX&#34;, &#34;ECX&#34;, &#34;stack_3&#34;, &#34;stack_4&#34;, &#34;stack_5&#34;, &#34;stack_6&#34;]}
        self.call_conventions[&#39;default&#39;] = self.call_conventions[&#39;cdecl&#39;]

        self.reg_sp = regnames.index(&#39;ESP&#39;)
        self.registers = {regnames[idx]: idx for idx in range(len(regnames)) }


    def get_pc(self, cpu):
        &#39;&#39;&#39;
        Overloaded function to return the x86 current program counter
        &#39;&#39;&#39;
        return cpu.env_ptr.eip

    def set_pc(self, cpu, val):
        &#39;&#39;&#39;
        Overloaded function to set the x86 program counter
        &#39;&#39;&#39;
        cpu.env_ptr.eip = val

    def _get_reg_val(self, cpu, reg):
        &#39;&#39;&#39;
        Return an x86 register
        &#39;&#39;&#39;
        return cpu.env_ptr.regs[reg]

    def _set_reg_val(self, cpu, reg, val):
        &#39;&#39;&#39;
        Set an x86 register
        &#39;&#39;&#39;
        cpu.env_ptr.regs[reg] = val

    def get_return_value(self, cpu):
        &#39;&#39;&#39;
        .. Deprecated:: use get_retval
        &#39;&#39;&#39;
        return self.get_retval(cpu)

    def get_return_address(self,cpu):
        &#39;&#39;&#39;
        looks up where ret will go
        &#39;&#39;&#39;
        esp = self.get_reg(cpu,&#34;ESP&#34;)
        return self.panda.virtual_memory_read(cpu,esp,4,fmt=&#39;int&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.arch.PandaArch" href="#pandare.arch.PandaArch">PandaArch</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.arch.X86Arch.get_pc"><code class="name flex">
<span>def <span class="ident">get_pc</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Overloaded function to return the x86 current program counter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pc(self, cpu):
    &#39;&#39;&#39;
    Overloaded function to return the x86 current program counter
    &#39;&#39;&#39;
    return cpu.env_ptr.eip</code></pre>
</details>
</dd>
<dt id="pandare.arch.X86Arch.get_return_address"><code class="name flex">
<span>def <span class="ident">get_return_address</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>looks up where ret will go</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_return_address(self,cpu):
    &#39;&#39;&#39;
    looks up where ret will go
    &#39;&#39;&#39;
    esp = self.get_reg(cpu,&#34;ESP&#34;)
    return self.panda.virtual_memory_read(cpu,esp,4,fmt=&#39;int&#39;)</code></pre>
</details>
</dd>
<dt id="pandare.arch.X86Arch.get_return_value"><code class="name flex">
<span>def <span class="ident">get_return_value</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><div class="admonition deprecated">
<p class="admonition-title">Deprecated:&ensp;use get_retval</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_return_value(self, cpu):
    &#39;&#39;&#39;
    .. Deprecated:: use get_retval
    &#39;&#39;&#39;
    return self.get_retval(cpu)</code></pre>
</details>
</dd>
<dt id="pandare.arch.X86Arch.set_pc"><code class="name flex">
<span>def <span class="ident">set_pc</span></span>(<span>self, cpu, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Overloaded function to set the x86 program counter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pc(self, cpu, val):
    &#39;&#39;&#39;
    Overloaded function to set the x86 program counter
    &#39;&#39;&#39;
    cpu.env_ptr.eip = val</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pandare.arch.PandaArch" href="#pandare.arch.PandaArch">PandaArch</a></b></code>:
<ul class="hlist">
<li><code><a title="pandare.arch.PandaArch.dump_regs" href="#pandare.arch.PandaArch.dump_regs">dump_regs</a></code></li>
<li><code><a title="pandare.arch.PandaArch.dump_stack" href="#pandare.arch.PandaArch.dump_stack">dump_stack</a></code></li>
<li><code><a title="pandare.arch.PandaArch.dump_state" href="#pandare.arch.PandaArch.dump_state">dump_state</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_arg" href="#pandare.arch.PandaArch.get_arg">get_arg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_reg" href="#pandare.arch.PandaArch.get_reg">get_reg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_retval" href="#pandare.arch.PandaArch.get_retval">get_retval</a></code></li>
<li><code><a title="pandare.arch.PandaArch.registers" href="#pandare.arch.PandaArch.registers">registers</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_arg" href="#pandare.arch.PandaArch.set_arg">set_arg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_reg" href="#pandare.arch.PandaArch.set_reg">set_reg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_retval" href="#pandare.arch.PandaArch.set_retval">set_retval</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pandare.arch.X86_64Arch"><code class="flex name class">
<span>class <span class="ident">X86_64Arch</span></span>
<span>(</span><span>panda)</span>
</code></dt>
<dd>
<div class="desc"><p>Register names and accessors for x86_64</p>
<p>Initialize a PANDA-supported architecture and hold a handle on the PANDA object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class X86_64Arch(PandaArch):
    &#39;&#39;&#39;
    Register names and accessors for x86_64
    &#39;&#39;&#39;

    def __init__(self, panda):
        super().__init__(panda)
        # The only place I could find the R_ names is in tcg/i386/tcg-target.h:50
        regnames = [&#39;RAX&#39;, &#39;RCX&#39;, &#39;RDX&#39;, &#39;RBX&#39;, &#39;RSP&#39;, &#39;RBP&#39;, &#39;RSI&#39;, &#39;RDI&#39;,
                    &#39;R8&#39;, &#39;R9&#39;, &#39;R10&#39;, &#39;R11&#39;, &#39;R12&#39;, &#39;R13&#39;, &#39;R14&#39;, &#39;R15&#39;]
        # XXX Note order is A C D B, because that&#39;s how qemu does it

        self.call_conventions = {&#39;sysv&#39;:           [&#39;RDI&#39;, &#39;RSI&#39;, &#39;RDX&#39;, &#39;RCX&#39;, &#39;R8&#39;, &#39;R9&#39;],
                                 &#39;syscall&#39;: [&#39;RAX&#39;, &#39;RDI&#39;, &#39;RSI&#39;, &#39;RDX&#39;, &#39;R10&#39;, &#39;R8&#39;, &#39;R9&#39;]}

        self.call_conventions[&#39;default&#39;] = self.call_conventions[&#39;sysv&#39;]
        self.call_conventions[&#39;linux_kernel&#39;] = self.call_conventions[&#39;sysv&#39;]

        self.reg_sp = regnames.index(&#39;RSP&#39;)
        self.reg_retval = {&#39;sysv&#39;: &#39;RAX&#39;,
                           &#39;syscall&#39;: &#39;RAX&#39;,
                           &#39;linux_kernel&#39;: &#39;RAX&#39;}
        self.reg_retval[&#39;default&#39;] = self.reg_retval[&#39;sysv&#39;]

        self.registers = {regnames[idx]: idx for idx in range(len(regnames)) }

        # Internal state to support some of the weird x86-64 registers
        self.reg_names_general = [&#39;EAX&#39;, &#39;ECX&#39;, &#39;EDX&#39;, &#39;EBX&#39;, &#39;ESP&#39;, &#39;EBP&#39;, &#39;ESI&#39;, &#39;EDI&#39;]
        self.reg_names_short = [&#39;AX&#39;, &#39;CX&#39;, &#39;DX&#39;, &#39;BX&#39;, &#39;SP&#39;, &#39;BP&#39;, &#39;SI&#39;, &#39;DI&#39;]
        self.reg_names_byte = [&#39;AL&#39;, &#39;CL&#39;, &#39;DL&#39;, &#39;BL&#39;, &#39;AH&#39;, &#39;CH&#39;, &#39;DH&#39;, &#39;BH&#39;]
        self.seg_names = [&#39;ES&#39;, &#39;CS&#39;, &#39;SS&#39;, &#39;DS&#39;, &#39;FS&#39;, &#39;GS&#39;]

    def _get_segment_register(self, env, seg_name):
        seg_idx = self.seg_names.index(seg_name)
        return env.segs[seg_idx].base

    def _get_general_purpose_register(self, env, reg_name, mask):
        return env.regs[self.reg_names_general.index(reg_name)] &amp; mask

    def _set_segment_register(self, env, seg_name, value):
        seg_idx = self.seg_names.index(seg_name)
        env.segs[seg_idx].base = value

    def _set_general_purpose_register(self, env, reg_name, value, mask):
        reg_idx = self.reg_names_general.index(reg_name)
        env.regs[reg_idx] = (env.regs[reg_idx] &amp; ~mask) | (value &amp; mask)

    def get_pc(self, cpu):
        &#39;&#39;&#39;
        Overloaded function to return the x86_64 current program counter
        &#39;&#39;&#39;
        return cpu.env_ptr.eip

    def get_retval(self, cpu, convention=&#39;default&#39;):
        &#39;&#39;&#39;
        Overloaded to support FreeBSD syscall ABI
        In that ABI, if eflags carry bit is set, an error has occured. To standardize
        pandare.arch returns across architectures/ABIs, we indicate a failure by returnning
        -ERRNO.
        &#39;&#39;&#39;

        error_flip = False
        if convention == &#39;syscall&#39; and self.panda.get_os_family() == &#39;OS_FREEBSD&#39; and \
                self.panda.libpanda.cpu_cc_compute_all(cpu.env_ptr, 1) &amp; 1 == 1:
            error_flip = True

        return super().get_retval(cpu, convention) * (-1 if error_flip else 1)

    def set_pc(self, cpu, val):
        &#39;&#39;&#39;
        Overloaded function to set the x86_64 program counter
        &#39;&#39;&#39;
        cpu.env_ptr.eip = val

    def _get_reg_val(self, cpu, reg):
        &#39;&#39;&#39;
        Return an x86_64 register
        &#39;&#39;&#39;
        return cpu.env_ptr.regs[reg]

    def _set_reg_val(self, cpu, reg, val):
        &#39;&#39;&#39;
        Set an x86_64 register
        &#39;&#39;&#39;
        cpu.env_ptr.regs[reg] = val

    def get_return_value(self, cpu):
        &#39;&#39;&#39;
        .. Deprecated:: use get_retval
        &#39;&#39;&#39;
        return self.get_retval(cpu)

    def get_return_address(self, cpu):
        &#39;&#39;&#39;
        looks up where ret will go
        &#39;&#39;&#39;
        esp = self.get_reg(cpu, &#34;RSP&#34;)
        return self.panda.virtual_memory_read(cpu, esp, 8, fmt=&#39;int&#39;)

    def get_reg(self, cpu, reg):
        &#39;&#39;&#39;
        X86_64 has a bunch of different ways to access registers. We support
        the regular names, the 32 and 16 bit varations (e.g., EAX, AX, AL),
        segment registers, and D/W/B style accesses to R8-R15
        &#39;&#39;&#39;
        if isinstance(reg, int):
            # If reg is an int, it should be an offset into our register array
            return self._get_reg_val(cpu, reg)

        reg = reg.upper()
        env = cpu.env_ptr
        if reg in self.seg_names:
            return self._get_segment_register(env, reg)
        elif reg in [&#39;RIP&#39;, &#39;PC&#39;, &#39;EIP&#39;]:
            pc = self.get_pc(cpu) # changes reg to &#39;IP&#39; and re-calls this
            if reg == &#39;EIP&#39;:
                pc &amp;= 0xFFFFFFFF
            return pc
        elif reg.startswith(&#39;XMM&#39;):
            raw_arr = env.xmm_regs[int(reg[3:].rstrip(&#39;HLQX&#39;))]
            _, endianness, _ = self._determine_bits()

            if reg.endswith(&#39;lq&#39;):
                value_bytes = raw_arr[0:8] # Lower 64 bits
            elif reg.endswith(&#39;hq&#39;):
                value_bytes = raw_arr[8:16] # Higher 64 bits
            elif reg.endswith(&#39;hx&#39;):
                value_bytes = raw_arr[4:8] # Higher 32 bits of the lower 64 bits
            else:
                value_bytes = raw_arr[0:16] # Full 128 bits
            return int.from_bytes(bytes(value_bytes), byteorder=endianness)

        elif reg.startswith(&#39;MM&#39;):
            raise ValueError(&#34;MM registers unsupported&#34;)
        elif reg.startswith(&#39;YMM&#39;):
            raise ValueError(&#34;YMM registers unsupported&#34;)
        elif reg.startswith(&#39;CR&#39;):
            return env.cr[int(reg[2:])]
        elif reg.startswith(&#39;R&#39;) and any([reg.endswith(x) for x in &#39;DWB&#39;]) and reg.strip(&#39;RDWB&#39;).isnumeric():
            # R8-R15 can be accessed with D (double word), W (word) and B (byte)
            # to select the lowest 32-bits, the lowest 16 bits, or the lowest 8 bits.
            reg_idx = int(reg.strip(&#39;RDWB&#39;)) - 8
            reg_suffix = reg[-1]
            mask = {&#39;D&#39;: 0xFFFFFFFF,
                    &#39;W&#39;: 0xFFFF,
                    &#39;B&#39;: 0xFF}[reg_suffix]
            return env.regs[reg_idx] &amp; mask
        elif reg in self.reg_names_general:
            return self._get_general_purpose_register(env, reg, 0xFFFFFFFF)
        elif reg in self.reg_names_short:
            return env.regs[self.reg_names_short.index(reg)] &amp; 0xFFFF
        elif reg in self.reg_names_byte:
            reg_idx = self.reg_names_byte.index(reg)
            if reg_idx &gt; 3:
                reg_idx -= 4
                return (env.regs[reg_idx] &gt;&gt; 8) &amp; 0xFF
            else:
                return env.regs[reg_idx] &amp; 0xFF
        else:
            return super().get_reg(cpu, reg)

    def set_reg(self, cpu, reg, val):
        reg = reg.upper()
        env = cpu.env_ptr

        if reg in [&#39;ES&#39;, &#39;CS&#39;, &#39;SS&#39;, &#39;DS&#39;, &#39;FS&#39;, &#39;GS&#39;]:
            self._set_segment_register(env, reg, val)
        elif reg in [&#39;RIP&#39;, &#39;PC&#39;]:
            return self.set_pc(cpu, val) # changes reg to &#39;IP&#39; and re-calls this
        elif reg.startswith(&#39;XMM&#39;):
            #env.xmm_regs[int(reg[3:])] = val
            raise NotImplementedError(&#34;XMM registers unsupported&#34;)
        elif reg.startswith(&#39;MM&#39;):
            raise NotImplementedError(&#34;MM registers unsupported&#34;)
        elif reg.startswith(&#39;YMM&#39;):
            raise NotImplementedError(&#34;YMM registers unsupported&#34;)
        elif reg.startswith(&#39;CR&#39;):
            env.cr[int(reg[2:])] = val
        elif reg.startswith(&#39;R&#39;) and any([reg.endswith(x) for x in &#39;DWB&#39;]):
            # R8-R15 can be accessed with D (double word), W (word) and B (byte)
            # to select the lowest 32-bits, the lowest 16 bits, or the lowest 8 bits.
            reg_idx = int(reg.strip(&#39;RDWB&#39;)) - 8
            reg_suffix = reg[-1]
            mask = {&#39;D&#39;: 0xFFFFFFFF,
                    &#39;W&#39;: 0xFFFF,
                    &#39;B&#39;: 0xFF}[reg_suffix]
            env.regs[reg_idx] &amp; mask
            env.regs[reg_idx] = (env.regs[reg_idx] &amp; ~mask) | (val &amp; mask)
        elif reg in self.reg_names_general:
            self._set_general_purpose_register(env, reg, val, 0xFFFFFFFF)
        elif reg in self.reg_names_short:
            self._set_general_purpose_register(env, reg, val, 0xFFFF)
        elif reg in self.reg_names_byte:
            reg_idx = self.reg_names_byte.index(reg)
            mask = 0xFF &lt;&lt; (8 * (reg_idx &gt; 3))
            reg_idx %= 4
            self._set_general_purpose_register(env, reg, val, mask)
        else:
            super().set_reg(cpu, reg, val)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.arch.PandaArch" href="#pandare.arch.PandaArch">PandaArch</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.arch.X86_64Arch.get_pc"><code class="name flex">
<span>def <span class="ident">get_pc</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Overloaded function to return the x86_64 current program counter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pc(self, cpu):
    &#39;&#39;&#39;
    Overloaded function to return the x86_64 current program counter
    &#39;&#39;&#39;
    return cpu.env_ptr.eip</code></pre>
</details>
</dd>
<dt id="pandare.arch.X86_64Arch.get_reg"><code class="name flex">
<span>def <span class="ident">get_reg</span></span>(<span>self, cpu, reg)</span>
</code></dt>
<dd>
<div class="desc"><p>X86_64 has a bunch of different ways to access registers. We support
the regular names, the 32 and 16 bit varations (e.g., EAX, AX, AL),
segment registers, and D/W/B style accesses to R8-R15</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reg(self, cpu, reg):
    &#39;&#39;&#39;
    X86_64 has a bunch of different ways to access registers. We support
    the regular names, the 32 and 16 bit varations (e.g., EAX, AX, AL),
    segment registers, and D/W/B style accesses to R8-R15
    &#39;&#39;&#39;
    if isinstance(reg, int):
        # If reg is an int, it should be an offset into our register array
        return self._get_reg_val(cpu, reg)

    reg = reg.upper()
    env = cpu.env_ptr
    if reg in self.seg_names:
        return self._get_segment_register(env, reg)
    elif reg in [&#39;RIP&#39;, &#39;PC&#39;, &#39;EIP&#39;]:
        pc = self.get_pc(cpu) # changes reg to &#39;IP&#39; and re-calls this
        if reg == &#39;EIP&#39;:
            pc &amp;= 0xFFFFFFFF
        return pc
    elif reg.startswith(&#39;XMM&#39;):
        raw_arr = env.xmm_regs[int(reg[3:].rstrip(&#39;HLQX&#39;))]
        _, endianness, _ = self._determine_bits()

        if reg.endswith(&#39;lq&#39;):
            value_bytes = raw_arr[0:8] # Lower 64 bits
        elif reg.endswith(&#39;hq&#39;):
            value_bytes = raw_arr[8:16] # Higher 64 bits
        elif reg.endswith(&#39;hx&#39;):
            value_bytes = raw_arr[4:8] # Higher 32 bits of the lower 64 bits
        else:
            value_bytes = raw_arr[0:16] # Full 128 bits
        return int.from_bytes(bytes(value_bytes), byteorder=endianness)

    elif reg.startswith(&#39;MM&#39;):
        raise ValueError(&#34;MM registers unsupported&#34;)
    elif reg.startswith(&#39;YMM&#39;):
        raise ValueError(&#34;YMM registers unsupported&#34;)
    elif reg.startswith(&#39;CR&#39;):
        return env.cr[int(reg[2:])]
    elif reg.startswith(&#39;R&#39;) and any([reg.endswith(x) for x in &#39;DWB&#39;]) and reg.strip(&#39;RDWB&#39;).isnumeric():
        # R8-R15 can be accessed with D (double word), W (word) and B (byte)
        # to select the lowest 32-bits, the lowest 16 bits, or the lowest 8 bits.
        reg_idx = int(reg.strip(&#39;RDWB&#39;)) - 8
        reg_suffix = reg[-1]
        mask = {&#39;D&#39;: 0xFFFFFFFF,
                &#39;W&#39;: 0xFFFF,
                &#39;B&#39;: 0xFF}[reg_suffix]
        return env.regs[reg_idx] &amp; mask
    elif reg in self.reg_names_general:
        return self._get_general_purpose_register(env, reg, 0xFFFFFFFF)
    elif reg in self.reg_names_short:
        return env.regs[self.reg_names_short.index(reg)] &amp; 0xFFFF
    elif reg in self.reg_names_byte:
        reg_idx = self.reg_names_byte.index(reg)
        if reg_idx &gt; 3:
            reg_idx -= 4
            return (env.regs[reg_idx] &gt;&gt; 8) &amp; 0xFF
        else:
            return env.regs[reg_idx] &amp; 0xFF
    else:
        return super().get_reg(cpu, reg)</code></pre>
</details>
</dd>
<dt id="pandare.arch.X86_64Arch.get_return_address"><code class="name flex">
<span>def <span class="ident">get_return_address</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>looks up where ret will go</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_return_address(self, cpu):
    &#39;&#39;&#39;
    looks up where ret will go
    &#39;&#39;&#39;
    esp = self.get_reg(cpu, &#34;RSP&#34;)
    return self.panda.virtual_memory_read(cpu, esp, 8, fmt=&#39;int&#39;)</code></pre>
</details>
</dd>
<dt id="pandare.arch.X86_64Arch.get_return_value"><code class="name flex">
<span>def <span class="ident">get_return_value</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><div class="admonition deprecated">
<p class="admonition-title">Deprecated:&ensp;use get_retval</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_return_value(self, cpu):
    &#39;&#39;&#39;
    .. Deprecated:: use get_retval
    &#39;&#39;&#39;
    return self.get_retval(cpu)</code></pre>
</details>
</dd>
<dt id="pandare.arch.X86_64Arch.get_retval"><code class="name flex">
<span>def <span class="ident">get_retval</span></span>(<span>self, cpu, convention='default')</span>
</code></dt>
<dd>
<div class="desc"><p>Overloaded to support FreeBSD syscall ABI
In that ABI, if eflags carry bit is set, an error has occured. To standardize
pandare.arch returns across architectures/ABIs, we indicate a failure by returnning
-ERRNO.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_retval(self, cpu, convention=&#39;default&#39;):
    &#39;&#39;&#39;
    Overloaded to support FreeBSD syscall ABI
    In that ABI, if eflags carry bit is set, an error has occured. To standardize
    pandare.arch returns across architectures/ABIs, we indicate a failure by returnning
    -ERRNO.
    &#39;&#39;&#39;

    error_flip = False
    if convention == &#39;syscall&#39; and self.panda.get_os_family() == &#39;OS_FREEBSD&#39; and \
            self.panda.libpanda.cpu_cc_compute_all(cpu.env_ptr, 1) &amp; 1 == 1:
        error_flip = True

    return super().get_retval(cpu, convention) * (-1 if error_flip else 1)</code></pre>
</details>
</dd>
<dt id="pandare.arch.X86_64Arch.set_pc"><code class="name flex">
<span>def <span class="ident">set_pc</span></span>(<span>self, cpu, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Overloaded function to set the x86_64 program counter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pc(self, cpu, val):
    &#39;&#39;&#39;
    Overloaded function to set the x86_64 program counter
    &#39;&#39;&#39;
    cpu.env_ptr.eip = val</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pandare.arch.PandaArch" href="#pandare.arch.PandaArch">PandaArch</a></b></code>:
<ul class="hlist">
<li><code><a title="pandare.arch.PandaArch.dump_regs" href="#pandare.arch.PandaArch.dump_regs">dump_regs</a></code></li>
<li><code><a title="pandare.arch.PandaArch.dump_stack" href="#pandare.arch.PandaArch.dump_stack">dump_stack</a></code></li>
<li><code><a title="pandare.arch.PandaArch.dump_state" href="#pandare.arch.PandaArch.dump_state">dump_state</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_arg" href="#pandare.arch.PandaArch.get_arg">get_arg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.registers" href="#pandare.arch.PandaArch.registers">registers</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_arg" href="#pandare.arch.PandaArch.set_arg">set_arg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_reg" href="#pandare.arch.PandaArch.set_reg">set_reg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_retval" href="#pandare.arch.PandaArch.set_retval">set_retval</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="panda.re Docs" href="/">
<img src="//panda.re/img/logo.png" alt="logo"> PANDA.re Docs
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pandare" href="index.html">pandare</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pandare.arch.Aarch64Arch" href="#pandare.arch.Aarch64Arch">Aarch64Arch</a></code></h4>
<ul class="">
<li><code><a title="pandare.arch.Aarch64Arch.get_pc" href="#pandare.arch.Aarch64Arch.get_pc">get_pc</a></code></li>
<li><code><a title="pandare.arch.Aarch64Arch.get_return_address" href="#pandare.arch.Aarch64Arch.get_return_address">get_return_address</a></code></li>
<li><code><a title="pandare.arch.Aarch64Arch.get_return_value" href="#pandare.arch.Aarch64Arch.get_return_value">get_return_value</a></code></li>
<li><code><a title="pandare.arch.Aarch64Arch.set_pc" href="#pandare.arch.Aarch64Arch.set_pc">set_pc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.arch.ArmArch" href="#pandare.arch.ArmArch">ArmArch</a></code></h4>
<ul class="">
<li><code><a title="pandare.arch.ArmArch.get_return_address" href="#pandare.arch.ArmArch.get_return_address">get_return_address</a></code></li>
<li><code><a title="pandare.arch.ArmArch.get_return_value" href="#pandare.arch.ArmArch.get_return_value">get_return_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.arch.Mips64Arch" href="#pandare.arch.Mips64Arch">Mips64Arch</a></code></h4>
</li>
<li>
<h4><code><a title="pandare.arch.MipsArch" href="#pandare.arch.MipsArch">MipsArch</a></code></h4>
<ul class="two-column">
<li><code><a title="pandare.arch.MipsArch.get_call_return" href="#pandare.arch.MipsArch.get_call_return">get_call_return</a></code></li>
<li><code><a title="pandare.arch.MipsArch.get_pc" href="#pandare.arch.MipsArch.get_pc">get_pc</a></code></li>
<li><code><a title="pandare.arch.MipsArch.get_reg" href="#pandare.arch.MipsArch.get_reg">get_reg</a></code></li>
<li><code><a title="pandare.arch.MipsArch.get_return_address" href="#pandare.arch.MipsArch.get_return_address">get_return_address</a></code></li>
<li><code><a title="pandare.arch.MipsArch.get_return_value" href="#pandare.arch.MipsArch.get_return_value">get_return_value</a></code></li>
<li><code><a title="pandare.arch.MipsArch.get_retval" href="#pandare.arch.MipsArch.get_retval">get_retval</a></code></li>
<li><code><a title="pandare.arch.MipsArch.set_pc" href="#pandare.arch.MipsArch.set_pc">set_pc</a></code></li>
<li><code><a title="pandare.arch.MipsArch.set_retval" href="#pandare.arch.MipsArch.set_retval">set_retval</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.arch.PandaArch" href="#pandare.arch.PandaArch">PandaArch</a></code></h4>
<ul class="two-column">
<li><code><a title="pandare.arch.PandaArch.dump_regs" href="#pandare.arch.PandaArch.dump_regs">dump_regs</a></code></li>
<li><code><a title="pandare.arch.PandaArch.dump_stack" href="#pandare.arch.PandaArch.dump_stack">dump_stack</a></code></li>
<li><code><a title="pandare.arch.PandaArch.dump_state" href="#pandare.arch.PandaArch.dump_state">dump_state</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_arg" href="#pandare.arch.PandaArch.get_arg">get_arg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_args" href="#pandare.arch.PandaArch.get_args">get_args</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_pc" href="#pandare.arch.PandaArch.get_pc">get_pc</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_reg" href="#pandare.arch.PandaArch.get_reg">get_reg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.get_retval" href="#pandare.arch.PandaArch.get_retval">get_retval</a></code></li>
<li><code><a title="pandare.arch.PandaArch.registers" href="#pandare.arch.PandaArch.registers">registers</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_arg" href="#pandare.arch.PandaArch.set_arg">set_arg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_pc" href="#pandare.arch.PandaArch.set_pc">set_pc</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_reg" href="#pandare.arch.PandaArch.set_reg">set_reg</a></code></li>
<li><code><a title="pandare.arch.PandaArch.set_retval" href="#pandare.arch.PandaArch.set_retval">set_retval</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.arch.X86Arch" href="#pandare.arch.X86Arch">X86Arch</a></code></h4>
<ul class="">
<li><code><a title="pandare.arch.X86Arch.get_pc" href="#pandare.arch.X86Arch.get_pc">get_pc</a></code></li>
<li><code><a title="pandare.arch.X86Arch.get_return_address" href="#pandare.arch.X86Arch.get_return_address">get_return_address</a></code></li>
<li><code><a title="pandare.arch.X86Arch.get_return_value" href="#pandare.arch.X86Arch.get_return_value">get_return_value</a></code></li>
<li><code><a title="pandare.arch.X86Arch.set_pc" href="#pandare.arch.X86Arch.set_pc">set_pc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.arch.X86_64Arch" href="#pandare.arch.X86_64Arch">X86_64Arch</a></code></h4>
<ul class="two-column">
<li><code><a title="pandare.arch.X86_64Arch.get_pc" href="#pandare.arch.X86_64Arch.get_pc">get_pc</a></code></li>
<li><code><a title="pandare.arch.X86_64Arch.get_reg" href="#pandare.arch.X86_64Arch.get_reg">get_reg</a></code></li>
<li><code><a title="pandare.arch.X86_64Arch.get_return_address" href="#pandare.arch.X86_64Arch.get_return_address">get_return_address</a></code></li>
<li><code><a title="pandare.arch.X86_64Arch.get_return_value" href="#pandare.arch.X86_64Arch.get_return_value">get_return_value</a></code></li>
<li><code><a title="pandare.arch.X86_64Arch.get_retval" href="#pandare.arch.X86_64Arch.get_retval">get_retval</a></code></li>
<li><code><a title="pandare.arch.X86_64Arch.set_pc" href="#pandare.arch.X86_64Arch.set_pc">set_pc</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>