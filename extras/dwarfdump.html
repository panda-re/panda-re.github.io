<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pandare.extras.dwarfdump API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<!-- Bootstrap core CSS -->
<!--
<link href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css" rel="stylesheet">
-->
<!-- hand-crafted bootstrap navbar -->
<style>
.bg-light {
background-color: #f8f9fa!important;
}
.navbar {
position: relative;
display: -ms-flexbox;
display: flex;
-ms-flex-wrap: wrap;
flex-wrap: wrap;
-ms-flex-align: center;
align-items: center;
-ms-flex-pack: justify;
justify-content: space-between;
padding: .5rem 1rem;
}
.navbar-expand-lg {
-ms-flex-direction: row;
flex-direction: row;
-ms-flex-wrap: nowrap;
flex-wrap: nowrap;
-ms-flex-pack: start;
justify-content: flex-start;
}
navbar-light .navbar-brand {
color: rgba(0,0,0,.9);
}
.navbar-brand {
display: inline-block;
padding-top: .3125rem;
padding-bottom: .3125rem;
margin-right: 1rem;
font-size: 1.25rem;
line-height: inherit;
white-space: nowrap;
}
.navbar-nav {
display: -ms-flexbox;
display: flex;
-ms-flex-direction: column;
flex-direction: column;
padding-left: 0;
margin-bottom: 0;
list-style: none;
}
.navbar-expand-lg .navbar-nav {
-ms-flex-direction: row;
flex-direction: row;
}
.mr-auto {
margin-right: auto!important;
}
.navbar-expand-lg .navbar-collapse {
display: -ms-flexbox!important;
display: flex!important;
}
.navbar-collapse {
-ms-flex-preferred-size: 100%;
flex-basis: 100%;
-ms-flex-align: center;
align-items: center;
}
.navbar-light .navbar-brand {
color: rgba(0,0,0,.9);
}
.navbar a {
color: #007bff;
text-decoration: none;
background-color: transparent;
-webkit-text-decoration-skip: objects;
}
.navbar-expand-lg .navbar-nav .nav-link {
padding-right: .5rem;
padding-left: .5rem;
}
.navbar .navbar-nav {
margin: 0;
font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
font-size: 1rem;
font-weight: 400;
line-height: 1.5;
color: #212529;
}
.navbar-light .navbar-nav .active>.nav-link, .navbar-light .navbar-nav .nav-link.active, .navbar-light .navbar-nav .nav-link.show, .navbar-light .navbar-nav .show>.nav-link {
color: rgba(0,0,0,.9);
}
.navbar-light .navbar-nav .nav-link {
color: rgba(0,0,0,.5);
}
.nav-link {
display: block;
padding: .5rem 1rem;
}
</style>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-light">
<a class="navbar-brand" href="/">PANDA.re</a>
<div class="collapse navbar-collapse" id="navbarSupportedContent">
<ul class="navbar-nav mr-auto">
<li class="nav-item">
<a class="nav-link" href="//panda.re/">Home</a>
</li>
<li class="nav-item">
<a class="nav-link" target="_new" href="https://github.com/panda-re/panda">Github</a>
</li>
<li class="nav-item ">
<a class="nav-link" href="//panda.re/blog/">Blog</a>
</li>
<li class="nav-item ">
<a class="nav-link active" href="//docs.panda.re">Python Docs</a>
</li>
<li class="nav-item ">
<a class="nav-link" href="//panda.re/invite.php">Slack</a>
</li>
<!-- No resources tab here because we don't have real bootstrap -->
</div>
</nav>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pandare.extras.dwarfdump</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import sys
import json

# dwarfdump -dil $PROG

def parse_die(ent):
    result = {}
    for e in ent.split(&#39;&gt; &#39;)[1:]:
        while e.endswith(&#39;&gt;&#39;):
            e = e[:-1]
        assert (e.startswith(&#39;DW_AT_&#39;))
        dat = e.split(&#39;&lt;&#39;)
        attr = dat[0].strip()
        for v in dat[1:]:
            v = v.strip()
            if v:
                result[attr] = v
    return result

def parse_section(indat):
    result = {&#39;.debug_line&#39;: [], &#39;.debug_info&#39;: []}
    data = indat.decode().strip().split(&#39;\n&#39;)
    for l in data:
        l = l.strip()
        if l.startswith(&#34;0x&#34;):
            result[&#39;.debug_line&#39;].append(l)
            # Signal End of Text
            if &#39;ET&#39; in l.split():
                result[&#39;.debug_line&#39;].append(None)
        elif l.startswith(&#34;&lt;&#34;) and not l.startswith(&#34;&lt;pc&gt;&#34;):
            result[&#39;.debug_info&#39;].append(l)
    return result

def reprocess_ops(ops):
    out = []
    for op in ops:
        if op.startswith(&#39;DW_&#39;):
            out.append(op)
        elif type(op) == str:
            if op.lstrip(&#39;-+&#39;).startswith(&#34;0x&#34;):
                out.append(int(op, 16))
            else:
                out.append(int(op))
        else:
            out.append(op)
    return out


class TypeDB(object):
    def __init__(self):
        self.data = {}

    def insert(self, cu, off, ty):
        if cu not in self.data:
            self.data[cu] = {}
        if off not in self.data[cu]:
            self.data[cu][off] = ty

    def jsondump(self):
        jout = {}
        for cu in self.data:
            jout[cu] = {}
            for off in self.data[cu]:
                jout[cu][off] = self.data[cu][off].jsondump()
        #return json.dumps(jout)
        return jout

class LineDB(object):
    def __init__(self):
        self.data = {}

    def _find_best_fit(self, srcfn, lno, addr):
        r = [-1, -1]
        for i in range(len(self.data[srcfn])):
            if self.data[srcfn][i].lno == lno:
                if r[1] &lt; self.data[srcfn][i].highpc and addr &gt; self.data[srcfn][i].highpc:
                    r = [i, self.data[srcfn][i].highpc]
        return r[0]

    def insert(self, srcfn, lno, col, addr, func=None):
        if srcfn not in self.data:
            self.data[srcfn] = []

        if self.data[srcfn] and lno &lt; self.data[srcfn][-1].lno:
            i = -1
        else:
            i = self._find_best_fit(srcfn, lno, addr)
        if i == -1:
            self.data[srcfn].append(LineRange(lno, col, addr, addr, func))
            self.data[srcfn].sort(key = lambda x: x.lno)

        prevlno = lno-1
        i = self._find_best_fit(srcfn, prevlno, addr)
        while prevlno &gt; 0 and i == -1:
            prevlno -= 1
            i = self._find_best_fit(srcfn, prevlno, addr)
        if i != -1:
            self.data[srcfn][i].highpc = addr

    def update_function(self, base_addr, end_addr, finfo):
        srcinfo = None
        for srcfn in self.data:
            for i in range(len(self.data[srcfn])):
                if self.data[srcfn][i].lowpc == base_addr:
                    srcinfo = (srcfn, self.data[srcfn][i].lno)
                if self.data[srcfn][i].lowpc &gt;= base_addr \
                        and self.data[srcfn][i].highpc &lt; end_addr:
                    self.data[srcfn][i].func = finfo.scope.lowpc
        return srcinfo

    def jsondump(self):
        jout = {}
        for srcfn in self.data:
            key = srcfn
            while srcfn[0] in [&#39;&#34;&#39;, &#34;&#39;&#34;]:
                srcfn = srcfn[1:]
            while srcfn[-1] in [&#39;&#34;&#39;, &#34;&#39;&#34;]:
                srcfn = srcfn[:-1]
            jout[srcfn] = []
            for lr in self.data[key]:
                jout[srcfn].append(lr.jsondump())
        #return json.dumps(jout)
        return jout

class GlobVarDB(object):
    def __init__(self):
        self.data = {}

    def insert(self, cu, var):
        if cu not in self.data:
            self.data[cu] = set()
        self.data[cu].add(var)

    def jsondump(self):
        jout = {}
        for cu in self.data:
            jout[cu] = [f.jsondump() for f in self.data[cu]]
        #return json.dumps(jout)
        return jout

class FunctionDB(object):
    def __init__(self):
        self.data = {}

    def insert(self, cu, f):
        if cu not in self.data:
            self.data[cu] = set()
        self.data[cu].add(f)

    def jsondump(self):
        jout = {}
        for cu in self.data:
            jout[cu] = [f.jsondump() for f in self.data[cu]]
        #return json.dumps(jout)
        return jout


class VarInfo(object):
    def __init__(self, name, cu_off):
        self.name = name
        self.cu_offset = cu_off
        self.scope = None
        self.decl_lno = None
        self.decl_fn = None
        self.loc_op = []
        self.type = None

    def jsondump(self):
        return {&#39;name&#39;: self.name, \
                &#39;cu_offset&#39;: self.cu_offset, \
                &#39;scope&#39;: self.scope.jsondump(), \
                &#39;decl_lno&#39;: self.decl_lno, \
                &#39;decl_fn&#39;: self.decl_fn, \
                &#39;loc_op&#39;: self.loc_op, \
                &#39;type&#39;: self.type}

class FuncInfo(object):
    def __init__(self, cu_off, name, scope, fb_op):
        self.cu_offset = cu_off
        self.name = name
        self.scope = scope
        self.framebase = fb_op
        self.fn = None
        self.lno = None
        self.varlist = []

    def jsondump(self):
        return {&#39;name&#39;: self.name, \
                &#39;cu_offset&#39;: self.cu_offset, \
                &#39;scope&#39;: self.scope.jsondump(), \
                &#39;framebase&#39;: self.framebase, \
                &#39;fn&#39;: self.fn, \
                &#39;lno&#39;: self.lno, \
                &#39;varlist&#39;: [v.jsondump() for v in self.varlist]}

class TypeInfo(object):
    def __init__(self, name):
        self.name = name

    def jsondump(self):
        return {&#39;name&#39;: self.name}

class StructType(TypeInfo):
    def __init__(self, name, cu_off, size):
        TypeInfo.__init__(self, name)
        self.size = size
        self.cu_off = cu_off
        self.children = {}  # &lt;member_offset: (name, type_offset)&gt;

    def jsondump(self):
        d = TypeInfo.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;StructType&#39;,
                &#39;size&#39;: self.size,
                &#39;cu_off&#39;: self.cu_off,
                &#39;children&#39;: self.children,
                })
        return d

class BaseType(TypeInfo):
    def __init__(self, name, size):
        TypeInfo.__init__(self, name)
        self.size = size

    def jsondump(self):
        d = TypeInfo.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;BaseType&#39;,
                &#39;size&#39;: self.size,
                })
        return d

class SugarType(TypeInfo):
    def __init__(self, name, cu_off):
        TypeInfo.__init__(self, name)
        self.cu_off = cu_off
        self.ref = None

    def jsondump(self):
        d = TypeInfo.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;SugarType&#39;,
                &#39;cu_off&#39;: self.cu_off,
                &#39;ref&#39;: self.ref,
                })
        return d

class PointerType(SugarType):
    def __init__(self, name, cu_off, target):
        SugarType.__init__(self, name, cu_off)
        self.ref = target

    def jsondump(self):
        d = SugarType.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;PointerType&#39;,
                })
        return d

class ArrayType(SugarType):
    def __init__(self, name, cu_off, elemty):
        SugarType.__init__(self, name, cu_off)
        self.ref = elemty
        self.range = []

    def jsondump(self):
        d = SugarType.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;ArrayType&#39;,
                &#39;range&#39;: self.range,
                })
        return d

class ArrayRangeType(SugarType):
    def __init__(self, name, cu_off, rtype, cnt):
        SugarType.__init__(self, name, cu_off)
        self.ref = rtype
        self.size = cnt

    def jsondump(self):
        d = SugarType.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;ArrayRangeType&#39;,
                &#39;size&#39;: self.size,
                })
        return d

class EnumType(TypeInfo):
    def __init__(self, name, size):
        TypeInfo.__init__(self, name)
        self.size = size

    def jsondump(self):
        d = TypeInfo.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;EnumType&#39;,
                &#39;size&#39;: self.size,
                })
        return d

class SubroutineType(TypeInfo):
    def __init__(self, name):
        TypeInfo.__init__(self, name)

    def jsondump(self):
        d = TypeInfo.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;SubroutineType&#39;,
                })
        return d

class UnionType(TypeInfo):
    def __init__(self, name, cu_off, size):
        TypeInfo.__init__(self, name)
        self.size = size
        self.cu_off = cu_off
        self.children = {}  # &lt;member_offset: (name, type_offset)&gt;

    def jsondump(self):
        d = TypeInfo.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;UnionType&#39;,
                &#39;size&#39;: self.size,
                &#39;cu_off&#39;: self.cu_off,
                &#39;children&#39;: self.children,
                })
        return d

class Scope(object):
    def __init__(self, lopc, hipc):
        self.lowpc = lopc
        self.highpc = hipc

    def jsondump(self):
        return {&#39;lowpc&#39;: self.lowpc, &#39;highpc&#39;: self.highpc}

class LineRange(object):
    def __init__(self, lno, col, lopc, hipc, func):
        self.lno = lno
        self.col = col
        self.lowpc = lopc
        self.highpc = hipc
        self.func = func

    def jsondump(self):
        return {
                &#39;lno&#39;: self.lno,
                &#39;col&#39;: self.col,
                &#39;lowpc&#39;: self.lowpc,
                &#39;highpc&#39;: self.highpc,
                &#39;func&#39;: self.func,
                }

def parse_dwarfdump(indat, prefix=&#34;&#34;):
    reloc_base = 0
    line_info = LineDB()
    globvar_info = GlobVarDB()
    func_info = FunctionDB()
    type_info = TypeDB()

    data = parse_section(indat)
    tag = &#34;.debug_line&#34;
    if tag in data:
        srcname = &#34;&#34;
        for line in data[tag]:
            if line == None:
                srcname = &#34;&#34;
                continue
            line = line.strip()
            if line.startswith(&#34;0x&#34;):
                addrstr, rest = line.split(&#39;[&#39;)
                lnostr, info = rest.split(&#39;]&#39;)
                if &#34;uri:&#34; in info:
                    srcfn = info.split(&#34;uri:&#34;)[-1].strip()
                assert (srcfn)
                addr = int(addrstr.strip(), 16) + reloc_base
                lno = int(lnostr.strip().split(&#39;,&#39;)[0])
                col = int(lnostr.strip().split(&#39;,&#39;)[1])
                line_info.insert(srcfn, lno, col, addr)

    type_overlay = None
    cu_off = None
    lvl_stack = []
    scope_stack = []
    func_stack = []
    type_stack = []
    tag = &#34;.debug_info&#34;
    if tag in data:
        for line in data[tag]:
            line = line.strip()
            print(line)
            if not line:
                continue
            if not line.startswith(&#39;&lt;&#39;):
                continue

            die = line.split(&#39; &#39;)[0].strip()
            assert (die.startswith(&#39;&lt;&#39;) and die.endswith(&#39;&gt;&#39;))
            lvl, idx, tname = die[1:-1].split(&#39;&gt;&lt;&#39;)
            lvl = int(lvl)

            res = parse_die(line)
            if &#34;DW_TAG_compile_unit&#34; in line:
                assert (&#39;DW_AT_low_pc&#39; in res)
                assert (&#39;DW_AT_high_pc&#39; in res)
                base_addr = int(res[&#39;DW_AT_low_pc&#39;], 16) + reloc_base
                end_addr = int(res[&#39;DW_AT_high_pc&#39;], 16) + reloc_base
                scope_stack = [Scope(base_addr, end_addr)]
                lvl_stack = [(lvl, &#39;DW_TAG_compile_unit&#39;)]
                func_stack = []
                type_stack = []
                cu_off = int(idx.split(&#39;+&#39;)[0], 16)
                continue

            idx = int(idx, 16)

            #print(lvl, idx, tname)

            while lvl &lt; lvl_stack[-1][0]:
                lvl_stack.pop()
                if lvl_stack[-1][1] == &#39;DW_TAG_lexical_block&#39;:
                    scope_stack.pop()
                if lvl_stack[-1][1] == &#39;DW_TAG_subprogram&#39;:
                    func_stack.pop()
                if lvl_stack[-1][1] == &#39;DW_TAG_structure_type&#39;:
                    type_stack.pop()
                if lvl_stack[-1][1] == &#39;DW_TAG_union_type&#39;:
                    type_stack.pop()
                if lvl_stack[-1][1] == &#39;DW_TAG_array_type&#39;:
                    type_stack.pop()

            if lvl != lvl_stack[-1][0] and lvl != (lvl_stack[-1][0]+1):
                continue

            if lvl_stack[-1][1] in [&#39;SugarType&#39;, &#39;DW_TAG_pointer_type&#39;]:
                assert (lvl == lvl_stack[-1][0])
                lvl_stack.pop()
                assert (type_overlay)
                type_overlay[2].ref = idx
                type_info.insert(type_overlay[0], type_overlay[1], type_overlay[2])
                type_overlay = None

            if tname == &#34;DW_TAG_lexical_block&#34;:
                assert (&#39;DW_AT_low_pc&#39; in res)
                assert (&#39;DW_AT_high_pc&#39; in res)
                base_addr = int(res[&#39;DW_AT_low_pc&#39;], 16) + reloc_base
                end_addr = int(res[&#39;DW_AT_high_pc&#39;], 16) + reloc_base
                scope_stack.append(Scope(base_addr, end_addr))
                lvl_stack.append((lvl, &#39;DW_TAG_lexical_block&#39;))

            elif tname == &#34;DW_TAG_variable&#34;:
                assert (&#39;DW_AT_name&#39; in res)
                name = res[&#39;DW_AT_name&#39;]
                v = VarInfo(name, cu_off)

                v.scope = scope_stack[-1]
                assert (&#39;DW_AT_decl_line&#39; in res)
                v.decl_lno = int(res[&#39;DW_AT_decl_line&#39;], 16)
                assert (&#39;DW_AT_decl_file&#39; in res)
                v.decl_fn = res[&#39;DW_AT_decl_file&#39;]
                v.decl_fn = v.decl_fn[v.decl_fn.find(&#39; &#39;)+1:]
                if &#39;DW_AT_location&#39; not in res:
                    continue
                for x in res[&#39;DW_AT_location&#39;].split(&#39;:&#39;)[-1].strip().split(&#39;DW_OP_&#39;):
                    x = x.strip()
                    if not x:
                        continue
                    v.loc_op.extend(&#39;DW_OP_{}&#39;.format(x).split())
                v.loc_op = reprocess_ops(v.loc_op)
                assert (&#39;DW_AT_type&#39; in res)
                v.type = int(res[&#39;DW_AT_type&#39;], 16)

                if len(func_stack) == 0:
                    globvar_info.insert(cu_off, v)
                else:
                    func_stack[-1].varlist.append(v)

            elif tname == &#34;DW_TAG_formal_parameter&#34;:
                if &#39;DW_AT_name&#39; not in res:
                    continue
                name = res[&#39;DW_AT_name&#39;]
                v = VarInfo(name, cu_off)

                v.scope = scope_stack[-1]
                assert (&#39;DW_AT_decl_line&#39; in res)
                v.decl_lno = int(res[&#39;DW_AT_decl_line&#39;], 16)
                assert (&#39;DW_AT_decl_file&#39; in res)
                v.decl_fn = res[&#39;DW_AT_decl_file&#39;]
                v.decl_fn = v.decl_fn[v.decl_fn.find(&#39; &#39;)+1:]
                if &#39;DW_AT_location&#39; not in res:
                    continue
                for x in res[&#39;DW_AT_location&#39;].split(&#39;:&#39;)[-1].strip().split(&#39;DW_OP_&#39;):
                    x = x.strip()
                    if not x:
                        continue
                    v.loc_op.extend(&#39;DW_OP_{}&#39;.format(x).split())
                v.loc_op = reprocess_ops(v.loc_op)
                assert (&#39;DW_AT_type&#39; in res)
                v.type = int(res[&#39;DW_AT_type&#39;], 16)

                assert (len(func_stack) &gt; 0)
                func_stack[-1].varlist.append(v)

            elif tname == &#34;DW_TAG_subprogram&#34;:
                assert (&#39;DW_AT_name&#39; in res)
                name = res[&#39;DW_AT_name&#39;]

                assert (&#39;DW_AT_low_pc&#39; in res)
                assert (&#39;DW_AT_high_pc&#39; in res)
                base_addr = int(res[&#39;DW_AT_low_pc&#39;], 16) + reloc_base
                end_addr = int(res[&#39;DW_AT_high_pc&#39;], 16) + reloc_base
                scope = Scope(base_addr, end_addr)
                scope_stack.append(scope)
                lvl_stack.append((lvl, &#39;DW_TAG_subprogram&#39;))

                assert (&#39;DW_AT_decl_file&#39; in res)
                decl_fn = res[&#39;DW_AT_decl_file&#39;]
                decl_fn = decl_fn[v.decl_fn.find(&#39; &#39;)+1:]

                if &#39;DW_AT_frame_base&#39; in res:
                    fb_op = [res[&#39;DW_AT_frame_base&#39;].split(&#39;:&#39;)[-1].strip()]
                else:
                    fb_op = []
                fb_op = reprocess_ops(fb_op)

                f = FuncInfo(cu_off, name, scope, fb_op)

                f.fn, f.lno = line_info.update_function(base_addr, end_addr, f)

                func_stack.append(f)
                func_info.insert(cu_off, f)

            elif tname == &#34;DW_TAG_structure_type&#34;:
                if &#39;DW_AT_byte_size&#39; not in res:
                    continue
                sz = int(res[&#39;DW_AT_byte_size&#39;], 16)
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;
                t = StructType(name, cu_off, sz)

                type_info.insert(cu_off, idx, t)

                type_stack.append(t)
                lvl_stack.append((lvl, &#39;DW_TAG_structure_type&#39;))

            elif tname == &#34;DW_TAG_member&#34;:
                assert (lvl_stack[-1][1] in [&#39;DW_TAG_structure_type&#39;, &#39;DW_TAG_union_type&#39;])

                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;

                # Skip bit fields
                if &#39;DW_AT_bit_size&#39; in res or &#39;DW_AT_bit_offset&#39; in res:
                    continue

                assert (&#39;DW_AT_type&#39; in res)
                toff = int(res[&#39;DW_AT_type&#39;], 16)

                assert (&#39;DW_AT_data_member_location&#39; in res)
                loc_op = [&#39;DW_OP_{}&#39;.format(x.strip()) for x in \
                        res[&#39;DW_AT_data_member_location&#39;].split(&#39;:&#39;)[-1].strip().split(&#39;DW_OP_&#39;)[1:]]
                # Signal attribute form DW_FORM_data1/2/4/8
                assert (len(loc_op) == 1)
                assert (loc_op[0].split()[0] == &#39;DW_OP_plus_uconst&#39;)
                off = int(loc_op[0].split()[1])

                type_stack[-1].children[off] = (name, toff)

            elif tname == &#34;DW_TAG_array_type&#34;:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;
                assert (&#39;DW_AT_type&#39; in res)
                elemoff = int(res[&#39;DW_AT_type&#39;], 16)

                t = ArrayType(name, cu_off, elemoff)

                type_info.insert(cu_off, idx, t)

                lvl_stack.append((lvl, &#39;DW_TAG_array_type&#39;))
                type_stack.append(t)

            elif tname == &#34;DW_TAG_subrange_type&#34;:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;
                assert (&#39;DW_AT_type&#39; in res)
                toff = int(res[&#39;DW_AT_type&#39;], 16)
                assert (&#39;DW_AT_count&#39; in res)
                cnt = int(res[&#39;DW_AT_count&#39;], 16)
                # cnt = int(res[&#39;DW_AT_upper_bound&#39;], 16)

                t = ArrayRangeType(name, cu_off, toff, cnt)

                type_info.insert(cu_off, idx, t)

                assert (lvl_stack[-1][1] == &#39;DW_TAG_array_type&#39;)
                assert ((lvl_stack[-1][0]+1) == lvl)

                type_stack[-1].range.append(idx)

            elif tname == &#34;DW_TAG_subroutine_type&#34;:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;
                t = SubroutineType(name)

                type_info.insert(cu_off, idx, t)

            elif tname == &#34;DW_TAG_base_type&#34;:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;
                assert (&#39;DW_AT_byte_size&#39; in res)
                sz = int(res[&#39;DW_AT_byte_size&#39;], 16)
                t = BaseType(name, sz)

                type_info.insert(cu_off, idx, t)

            elif tname == &#34;DW_TAG_pointer_type&#34;:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;

                if &#39;DW_AT_type&#39; not in res:
                    lvl_stack.append((lvl, &#39;DW_TAG_pointer_type&#39;))
                    type_overlay = (cu_off, idx, PointerType(name, cu_off, None))
                    continue
                target = int(res[&#39;DW_AT_type&#39;], 16)

                t = PointerType(name, cu_off, target)

                type_info.insert(cu_off, idx, t)

            elif tname == &#34;DW_TAG_enumeration_type&#34;:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;

                assert (&#39;DW_AT_byte_size&#39; in res)
                sz = int(res[&#39;DW_AT_byte_size&#39;], 16)

                t = EnumType(name, sz)

                type_info.insert(cu_off, idx, t)

            elif tname in [
                    &#34;DW_TAG_restrict_type&#34;,
                    &#34;DW_TAG_const_type&#34;,
                    &#34;DW_TAG_volatile_type&#34;,
                    &#34;DW_TAG_typedef&#34;
                    ]:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;
                t = SugarType(name, cu_off)

                if &#39;DW_AT_type&#39; not in res:
                    lvl_stack.append((lvl, &#39;SugarType&#39;))
                    type_overlay = (cu_off, idx, t)
                    continue
                t.ref = int(res[&#39;DW_AT_type&#39;], 16)

                type_info.insert(cu_off, idx, t)

            elif tname == &#34;DW_TAG_union_type&#34;:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;
                assert (&#39;DW_AT_byte_size&#39; in res)
                sz = int(res[&#39;DW_AT_byte_size&#39;], 16)
                t = UnionType(name, cu_off, sz)

                type_info.insert(cu_off, idx, t)

                type_stack.append(t)
                lvl_stack.append((lvl, &#39;DW_TAG_union_type&#39;))

            elif tname == &#34;DW_TAG_ptr_to_member_type&#34;:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;
                t = PointerType(name, cu_off, None)

                type_info.insert(cu_off, idx, t)

            elif tname == &#34;DW_TAG_imported_declaration&#34;:
                pass
            elif tname == &#34;DW_TAG_unspecified_parameters&#34;:
                pass
            elif tname == &#34;DW_TAG_constant&#34;:
                pass

    with open(prefix+&#39;_lineinfo.json&#39;, &#39;w&#39;) as fd:
        dump_json(fd, line_info)
    with open(prefix+&#39;_globvar.json&#39;, &#39;w&#39;) as fd:
        dump_json(fd, globvar_info)
    with open(prefix+&#39;_funcinfo.json&#39;, &#39;w&#39;) as fd:
        dump_json(fd, func_info)
    with open(prefix+&#39;_typeinfo.json&#39;, &#39;w&#39;) as fd:
        dump_json(fd, type_info)

def dump_json(j, info):
    class DwarfJsonEncoder(json.JSONEncoder):
        def default(self, obj):
            if hasattr(obj, &#34;jsondump&#34;):
                return obj.jsondump()
            else:
                return json.JSONEncoder.default(self, obj)
    json.dump(info.jsondump(), j, cls=DwarfJsonEncoder)

if __name__ == &#39;__main__&#39;:
    with open(sys.argv[1], &#39;r&#39;) as fd:
        parse_dwarfdump(fd.read())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pandare.extras.dwarfdump.dump_json"><code class="name flex">
<span>def <span class="ident">dump_json</span></span>(<span>j, info)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_json(j, info):
    class DwarfJsonEncoder(json.JSONEncoder):
        def default(self, obj):
            if hasattr(obj, &#34;jsondump&#34;):
                return obj.jsondump()
            else:
                return json.JSONEncoder.default(self, obj)
    json.dump(info.jsondump(), j, cls=DwarfJsonEncoder)</code></pre>
</details>
</dd>
<dt id="pandare.extras.dwarfdump.parse_die"><code class="name flex">
<span>def <span class="ident">parse_die</span></span>(<span>ent)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_die(ent):
    result = {}
    for e in ent.split(&#39;&gt; &#39;)[1:]:
        while e.endswith(&#39;&gt;&#39;):
            e = e[:-1]
        assert (e.startswith(&#39;DW_AT_&#39;))
        dat = e.split(&#39;&lt;&#39;)
        attr = dat[0].strip()
        for v in dat[1:]:
            v = v.strip()
            if v:
                result[attr] = v
    return result</code></pre>
</details>
</dd>
<dt id="pandare.extras.dwarfdump.parse_dwarfdump"><code class="name flex">
<span>def <span class="ident">parse_dwarfdump</span></span>(<span>indat, prefix='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_dwarfdump(indat, prefix=&#34;&#34;):
    reloc_base = 0
    line_info = LineDB()
    globvar_info = GlobVarDB()
    func_info = FunctionDB()
    type_info = TypeDB()

    data = parse_section(indat)
    tag = &#34;.debug_line&#34;
    if tag in data:
        srcname = &#34;&#34;
        for line in data[tag]:
            if line == None:
                srcname = &#34;&#34;
                continue
            line = line.strip()
            if line.startswith(&#34;0x&#34;):
                addrstr, rest = line.split(&#39;[&#39;)
                lnostr, info = rest.split(&#39;]&#39;)
                if &#34;uri:&#34; in info:
                    srcfn = info.split(&#34;uri:&#34;)[-1].strip()
                assert (srcfn)
                addr = int(addrstr.strip(), 16) + reloc_base
                lno = int(lnostr.strip().split(&#39;,&#39;)[0])
                col = int(lnostr.strip().split(&#39;,&#39;)[1])
                line_info.insert(srcfn, lno, col, addr)

    type_overlay = None
    cu_off = None
    lvl_stack = []
    scope_stack = []
    func_stack = []
    type_stack = []
    tag = &#34;.debug_info&#34;
    if tag in data:
        for line in data[tag]:
            line = line.strip()
            print(line)
            if not line:
                continue
            if not line.startswith(&#39;&lt;&#39;):
                continue

            die = line.split(&#39; &#39;)[0].strip()
            assert (die.startswith(&#39;&lt;&#39;) and die.endswith(&#39;&gt;&#39;))
            lvl, idx, tname = die[1:-1].split(&#39;&gt;&lt;&#39;)
            lvl = int(lvl)

            res = parse_die(line)
            if &#34;DW_TAG_compile_unit&#34; in line:
                assert (&#39;DW_AT_low_pc&#39; in res)
                assert (&#39;DW_AT_high_pc&#39; in res)
                base_addr = int(res[&#39;DW_AT_low_pc&#39;], 16) + reloc_base
                end_addr = int(res[&#39;DW_AT_high_pc&#39;], 16) + reloc_base
                scope_stack = [Scope(base_addr, end_addr)]
                lvl_stack = [(lvl, &#39;DW_TAG_compile_unit&#39;)]
                func_stack = []
                type_stack = []
                cu_off = int(idx.split(&#39;+&#39;)[0], 16)
                continue

            idx = int(idx, 16)

            #print(lvl, idx, tname)

            while lvl &lt; lvl_stack[-1][0]:
                lvl_stack.pop()
                if lvl_stack[-1][1] == &#39;DW_TAG_lexical_block&#39;:
                    scope_stack.pop()
                if lvl_stack[-1][1] == &#39;DW_TAG_subprogram&#39;:
                    func_stack.pop()
                if lvl_stack[-1][1] == &#39;DW_TAG_structure_type&#39;:
                    type_stack.pop()
                if lvl_stack[-1][1] == &#39;DW_TAG_union_type&#39;:
                    type_stack.pop()
                if lvl_stack[-1][1] == &#39;DW_TAG_array_type&#39;:
                    type_stack.pop()

            if lvl != lvl_stack[-1][0] and lvl != (lvl_stack[-1][0]+1):
                continue

            if lvl_stack[-1][1] in [&#39;SugarType&#39;, &#39;DW_TAG_pointer_type&#39;]:
                assert (lvl == lvl_stack[-1][0])
                lvl_stack.pop()
                assert (type_overlay)
                type_overlay[2].ref = idx
                type_info.insert(type_overlay[0], type_overlay[1], type_overlay[2])
                type_overlay = None

            if tname == &#34;DW_TAG_lexical_block&#34;:
                assert (&#39;DW_AT_low_pc&#39; in res)
                assert (&#39;DW_AT_high_pc&#39; in res)
                base_addr = int(res[&#39;DW_AT_low_pc&#39;], 16) + reloc_base
                end_addr = int(res[&#39;DW_AT_high_pc&#39;], 16) + reloc_base
                scope_stack.append(Scope(base_addr, end_addr))
                lvl_stack.append((lvl, &#39;DW_TAG_lexical_block&#39;))

            elif tname == &#34;DW_TAG_variable&#34;:
                assert (&#39;DW_AT_name&#39; in res)
                name = res[&#39;DW_AT_name&#39;]
                v = VarInfo(name, cu_off)

                v.scope = scope_stack[-1]
                assert (&#39;DW_AT_decl_line&#39; in res)
                v.decl_lno = int(res[&#39;DW_AT_decl_line&#39;], 16)
                assert (&#39;DW_AT_decl_file&#39; in res)
                v.decl_fn = res[&#39;DW_AT_decl_file&#39;]
                v.decl_fn = v.decl_fn[v.decl_fn.find(&#39; &#39;)+1:]
                if &#39;DW_AT_location&#39; not in res:
                    continue
                for x in res[&#39;DW_AT_location&#39;].split(&#39;:&#39;)[-1].strip().split(&#39;DW_OP_&#39;):
                    x = x.strip()
                    if not x:
                        continue
                    v.loc_op.extend(&#39;DW_OP_{}&#39;.format(x).split())
                v.loc_op = reprocess_ops(v.loc_op)
                assert (&#39;DW_AT_type&#39; in res)
                v.type = int(res[&#39;DW_AT_type&#39;], 16)

                if len(func_stack) == 0:
                    globvar_info.insert(cu_off, v)
                else:
                    func_stack[-1].varlist.append(v)

            elif tname == &#34;DW_TAG_formal_parameter&#34;:
                if &#39;DW_AT_name&#39; not in res:
                    continue
                name = res[&#39;DW_AT_name&#39;]
                v = VarInfo(name, cu_off)

                v.scope = scope_stack[-1]
                assert (&#39;DW_AT_decl_line&#39; in res)
                v.decl_lno = int(res[&#39;DW_AT_decl_line&#39;], 16)
                assert (&#39;DW_AT_decl_file&#39; in res)
                v.decl_fn = res[&#39;DW_AT_decl_file&#39;]
                v.decl_fn = v.decl_fn[v.decl_fn.find(&#39; &#39;)+1:]
                if &#39;DW_AT_location&#39; not in res:
                    continue
                for x in res[&#39;DW_AT_location&#39;].split(&#39;:&#39;)[-1].strip().split(&#39;DW_OP_&#39;):
                    x = x.strip()
                    if not x:
                        continue
                    v.loc_op.extend(&#39;DW_OP_{}&#39;.format(x).split())
                v.loc_op = reprocess_ops(v.loc_op)
                assert (&#39;DW_AT_type&#39; in res)
                v.type = int(res[&#39;DW_AT_type&#39;], 16)

                assert (len(func_stack) &gt; 0)
                func_stack[-1].varlist.append(v)

            elif tname == &#34;DW_TAG_subprogram&#34;:
                assert (&#39;DW_AT_name&#39; in res)
                name = res[&#39;DW_AT_name&#39;]

                assert (&#39;DW_AT_low_pc&#39; in res)
                assert (&#39;DW_AT_high_pc&#39; in res)
                base_addr = int(res[&#39;DW_AT_low_pc&#39;], 16) + reloc_base
                end_addr = int(res[&#39;DW_AT_high_pc&#39;], 16) + reloc_base
                scope = Scope(base_addr, end_addr)
                scope_stack.append(scope)
                lvl_stack.append((lvl, &#39;DW_TAG_subprogram&#39;))

                assert (&#39;DW_AT_decl_file&#39; in res)
                decl_fn = res[&#39;DW_AT_decl_file&#39;]
                decl_fn = decl_fn[v.decl_fn.find(&#39; &#39;)+1:]

                if &#39;DW_AT_frame_base&#39; in res:
                    fb_op = [res[&#39;DW_AT_frame_base&#39;].split(&#39;:&#39;)[-1].strip()]
                else:
                    fb_op = []
                fb_op = reprocess_ops(fb_op)

                f = FuncInfo(cu_off, name, scope, fb_op)

                f.fn, f.lno = line_info.update_function(base_addr, end_addr, f)

                func_stack.append(f)
                func_info.insert(cu_off, f)

            elif tname == &#34;DW_TAG_structure_type&#34;:
                if &#39;DW_AT_byte_size&#39; not in res:
                    continue
                sz = int(res[&#39;DW_AT_byte_size&#39;], 16)
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;
                t = StructType(name, cu_off, sz)

                type_info.insert(cu_off, idx, t)

                type_stack.append(t)
                lvl_stack.append((lvl, &#39;DW_TAG_structure_type&#39;))

            elif tname == &#34;DW_TAG_member&#34;:
                assert (lvl_stack[-1][1] in [&#39;DW_TAG_structure_type&#39;, &#39;DW_TAG_union_type&#39;])

                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;

                # Skip bit fields
                if &#39;DW_AT_bit_size&#39; in res or &#39;DW_AT_bit_offset&#39; in res:
                    continue

                assert (&#39;DW_AT_type&#39; in res)
                toff = int(res[&#39;DW_AT_type&#39;], 16)

                assert (&#39;DW_AT_data_member_location&#39; in res)
                loc_op = [&#39;DW_OP_{}&#39;.format(x.strip()) for x in \
                        res[&#39;DW_AT_data_member_location&#39;].split(&#39;:&#39;)[-1].strip().split(&#39;DW_OP_&#39;)[1:]]
                # Signal attribute form DW_FORM_data1/2/4/8
                assert (len(loc_op) == 1)
                assert (loc_op[0].split()[0] == &#39;DW_OP_plus_uconst&#39;)
                off = int(loc_op[0].split()[1])

                type_stack[-1].children[off] = (name, toff)

            elif tname == &#34;DW_TAG_array_type&#34;:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;
                assert (&#39;DW_AT_type&#39; in res)
                elemoff = int(res[&#39;DW_AT_type&#39;], 16)

                t = ArrayType(name, cu_off, elemoff)

                type_info.insert(cu_off, idx, t)

                lvl_stack.append((lvl, &#39;DW_TAG_array_type&#39;))
                type_stack.append(t)

            elif tname == &#34;DW_TAG_subrange_type&#34;:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;
                assert (&#39;DW_AT_type&#39; in res)
                toff = int(res[&#39;DW_AT_type&#39;], 16)
                assert (&#39;DW_AT_count&#39; in res)
                cnt = int(res[&#39;DW_AT_count&#39;], 16)
                # cnt = int(res[&#39;DW_AT_upper_bound&#39;], 16)

                t = ArrayRangeType(name, cu_off, toff, cnt)

                type_info.insert(cu_off, idx, t)

                assert (lvl_stack[-1][1] == &#39;DW_TAG_array_type&#39;)
                assert ((lvl_stack[-1][0]+1) == lvl)

                type_stack[-1].range.append(idx)

            elif tname == &#34;DW_TAG_subroutine_type&#34;:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;
                t = SubroutineType(name)

                type_info.insert(cu_off, idx, t)

            elif tname == &#34;DW_TAG_base_type&#34;:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;
                assert (&#39;DW_AT_byte_size&#39; in res)
                sz = int(res[&#39;DW_AT_byte_size&#39;], 16)
                t = BaseType(name, sz)

                type_info.insert(cu_off, idx, t)

            elif tname == &#34;DW_TAG_pointer_type&#34;:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;

                if &#39;DW_AT_type&#39; not in res:
                    lvl_stack.append((lvl, &#39;DW_TAG_pointer_type&#39;))
                    type_overlay = (cu_off, idx, PointerType(name, cu_off, None))
                    continue
                target = int(res[&#39;DW_AT_type&#39;], 16)

                t = PointerType(name, cu_off, target)

                type_info.insert(cu_off, idx, t)

            elif tname == &#34;DW_TAG_enumeration_type&#34;:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;

                assert (&#39;DW_AT_byte_size&#39; in res)
                sz = int(res[&#39;DW_AT_byte_size&#39;], 16)

                t = EnumType(name, sz)

                type_info.insert(cu_off, idx, t)

            elif tname in [
                    &#34;DW_TAG_restrict_type&#34;,
                    &#34;DW_TAG_const_type&#34;,
                    &#34;DW_TAG_volatile_type&#34;,
                    &#34;DW_TAG_typedef&#34;
                    ]:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;
                t = SugarType(name, cu_off)

                if &#39;DW_AT_type&#39; not in res:
                    lvl_stack.append((lvl, &#39;SugarType&#39;))
                    type_overlay = (cu_off, idx, t)
                    continue
                t.ref = int(res[&#39;DW_AT_type&#39;], 16)

                type_info.insert(cu_off, idx, t)

            elif tname == &#34;DW_TAG_union_type&#34;:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;
                assert (&#39;DW_AT_byte_size&#39; in res)
                sz = int(res[&#39;DW_AT_byte_size&#39;], 16)
                t = UnionType(name, cu_off, sz)

                type_info.insert(cu_off, idx, t)

                type_stack.append(t)
                lvl_stack.append((lvl, &#39;DW_TAG_union_type&#39;))

            elif tname == &#34;DW_TAG_ptr_to_member_type&#34;:
                name = res[&#39;DW_AT_name&#39;] if &#39;DW_AT_name&#39; in res else &#34;void&#34;
                t = PointerType(name, cu_off, None)

                type_info.insert(cu_off, idx, t)

            elif tname == &#34;DW_TAG_imported_declaration&#34;:
                pass
            elif tname == &#34;DW_TAG_unspecified_parameters&#34;:
                pass
            elif tname == &#34;DW_TAG_constant&#34;:
                pass

    with open(prefix+&#39;_lineinfo.json&#39;, &#39;w&#39;) as fd:
        dump_json(fd, line_info)
    with open(prefix+&#39;_globvar.json&#39;, &#39;w&#39;) as fd:
        dump_json(fd, globvar_info)
    with open(prefix+&#39;_funcinfo.json&#39;, &#39;w&#39;) as fd:
        dump_json(fd, func_info)
    with open(prefix+&#39;_typeinfo.json&#39;, &#39;w&#39;) as fd:
        dump_json(fd, type_info)</code></pre>
</details>
</dd>
<dt id="pandare.extras.dwarfdump.parse_section"><code class="name flex">
<span>def <span class="ident">parse_section</span></span>(<span>indat)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_section(indat):
    result = {&#39;.debug_line&#39;: [], &#39;.debug_info&#39;: []}
    data = indat.decode().strip().split(&#39;\n&#39;)
    for l in data:
        l = l.strip()
        if l.startswith(&#34;0x&#34;):
            result[&#39;.debug_line&#39;].append(l)
            # Signal End of Text
            if &#39;ET&#39; in l.split():
                result[&#39;.debug_line&#39;].append(None)
        elif l.startswith(&#34;&lt;&#34;) and not l.startswith(&#34;&lt;pc&gt;&#34;):
            result[&#39;.debug_info&#39;].append(l)
    return result</code></pre>
</details>
</dd>
<dt id="pandare.extras.dwarfdump.reprocess_ops"><code class="name flex">
<span>def <span class="ident">reprocess_ops</span></span>(<span>ops)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reprocess_ops(ops):
    out = []
    for op in ops:
        if op.startswith(&#39;DW_&#39;):
            out.append(op)
        elif type(op) == str:
            if op.lstrip(&#39;-+&#39;).startswith(&#34;0x&#34;):
                out.append(int(op, 16))
            else:
                out.append(int(op))
        else:
            out.append(op)
    return out</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pandare.extras.dwarfdump.ArrayRangeType"><code class="flex name class">
<span>class <span class="ident">ArrayRangeType</span></span>
<span>(</span><span>name, cu_off, rtype, cnt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArrayRangeType(SugarType):
    def __init__(self, name, cu_off, rtype, cnt):
        SugarType.__init__(self, name, cu_off)
        self.ref = rtype
        self.size = cnt

    def jsondump(self):
        d = SugarType.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;ArrayRangeType&#39;,
                &#39;size&#39;: self.size,
                })
        return d</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.extras.dwarfdump.SugarType" href="#pandare.extras.dwarfdump.SugarType">SugarType</a></li>
<li><a title="pandare.extras.dwarfdump.TypeInfo" href="#pandare.extras.dwarfdump.TypeInfo">TypeInfo</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.ArrayRangeType.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    d = SugarType.jsondump(self)
    d.update({
            &#39;tag&#39;: &#39;ArrayRangeType&#39;,
            &#39;size&#39;: self.size,
            })
    return d</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.ArrayType"><code class="flex name class">
<span>class <span class="ident">ArrayType</span></span>
<span>(</span><span>name, cu_off, elemty)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArrayType(SugarType):
    def __init__(self, name, cu_off, elemty):
        SugarType.__init__(self, name, cu_off)
        self.ref = elemty
        self.range = []

    def jsondump(self):
        d = SugarType.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;ArrayType&#39;,
                &#39;range&#39;: self.range,
                })
        return d</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.extras.dwarfdump.SugarType" href="#pandare.extras.dwarfdump.SugarType">SugarType</a></li>
<li><a title="pandare.extras.dwarfdump.TypeInfo" href="#pandare.extras.dwarfdump.TypeInfo">TypeInfo</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.ArrayType.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    d = SugarType.jsondump(self)
    d.update({
            &#39;tag&#39;: &#39;ArrayType&#39;,
            &#39;range&#39;: self.range,
            })
    return d</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.BaseType"><code class="flex name class">
<span>class <span class="ident">BaseType</span></span>
<span>(</span><span>name, size)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseType(TypeInfo):
    def __init__(self, name, size):
        TypeInfo.__init__(self, name)
        self.size = size

    def jsondump(self):
        d = TypeInfo.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;BaseType&#39;,
                &#39;size&#39;: self.size,
                })
        return d</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.extras.dwarfdump.TypeInfo" href="#pandare.extras.dwarfdump.TypeInfo">TypeInfo</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.BaseType.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    d = TypeInfo.jsondump(self)
    d.update({
            &#39;tag&#39;: &#39;BaseType&#39;,
            &#39;size&#39;: self.size,
            })
    return d</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.EnumType"><code class="flex name class">
<span>class <span class="ident">EnumType</span></span>
<span>(</span><span>name, size)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumType(TypeInfo):
    def __init__(self, name, size):
        TypeInfo.__init__(self, name)
        self.size = size

    def jsondump(self):
        d = TypeInfo.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;EnumType&#39;,
                &#39;size&#39;: self.size,
                })
        return d</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.extras.dwarfdump.TypeInfo" href="#pandare.extras.dwarfdump.TypeInfo">TypeInfo</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.EnumType.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    d = TypeInfo.jsondump(self)
    d.update({
            &#39;tag&#39;: &#39;EnumType&#39;,
            &#39;size&#39;: self.size,
            })
    return d</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.FuncInfo"><code class="flex name class">
<span>class <span class="ident">FuncInfo</span></span>
<span>(</span><span>cu_off, name, scope, fb_op)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FuncInfo(object):
    def __init__(self, cu_off, name, scope, fb_op):
        self.cu_offset = cu_off
        self.name = name
        self.scope = scope
        self.framebase = fb_op
        self.fn = None
        self.lno = None
        self.varlist = []

    def jsondump(self):
        return {&#39;name&#39;: self.name, \
                &#39;cu_offset&#39;: self.cu_offset, \
                &#39;scope&#39;: self.scope.jsondump(), \
                &#39;framebase&#39;: self.framebase, \
                &#39;fn&#39;: self.fn, \
                &#39;lno&#39;: self.lno, \
                &#39;varlist&#39;: [v.jsondump() for v in self.varlist]}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.FuncInfo.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    return {&#39;name&#39;: self.name, \
            &#39;cu_offset&#39;: self.cu_offset, \
            &#39;scope&#39;: self.scope.jsondump(), \
            &#39;framebase&#39;: self.framebase, \
            &#39;fn&#39;: self.fn, \
            &#39;lno&#39;: self.lno, \
            &#39;varlist&#39;: [v.jsondump() for v in self.varlist]}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.FunctionDB"><code class="flex name class">
<span>class <span class="ident">FunctionDB</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FunctionDB(object):
    def __init__(self):
        self.data = {}

    def insert(self, cu, f):
        if cu not in self.data:
            self.data[cu] = set()
        self.data[cu].add(f)

    def jsondump(self):
        jout = {}
        for cu in self.data:
            jout[cu] = [f.jsondump() for f in self.data[cu]]
        #return json.dumps(jout)
        return jout</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.FunctionDB.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, cu, f)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, cu, f):
    if cu not in self.data:
        self.data[cu] = set()
    self.data[cu].add(f)</code></pre>
</details>
</dd>
<dt id="pandare.extras.dwarfdump.FunctionDB.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    jout = {}
    for cu in self.data:
        jout[cu] = [f.jsondump() for f in self.data[cu]]
    #return json.dumps(jout)
    return jout</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.GlobVarDB"><code class="flex name class">
<span>class <span class="ident">GlobVarDB</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GlobVarDB(object):
    def __init__(self):
        self.data = {}

    def insert(self, cu, var):
        if cu not in self.data:
            self.data[cu] = set()
        self.data[cu].add(var)

    def jsondump(self):
        jout = {}
        for cu in self.data:
            jout[cu] = [f.jsondump() for f in self.data[cu]]
        #return json.dumps(jout)
        return jout</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.GlobVarDB.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, cu, var)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, cu, var):
    if cu not in self.data:
        self.data[cu] = set()
    self.data[cu].add(var)</code></pre>
</details>
</dd>
<dt id="pandare.extras.dwarfdump.GlobVarDB.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    jout = {}
    for cu in self.data:
        jout[cu] = [f.jsondump() for f in self.data[cu]]
    #return json.dumps(jout)
    return jout</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.LineDB"><code class="flex name class">
<span>class <span class="ident">LineDB</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LineDB(object):
    def __init__(self):
        self.data = {}

    def _find_best_fit(self, srcfn, lno, addr):
        r = [-1, -1]
        for i in range(len(self.data[srcfn])):
            if self.data[srcfn][i].lno == lno:
                if r[1] &lt; self.data[srcfn][i].highpc and addr &gt; self.data[srcfn][i].highpc:
                    r = [i, self.data[srcfn][i].highpc]
        return r[0]

    def insert(self, srcfn, lno, col, addr, func=None):
        if srcfn not in self.data:
            self.data[srcfn] = []

        if self.data[srcfn] and lno &lt; self.data[srcfn][-1].lno:
            i = -1
        else:
            i = self._find_best_fit(srcfn, lno, addr)
        if i == -1:
            self.data[srcfn].append(LineRange(lno, col, addr, addr, func))
            self.data[srcfn].sort(key = lambda x: x.lno)

        prevlno = lno-1
        i = self._find_best_fit(srcfn, prevlno, addr)
        while prevlno &gt; 0 and i == -1:
            prevlno -= 1
            i = self._find_best_fit(srcfn, prevlno, addr)
        if i != -1:
            self.data[srcfn][i].highpc = addr

    def update_function(self, base_addr, end_addr, finfo):
        srcinfo = None
        for srcfn in self.data:
            for i in range(len(self.data[srcfn])):
                if self.data[srcfn][i].lowpc == base_addr:
                    srcinfo = (srcfn, self.data[srcfn][i].lno)
                if self.data[srcfn][i].lowpc &gt;= base_addr \
                        and self.data[srcfn][i].highpc &lt; end_addr:
                    self.data[srcfn][i].func = finfo.scope.lowpc
        return srcinfo

    def jsondump(self):
        jout = {}
        for srcfn in self.data:
            key = srcfn
            while srcfn[0] in [&#39;&#34;&#39;, &#34;&#39;&#34;]:
                srcfn = srcfn[1:]
            while srcfn[-1] in [&#39;&#34;&#39;, &#34;&#39;&#34;]:
                srcfn = srcfn[:-1]
            jout[srcfn] = []
            for lr in self.data[key]:
                jout[srcfn].append(lr.jsondump())
        #return json.dumps(jout)
        return jout</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.LineDB.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, srcfn, lno, col, addr, func=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, srcfn, lno, col, addr, func=None):
    if srcfn not in self.data:
        self.data[srcfn] = []

    if self.data[srcfn] and lno &lt; self.data[srcfn][-1].lno:
        i = -1
    else:
        i = self._find_best_fit(srcfn, lno, addr)
    if i == -1:
        self.data[srcfn].append(LineRange(lno, col, addr, addr, func))
        self.data[srcfn].sort(key = lambda x: x.lno)

    prevlno = lno-1
    i = self._find_best_fit(srcfn, prevlno, addr)
    while prevlno &gt; 0 and i == -1:
        prevlno -= 1
        i = self._find_best_fit(srcfn, prevlno, addr)
    if i != -1:
        self.data[srcfn][i].highpc = addr</code></pre>
</details>
</dd>
<dt id="pandare.extras.dwarfdump.LineDB.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    jout = {}
    for srcfn in self.data:
        key = srcfn
        while srcfn[0] in [&#39;&#34;&#39;, &#34;&#39;&#34;]:
            srcfn = srcfn[1:]
        while srcfn[-1] in [&#39;&#34;&#39;, &#34;&#39;&#34;]:
            srcfn = srcfn[:-1]
        jout[srcfn] = []
        for lr in self.data[key]:
            jout[srcfn].append(lr.jsondump())
    #return json.dumps(jout)
    return jout</code></pre>
</details>
</dd>
<dt id="pandare.extras.dwarfdump.LineDB.update_function"><code class="name flex">
<span>def <span class="ident">update_function</span></span>(<span>self, base_addr, end_addr, finfo)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_function(self, base_addr, end_addr, finfo):
    srcinfo = None
    for srcfn in self.data:
        for i in range(len(self.data[srcfn])):
            if self.data[srcfn][i].lowpc == base_addr:
                srcinfo = (srcfn, self.data[srcfn][i].lno)
            if self.data[srcfn][i].lowpc &gt;= base_addr \
                    and self.data[srcfn][i].highpc &lt; end_addr:
                self.data[srcfn][i].func = finfo.scope.lowpc
    return srcinfo</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.LineRange"><code class="flex name class">
<span>class <span class="ident">LineRange</span></span>
<span>(</span><span>lno, col, lopc, hipc, func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LineRange(object):
    def __init__(self, lno, col, lopc, hipc, func):
        self.lno = lno
        self.col = col
        self.lowpc = lopc
        self.highpc = hipc
        self.func = func

    def jsondump(self):
        return {
                &#39;lno&#39;: self.lno,
                &#39;col&#39;: self.col,
                &#39;lowpc&#39;: self.lowpc,
                &#39;highpc&#39;: self.highpc,
                &#39;func&#39;: self.func,
                }</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.LineRange.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    return {
            &#39;lno&#39;: self.lno,
            &#39;col&#39;: self.col,
            &#39;lowpc&#39;: self.lowpc,
            &#39;highpc&#39;: self.highpc,
            &#39;func&#39;: self.func,
            }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.PointerType"><code class="flex name class">
<span>class <span class="ident">PointerType</span></span>
<span>(</span><span>name, cu_off, target)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PointerType(SugarType):
    def __init__(self, name, cu_off, target):
        SugarType.__init__(self, name, cu_off)
        self.ref = target

    def jsondump(self):
        d = SugarType.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;PointerType&#39;,
                })
        return d</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.extras.dwarfdump.SugarType" href="#pandare.extras.dwarfdump.SugarType">SugarType</a></li>
<li><a title="pandare.extras.dwarfdump.TypeInfo" href="#pandare.extras.dwarfdump.TypeInfo">TypeInfo</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.PointerType.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    d = SugarType.jsondump(self)
    d.update({
            &#39;tag&#39;: &#39;PointerType&#39;,
            })
    return d</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.Scope"><code class="flex name class">
<span>class <span class="ident">Scope</span></span>
<span>(</span><span>lopc, hipc)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scope(object):
    def __init__(self, lopc, hipc):
        self.lowpc = lopc
        self.highpc = hipc

    def jsondump(self):
        return {&#39;lowpc&#39;: self.lowpc, &#39;highpc&#39;: self.highpc}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.Scope.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    return {&#39;lowpc&#39;: self.lowpc, &#39;highpc&#39;: self.highpc}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.StructType"><code class="flex name class">
<span>class <span class="ident">StructType</span></span>
<span>(</span><span>name, cu_off, size)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StructType(TypeInfo):
    def __init__(self, name, cu_off, size):
        TypeInfo.__init__(self, name)
        self.size = size
        self.cu_off = cu_off
        self.children = {}  # &lt;member_offset: (name, type_offset)&gt;

    def jsondump(self):
        d = TypeInfo.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;StructType&#39;,
                &#39;size&#39;: self.size,
                &#39;cu_off&#39;: self.cu_off,
                &#39;children&#39;: self.children,
                })
        return d</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.extras.dwarfdump.TypeInfo" href="#pandare.extras.dwarfdump.TypeInfo">TypeInfo</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.StructType.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    d = TypeInfo.jsondump(self)
    d.update({
            &#39;tag&#39;: &#39;StructType&#39;,
            &#39;size&#39;: self.size,
            &#39;cu_off&#39;: self.cu_off,
            &#39;children&#39;: self.children,
            })
    return d</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.SubroutineType"><code class="flex name class">
<span>class <span class="ident">SubroutineType</span></span>
<span>(</span><span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubroutineType(TypeInfo):
    def __init__(self, name):
        TypeInfo.__init__(self, name)

    def jsondump(self):
        d = TypeInfo.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;SubroutineType&#39;,
                })
        return d</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.extras.dwarfdump.TypeInfo" href="#pandare.extras.dwarfdump.TypeInfo">TypeInfo</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.SubroutineType.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    d = TypeInfo.jsondump(self)
    d.update({
            &#39;tag&#39;: &#39;SubroutineType&#39;,
            })
    return d</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.SugarType"><code class="flex name class">
<span>class <span class="ident">SugarType</span></span>
<span>(</span><span>name, cu_off)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SugarType(TypeInfo):
    def __init__(self, name, cu_off):
        TypeInfo.__init__(self, name)
        self.cu_off = cu_off
        self.ref = None

    def jsondump(self):
        d = TypeInfo.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;SugarType&#39;,
                &#39;cu_off&#39;: self.cu_off,
                &#39;ref&#39;: self.ref,
                })
        return d</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.extras.dwarfdump.TypeInfo" href="#pandare.extras.dwarfdump.TypeInfo">TypeInfo</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pandare.extras.dwarfdump.ArrayRangeType" href="#pandare.extras.dwarfdump.ArrayRangeType">ArrayRangeType</a></li>
<li><a title="pandare.extras.dwarfdump.ArrayType" href="#pandare.extras.dwarfdump.ArrayType">ArrayType</a></li>
<li><a title="pandare.extras.dwarfdump.PointerType" href="#pandare.extras.dwarfdump.PointerType">PointerType</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.SugarType.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    d = TypeInfo.jsondump(self)
    d.update({
            &#39;tag&#39;: &#39;SugarType&#39;,
            &#39;cu_off&#39;: self.cu_off,
            &#39;ref&#39;: self.ref,
            })
    return d</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.TypeDB"><code class="flex name class">
<span>class <span class="ident">TypeDB</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypeDB(object):
    def __init__(self):
        self.data = {}

    def insert(self, cu, off, ty):
        if cu not in self.data:
            self.data[cu] = {}
        if off not in self.data[cu]:
            self.data[cu][off] = ty

    def jsondump(self):
        jout = {}
        for cu in self.data:
            jout[cu] = {}
            for off in self.data[cu]:
                jout[cu][off] = self.data[cu][off].jsondump()
        #return json.dumps(jout)
        return jout</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.TypeDB.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, cu, off, ty)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, cu, off, ty):
    if cu not in self.data:
        self.data[cu] = {}
    if off not in self.data[cu]:
        self.data[cu][off] = ty</code></pre>
</details>
</dd>
<dt id="pandare.extras.dwarfdump.TypeDB.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    jout = {}
    for cu in self.data:
        jout[cu] = {}
        for off in self.data[cu]:
            jout[cu][off] = self.data[cu][off].jsondump()
    #return json.dumps(jout)
    return jout</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.TypeInfo"><code class="flex name class">
<span>class <span class="ident">TypeInfo</span></span>
<span>(</span><span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypeInfo(object):
    def __init__(self, name):
        self.name = name

    def jsondump(self):
        return {&#39;name&#39;: self.name}</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pandare.extras.dwarfdump.BaseType" href="#pandare.extras.dwarfdump.BaseType">BaseType</a></li>
<li><a title="pandare.extras.dwarfdump.EnumType" href="#pandare.extras.dwarfdump.EnumType">EnumType</a></li>
<li><a title="pandare.extras.dwarfdump.StructType" href="#pandare.extras.dwarfdump.StructType">StructType</a></li>
<li><a title="pandare.extras.dwarfdump.SubroutineType" href="#pandare.extras.dwarfdump.SubroutineType">SubroutineType</a></li>
<li><a title="pandare.extras.dwarfdump.SugarType" href="#pandare.extras.dwarfdump.SugarType">SugarType</a></li>
<li><a title="pandare.extras.dwarfdump.UnionType" href="#pandare.extras.dwarfdump.UnionType">UnionType</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.TypeInfo.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    return {&#39;name&#39;: self.name}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.UnionType"><code class="flex name class">
<span>class <span class="ident">UnionType</span></span>
<span>(</span><span>name, cu_off, size)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnionType(TypeInfo):
    def __init__(self, name, cu_off, size):
        TypeInfo.__init__(self, name)
        self.size = size
        self.cu_off = cu_off
        self.children = {}  # &lt;member_offset: (name, type_offset)&gt;

    def jsondump(self):
        d = TypeInfo.jsondump(self)
        d.update({
                &#39;tag&#39;: &#39;UnionType&#39;,
                &#39;size&#39;: self.size,
                &#39;cu_off&#39;: self.cu_off,
                &#39;children&#39;: self.children,
                })
        return d</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.extras.dwarfdump.TypeInfo" href="#pandare.extras.dwarfdump.TypeInfo">TypeInfo</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.UnionType.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    d = TypeInfo.jsondump(self)
    d.update({
            &#39;tag&#39;: &#39;UnionType&#39;,
            &#39;size&#39;: self.size,
            &#39;cu_off&#39;: self.cu_off,
            &#39;children&#39;: self.children,
            })
    return d</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.dwarfdump.VarInfo"><code class="flex name class">
<span>class <span class="ident">VarInfo</span></span>
<span>(</span><span>name, cu_off)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VarInfo(object):
    def __init__(self, name, cu_off):
        self.name = name
        self.cu_offset = cu_off
        self.scope = None
        self.decl_lno = None
        self.decl_fn = None
        self.loc_op = []
        self.type = None

    def jsondump(self):
        return {&#39;name&#39;: self.name, \
                &#39;cu_offset&#39;: self.cu_offset, \
                &#39;scope&#39;: self.scope.jsondump(), \
                &#39;decl_lno&#39;: self.decl_lno, \
                &#39;decl_fn&#39;: self.decl_fn, \
                &#39;loc_op&#39;: self.loc_op, \
                &#39;type&#39;: self.type}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.dwarfdump.VarInfo.jsondump"><code class="name flex">
<span>def <span class="ident">jsondump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsondump(self):
    return {&#39;name&#39;: self.name, \
            &#39;cu_offset&#39;: self.cu_offset, \
            &#39;scope&#39;: self.scope.jsondump(), \
            &#39;decl_lno&#39;: self.decl_lno, \
            &#39;decl_fn&#39;: self.decl_fn, \
            &#39;loc_op&#39;: self.loc_op, \
            &#39;type&#39;: self.type}</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="panda.re Docs" href="/">
<img src="//panda.re/img/logo.png" alt="logo"> PANDA.re Docs
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pandare.extras" href="index.html">pandare.extras</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.dump_json" href="#pandare.extras.dwarfdump.dump_json">dump_json</a></code></li>
<li><code><a title="pandare.extras.dwarfdump.parse_die" href="#pandare.extras.dwarfdump.parse_die">parse_die</a></code></li>
<li><code><a title="pandare.extras.dwarfdump.parse_dwarfdump" href="#pandare.extras.dwarfdump.parse_dwarfdump">parse_dwarfdump</a></code></li>
<li><code><a title="pandare.extras.dwarfdump.parse_section" href="#pandare.extras.dwarfdump.parse_section">parse_section</a></code></li>
<li><code><a title="pandare.extras.dwarfdump.reprocess_ops" href="#pandare.extras.dwarfdump.reprocess_ops">reprocess_ops</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pandare.extras.dwarfdump.ArrayRangeType" href="#pandare.extras.dwarfdump.ArrayRangeType">ArrayRangeType</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.ArrayRangeType.jsondump" href="#pandare.extras.dwarfdump.ArrayRangeType.jsondump">jsondump</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.ArrayType" href="#pandare.extras.dwarfdump.ArrayType">ArrayType</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.ArrayType.jsondump" href="#pandare.extras.dwarfdump.ArrayType.jsondump">jsondump</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.BaseType" href="#pandare.extras.dwarfdump.BaseType">BaseType</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.BaseType.jsondump" href="#pandare.extras.dwarfdump.BaseType.jsondump">jsondump</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.EnumType" href="#pandare.extras.dwarfdump.EnumType">EnumType</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.EnumType.jsondump" href="#pandare.extras.dwarfdump.EnumType.jsondump">jsondump</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.FuncInfo" href="#pandare.extras.dwarfdump.FuncInfo">FuncInfo</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.FuncInfo.jsondump" href="#pandare.extras.dwarfdump.FuncInfo.jsondump">jsondump</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.FunctionDB" href="#pandare.extras.dwarfdump.FunctionDB">FunctionDB</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.FunctionDB.insert" href="#pandare.extras.dwarfdump.FunctionDB.insert">insert</a></code></li>
<li><code><a title="pandare.extras.dwarfdump.FunctionDB.jsondump" href="#pandare.extras.dwarfdump.FunctionDB.jsondump">jsondump</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.GlobVarDB" href="#pandare.extras.dwarfdump.GlobVarDB">GlobVarDB</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.GlobVarDB.insert" href="#pandare.extras.dwarfdump.GlobVarDB.insert">insert</a></code></li>
<li><code><a title="pandare.extras.dwarfdump.GlobVarDB.jsondump" href="#pandare.extras.dwarfdump.GlobVarDB.jsondump">jsondump</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.LineDB" href="#pandare.extras.dwarfdump.LineDB">LineDB</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.LineDB.insert" href="#pandare.extras.dwarfdump.LineDB.insert">insert</a></code></li>
<li><code><a title="pandare.extras.dwarfdump.LineDB.jsondump" href="#pandare.extras.dwarfdump.LineDB.jsondump">jsondump</a></code></li>
<li><code><a title="pandare.extras.dwarfdump.LineDB.update_function" href="#pandare.extras.dwarfdump.LineDB.update_function">update_function</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.LineRange" href="#pandare.extras.dwarfdump.LineRange">LineRange</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.LineRange.jsondump" href="#pandare.extras.dwarfdump.LineRange.jsondump">jsondump</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.PointerType" href="#pandare.extras.dwarfdump.PointerType">PointerType</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.PointerType.jsondump" href="#pandare.extras.dwarfdump.PointerType.jsondump">jsondump</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.Scope" href="#pandare.extras.dwarfdump.Scope">Scope</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.Scope.jsondump" href="#pandare.extras.dwarfdump.Scope.jsondump">jsondump</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.StructType" href="#pandare.extras.dwarfdump.StructType">StructType</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.StructType.jsondump" href="#pandare.extras.dwarfdump.StructType.jsondump">jsondump</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.SubroutineType" href="#pandare.extras.dwarfdump.SubroutineType">SubroutineType</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.SubroutineType.jsondump" href="#pandare.extras.dwarfdump.SubroutineType.jsondump">jsondump</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.SugarType" href="#pandare.extras.dwarfdump.SugarType">SugarType</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.SugarType.jsondump" href="#pandare.extras.dwarfdump.SugarType.jsondump">jsondump</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.TypeDB" href="#pandare.extras.dwarfdump.TypeDB">TypeDB</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.TypeDB.insert" href="#pandare.extras.dwarfdump.TypeDB.insert">insert</a></code></li>
<li><code><a title="pandare.extras.dwarfdump.TypeDB.jsondump" href="#pandare.extras.dwarfdump.TypeDB.jsondump">jsondump</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.TypeInfo" href="#pandare.extras.dwarfdump.TypeInfo">TypeInfo</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.TypeInfo.jsondump" href="#pandare.extras.dwarfdump.TypeInfo.jsondump">jsondump</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.UnionType" href="#pandare.extras.dwarfdump.UnionType">UnionType</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.UnionType.jsondump" href="#pandare.extras.dwarfdump.UnionType.jsondump">jsondump</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.dwarfdump.VarInfo" href="#pandare.extras.dwarfdump.VarInfo">VarInfo</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.dwarfdump.VarInfo.jsondump" href="#pandare.extras.dwarfdump.VarInfo.jsondump">jsondump</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>