<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>pandare.extras.file_faker API documentation</title>
<meta name="description" content="Framework for halucinating files inside the guest through
modifications around syscalls involving filenames and file
descriptors â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pandare.extras.file_faker</code></h1>
</header>
<section id="section-intro">
<p>Framework for halucinating files inside the guest through
modifications around syscalls involving filenames and file
descriptors.</p>
<p>High-level idea:
When we see an open of a file we want to fake, change it to another filename
that really exists and capture the file descriptor assigned to it.
Then whenever there are uses of that file descriptor, ignore/drop the request
and fake return values.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Framework for halucinating files inside the guest through
modifications around syscalls involving filenames and file
descriptors.

High-level idea:
    When we see an open of a file we want to fake, change it to another filename
    that really exists and capture the file descriptor assigned to it.
    Then whenever there are uses of that file descriptor, ignore/drop the request
    and fake return values.
&#34;&#34;&#34;


from pandare.extras.file_hook import FileHook
from pandare.ffi_importer import ffi
from math import ceil
import logging


class FakeFile:
    &#39;&#39;&#39;
    A fake file behind a hyperFD - this class will generate data when the
    corresponding file descriptor(s) are accessed.
    Users can inherit and modify this to customize how data is generated

    Note: a single FileFaker might be opened and in use by multiple FDs in the guest

    &#39;&#39;&#39;
    def __init__(self, fake_contents=&#34;&#34;, filename=None):
        self.logger = logging.getLogger(&#39;panda.hooking&#39;)

        if isinstance(fake_contents, str):
            fake_contents = fake_contents.encode(&#34;utf8&#34;)
        fake_contents += b&#39;\x00&#39;
        self.contents = fake_contents
        self.initial_contents = fake_contents
        self.refcount = 0 # Reference count
        self.filename = filename # Just for debug printing

    def read(self, size, offset):
        &#39;&#39;&#39;
        Generate data for a given read of size.  Returns data.
        &#39;&#39;&#39;

        if offset &gt;= len(self.contents):  # No bytes left to read
            return b&#34;&#34;
        # Otherwise there are bytes left to read
        read_data = self.contents[offset:offset+size]

        return read_data

    def write(self, offset, write_data):
        &#39;&#39;&#39;
        Update contents from offset. It&#39;s a bytearray so we can&#39;t just mutate
        Return how much HyperFD offset should be incremented by
        XXX what about writes past end of the file?
        &#39;&#39;&#39;
        self.logger.info(&#34;FakeFD({self.filename}) writing {new_data} at offset {self.offset}&#34;)
        new_data  = self.contents[:offset]
        new_data += write_data
        new_data += self.contents[offset+len(new_data):]

        self.contents = new_data
        return len(write_data)

    def close(self):
        self.refcount -= 1
        if self.refcount == 0: # All FDs are now closed
            if self.initial_contents == self.contents:
                self.logger.debug(f&#34;All handles to Faker({self.filename}) closed. Unmodified contents&#34;)
            else: # it was mutated!
                self.logger.info(f&#34;All handles to Faker({self.filename}) closed. Modified contents: {repr(self.contents)}&#34;)

    def get_mode(self):
        return 0o664 # Regular file (octal)

    def get_size(self, bytesize):
        return ceil(len(self.contents)/bytesize)

    def __str__(self):
        return f&#34;Faker({self.filename} -&gt; {repr(self.contents[:10])}...&#34;


    def _delete(self):
        self.close()

    def __del__(self):
        # XXX: This destructor isn&#39;t called automatically
        self._delete()

class HyperFD:
    &#39;&#39;&#39;
    A HyperFD is what we use to track the state of a faked FD in the guest.
    It is backed by a FakeFile.
    Stores the filename originally associated with it at time of open
    &#39;&#39;&#39;
    def __init__(self,  filename, fakefile, offset=0):
        self.name = filename
        self.file = fakefile
        self.file.refcount+=1 # Count of open FDs pointing to the file
        self.offset = offset

    def read(self, size):
        &#39;&#39;&#39;
        Read from the file descriptor. Determine current offset
        and then pass request through to FakeFile
        Returns (data read, count)
        &#39;&#39;&#39;
        assert(self.file)
        data = self.file.read(size, self.offset)
        self.offset+=len(data)
        return (data, len(data))

    def write(self, data):
        assert(self.file)
        bytes_written =  self.file.write(self.offset, data)
        self.offset +- bytes_written
        return bytes_written

    def get_mode(self):
        assert(self.file)
        return self.file.get_mode()

    def get_size(self):
        assert(self.file)
        return self.file.get_mode()

    def close(self):
        &#39;&#39;&#39;
        Decrement the reference counter
        &#39;&#39;&#39;
        assert(self.file)
        self.file.close()
        #del self # ???

    def seek(self, offset, whence):
        # From include/uapi/linux/fs.h
        SEEK_SET = 0
        SEEK_CUR = 1
        SEEK_END = 2

        if whence == SEEK_SET:
            self.offset = offset
        elif whence == SEEK_CUR:
            self.offset = self.offset + offset
        elif whence == SEEK_END:
            self.offset = self.offset + offset
        else:
            raise ValueError(f&#34;Unsupported whence {whence} in seek&#34;)

    def __str__(self):
        return f&#34;HyperFD with name {self.name} offset {self.offset} backed by {self.file}&#34;


class FileFaker(FileHook):
    &#39;&#39;&#39;
    Class to halucinate fake files within the guest. When the guest attempts to access a faked file,
    we transparenly redirect the access to another file on disk and grab the FD generated using FileHook.

    When the guest attempts to use a FD related to a faked file, we mutate the request. Reads are created
    from fake conents and writes are logged.
    &#39;&#39;&#39;

    def __init__(self, panda):
        &#39;&#39;&#39;
        Initialize FileHook and vars. Setup callbacks for all fd-based syscalls
        &#39;&#39;&#39;
        super().__init__(panda)

        self.faked_files = {} # filename: Fake
        self.hooked_fds = {} # (fd, cr3): HyperFD-&gt;faker
        self.currently_hooked = None # fd, asid tuple. Set when we&#39;re entering a syscall to hook. cleared on return
        self.pending_hfd = None

        to_hook = {} # index of fd argument: list of names
        if panda.arch == &#34;i386&#34;:
            # grep &#39;int fd&#39; syscall_switch_enter_linux_x86.cpp  | grep &#34;\[&#39;int fd\|\[&#39;unsigned int fd&#34; | grep -o sys_[a-zA-Z0-9_]* | sed -n -e &#39;s/sys_\(.*\)/&#34;\1&#34; /p&#39; | paste -sd &#34;,&#34; -
            # Note the grep commands missed dup2 and dup3 which take oldfd as 1st arg
            to_hook[0] = [&#34;read&#34;, &#34;write&#34;, &#34;close&#34;, &#34;lseek&#34;, &#34;fstat&#34;, &#34;ioctl&#34;, &#34;fcntl&#34;, &#34;ftruncate&#34;, &#34;fchmod&#34;,
                          &#34;fchown16&#34;, &#34;fstatfs&#34;, &#34;newfstat&#34;, &#34;fsync&#34;, &#34;fchdir&#34;, &#34;llseek&#34;, &#34;getdents&#34;, &#34;flock&#34;,
                          &#34;fdatasync&#34;, &#34;pread64&#34;, &#34;pwrite64&#34;, &#34;ftruncate64&#34;, &#34;fchown&#34;, &#34;getdents64&#34;, &#34;fcntl64&#34;,
                          &#34;readahead&#34;, &#34;fsetxattr&#34;, &#34;fgetxattr&#34;, &#34;flistxattr&#34;, &#34;fremovexattr&#34;, &#34;fadvise64&#34;,
                          &#34;fstatfs64&#34;, &#34;fadvise64_64&#34;, &#34;inotify_add_watch&#34;, &#34;inotify_rm_watch&#34;, &#34;splice&#34;,
                          &#34;sync_file_range&#34;, &#34;tee&#34;, &#34;vmsplice&#34;, &#34;fallocate&#34;, &#34;recvmmsg&#34;, &#34;syncfs&#34;, &#34;sendmmsg&#34;,
                          &#34;setns&#34;, &#34;finit_module&#34;, &#34;getsockopt&#34;, &#34;setsockopt&#34;, &#34;sendmsg&#34;, &#34;recvmsg&#34;, &#34;dup2&#34;,
                          &#34;dup3&#34; ]

            # grep &#39;int fd&#39; syscall_switch_enter_linux_x86.cpp  | grep -v &#34;\[&#39;int fd\|\[&#39;unsigned int fd&#34; # + manual
            to_hook[2] = [&#34;epoll_ctl&#34;]
            to_hook[3] = [&#34;fanotify_mark&#34;]

        elif panda.arch == &#34;x86_64&#34;:
            to_hook[0] = [&#34;read&#34;, &#34;write&#34;, &#34;close&#34;, &#34;newfstat&#34;, &#34;lseek&#34;, &#34;ioctl&#34;, &#34;pread64&#34;, &#34;pwrite64&#34;, &#34;sendmsg&#34;,
                          &#34;recvmsg&#34;, &#34;setsockopt&#34;, &#34;getsockopt&#34;, &#34;fcntl&#34;, &#34;flock&#34;, &#34;fsync&#34;, &#34;fdatasync&#34;, &#34;ftruncate&#34;,
                          &#34;getdents&#34;, &#34;fchdir&#34;, &#34;fchmod&#34;, &#34;fchown&#34;, &#34;fstatfs&#34;, &#34;readahead&#34;, &#34;fsetxattr&#34;, &#34;fgetxattr&#34;,
                          &#34;flistxattr&#34;, &#34;fremovexattr&#34;, &#34;getdents64&#34;, &#34;fadvise64&#34;, &#34;inotify_add_watch&#34;,
                          &#34;inotify_rm_watch&#34;, &#34;splice&#34;, &#34;tee&#34;, &#34;sync_file_range&#34;, &#34;vmsplice&#34;, &#34;fallocate&#34;, &#34;recvmmsg&#34;,
                          &#34;syncfs&#34;, &#34;sendmmsg&#34;, &#34;setns&#34;, &#34;finit_module&#34;, &#34;copy_file_range&#34;, &#34;dup2&#34;, &#34;dup3&#34;]
            to_hook[2] = [&#34;epoll_ctl&#34;]
            to_hook[3] = [&#34;fanotify_mark&#34;]

        elif panda.arch == &#34;arm&#34;:
            to_hook[0] = [&#34;read&#34;, &#34;write&#34;, &#34;close&#34;, &#34;lseek&#34;, &#34;ioctl&#34;, &#34;fcntl&#34;, &#34;ftruncate&#34;, &#34;fchmod&#34;, &#34;fchown16&#34;,
                          &#34;fstatfs&#34;, &#34;newfstat&#34;, &#34;fsync&#34;, &#34;fchdir&#34;, &#34;llseek&#34;, &#34;getdents&#34;, &#34;flock&#34;, &#34;fdatasync&#34;,
                          &#34;pread64&#34;, &#34;pwrite64&#34;, &#34;ftruncate64&#34;, &#34;fchown&#34;, &#34;getdents64&#34;, &#34;fcntl64&#34;, &#34;readahead&#34;,
                          &#34;fsetxattr&#34;, &#34;fgetxattr&#34;, &#34;flistxattr&#34;, &#34;fremovexattr&#34;, &#34;fstatfs64&#34;, &#34;arm_fadvise64_64&#34;,
                          &#34;setsockopt&#34;, &#34;getsockopt&#34;, &#34;sendmsg&#34;, &#34;recvmsg&#34;, &#34;inotify_add_watch&#34;, &#34;inotify_rm_watch&#34;,
                          &#34;splice&#34;, &#34;sync_file_range2&#34;, &#34;tee&#34;, &#34;vmsplice&#34;, &#34;fallocate&#34;, &#34;recvmmsg&#34;, &#34;syncfs&#34;,
                          &#34;sendmmsg&#34;, &#34;setns&#34;, &#34;finit_module&#34;, &#34;dup2&#34;, &#34;dup3&#34;]
            to_hook[2] = [&#34;epoll_ctl&#34;]
            to_hook[3] = [&#34;fanotify_mark&#34;]
        else:
            raise ValueError(f&#34;Unsupported PANDA arch: {panda.arch}&#34;)

        for arg_offset, names in to_hook.items():
            for name in names:
                self._gen_fd_cb(name, arg_offset)

    def replace_file(self, filename, faker):
        &#39;&#39;&#39;
        Replace all accesses to filename with accesses to the fake file instead
        &#39;&#39;&#39;
        self.faked_files[filename] = faker

        # XXX: We rename the files to real files to the guest kernel can manage FDs for us.
        #      this may need to use different real files depending on permissions requested
        self.rename_file(filename, &#34;/etc/passwd&#34;)

    def _gen_fd_cb(self, name, fd_offset):
        &#39;&#39;&#39;
        Register syscalls2 PPP callback on enter and return for the given name
        which has an argument of fd at fd_offset in the argument list
        &#39;&#39;&#39;
        self._panda.ppp(&#34;syscalls2&#34;, f&#34;on_sys_{name}_enter&#34;, name=f&#34;file_faker_enter_{name}&#34;)( \
                    lambda *args: self._enter_fd_cb(name, fd_offset, args=args))
        self._panda.ppp(&#34;syscalls2&#34;, f&#34;on_sys_{name}_return&#34;, name=f&#34;file_faker_return_{name}&#34;)( \
                    lambda *args: self._return_fd_cb(name, fd_offset, args=args))

    def _enter_fd_cb(self, syscall_name, fd_pos, args=None):
        &#39;&#39;&#39;
        When we&#39;re about to enter a callback. Check if the fd is hooked and if so
        update currently_hooked so we can fix it upon return.
        Maybe this could be updated to skip the hooked syscalls entirely?
        &#39;&#39;&#39;
        assert(args)
        (cpu, pc) = args[0:2]
        fd = args[2+fd_pos]
        asid = self._panda.current_asid(cpu)

        if fd == 0xffffffff:
            self.logger.debug(f&#34;Got -1 for fd in enter of {syscall_name}&#34;)
            return

        assert(fd &lt; 0xffffffff), &#34;FD overflow?&#34;

        # Looks like this file isn&#39;t hooked. Let&#39;s use OSI and confirm
        if (fd, asid) not in self.hooked_fds:
            # Let&#39;s use OSI to figure out the backing filename here
            fname = self._get_fname(cpu, fd)
            if fname and fname in self.faked_files:
                self.logger.warning(&#34;Entering {syscall_name} with fd {fd} backed by {fname} but we missed it earlier - adding it now&#34;)
                hfd = HyperFD(fname, self.faked_files[fname]) # Create HFD
                self.hooked_fds[(fd, asid)] =  hfd

        # If this file descriptor is already hooked, update currently_hooked
        # so we know to mutate it when it returns
        if (fd, asid) in self.hooked_fds:
            hfd = self.hooked_fds[(fd, asid)]
            self.logger.info(f&#34;Entering hooked syscall {syscall_name} for fd {fd}, &#34; + \
                                f&#34;filename {hfd.name}&#34;)
            self.currently_hooked = (fd, asid)


    def _return_fd_cb(self, syscall_name, fd_pos, args=None):
        &#39;&#39;&#39;
        When we&#39;re returnuing from a syscall, mutate memory
        to put the results we want there
        &#39;&#39;&#39;
        if not self.currently_hooked:
            return

        (fd, asid) = self.currently_hooked
        hfd = self.hooked_fds[(fd, asid)]

        self.currently_hooked = None
        assert(args)

        (cpu, pc) = args[0:2]
        fd = args[2+fd_pos]
        asid = self._panda.current_asid(cpu)

        if syscall_name == &#34;read&#34;:
            self.logger.debug(f&#34;Handling READ of fakeFD {fd} {hfd.name}&#34;)
            # Place up to `count` bytes of data into memory at `buf_ptr`
            buf_ptr = args[3]
            count   = args[4]

            (data, data_len) = hfd.read(count)
            if data:
                try:
                    self._panda.virtual_memory_write(cpu, buf_ptr, data)
                except ValueError:
                    self.logger.error(f&#34;Unable to store fake data after read to {hfd}&#34;)
                    return

            cpu.env_ptr.regs[0] = data_len

            #self.logger.info(f&#34;Returning {data_len} bytes&#34;)

        elif syscall_name == &#34;close&#34;:
            # We want the guest to close the real FD. Delete it from our map of hooked fds
            hfd.close()
            if (fd, asid) in self.hooked_fds:
                del self.hooked_fds[(fd, asid)]

        elif syscall_name == &#34;write&#34;:
            # read count bytes from buf, add to our hyper-fd
            buf_ptr = args[3]
            count   = args[4]
            try:
                data = self._panda.virtual_memory_read(cpu, buf_ptr, count)
            except ValueError:
                self.logger.error(f&#34;Unable to read buffer that was being written&#34;)
                return

            bytes_written = hfd.write(data)
            cpu.env_ptr.regs[0] = bytes_written

        elif syscall_name == &#34;lseek&#34;: # LLSEEK?
            offset = args[2]
            whence = args[3]
            hfd.seek(offset, whence)


        elif syscall_name in [&#34;dup2&#34;, &#34;dup3&#34;]:
            # add newfd
            oldfd = args[2]
            newfd = args[3]
            self.logger.debug(f&#34;Duplicating faked fd {oldfd} to {newfd}&#34;)

            # Duplicate the old hfd - but not the file behind it
            new_hfd = HyperFD(hfd.name, hfd.file, hfd.offset)
            self.hooked_fds[(newfd, asid)] = new_hfd

        else:
            self.logger.error(f&#34;Unsupported syscall on FakeFD{fd}: {syscall_name}. Not intercepting (Running on real guest FD)&#34;)


    def _before_modified_enter(self, cpu, pc, syscall_name, fname):
        &#39;&#39;&#39;
        Overload FileHook function. Determine if a syscall we&#39;re about to
        enter is using a filename we want to fake

        After the modified syscall returns, we grab the real FD and map it to the HFD
        &#39;&#39;&#39;
        if fname in self.faked_files:
            self.pending_hfd =  HyperFD(fname, self.faked_files[fname]) # Create HFD
            asid = self._panda.current_asid(cpu)

    def _after_modified_return(self, cpu, pc, syscall_name):
        &#39;&#39;&#39;
        Overload FileHook function. Determine if a syscall we&#39;re about to
        return from was using a filename we want to fake. If so, grab the FD
        &#39;&#39;&#39;
        if self.pending_hfd:
            # XXX: is asid correct here?
            fd = cpu.env_ptr.regs[0] # XXX: definitely isn&#39;t true for all syscalls
            asid = self._panda.current_asid(cpu)
            self.hooked_fds[(fd, asid)] =  self.pending_hfd
            self.pending_hfd = None


    def close(self):
        # Close all open hfds
        if len(self.hooked_fds):
            self.logger.debug(&#34;Cleaning up open hyper file descriptors&#34;)
            for (fd, asid) in list(self.hooked_fds.keys()):
                self.hooked_fds[(fd, asid)].close()
                del self.hooked_fds[(fd, asid)]


    def __del__(self):
        # XXX: This isn&#39;t being called for some reason on destruction
        self.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pandare.extras.file_faker.FakeFile"><code class="flex name class">
<span>class <span class="ident">FakeFile</span></span>
<span>(</span><span>fake_contents='', filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A fake file behind a hyperFD - this class will generate data when the
corresponding file descriptor(s) are accessed.
Users can inherit and modify this to customize how data is generated</p>
<p>Note: a single FileFaker might be opened and in use by multiple FDs in the guest</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FakeFile:
    &#39;&#39;&#39;
    A fake file behind a hyperFD - this class will generate data when the
    corresponding file descriptor(s) are accessed.
    Users can inherit and modify this to customize how data is generated

    Note: a single FileFaker might be opened and in use by multiple FDs in the guest

    &#39;&#39;&#39;
    def __init__(self, fake_contents=&#34;&#34;, filename=None):
        self.logger = logging.getLogger(&#39;panda.hooking&#39;)

        if isinstance(fake_contents, str):
            fake_contents = fake_contents.encode(&#34;utf8&#34;)
        fake_contents += b&#39;\x00&#39;
        self.contents = fake_contents
        self.initial_contents = fake_contents
        self.refcount = 0 # Reference count
        self.filename = filename # Just for debug printing

    def read(self, size, offset):
        &#39;&#39;&#39;
        Generate data for a given read of size.  Returns data.
        &#39;&#39;&#39;

        if offset &gt;= len(self.contents):  # No bytes left to read
            return b&#34;&#34;
        # Otherwise there are bytes left to read
        read_data = self.contents[offset:offset+size]

        return read_data

    def write(self, offset, write_data):
        &#39;&#39;&#39;
        Update contents from offset. It&#39;s a bytearray so we can&#39;t just mutate
        Return how much HyperFD offset should be incremented by
        XXX what about writes past end of the file?
        &#39;&#39;&#39;
        self.logger.info(&#34;FakeFD({self.filename}) writing {new_data} at offset {self.offset}&#34;)
        new_data  = self.contents[:offset]
        new_data += write_data
        new_data += self.contents[offset+len(new_data):]

        self.contents = new_data
        return len(write_data)

    def close(self):
        self.refcount -= 1
        if self.refcount == 0: # All FDs are now closed
            if self.initial_contents == self.contents:
                self.logger.debug(f&#34;All handles to Faker({self.filename}) closed. Unmodified contents&#34;)
            else: # it was mutated!
                self.logger.info(f&#34;All handles to Faker({self.filename}) closed. Modified contents: {repr(self.contents)}&#34;)

    def get_mode(self):
        return 0o664 # Regular file (octal)

    def get_size(self, bytesize):
        return ceil(len(self.contents)/bytesize)

    def __str__(self):
        return f&#34;Faker({self.filename} -&gt; {repr(self.contents[:10])}...&#34;


    def _delete(self):
        self.close()

    def __del__(self):
        # XXX: This destructor isn&#39;t called automatically
        self._delete()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.file_faker.FakeFile.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    self.refcount -= 1
    if self.refcount == 0: # All FDs are now closed
        if self.initial_contents == self.contents:
            self.logger.debug(f&#34;All handles to Faker({self.filename}) closed. Unmodified contents&#34;)
        else: # it was mutated!
            self.logger.info(f&#34;All handles to Faker({self.filename}) closed. Modified contents: {repr(self.contents)}&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.extras.file_faker.FakeFile.get_mode"><code class="name flex">
<span>def <span class="ident">get_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mode(self):
    return 0o664 # Regular file (octal)</code></pre>
</details>
</dd>
<dt id="pandare.extras.file_faker.FakeFile.get_size"><code class="name flex">
<span>def <span class="ident">get_size</span></span>(<span>self, bytesize)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size(self, bytesize):
    return ceil(len(self.contents)/bytesize)</code></pre>
</details>
</dd>
<dt id="pandare.extras.file_faker.FakeFile.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, size, offset)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate data for a given read of size.
Returns data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, size, offset):
    &#39;&#39;&#39;
    Generate data for a given read of size.  Returns data.
    &#39;&#39;&#39;

    if offset &gt;= len(self.contents):  # No bytes left to read
        return b&#34;&#34;
    # Otherwise there are bytes left to read
    read_data = self.contents[offset:offset+size]

    return read_data</code></pre>
</details>
</dd>
<dt id="pandare.extras.file_faker.FakeFile.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, offset, write_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Update contents from offset. It's a bytearray so we can't just mutate
Return how much HyperFD offset should be incremented by
XXX what about writes past end of the file?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, offset, write_data):
    &#39;&#39;&#39;
    Update contents from offset. It&#39;s a bytearray so we can&#39;t just mutate
    Return how much HyperFD offset should be incremented by
    XXX what about writes past end of the file?
    &#39;&#39;&#39;
    self.logger.info(&#34;FakeFD({self.filename}) writing {new_data} at offset {self.offset}&#34;)
    new_data  = self.contents[:offset]
    new_data += write_data
    new_data += self.contents[offset+len(new_data):]

    self.contents = new_data
    return len(write_data)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.file_faker.FileFaker"><code class="flex name class">
<span>class <span class="ident">FileFaker</span></span>
<span>(</span><span>panda)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to halucinate fake files within the guest. When the guest attempts to access a faked file,
we transparenly redirect the access to another file on disk and grab the FD generated using FileHook.</p>
<p>When the guest attempts to use a FD related to a faked file, we mutate the request. Reads are created
from fake conents and writes are logged.</p>
<p>Initialize FileHook and vars. Setup callbacks for all fd-based syscalls</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileFaker(FileHook):
    &#39;&#39;&#39;
    Class to halucinate fake files within the guest. When the guest attempts to access a faked file,
    we transparenly redirect the access to another file on disk and grab the FD generated using FileHook.

    When the guest attempts to use a FD related to a faked file, we mutate the request. Reads are created
    from fake conents and writes are logged.
    &#39;&#39;&#39;

    def __init__(self, panda):
        &#39;&#39;&#39;
        Initialize FileHook and vars. Setup callbacks for all fd-based syscalls
        &#39;&#39;&#39;
        super().__init__(panda)

        self.faked_files = {} # filename: Fake
        self.hooked_fds = {} # (fd, cr3): HyperFD-&gt;faker
        self.currently_hooked = None # fd, asid tuple. Set when we&#39;re entering a syscall to hook. cleared on return
        self.pending_hfd = None

        to_hook = {} # index of fd argument: list of names
        if panda.arch == &#34;i386&#34;:
            # grep &#39;int fd&#39; syscall_switch_enter_linux_x86.cpp  | grep &#34;\[&#39;int fd\|\[&#39;unsigned int fd&#34; | grep -o sys_[a-zA-Z0-9_]* | sed -n -e &#39;s/sys_\(.*\)/&#34;\1&#34; /p&#39; | paste -sd &#34;,&#34; -
            # Note the grep commands missed dup2 and dup3 which take oldfd as 1st arg
            to_hook[0] = [&#34;read&#34;, &#34;write&#34;, &#34;close&#34;, &#34;lseek&#34;, &#34;fstat&#34;, &#34;ioctl&#34;, &#34;fcntl&#34;, &#34;ftruncate&#34;, &#34;fchmod&#34;,
                          &#34;fchown16&#34;, &#34;fstatfs&#34;, &#34;newfstat&#34;, &#34;fsync&#34;, &#34;fchdir&#34;, &#34;llseek&#34;, &#34;getdents&#34;, &#34;flock&#34;,
                          &#34;fdatasync&#34;, &#34;pread64&#34;, &#34;pwrite64&#34;, &#34;ftruncate64&#34;, &#34;fchown&#34;, &#34;getdents64&#34;, &#34;fcntl64&#34;,
                          &#34;readahead&#34;, &#34;fsetxattr&#34;, &#34;fgetxattr&#34;, &#34;flistxattr&#34;, &#34;fremovexattr&#34;, &#34;fadvise64&#34;,
                          &#34;fstatfs64&#34;, &#34;fadvise64_64&#34;, &#34;inotify_add_watch&#34;, &#34;inotify_rm_watch&#34;, &#34;splice&#34;,
                          &#34;sync_file_range&#34;, &#34;tee&#34;, &#34;vmsplice&#34;, &#34;fallocate&#34;, &#34;recvmmsg&#34;, &#34;syncfs&#34;, &#34;sendmmsg&#34;,
                          &#34;setns&#34;, &#34;finit_module&#34;, &#34;getsockopt&#34;, &#34;setsockopt&#34;, &#34;sendmsg&#34;, &#34;recvmsg&#34;, &#34;dup2&#34;,
                          &#34;dup3&#34; ]

            # grep &#39;int fd&#39; syscall_switch_enter_linux_x86.cpp  | grep -v &#34;\[&#39;int fd\|\[&#39;unsigned int fd&#34; # + manual
            to_hook[2] = [&#34;epoll_ctl&#34;]
            to_hook[3] = [&#34;fanotify_mark&#34;]

        elif panda.arch == &#34;x86_64&#34;:
            to_hook[0] = [&#34;read&#34;, &#34;write&#34;, &#34;close&#34;, &#34;newfstat&#34;, &#34;lseek&#34;, &#34;ioctl&#34;, &#34;pread64&#34;, &#34;pwrite64&#34;, &#34;sendmsg&#34;,
                          &#34;recvmsg&#34;, &#34;setsockopt&#34;, &#34;getsockopt&#34;, &#34;fcntl&#34;, &#34;flock&#34;, &#34;fsync&#34;, &#34;fdatasync&#34;, &#34;ftruncate&#34;,
                          &#34;getdents&#34;, &#34;fchdir&#34;, &#34;fchmod&#34;, &#34;fchown&#34;, &#34;fstatfs&#34;, &#34;readahead&#34;, &#34;fsetxattr&#34;, &#34;fgetxattr&#34;,
                          &#34;flistxattr&#34;, &#34;fremovexattr&#34;, &#34;getdents64&#34;, &#34;fadvise64&#34;, &#34;inotify_add_watch&#34;,
                          &#34;inotify_rm_watch&#34;, &#34;splice&#34;, &#34;tee&#34;, &#34;sync_file_range&#34;, &#34;vmsplice&#34;, &#34;fallocate&#34;, &#34;recvmmsg&#34;,
                          &#34;syncfs&#34;, &#34;sendmmsg&#34;, &#34;setns&#34;, &#34;finit_module&#34;, &#34;copy_file_range&#34;, &#34;dup2&#34;, &#34;dup3&#34;]
            to_hook[2] = [&#34;epoll_ctl&#34;]
            to_hook[3] = [&#34;fanotify_mark&#34;]

        elif panda.arch == &#34;arm&#34;:
            to_hook[0] = [&#34;read&#34;, &#34;write&#34;, &#34;close&#34;, &#34;lseek&#34;, &#34;ioctl&#34;, &#34;fcntl&#34;, &#34;ftruncate&#34;, &#34;fchmod&#34;, &#34;fchown16&#34;,
                          &#34;fstatfs&#34;, &#34;newfstat&#34;, &#34;fsync&#34;, &#34;fchdir&#34;, &#34;llseek&#34;, &#34;getdents&#34;, &#34;flock&#34;, &#34;fdatasync&#34;,
                          &#34;pread64&#34;, &#34;pwrite64&#34;, &#34;ftruncate64&#34;, &#34;fchown&#34;, &#34;getdents64&#34;, &#34;fcntl64&#34;, &#34;readahead&#34;,
                          &#34;fsetxattr&#34;, &#34;fgetxattr&#34;, &#34;flistxattr&#34;, &#34;fremovexattr&#34;, &#34;fstatfs64&#34;, &#34;arm_fadvise64_64&#34;,
                          &#34;setsockopt&#34;, &#34;getsockopt&#34;, &#34;sendmsg&#34;, &#34;recvmsg&#34;, &#34;inotify_add_watch&#34;, &#34;inotify_rm_watch&#34;,
                          &#34;splice&#34;, &#34;sync_file_range2&#34;, &#34;tee&#34;, &#34;vmsplice&#34;, &#34;fallocate&#34;, &#34;recvmmsg&#34;, &#34;syncfs&#34;,
                          &#34;sendmmsg&#34;, &#34;setns&#34;, &#34;finit_module&#34;, &#34;dup2&#34;, &#34;dup3&#34;]
            to_hook[2] = [&#34;epoll_ctl&#34;]
            to_hook[3] = [&#34;fanotify_mark&#34;]
        else:
            raise ValueError(f&#34;Unsupported PANDA arch: {panda.arch}&#34;)

        for arg_offset, names in to_hook.items():
            for name in names:
                self._gen_fd_cb(name, arg_offset)

    def replace_file(self, filename, faker):
        &#39;&#39;&#39;
        Replace all accesses to filename with accesses to the fake file instead
        &#39;&#39;&#39;
        self.faked_files[filename] = faker

        # XXX: We rename the files to real files to the guest kernel can manage FDs for us.
        #      this may need to use different real files depending on permissions requested
        self.rename_file(filename, &#34;/etc/passwd&#34;)

    def _gen_fd_cb(self, name, fd_offset):
        &#39;&#39;&#39;
        Register syscalls2 PPP callback on enter and return for the given name
        which has an argument of fd at fd_offset in the argument list
        &#39;&#39;&#39;
        self._panda.ppp(&#34;syscalls2&#34;, f&#34;on_sys_{name}_enter&#34;, name=f&#34;file_faker_enter_{name}&#34;)( \
                    lambda *args: self._enter_fd_cb(name, fd_offset, args=args))
        self._panda.ppp(&#34;syscalls2&#34;, f&#34;on_sys_{name}_return&#34;, name=f&#34;file_faker_return_{name}&#34;)( \
                    lambda *args: self._return_fd_cb(name, fd_offset, args=args))

    def _enter_fd_cb(self, syscall_name, fd_pos, args=None):
        &#39;&#39;&#39;
        When we&#39;re about to enter a callback. Check if the fd is hooked and if so
        update currently_hooked so we can fix it upon return.
        Maybe this could be updated to skip the hooked syscalls entirely?
        &#39;&#39;&#39;
        assert(args)
        (cpu, pc) = args[0:2]
        fd = args[2+fd_pos]
        asid = self._panda.current_asid(cpu)

        if fd == 0xffffffff:
            self.logger.debug(f&#34;Got -1 for fd in enter of {syscall_name}&#34;)
            return

        assert(fd &lt; 0xffffffff), &#34;FD overflow?&#34;

        # Looks like this file isn&#39;t hooked. Let&#39;s use OSI and confirm
        if (fd, asid) not in self.hooked_fds:
            # Let&#39;s use OSI to figure out the backing filename here
            fname = self._get_fname(cpu, fd)
            if fname and fname in self.faked_files:
                self.logger.warning(&#34;Entering {syscall_name} with fd {fd} backed by {fname} but we missed it earlier - adding it now&#34;)
                hfd = HyperFD(fname, self.faked_files[fname]) # Create HFD
                self.hooked_fds[(fd, asid)] =  hfd

        # If this file descriptor is already hooked, update currently_hooked
        # so we know to mutate it when it returns
        if (fd, asid) in self.hooked_fds:
            hfd = self.hooked_fds[(fd, asid)]
            self.logger.info(f&#34;Entering hooked syscall {syscall_name} for fd {fd}, &#34; + \
                                f&#34;filename {hfd.name}&#34;)
            self.currently_hooked = (fd, asid)


    def _return_fd_cb(self, syscall_name, fd_pos, args=None):
        &#39;&#39;&#39;
        When we&#39;re returnuing from a syscall, mutate memory
        to put the results we want there
        &#39;&#39;&#39;
        if not self.currently_hooked:
            return

        (fd, asid) = self.currently_hooked
        hfd = self.hooked_fds[(fd, asid)]

        self.currently_hooked = None
        assert(args)

        (cpu, pc) = args[0:2]
        fd = args[2+fd_pos]
        asid = self._panda.current_asid(cpu)

        if syscall_name == &#34;read&#34;:
            self.logger.debug(f&#34;Handling READ of fakeFD {fd} {hfd.name}&#34;)
            # Place up to `count` bytes of data into memory at `buf_ptr`
            buf_ptr = args[3]
            count   = args[4]

            (data, data_len) = hfd.read(count)
            if data:
                try:
                    self._panda.virtual_memory_write(cpu, buf_ptr, data)
                except ValueError:
                    self.logger.error(f&#34;Unable to store fake data after read to {hfd}&#34;)
                    return

            cpu.env_ptr.regs[0] = data_len

            #self.logger.info(f&#34;Returning {data_len} bytes&#34;)

        elif syscall_name == &#34;close&#34;:
            # We want the guest to close the real FD. Delete it from our map of hooked fds
            hfd.close()
            if (fd, asid) in self.hooked_fds:
                del self.hooked_fds[(fd, asid)]

        elif syscall_name == &#34;write&#34;:
            # read count bytes from buf, add to our hyper-fd
            buf_ptr = args[3]
            count   = args[4]
            try:
                data = self._panda.virtual_memory_read(cpu, buf_ptr, count)
            except ValueError:
                self.logger.error(f&#34;Unable to read buffer that was being written&#34;)
                return

            bytes_written = hfd.write(data)
            cpu.env_ptr.regs[0] = bytes_written

        elif syscall_name == &#34;lseek&#34;: # LLSEEK?
            offset = args[2]
            whence = args[3]
            hfd.seek(offset, whence)


        elif syscall_name in [&#34;dup2&#34;, &#34;dup3&#34;]:
            # add newfd
            oldfd = args[2]
            newfd = args[3]
            self.logger.debug(f&#34;Duplicating faked fd {oldfd} to {newfd}&#34;)

            # Duplicate the old hfd - but not the file behind it
            new_hfd = HyperFD(hfd.name, hfd.file, hfd.offset)
            self.hooked_fds[(newfd, asid)] = new_hfd

        else:
            self.logger.error(f&#34;Unsupported syscall on FakeFD{fd}: {syscall_name}. Not intercepting (Running on real guest FD)&#34;)


    def _before_modified_enter(self, cpu, pc, syscall_name, fname):
        &#39;&#39;&#39;
        Overload FileHook function. Determine if a syscall we&#39;re about to
        enter is using a filename we want to fake

        After the modified syscall returns, we grab the real FD and map it to the HFD
        &#39;&#39;&#39;
        if fname in self.faked_files:
            self.pending_hfd =  HyperFD(fname, self.faked_files[fname]) # Create HFD
            asid = self._panda.current_asid(cpu)

    def _after_modified_return(self, cpu, pc, syscall_name):
        &#39;&#39;&#39;
        Overload FileHook function. Determine if a syscall we&#39;re about to
        return from was using a filename we want to fake. If so, grab the FD
        &#39;&#39;&#39;
        if self.pending_hfd:
            # XXX: is asid correct here?
            fd = cpu.env_ptr.regs[0] # XXX: definitely isn&#39;t true for all syscalls
            asid = self._panda.current_asid(cpu)
            self.hooked_fds[(fd, asid)] =  self.pending_hfd
            self.pending_hfd = None


    def close(self):
        # Close all open hfds
        if len(self.hooked_fds):
            self.logger.debug(&#34;Cleaning up open hyper file descriptors&#34;)
            for (fd, asid) in list(self.hooked_fds.keys()):
                self.hooked_fds[(fd, asid)].close()
                del self.hooked_fds[(fd, asid)]


    def __del__(self):
        # XXX: This isn&#39;t being called for some reason on destruction
        self.close()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.extras.file_hook.FileHook" href="file_hook.html#pandare.extras.file_hook.FileHook">FileHook</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.file_faker.FileFaker.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    # Close all open hfds
    if len(self.hooked_fds):
        self.logger.debug(&#34;Cleaning up open hyper file descriptors&#34;)
        for (fd, asid) in list(self.hooked_fds.keys()):
            self.hooked_fds[(fd, asid)].close()
            del self.hooked_fds[(fd, asid)]</code></pre>
</details>
</dd>
<dt id="pandare.extras.file_faker.FileFaker.replace_file"><code class="name flex">
<span>def <span class="ident">replace_file</span></span>(<span>self, filename, faker)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace all accesses to filename with accesses to the fake file instead</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_file(self, filename, faker):
    &#39;&#39;&#39;
    Replace all accesses to filename with accesses to the fake file instead
    &#39;&#39;&#39;
    self.faked_files[filename] = faker

    # XXX: We rename the files to real files to the guest kernel can manage FDs for us.
    #      this may need to use different real files depending on permissions requested
    self.rename_file(filename, &#34;/etc/passwd&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pandare.extras.file_hook.FileHook" href="file_hook.html#pandare.extras.file_hook.FileHook">FileHook</a></b></code>:
<ul class="hlist">
<li><code><a title="pandare.extras.file_hook.FileHook.rename_file" href="file_hook.html#pandare.extras.file_hook.FileHook.rename_file">rename_file</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pandare.extras.file_faker.HyperFD"><code class="flex name class">
<span>class <span class="ident">HyperFD</span></span>
<span>(</span><span>filename, fakefile, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>A HyperFD is what we use to track the state of a faked FD in the guest.
It is backed by a FakeFile.
Stores the filename originally associated with it at time of open</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HyperFD:
    &#39;&#39;&#39;
    A HyperFD is what we use to track the state of a faked FD in the guest.
    It is backed by a FakeFile.
    Stores the filename originally associated with it at time of open
    &#39;&#39;&#39;
    def __init__(self,  filename, fakefile, offset=0):
        self.name = filename
        self.file = fakefile
        self.file.refcount+=1 # Count of open FDs pointing to the file
        self.offset = offset

    def read(self, size):
        &#39;&#39;&#39;
        Read from the file descriptor. Determine current offset
        and then pass request through to FakeFile
        Returns (data read, count)
        &#39;&#39;&#39;
        assert(self.file)
        data = self.file.read(size, self.offset)
        self.offset+=len(data)
        return (data, len(data))

    def write(self, data):
        assert(self.file)
        bytes_written =  self.file.write(self.offset, data)
        self.offset +- bytes_written
        return bytes_written

    def get_mode(self):
        assert(self.file)
        return self.file.get_mode()

    def get_size(self):
        assert(self.file)
        return self.file.get_mode()

    def close(self):
        &#39;&#39;&#39;
        Decrement the reference counter
        &#39;&#39;&#39;
        assert(self.file)
        self.file.close()
        #del self # ???

    def seek(self, offset, whence):
        # From include/uapi/linux/fs.h
        SEEK_SET = 0
        SEEK_CUR = 1
        SEEK_END = 2

        if whence == SEEK_SET:
            self.offset = offset
        elif whence == SEEK_CUR:
            self.offset = self.offset + offset
        elif whence == SEEK_END:
            self.offset = self.offset + offset
        else:
            raise ValueError(f&#34;Unsupported whence {whence} in seek&#34;)

    def __str__(self):
        return f&#34;HyperFD with name {self.name} offset {self.offset} backed by {self.file}&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.file_faker.HyperFD.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Decrement the reference counter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#39;&#39;&#39;
    Decrement the reference counter
    &#39;&#39;&#39;
    assert(self.file)
    self.file.close()</code></pre>
</details>
</dd>
<dt id="pandare.extras.file_faker.HyperFD.get_mode"><code class="name flex">
<span>def <span class="ident">get_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mode(self):
    assert(self.file)
    return self.file.get_mode()</code></pre>
</details>
</dd>
<dt id="pandare.extras.file_faker.HyperFD.get_size"><code class="name flex">
<span>def <span class="ident">get_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size(self):
    assert(self.file)
    return self.file.get_mode()</code></pre>
</details>
</dd>
<dt id="pandare.extras.file_faker.HyperFD.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Read from the file descriptor. Determine current offset
and then pass request through to FakeFile
Returns (data read, count)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, size):
    &#39;&#39;&#39;
    Read from the file descriptor. Determine current offset
    and then pass request through to FakeFile
    Returns (data read, count)
    &#39;&#39;&#39;
    assert(self.file)
    data = self.file.read(size, self.offset)
    self.offset+=len(data)
    return (data, len(data))</code></pre>
</details>
</dd>
<dt id="pandare.extras.file_faker.HyperFD.seek"><code class="name flex">
<span>def <span class="ident">seek</span></span>(<span>self, offset, whence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seek(self, offset, whence):
    # From include/uapi/linux/fs.h
    SEEK_SET = 0
    SEEK_CUR = 1
    SEEK_END = 2

    if whence == SEEK_SET:
        self.offset = offset
    elif whence == SEEK_CUR:
        self.offset = self.offset + offset
    elif whence == SEEK_END:
        self.offset = self.offset + offset
    else:
        raise ValueError(f&#34;Unsupported whence {whence} in seek&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.extras.file_faker.HyperFD.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, data):
    assert(self.file)
    bytes_written =  self.file.write(self.offset, data)
    self.offset +- bytes_written
    return bytes_written</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pandare.extras" href="index.html">pandare.extras</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pandare.extras.file_faker.FakeFile" href="#pandare.extras.file_faker.FakeFile">FakeFile</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.file_faker.FakeFile.close" href="#pandare.extras.file_faker.FakeFile.close">close</a></code></li>
<li><code><a title="pandare.extras.file_faker.FakeFile.get_mode" href="#pandare.extras.file_faker.FakeFile.get_mode">get_mode</a></code></li>
<li><code><a title="pandare.extras.file_faker.FakeFile.get_size" href="#pandare.extras.file_faker.FakeFile.get_size">get_size</a></code></li>
<li><code><a title="pandare.extras.file_faker.FakeFile.read" href="#pandare.extras.file_faker.FakeFile.read">read</a></code></li>
<li><code><a title="pandare.extras.file_faker.FakeFile.write" href="#pandare.extras.file_faker.FakeFile.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.file_faker.FileFaker" href="#pandare.extras.file_faker.FileFaker">FileFaker</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.file_faker.FileFaker.close" href="#pandare.extras.file_faker.FileFaker.close">close</a></code></li>
<li><code><a title="pandare.extras.file_faker.FileFaker.replace_file" href="#pandare.extras.file_faker.FileFaker.replace_file">replace_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.file_faker.HyperFD" href="#pandare.extras.file_faker.HyperFD">HyperFD</a></code></h4>
<ul class="two-column">
<li><code><a title="pandare.extras.file_faker.HyperFD.close" href="#pandare.extras.file_faker.HyperFD.close">close</a></code></li>
<li><code><a title="pandare.extras.file_faker.HyperFD.get_mode" href="#pandare.extras.file_faker.HyperFD.get_mode">get_mode</a></code></li>
<li><code><a title="pandare.extras.file_faker.HyperFD.get_size" href="#pandare.extras.file_faker.HyperFD.get_size">get_size</a></code></li>
<li><code><a title="pandare.extras.file_faker.HyperFD.read" href="#pandare.extras.file_faker.HyperFD.read">read</a></code></li>
<li><code><a title="pandare.extras.file_faker.HyperFD.seek" href="#pandare.extras.file_faker.HyperFD.seek">seek</a></code></li>
<li><code><a title="pandare.extras.file_faker.HyperFD.write" href="#pandare.extras.file_faker.HyperFD.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>