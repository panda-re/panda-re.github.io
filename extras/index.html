<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pandare.extras API documentation</title>
<meta name="description" content="Extras are PyPANDA plugins which you can import into other python analyses. Typically
this is done by passing a handle from your script&#39;s PANDA object …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<!-- Bootstrap core CSS -->
<!--
<link href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css" rel="stylesheet">
-->
<!-- hand-crafted bootstrap navbar -->
<style>
.bg-light {
background-color: #f8f9fa!important;
}
.navbar {
position: relative;
display: -ms-flexbox;
display: flex;
-ms-flex-wrap: wrap;
flex-wrap: wrap;
-ms-flex-align: center;
align-items: center;
-ms-flex-pack: justify;
justify-content: space-between;
padding: .5rem 1rem;
}
.navbar-expand-lg {
-ms-flex-direction: row;
flex-direction: row;
-ms-flex-wrap: nowrap;
flex-wrap: nowrap;
-ms-flex-pack: start;
justify-content: flex-start;
}
navbar-light .navbar-brand {
color: rgba(0,0,0,.9);
}
.navbar-brand {
display: inline-block;
padding-top: .3125rem;
padding-bottom: .3125rem;
margin-right: 1rem;
font-size: 1.25rem;
line-height: inherit;
white-space: nowrap;
}
.navbar-nav {
display: -ms-flexbox;
display: flex;
-ms-flex-direction: column;
flex-direction: column;
padding-left: 0;
margin-bottom: 0;
list-style: none;
}
.navbar-expand-lg .navbar-nav {
-ms-flex-direction: row;
flex-direction: row;
}
.mr-auto {
margin-right: auto!important;
}
.navbar-expand-lg .navbar-collapse {
display: -ms-flexbox!important;
display: flex!important;
}
.navbar-collapse {
-ms-flex-preferred-size: 100%;
flex-basis: 100%;
-ms-flex-align: center;
align-items: center;
}
.navbar-light .navbar-brand {
color: rgba(0,0,0,.9);
}
.navbar a {
color: #007bff;
text-decoration: none;
background-color: transparent;
-webkit-text-decoration-skip: objects;
}
.navbar-expand-lg .navbar-nav .nav-link {
padding-right: .5rem;
padding-left: .5rem;
}
.navbar .navbar-nav {
margin: 0;
font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
font-size: 1rem;
font-weight: 400;
line-height: 1.5;
color: #212529;
}
.navbar-light .navbar-nav .active>.nav-link, .navbar-light .navbar-nav .nav-link.active, .navbar-light .navbar-nav .nav-link.show, .navbar-light .navbar-nav .show>.nav-link {
color: rgba(0,0,0,.9);
}
.navbar-light .navbar-nav .nav-link {
color: rgba(0,0,0,.5);
}
.nav-link {
display: block;
padding: .5rem 1rem;
}
</style>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-light">
<a class="navbar-brand" href="/">PANDA.re</a>
<div class="collapse navbar-collapse" id="navbarSupportedContent">
<ul class="navbar-nav mr-auto">
<li class="nav-item">
<a class="nav-link" href="//panda.re/">Home</a>
</li>
<li class="nav-item">
<a class="nav-link" target="_new" href="https://github.com/panda-re/panda">Github</a>
</li>
<li class="nav-item ">
<a class="nav-link" href="//panda.re/blog/">Blog</a>
</li>
<li class="nav-item ">
<a class="nav-link active" href="//docs.panda.re">Python Docs</a>
</li>
<li class="nav-item ">
<a class="nav-link" href="//panda.re/invite.php">Slack</a>
</li>
<!-- No resources tab here because we don't have real bootstrap -->
</div>
</nav>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pandare.extras</code></h1>
</header>
<section id="section-intro">
<p>Extras are PyPANDA plugins which you can import into other python analyses. Typically
this is done by passing a handle from your script's PANDA object to the plugin.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Extras are PyPANDA plugins which you can import into other python analyses. Typically
this is done by passing a handle from your script&#39;s PANDA object to the plugin.
&#34;&#34;&#34;

# Note file names should not contain underscores, let&#39;s keep these in lower
# camelCase going forward (e.g., modeFilter) so they match the class names.
from .fileFaker import FakeFile, FileFaker
from .fileHook import FileHook
from .ioctlFaker import IoctlFaker
from .modeFilter import ModeFilter
from .procWriteCapture import ProcWriteCapture
from .procTrace import ProcGraph


__all__ = [&#39;FakeFile&#39;, &#39;FileFaker&#39;, &#39;FileHook&#39;, &#39;IoctlFaker&#39;, &#39;ModeFilter&#39;, &#39;ProcWriteCapture&#39;,
           &#39;Snake&#39;, &#39;ProcGraph&#39;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pandare.extras.dwarfdump" href="dwarfdump.html">pandare.extras.dwarfdump</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pandare.extras.fileFaker" href="fileFaker.html">pandare.extras.fileFaker</a></code></dt>
<dd>
<div class="desc"><p>Framework for halucinating files inside the guest through
modifications around syscalls involving filenames and file
descriptors …</p></div>
</dd>
<dt><code class="name"><a title="pandare.extras.fileHook" href="fileHook.html">pandare.extras.fileHook</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pandare.extras.ioctlFaker" href="ioctlFaker.html">pandare.extras.ioctlFaker</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pandare.extras.modeFilter" href="modeFilter.html">pandare.extras.modeFilter</a></code></dt>
<dd>
<div class="desc"><p>Simple helper and example to selectively execute callbacks based on a mode string</p></div>
</dd>
<dt><code class="name"><a title="pandare.extras.procTrace" href="procTrace.html">pandare.extras.procTrace</a></code></dt>
<dd>
<div class="desc"><p>Create a graph of which processes run/ran over time …</p></div>
</dd>
<dt><code class="name"><a title="pandare.extras.procWriteCapture" href="procWriteCapture.html">pandare.extras.procWriteCapture</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pandare.extras.FakeFile"><code class="flex name class">
<span>class <span class="ident">FakeFile</span></span>
<span>(</span><span>fake_contents='', filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A fake file behind a hyperFD - this class will generate data when the
corresponding file descriptor(s) are accessed.
Users can inherit and modify this to customize how data is generated</p>
<p>Note: a single FileFaker might be opened and in use by multiple FDs in the guest</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FakeFile:
    &#39;&#39;&#39;
    A fake file behind a hyperFD - this class will generate data when the
    corresponding file descriptor(s) are accessed.
    Users can inherit and modify this to customize how data is generated

    Note: a single FileFaker might be opened and in use by multiple FDs in the guest

    &#39;&#39;&#39;
    def __init__(self, fake_contents=&#34;&#34;, filename=None):
        self.logger = logging.getLogger(&#39;panda.filehook.fakefile&#39;)

        if isinstance(fake_contents, str):
            fake_contents = fake_contents.encode(&#34;utf8&#34;)
        self.contents = fake_contents
        self.initial_contents = fake_contents
        self.refcount = 0 # Reference count
        self.filename = filename # Just for debug printing

    def read(self, size, offset):
        &#39;&#39;&#39;
        Generate data for a given read of size.  Returns data.
        &#39;&#39;&#39;

        if offset &gt;= len(self.contents):  # No bytes left to read
            return b&#34;&#34;
        # Otherwise there are bytes left to read
        read_data = self.contents[offset:offset+size]

        return read_data

    def write(self, offset, write_data):
        &#39;&#39;&#39;
        Update contents from offset. It&#39;s a bytearray so we can&#39;t just mutate
        Return how much HyperFD offset should be incremented by
        XXX what about writes past end of the file?
        &#39;&#39;&#39;
        new_data  = self.contents[:offset]
        new_data += write_data
        new_data += self.contents[offset+len(new_data):]
        
        self.logger.info(f&#34;FakeFD({self.filename}) writing {new_data} at offset {offset}&#34;)

        self.contents = new_data
        return len(write_data)

    def close(self):
        self.refcount -= 1
        if self.refcount == 0: # All FDs are now closed
            if self.initial_contents == self.contents:
                self.logger.debug(f&#34;All handles to Faker({self.filename}) closed. Unmodified contents&#34;)
            else: # it was mutated!
                self.logger.info(f&#34;All handles to Faker({self.filename}) closed. Modified contents: {repr(self.contents)}&#34;)

    def get_mode(self):
        return 0o664 # Regular file (octal)

    def get_size(self, bytesize):
        return ceil(len(self.contents)/bytesize)

    def __str__(self):
        return f&#34;Faker({self.filename} -&gt; {repr(self.contents[:10])}...&#34;


    def _delete(self):
        self.close()

    def __del__(self):
        # XXX: This destructor isn&#39;t called automatically
        self._delete()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.FakeFile.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    self.refcount -= 1
    if self.refcount == 0: # All FDs are now closed
        if self.initial_contents == self.contents:
            self.logger.debug(f&#34;All handles to Faker({self.filename}) closed. Unmodified contents&#34;)
        else: # it was mutated!
            self.logger.info(f&#34;All handles to Faker({self.filename}) closed. Modified contents: {repr(self.contents)}&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.extras.FakeFile.get_mode"><code class="name flex">
<span>def <span class="ident">get_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mode(self):
    return 0o664 # Regular file (octal)</code></pre>
</details>
</dd>
<dt id="pandare.extras.FakeFile.get_size"><code class="name flex">
<span>def <span class="ident">get_size</span></span>(<span>self, bytesize)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size(self, bytesize):
    return ceil(len(self.contents)/bytesize)</code></pre>
</details>
</dd>
<dt id="pandare.extras.FakeFile.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, size, offset)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate data for a given read of size.
Returns data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, size, offset):
    &#39;&#39;&#39;
    Generate data for a given read of size.  Returns data.
    &#39;&#39;&#39;

    if offset &gt;= len(self.contents):  # No bytes left to read
        return b&#34;&#34;
    # Otherwise there are bytes left to read
    read_data = self.contents[offset:offset+size]

    return read_data</code></pre>
</details>
</dd>
<dt id="pandare.extras.FakeFile.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, offset, write_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Update contents from offset. It's a bytearray so we can't just mutate
Return how much HyperFD offset should be incremented by
XXX what about writes past end of the file?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, offset, write_data):
    &#39;&#39;&#39;
    Update contents from offset. It&#39;s a bytearray so we can&#39;t just mutate
    Return how much HyperFD offset should be incremented by
    XXX what about writes past end of the file?
    &#39;&#39;&#39;
    new_data  = self.contents[:offset]
    new_data += write_data
    new_data += self.contents[offset+len(new_data):]
    
    self.logger.info(f&#34;FakeFD({self.filename}) writing {new_data} at offset {offset}&#34;)

    self.contents = new_data
    return len(write_data)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.FileFaker"><code class="flex name class">
<span>class <span class="ident">FileFaker</span></span>
<span>(</span><span>panda)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to halucinate fake files within the guest. When the guest attempts to access a faked file,
we transparenly redirect the access to another file on disk and grab the FD generated using FileHook.</p>
<p>When the guest attempts to use a FD related to a faked file, we mutate the request. Reads are created
from fake conents and writes are logged.</p>
<p>Initialize FileHook and vars. Setup callbacks for all fd-based syscalls</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileFaker(FileHook):
    &#39;&#39;&#39;
    Class to halucinate fake files within the guest. When the guest attempts to access a faked file,
    we transparenly redirect the access to another file on disk and grab the FD generated using FileHook.

    When the guest attempts to use a FD related to a faked file, we mutate the request. Reads are created
    from fake conents and writes are logged.
    &#39;&#39;&#39;

    def __init__(self, panda):
        &#39;&#39;&#39;
        Initialize FileHook and vars. Setup callbacks for all fd-based syscalls
        &#39;&#39;&#39;
        super().__init__(panda)
        self.ff_logger = logging.getLogger(&#39;panda.filehook.fakefile&#39;)

        self.faked_files = {} # filename: Fake
        self.hooked_fds = {} # (fd, cr3): HyperFD-&gt;faker
        self.pending_hfd = None

        to_hook = {} # index of fd argument: list of names
        if panda.arch_name == &#34;i386&#34;:
            # grep &#39;int fd&#39; syscall_switch_enter_linux_x86.cpp  | grep &#34;\[&#39;int fd\|\[&#39;unsigned int fd&#34; | grep -o sys_[a-zA-Z0-9_]* | sed -n -e &#39;s/sys_\(.*\)/&#34;\1&#34; /p&#39; | paste -sd &#34;,&#34; -
            # Note the grep commands missed dup2 and dup3 which take oldfd as 1st arg
            to_hook[0] = [&#34;read&#34;, &#34;write&#34;, &#34;close&#34;, &#34;lseek&#34;, &#34;fstat&#34;, &#34;ioctl&#34;, &#34;fcntl&#34;, &#34;ftruncate&#34;, &#34;fchmod&#34;,
                          &#34;fchown16&#34;, &#34;fstatfs&#34;, &#34;newfstat&#34;, &#34;fsync&#34;, &#34;fchdir&#34;, &#34;llseek&#34;, &#34;getdents&#34;, &#34;flock&#34;,
                          &#34;fdatasync&#34;, &#34;pread64&#34;, &#34;pwrite64&#34;, &#34;ftruncate64&#34;, &#34;fchown&#34;, &#34;getdents64&#34;, &#34;fcntl64&#34;,
                          &#34;readahead&#34;, &#34;fsetxattr&#34;, &#34;fgetxattr&#34;, &#34;flistxattr&#34;, &#34;fremovexattr&#34;, &#34;fadvise64&#34;,
                          &#34;fstatfs64&#34;, &#34;fadvise64_64&#34;, &#34;inotify_add_watch&#34;, &#34;inotify_rm_watch&#34;, &#34;splice&#34;,
                          &#34;sync_file_range&#34;, &#34;tee&#34;, &#34;vmsplice&#34;, &#34;fallocate&#34;, &#34;recvmmsg&#34;, &#34;syncfs&#34;, &#34;sendmmsg&#34;,
                          &#34;setns&#34;, &#34;finit_module&#34;, &#34;getsockopt&#34;, &#34;setsockopt&#34;, &#34;sendmsg&#34;, &#34;recvmsg&#34;, &#34;dup2&#34;,
                          &#34;dup3&#34; ]

            # grep &#39;int fd&#39; syscall_switch_enter_linux_x86.cpp  | grep -v &#34;\[&#39;int fd\|\[&#39;unsigned int fd&#34; # + manual
            to_hook[2] = [&#34;epoll_ctl&#34;]
            to_hook[3] = [&#34;fanotify_mark&#34;]

        elif panda.arch_name == &#34;x86_64&#34;:
            to_hook[0] = [&#34;read&#34;, &#34;write&#34;, &#34;close&#34;, &#34;newfstat&#34;, &#34;lseek&#34;, &#34;ioctl&#34;, &#34;pread64&#34;, &#34;pwrite64&#34;, &#34;sendmsg&#34;,
                          &#34;recvmsg&#34;, &#34;setsockopt&#34;, &#34;getsockopt&#34;, &#34;fcntl&#34;, &#34;flock&#34;, &#34;fsync&#34;, &#34;fdatasync&#34;, &#34;ftruncate&#34;,
                          &#34;getdents&#34;, &#34;fchdir&#34;, &#34;fchmod&#34;, &#34;fchown&#34;, &#34;fstatfs&#34;, &#34;readahead&#34;, &#34;fsetxattr&#34;, &#34;fgetxattr&#34;,
                          &#34;flistxattr&#34;, &#34;fremovexattr&#34;, &#34;getdents64&#34;, &#34;fadvise64&#34;, &#34;inotify_add_watch&#34;,
                          &#34;inotify_rm_watch&#34;, &#34;splice&#34;, &#34;tee&#34;, &#34;sync_file_range&#34;, &#34;vmsplice&#34;, &#34;fallocate&#34;, &#34;recvmmsg&#34;,
                          &#34;syncfs&#34;, &#34;sendmmsg&#34;, &#34;setns&#34;, &#34;finit_module&#34;, &#34;copy_file_range&#34;, &#34;dup2&#34;, &#34;dup3&#34;]
            to_hook[2] = [&#34;epoll_ctl&#34;]
            to_hook[3] = [&#34;fanotify_mark&#34;]

        elif panda.arch_name == &#34;arm&#34;:
            to_hook[0] = [&#34;read&#34;, &#34;write&#34;, &#34;close&#34;, &#34;lseek&#34;, &#34;ioctl&#34;, &#34;fcntl&#34;, &#34;ftruncate&#34;, &#34;fchmod&#34;, &#34;fchown16&#34;,
                          &#34;fstatfs&#34;, &#34;newfstat&#34;, &#34;fsync&#34;, &#34;fchdir&#34;, &#34;llseek&#34;, &#34;getdents&#34;, &#34;flock&#34;, &#34;fdatasync&#34;,
                          &#34;pread64&#34;, &#34;pwrite64&#34;, &#34;ftruncate64&#34;, &#34;fchown&#34;, &#34;getdents64&#34;, &#34;fcntl64&#34;, &#34;readahead&#34;,
                          &#34;fsetxattr&#34;, &#34;fgetxattr&#34;, &#34;flistxattr&#34;, &#34;fremovexattr&#34;, &#34;fstatfs64&#34;, &#34;arm_fadvise64_64&#34;,
                          &#34;setsockopt&#34;, &#34;getsockopt&#34;, &#34;sendmsg&#34;, &#34;recvmsg&#34;, &#34;inotify_add_watch&#34;, &#34;inotify_rm_watch&#34;,
                          &#34;splice&#34;, &#34;sync_file_range2&#34;, &#34;tee&#34;, &#34;vmsplice&#34;, &#34;fallocate&#34;, &#34;recvmmsg&#34;, &#34;syncfs&#34;,
                          &#34;sendmmsg&#34;, &#34;setns&#34;, &#34;finit_module&#34;, &#34;dup2&#34;, &#34;dup3&#34;]
            to_hook[2] = [&#34;epoll_ctl&#34;]
            to_hook[3] = [&#34;fanotify_mark&#34;]
        else:
            raise ValueError(f&#34;Unsupported PANDA arch: {panda.arch_name}&#34;)

        for arg_offset, names in to_hook.items():
            for name in names:
                self._gen_fd_cb(name, arg_offset)

    def replace_file(self, filename, faker, disk_file=&#34;/etc/passwd&#34;):
        &#39;&#39;&#39;
        Replace all accesses to filename with accesses to the fake file instead
        which optionally may be specified by disk_file.
        &#39;&#39;&#39;
        self.faked_files[filename] = faker

        # XXX: We rename the files to real files to the guest kernel can manage FDs for us.
        #      this may need to use different real files depending on permissions requested
        self.rename_file(filename, disk_file)

    def _gen_fd_cb(self, name, fd_offset):
        &#39;&#39;&#39;
        Register syscalls2 PPP callback on enter and return for the given name
        which has an argument of fd at fd_offset in the argument list
        &#39;&#39;&#39;
        self._panda.ppp(&#34;syscalls2&#34;, f&#34;on_sys_{name}_return&#34;, name=f&#34;file_faker_return_{name}&#34;)( \
                    lambda *args: self._return_fd_cb(name, fd_offset, args=args))

    def _return_fd_cb(self, syscall_name, fd_pos, args=None):
        &#39;&#39;&#39;
        When we&#39;re returnuing from a syscall, mutate memory
        to put the results we want there
        &#39;&#39;&#39;

        (cpu, pc) = args[0:2]
        fd = args[2+fd_pos]
        asid = self._panda.current_asid(cpu)

        if (fd, asid) not in self.hooked_fds:
            return

        assert(args)
        hfd = self.hooked_fds[(fd, asid)]

        if syscall_name == &#34;read&#34;:
            # Place up to `count` bytes of data into memory at `buf_ptr`
            buf_ptr = args[3]
            count   = args[4]

            (data, data_len) = hfd.read(count)
            if data:
                try:
                    self._panda.virtual_memory_write(cpu, buf_ptr, data)
                except ValueError:
                    self.ff_logger.error(f&#34;Unable to store fake data after read to {hfd}&#34;)
                    return

            cpu.env_ptr.regs[0] = data_len

            self.ff_logger.info(f&#34;Read - returning {data_len} bytes&#34;)

        elif syscall_name == &#34;close&#34;:
            # We want the guest to close the real FD. Delete it from our map of hooked fds
            hfd.close()
            if (fd, asid) in self.hooked_fds:
                del self.hooked_fds[(fd, asid)]

        elif syscall_name == &#34;write&#34;:
            # read count bytes from buf, add to our hyper-fd
            buf_ptr = args[3]
            count   = args[4]
            try:
                data = self._panda.virtual_memory_read(cpu, buf_ptr, count)
            except ValueError:
                self.ff_logger.error(f&#34;Unable to read buffer that was being written&#34;)
                return

            bytes_written = hfd.write(data)
            cpu.env_ptr.regs[0] = bytes_written

        elif syscall_name == &#34;lseek&#34;: # LLSEEK?
            offset = args[2]
            whence = args[3]
            hfd.seek(offset, whence)


        elif syscall_name in [&#34;dup2&#34;, &#34;dup3&#34;]:
            # add newfd
            oldfd = args[2]
            newfd = args[3]
            self.ff_logger.debug(f&#34;Duplicating faked fd {oldfd} to {newfd}&#34;)

            # Duplicate the old hfd - but not the file behind it
            new_hfd = HyperFD(hfd.name, hfd.file, hfd.offset)
            self.hooked_fds[(newfd, asid)] = new_hfd

        else:
            self.ff_logger.error(f&#34;Unsupported syscall on FakeFD{fd}: {syscall_name}. Not intercepting (Running on real guest FD)&#34;)


    def _before_modified_enter(self, cpu, pc, syscall_name, fname):
        &#39;&#39;&#39;
        Overload FileHook function. Determine if a syscall we&#39;re about to
        enter is using a filename we want to fake

        After the modified syscall returns, we grab the real FD and map it to the HFD
        &#39;&#39;&#39;
        if fname in self.faked_files:
            self.pending_hfd =  HyperFD(fname, self.faked_files[fname]) # Create HFD
            asid = self._panda.current_asid(cpu)

    def _after_modified_return(self, cpu, pc, syscall_name, fd):
        &#39;&#39;&#39;
        Overload FileHook function. Determine if a syscall we&#39;re about to
        return from was using a filename we want to fake. If so, grab the FD
        &#39;&#39;&#39;
        if self.pending_hfd:
            asid = self._panda.current_asid(cpu)
            self.hooked_fds[(fd, asid)] =  self.pending_hfd
            self.logger.info(f&#34;A file we want to hook was created {self.pending_hfd}&#34;)
            self.pending_hfd = None

    def close(self):
        # Close all open hfds
        if len(self.hooked_fds):
            self.ff_logger.debug(&#34;Cleaning up open hyper file descriptors&#34;)
            for (fd, asid) in list(self.hooked_fds.keys()):
                self.hooked_fds[(fd, asid)].close()
                del self.hooked_fds[(fd, asid)]


    def __del__(self):
        # XXX: This isn&#39;t being called for some reason on destruction
        self.close()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.extras.fileHook.FileHook" href="fileHook.html#pandare.extras.fileHook.FileHook">FileHook</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.FileFaker.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    # Close all open hfds
    if len(self.hooked_fds):
        self.ff_logger.debug(&#34;Cleaning up open hyper file descriptors&#34;)
        for (fd, asid) in list(self.hooked_fds.keys()):
            self.hooked_fds[(fd, asid)].close()
            del self.hooked_fds[(fd, asid)]</code></pre>
</details>
</dd>
<dt id="pandare.extras.FileFaker.replace_file"><code class="name flex">
<span>def <span class="ident">replace_file</span></span>(<span>self, filename, faker, disk_file='/etc/passwd')</span>
</code></dt>
<dd>
<div class="desc"><p>Replace all accesses to filename with accesses to the fake file instead
which optionally may be specified by disk_file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_file(self, filename, faker, disk_file=&#34;/etc/passwd&#34;):
    &#39;&#39;&#39;
    Replace all accesses to filename with accesses to the fake file instead
    which optionally may be specified by disk_file.
    &#39;&#39;&#39;
    self.faked_files[filename] = faker

    # XXX: We rename the files to real files to the guest kernel can manage FDs for us.
    #      this may need to use different real files depending on permissions requested
    self.rename_file(filename, disk_file)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pandare.extras.fileHook.FileHook" href="fileHook.html#pandare.extras.fileHook.FileHook">FileHook</a></b></code>:
<ul class="hlist">
<li><code><a title="pandare.extras.fileHook.FileHook.rename_file" href="fileHook.html#pandare.extras.fileHook.FileHook.rename_file">rename_file</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pandare.extras.FileHook"><code class="flex name class">
<span>class <span class="ident">FileHook</span></span>
<span>(</span><span>panda, use_osi=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to modify guest memory just before syscalls with filename arguments.
As the system call is about to be executed, change the data pointed to by the
filename pointer. When the syscall returns, restore the mutated data to its
original values.</p>
<p>This provides a simple, cross-platform interface to redirect file accesses
just using the OSI plugin.</p>
<p>usage:
panda = Panda(&hellip;)
hook = FileHook(panda)
hook.rename_file("/rename_this", "/to_this")</p>
<p>Store a reference to the panda object, and register
the appropriate syscalls2 callbacks for entering and exiting
from all syscalls that have a char* filename argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileHook:
    &#39;&#39;&#39;
    Class to modify guest memory just before syscalls with filename arguments.
    As the system call is about to be executed, change the data pointed to by the
    filename pointer. When the syscall returns, restore the mutated data to its
    original values.

    This provides a simple, cross-platform interface to redirect file accesses
    just using the OSI plugin.

    usage:
        panda = Panda(...)
        hook = FileHook(panda)
        hook.rename_file(&#34;/rename_this&#34;, &#34;/to_this&#34;)
    &#39;&#39;&#39;

    def __init__(self, panda, use_osi=True):
        &#39;&#39;&#39;
        Store a reference to the panda object, and register
        the appropriate syscalls2 callbacks for entering and exiting
        from all syscalls that have a char* filename argument.
        &#39;&#39;&#39;

        self._panda = panda
        self._renamed_files = {} # old_fname (str): new_fname (bytes)
        self._changed_strs = {} # callback_name: original_data
        self.use_osi = use_osi

        self.logger = logging.getLogger(&#39;panda.filehook&#39;)
        try:
            import coloredlogs
            coloredlogs.install(level=&#39;WARN&#39;)
        except ImportError:
            pass
        self.pending_virt_read = None

        panda.load_plugin(&#34;syscalls2&#34;)

        # For each architecture, we have a different set of syscalls. They all
        # either call our functions with (cpu, pc, filename_ptr, ...)
        # or (cpu, pc, something_else, filename_ptr, ...). Here we
        # Programmatically generate callbacks for all of them

        # These lists were made with commands like the following in syscalls2/generated:
        # grep filename syscall_switch_enter_linux_x86.cpp | grep &#34;\[&#39;const char &#34; | grep -o sys_[a-zA-Z0-9]* | grep -o [a-z0-9]*$
        # grep filename syscall_switch_enter_linux_x86.cpp | grep -v &#34;\[&#39;const char &#34; | grep -o sys_[a-zA-Z0-9]* | grep -o [a-z0-9]*$
        to_hook = {}
        if panda.arch_name == &#34;i386&#34;:
            to_hook[0] = [&#34;open&#34;, &#34;execve&#34;, &#34;chdir&#34;, &#34;mknod&#34;, &#34;chmod&#34;, &#34;lchown16&#34;, &#34;stat&#34;, &#34;access&#34;, &#34;chroot&#34;,
                         &#34;lstat&#34;, &#34;newstat&#34;, &#34;newlstat&#34;, &#34;chown16&#34;, &#34;stat64&#34;, &#34;lstat64&#34;, &#34;lchown&#34;, &#34;chown&#34; ]
            to_hook[1] = [&#34;utime&#34;, &#34;utimes&#34;, &#34;openat&#34;, &#34;mknodat&#34;, &#34;fchownat&#34;, &#34;futimesat&#34;, &#34;fstatat64&#34;,
                          &#34;fchmodat&#34;, &#34;faccessat&#34;, &#34;utimensat&#34;, &#34;execveat&#34;]

        elif panda.arch_name == &#34;x86_64&#34;:
            to_hook[0] = [&#34;open&#34;, &#34;newstat&#34;, &#34;newlstat&#34;, &#34;access&#34;, &#34;chdir&#34;, &#34;chmod&#34;, &#34;chown&#34;, &#34;lchown&#34;, &#34;mknod&#34;, &#34;chroot&#34;]
            to_hook[1] = [&#34;utime&#34;, &#34;utimes&#34;, &#34;openat&#34;, &#34;mknodat&#34;, &#34;fchownat&#34;, &#34;futimesat&#34;, &#34;newfstatat&#34;, &#34;fchmodat&#34;, &#34;faccessat&#34;, &#34;utimensat&#34;]

        elif panda.arch_name == &#34;arm&#34;:
            to_hook[0] = [&#34;open&#34;, &#34;execve&#34;, &#34;chdir&#34;, &#34;mknod&#34;, &#34;chmod&#34;, &#34;lchown16&#34;, &#34;access&#34;, &#34;chroot&#34;, &#34;newstat&#34;, &#34;newlstat&#34;, &#34;chown16&#34;, &#34;stat64&#34;, &#34;lstat64&#34;, &#34;lchown&#34;, &#34;chown&#34;]
            to_hook[1] = [&#34;utime&#34;, &#34;utimes&#34;, &#34;openat&#34;, &#34;mknodat&#34;, &#34;fchownat&#34;, &#34;futimesat&#34;, &#34;fstatat64&#34;, &#34;fchmodat&#34;, &#34;faccessat&#34;, &#34;utimensat&#34;, &#34;execveat&#34;]
        else:
            raise ValueError(f&#34;Unsupported PANDA arch: {panda.arch_name}&#34;)

        # Register the callbacks
        for arg_offset, names in to_hook.items():
            for name in names:
                self._gen_cb(name, arg_offset)


        # Fallback callback used when syscall with file name isn&#39;t mapped into memory
        @self._panda.cb_virt_mem_before_read(enabled=False)
        def before_virt_read(cpu, pc, addr, size):
            &#39;&#39;&#39;
            This callback is necessary for the case when we enter a syscall but the filename pointer is paged out.
            When that happens, we enable this (slow) callback which checks every mem-read while we&#39;re in that syscall
            to see if the memory has since been paged-in. It should always eventually be paged in. Once it is,
            we mutate the memory and then disable this callback.

            If this hasn&#39;t run by the time the callback returns, we give up and disable it
            &#39;&#39;&#39;
            if not self.pending_virt_read:
                return

            # Is our pending read a subset of the current read? If so try to read it
            if addr &lt;= self.pending_virt_read and addr+size &gt; self.pending_virt_read:
                try:
                    fname = self._panda.read_str(cpu, self.pending_virt_read)
                except ValueError:
                    return # Still not available. Keep waiting
                self.logger.debug(f&#34;recovered missed filename: {fname}&#34;)

                # It is available! Disable this slow callback and rerurn _enter_cb with the data
                fname_ptr = self.pending_virt_read
                self.pending_virt_read = None
                self._panda.disable_callback(&#39;before_virt_read&#39;)
                self._enter_cb(self.pending_syscall, args=(cpu, pc), fname_ptr=fname_ptr)


    def rename_file(self, old_name, new_name):
        &#39;&#39;&#39;
        Mutate a given filename into a new name at the syscall interface
        &#39;&#39;&#39;
        assert(old_name not in self._renamed_files), f&#34;Already have a rename rule for {old_name}&#34;

        if not isinstance(new_name, bytes):
            new_name = new_name.encode(&#34;utf8&#34;)

        if not new_name.endswith(b&#34;\x00&#34;):
            new_name += b&#34;\x00&#34;

        self._renamed_files[old_name] = new_name

    def _get_fname(self, cpu, fd):
        &#39;&#39;&#39;
        Use OSI to get the filename behind a file descriptor.
        If not self.use_osi, return None
        &#39;&#39;&#39;
        if not self.use_osi:
            return None
        fname_s = None
        proc = self._panda.plugins[&#39;osi&#39;].get_current_process(cpu)
        if proc != self._panda.ffi.NULL:
            fname = self._panda.plugins[&#39;osi_linux&#39;].osi_linux_fd_to_filename(cpu, proc, self._panda.ffi.cast(&#34;int&#34;, fd))
            if fname != self._panda.ffi.NULL:
                fname_s = self._panda.ffi.string(fname).decode(&#39;utf8&#39;, &#39;ignore&#39;)
        return fname_s

    def _gen_cb(self, name, fname_ptr_pos):
        &#39;&#39;&#39;
        Register syscalls2 PPP callback on enter and return for the given name
        which has an argument of char* filename at fname_ptr_pos in the arguments list
        &#39;&#39;&#39;
        self._panda.ppp(&#34;syscalls2&#34;, f&#34;on_sys_{name}_enter&#34;, name = f&#34;file_hook_enter_{name}&#34;)( \
                    lambda *args: self._enter_cb(name, fname_ptr_pos, args=args))
        self._panda.ppp(&#34;syscalls2&#34;, f&#34;on_sys_{name}_return&#34;, name = f&#34;file_hook_return_{name}&#34;)( \
                    lambda *args: self._return_cb(name, fname_ptr_pos, args=args))

    def _enter_cb(self, syscall_name, fname_ptr_pos=0, args=None, fname_ptr=None):
        &#39;&#39;&#39;
        When we return, check if we mutated the fname buffer. If so,
        we need to restore whatever data was there (we may have written
        past the end of the string).

        if fname_ptr is set, just skip the logic to extract it
        &#39;&#39;&#39;

        assert(args)
        (cpu, pc) = args[0:2]

        if not fname_ptr:
            fname_ptr = args[2+fname_ptr_pos] # offset to after (cpu, pc) in callback args

        try:
            fname = self._panda.read_str(cpu, fname_ptr)
        except:
            fname = self._get_fname(cpu, args[2+fname_ptr_pos])

            if fname:
                self.logger.info(f&#34;OSI found fname after simple logic missed it in call to {syscall_name}&#34;)
            else:
                self.logger.debug(f&#34;missed filename at 0x{fname_ptr:x} in call to {syscall_name} - trying to find&#34;)
                self.pending_virt_read = cpu.env_ptr.regs[0]
                self.pending_syscall = syscall_name
                self._panda.enable_callback(&#39;before_virt_read&#39;)
                #self._panda_enable_memcb()
                return

        fname = path.normpath(fname) # Normalize it
        #self.logger.info(f&#34;Entering {syscall_name} with file={fname}&#34;)

        if fname in self._renamed_files:
            # It matches, now let&#39;s take our action! Either rename or callback

            self.logger.debug(f&#34;modifying filename {fname} in {syscall_name} to {self._renamed_files[fname]}&#34;)
            assert(syscall_name not in self._changed_strs), &#34;Entering syscall that already has a pending restore&#34;

            # First read a buffer of the same size as our new value. XXX the string we already read might be shorter
            # than what we&#39;re inserting so we read again so we can later restore the old data
            try:
                clobbered_data = self._panda.virtual_memory_read(cpu, fname_ptr, len(self._renamed_files[fname]))
            except ValueError:
                self.logger.error(f&#34;Failed to read target buffer at call into {syscall_name}&#34;)
                return

            # Now replace those bytes with our new name
            try:
                self._panda.virtual_memory_write(cpu, fname_ptr, self._renamed_files[fname])
            except ValueError:
                self.logger.warn(f&#34;Failed to mutate filename buffer at call into {syscall_name}&#34;)
                return

            # If it all worked, save the clobbered data
            asid = self._panda.current_asid(cpu)
            self._changed_strs[(syscall_name, asid)] = clobbered_data

            self._before_modified_enter(cpu, pc, syscall_name, fname)


    def _return_cb(self, syscall_name, fname_ptr_pos, args=None):
        &#39;&#39;&#39;
        When we return, check if we mutated the fname buffer. If so,
        we need to restore whatever data was there (we may have written
        past the end of the string)
        &#39;&#39;&#39;
        (cpu, pc) = args[0:2]
        if self.pending_virt_read:
            fname_ptr = args[2+fname_ptr_pos] # offset to after (cpu, pc) in callback args

            self.logger.warning(f&#34;missed filename in call to {syscall_name} with fname at 0x{fname_ptr:x}. Ignoring it&#34;)

            self._panda.disable_callback(&#39;before_virt_read&#39;) # No point in continuing this
            self.pending_virt_read = None # Virtual address that we&#39;re waiting to read as soon as possible
            return

        asid = self._panda.current_asid(cpu)
        if (syscall_name, asid) in self._changed_strs:
            assert(args)
            fname_ptr = args[2+fname_ptr_pos] # offset to after (cpu, pc) in callback args
            try:
                self._panda.virtual_memory_write(cpu, fname_ptr, self._changed_strs[(syscall_name, asid)])
            except ValueError:
                self.logger.warn(f&#34;Failed to fix filename buffer at return of {syscall_name}&#34;)
            del self._changed_strs[(syscall_name, asid)]

            fd = self._panda.arch.get_retval(cpu, convention=&#39;syscall&#39;)
            self.logger.info(f&#34;Returning from {syscall_name} after modifying argument - modified FD is {fd}&#34;)
            self._after_modified_return(cpu, pc, syscall_name, fd=fd)

    def _before_modified_enter(self, cpu, pc, syscall_name, fname):
        &#39;&#39;&#39;
        Internal callback run before we enter a syscall where we mutated
        the filename. Exists to be overloaded by subclasses
        &#39;&#39;&#39;
        pass

    def _after_modified_return(self, cpu, pc, syscall_name, fd):
        &#39;&#39;&#39;
        Internal callback run before we return from a syscall where we mutated
        the filename. Exists to be overloaded by subclasses
        &#39;&#39;&#39;
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pandare.extras.fileFaker.FileFaker" href="fileFaker.html#pandare.extras.fileFaker.FileFaker">FileFaker</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.FileHook.rename_file"><code class="name flex">
<span>def <span class="ident">rename_file</span></span>(<span>self, old_name, new_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Mutate a given filename into a new name at the syscall interface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_file(self, old_name, new_name):
    &#39;&#39;&#39;
    Mutate a given filename into a new name at the syscall interface
    &#39;&#39;&#39;
    assert(old_name not in self._renamed_files), f&#34;Already have a rename rule for {old_name}&#34;

    if not isinstance(new_name, bytes):
        new_name = new_name.encode(&#34;utf8&#34;)

    if not new_name.endswith(b&#34;\x00&#34;):
        new_name += b&#34;\x00&#34;

    self._renamed_files[old_name] = new_name</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.IoctlFaker"><code class="flex name class">
<span>class <span class="ident">IoctlFaker</span></span>
<span>(</span><span>panda, use_osi_linux=False, log=False, ignore=[], intercept_ret_vals=[-25], intercept_all_non_zero=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpose ioctl() syscall returns, forcing successes for specific error codes to simulate missing drivers/peripherals.
Bin all returns into failures (needed forcing) and successes, store for later retrival/analysis.</p>
<p>Log enables/disables logging.
ignore contains a list of tuples (filename, cmd#) to be ignored.
intercept_ret_vals is a list of ioctl return values that should be intercepted. By default
we just intercept just -25 which indicates that a driver is not present to handle the ioctl.
intercept_all_non_zero is aggressive setting that takes precedence if set - any non-zero return code id changed to zero.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IoctlFaker():

    &#39;&#39;&#39;
    Interpose ioctl() syscall returns, forcing successes for specific error codes to simulate missing drivers/peripherals.
    Bin all returns into failures (needed forcing) and successes, store for later retrival/analysis.
    &#39;&#39;&#39;

    def __init__(
            self,
            panda,
            use_osi_linux = False,
            log = False,
            ignore = [],
            intercept_ret_vals = [-25],
            intercept_all_non_zero = False
        ):

        &#39;&#39;&#39;
        Log enables/disables logging.
        ignore contains a list of tuples (filename, cmd#) to be ignored.
        intercept_ret_vals is a list of ioctl return values that should be intercepted. By default
          we just intercept just -25 which indicates that a driver is not present to handle the ioctl.
        intercept_all_non_zero is aggressive setting that takes precedence if set - any non-zero return code id changed to zero.
        &#39;&#39;&#39;

        self.osi = use_osi_linux
        self._panda = panda
        self._panda.load_plugin(&#34;syscalls2&#34;)
        self._log = log
        self.ignore = ignore
        self.intercept_ret_vals = intercept_ret_vals
        self.intercept_all_non_zero = intercept_all_non_zero

        if self.osi:
            self._panda.load_plugin(&#34;osi&#34;)
            self._panda.load_plugin(&#34;osi_linux&#34;)

        if self._log:
            self._logger = logging.getLogger(&#39;panda.ioctls&#39;)
            self._logger.setLevel(logging.DEBUG)

        # Track ioctls in two sets: modified (forced_returns) and unmodified
        self._forced_returns = set()
        self._unmodified_returns = set()

        # Force success returns for missing drivers/peripherals
        @self._panda.ppp(&#34;syscalls2&#34;, &#34;on_sys_ioctl_return&#34;)
        def ioctl_faker_on_sys_ioctl_return(cpu, pc, fd, cmd, arg):

            ioctl = Ioctl(self._panda, cpu, fd, cmd, arg, self.osi)
            ioctl.get_ret_code(self._panda, cpu)

            # Modify
            if (self.intercept_all_non_zero and ioctl.original_ret_code != 0) or \
                ioctl.original_ret_code in self.intercept_ret_vals and \
                        (ioctl.file_name, ioctl.cmd.bits.cmd_num) not in self.ignore: # Allow ignoring specific commands on specific files

                if panda.arch_name == &#34;mipsel&#34; or panda.arch_name == &#34;mips&#34;:
                    cpu.env_ptr.active_tc.gpr[2] = 0
                elif panda.arch_name == &#34;aarch64&#34;:
                    cpu.env_ptr.xregs[0] = 0
                elif panda.arch_name == &#34;ppc&#34;:
                    raise RuntimeError(&#34;PPC currently unsupported!&#34;)
                else: # x86/x64/ARM
                    cpu.env_ptr.regs[0] = 0

                self._forced_returns.add(ioctl)

                if ioctl.has_buf and self._log:
                    self._logger.warning(&#34;Forcing success return for data-containing {}&#34;.format(ioctl))
                elif self._log:
                    self._logger.info(&#34;Forcing success return for data-less {}&#34;.format(ioctl))

            # Don&#39;t modify
            else:
                self._unmodified_returns.add(ioctl)

    def _get_returns(self, source, with_buf_only):

        if with_buf_only:
            return list(filter(lambda i: (i.has_buf == True), source))
        else:
            return source

    def get_forced_returns(self, with_buf_only = False):

        &#39;&#39;&#39;
        Retrieve ioctls whose error codes where overwritten
        &#39;&#39;&#39;

        return self._get_returns(self._forced_returns, with_buf_only)

    def get_unmodified_returns(self, with_buf_only = False):

        &#39;&#39;&#39;
        Retrieve ioctl that completed normally
        &#39;&#39;&#39;

        return self._get_returns(self._unmodified_returns, with_buf_only)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.IoctlFaker.get_forced_returns"><code class="name flex">
<span>def <span class="ident">get_forced_returns</span></span>(<span>self, with_buf_only=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve ioctls whose error codes where overwritten</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_forced_returns(self, with_buf_only = False):

    &#39;&#39;&#39;
    Retrieve ioctls whose error codes where overwritten
    &#39;&#39;&#39;

    return self._get_returns(self._forced_returns, with_buf_only)</code></pre>
</details>
</dd>
<dt id="pandare.extras.IoctlFaker.get_unmodified_returns"><code class="name flex">
<span>def <span class="ident">get_unmodified_returns</span></span>(<span>self, with_buf_only=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve ioctl that completed normally</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_unmodified_returns(self, with_buf_only = False):

    &#39;&#39;&#39;
    Retrieve ioctl that completed normally
    &#39;&#39;&#39;

    return self._get_returns(self._unmodified_returns, with_buf_only)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.ModeFilter"><code class="flex name class">
<span>class <span class="ident">ModeFilter</span></span>
</code></dt>
<dd>
<div class="desc"><p>Simple, inheritable class to provide a decorator to enable/disable callbacks
depending on self.mode value.</p>
<p>It is ill-advised to use on callbacks with high-performance impacts such as
before_block_exec as this is a pure-Python plugin.</p>
<h2 id="example">Example</h2>
<p>from pandare import Panda
from pandare.extras import ModeFilter</p>
<p>class MyClass(ModeFilter):
def <strong>init</strong>(self, panda)
self.panda = panda
self.set_mode("mode1")</p>
<pre><code>    @self.mode_filter("mode1")
    @self.panda.ppp("syscalls2", "on_sys_open_enter")
    def on_open(cpu, pc, fname_ptr, flags, mode):
        # assert(self.mode == "mode1") # Note decorator ensures this
        self.set_mode("mode2") # Change mode - so this callback won't run again
...
def run(self):
    self.panda.run()
</code></pre>
<p>p = panda(&hellip;)
mc = MyClass(panda)
mc.run()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModeFilter:
    &#39;&#39;&#39;
    Simple, inheritable class to provide a decorator to enable/disable callbacks
    depending on self.mode value.

    It is ill-advised to use on callbacks with high-performance impacts such as
    before_block_exec as this is a pure-Python plugin.

    Example:
        from pandare import Panda
        from pandare.extras import ModeFilter

        class MyClass(ModeFilter):
            def __init__(self, panda)
                self.panda = panda
                self.set_mode(&#34;mode1&#34;)

                @self.mode_filter(&#34;mode1&#34;)
                @self.panda.ppp(&#34;syscalls2&#34;, &#34;on_sys_open_enter&#34;)
                def on_open(cpu, pc, fname_ptr, flags, mode):
                    # assert(self.mode == &#34;mode1&#34;) # Note decorator ensures this
                    self.set_mode(&#34;mode2&#34;) # Change mode - so this callback won&#39;t run again
            ...
            def run(self):
                self.panda.run()

        p = panda(...)
        mc = MyClass(panda)
        mc.run()
    &#39;&#39;&#39;
    mode = &#34;start&#34;

    def mode_filter(self, mode_filter):
        &#39;&#39;&#39;
        Decorator to only run a function if self.mode matches the provided string
        &#39;&#39;&#39;
        def __mode_filter(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                if self.mode == mode_filter:
                    # Mode matches - run it!
                    func(*args, **kwargs)
            return wrapper
        return __mode_filter

    def set_mode(self, new):
        &#39;&#39;&#39;
        Helper to change mode
        &#39;&#39;&#39;
        if new != self.mode:
            print(f&#34;Switching modes from {self.mode} to {new}&#34;)
        self.mode = new</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pandare.extras.modeFilter.Tester" href="modeFilter.html#pandare.extras.modeFilter.Tester">Tester</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pandare.extras.ModeFilter.mode"><code class="name">var <span class="ident">mode</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.ModeFilter.mode_filter"><code class="name flex">
<span>def <span class="ident">mode_filter</span></span>(<span>self, mode_filter)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to only run a function if self.mode matches the provided string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mode_filter(self, mode_filter):
    &#39;&#39;&#39;
    Decorator to only run a function if self.mode matches the provided string
    &#39;&#39;&#39;
    def __mode_filter(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            if self.mode == mode_filter:
                # Mode matches - run it!
                func(*args, **kwargs)
        return wrapper
    return __mode_filter</code></pre>
</details>
</dd>
<dt id="pandare.extras.ModeFilter.set_mode"><code class="name flex">
<span>def <span class="ident">set_mode</span></span>(<span>self, new)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper to change mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_mode(self, new):
    &#39;&#39;&#39;
    Helper to change mode
    &#39;&#39;&#39;
    if new != self.mode:
        print(f&#34;Switching modes from {self.mode} to {new}&#34;)
    self.mode = new</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.ProcGraph"><code class="flex name class">
<span>class <span class="ident">ProcGraph</span></span>
<span>(</span><span>panda)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class which PyPANDA plugins should inherit. Subclasses may
register callbacks using the provided panda object and use the
PyPlugin APIs:</p>
<ul>
<li>self.get_args or self.get_arg_bool to check argument values</li>
<li>self.ppp to interact with other PyPlugins via PPP interfaces</li>
<li>self.ppp_cb_boilerplate('cb_name') to register a ppp-style callback</li>
<li>self.ppp_run_cb('cb_name') to run a previously-registered ppp-style callback</li>
<li>@PyPlugin.ppp_export to mark a class method as ppp-exported</li>
</ul>
<p>For more information, check out the pyplugin documentation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcGraph(PyPlugin):
    def __init__(self, panda):
        # Data collection
        self.procinfo = {} # PID: info
        self.time_data = [] # [(PID, #blocks)]
        self.total_insns = 0
        self.n_insns = 0
        self.last_pid = None
        self.show_ranges = not self.get_arg(&#34;hide_ranges&#34;)
        self.show_graph = not self.get_arg(&#34;hide_graph&#34;)
        self.panda = panda

        # config option: number of columns
        self.n_cols = self.get_arg(&#34;cols&#34;) or 120

        @panda.cb_start_block_exec
        def sbe(cpu, tb):
            self.n_insns += tb.icount
            self.total_insns += tb.icount

        @panda.ppp(&#34;osi&#34;, &#34;on_task_change&#34;)
        def task_change(cpu):
            proc = panda.plugins[&#39;osi&#39;].get_current_process(cpu)
            thread = panda.plugins[&#39;osi&#39;].get_current_thread(cpu)

            if proc == panda.ffi.NULL:
                print(f&#34;Warning: Unable to identify process at {self.n_insns}&#34;)
                return
            if thread == panda.ffi.NULL:
                print(f&#34;Warning: Unable to identify thread at {self.n_insns}&#34;)
                return

            proc_key = (proc.pid, thread.tid)
            if proc_key not in self.procinfo:
                self.procinfo[proc_key] = {&#34;names&#34;: set(), #&#34;tids&#34;: set(),
                                      &#34;first&#34;: self.total_insns, &#34;last&#34;: None,
                                      &#34;count&#34;: 0}

            name = panda.ffi.string(proc.name)  if proc.name != panda.ffi.NULL else &#34;(error)&#34;
            self.procinfo[proc_key][&#34;names&#34;].add(name)

            # Update insn count for last process and indicate it (maybe) ends at total_insns-1
            if self.last_pid:
                # count since we last ran is it&#39;s old end value, minus where it just ended
                self.procinfo[self.last_pid][&#34;count&#34;] += (self.total_insns-1) - self.procinfo[self.last_pid][&#34;last&#34;]  \
                                                if self.procinfo[self.last_pid][&#34;last&#34;] is not None \
                                                else (self.total_insns-1) - self.procinfo[self.last_pid][&#34;first&#34;]
                self.procinfo[self.last_pid][&#34;last&#34;] = self.total_insns-1

            self.last_pid = proc_key

            self.time_data.append((proc_key, self.n_insns))
            self.n_insns = 0

    def uninit(self):
        render_graph(self.procinfo, self.time_data, self.total_insns, n_cols=self.n_cols, show_ranges=self.show_ranges, show_graph=self.show_graph)

        # Fully reset state
        self.panda.disable_ppp(&#34;task_change&#34;)
        self.procinfo = {} # PID: info
        self.time_data = [] # [(PID, #blocks)]
        self.total_insns = 0
        self.n_insns = 0
        self.last_pid = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pandare.pyplugin.PyPlugin" href="../pyplugin.html#pandare.pyplugin.PyPlugin">PyPlugin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.ProcGraph.uninit"><code class="name flex">
<span>def <span class="ident">uninit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uninit(self):
    render_graph(self.procinfo, self.time_data, self.total_insns, n_cols=self.n_cols, show_ranges=self.show_ranges, show_graph=self.show_graph)

    # Fully reset state
    self.panda.disable_ppp(&#34;task_change&#34;)
    self.procinfo = {} # PID: info
    self.time_data = [] # [(PID, #blocks)]
    self.total_insns = 0
    self.n_insns = 0
    self.last_pid = None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pandare.pyplugin.PyPlugin" href="../pyplugin.html#pandare.pyplugin.PyPlugin">PyPlugin</a></b></code>:
<ul class="hlist">
<li><code><a title="pandare.pyplugin.PyPlugin.get_arg" href="../pyplugin.html#pandare.pyplugin.PyPlugin.get_arg">get_arg</a></code></li>
<li><code><a title="pandare.pyplugin.PyPlugin.get_arg_bool" href="../pyplugin.html#pandare.pyplugin.PyPlugin.get_arg_bool">get_arg_bool</a></code></li>
<li><code><a title="pandare.pyplugin.PyPlugin.ppp" href="../pyplugin.html#pandare.pyplugin.PyPlugin.ppp">ppp</a></code></li>
<li><code><a title="pandare.pyplugin.PyPlugin.ppp_cb_boilerplate" href="../pyplugin.html#pandare.pyplugin.PyPlugin.ppp_cb_boilerplate">ppp_cb_boilerplate</a></code></li>
<li><code><a title="pandare.pyplugin.PyPlugin.ppp_export" href="../pyplugin.html#pandare.pyplugin.PyPlugin.ppp_export">ppp_export</a></code></li>
<li><code><a title="pandare.pyplugin.PyPlugin.ppp_run_cb" href="../pyplugin.html#pandare.pyplugin.PyPlugin.ppp_run_cb">ppp_run_cb</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pandare.extras.ProcWriteCapture"><code class="flex name class">
<span>class <span class="ident">ProcWriteCapture</span></span>
<span>(</span><span>panda, console_capture=False, proc_name=None, log_dir=None, rm_existing_logs=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Set console_capture = True to capture all console output to file, including boot messages.
Set proc_name = "name_of_proc" to, for a named process, capture stdout/stderr and any file writes from the hypervisor, mirror results to log directory.
Can be stacked with console capture.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcWriteCapture():

    &#39;&#39;&#39;
    Set console_capture = True to capture all console output to file, including boot messages.
    Set proc_name = &#34;name_of_proc&#34; to, for a named process, capture stdout/stderr and any file writes from the hypervisor, mirror results to log directory.
    Can be stacked with console capture.
    &#39;&#39;&#39;

    def __init__(self, panda, console_capture = False, proc_name = None, log_dir = None, rm_existing_logs = False):

        self._panda = panda
        self._files_written = set()
        self._rm = rm_existing_logs
        self._console_capture = console_capture
        self._proc_name = proc_name
        self._proc_printed_err = False
        self._console_printed_err = False

        if log_dir == None:
            self._console_log_dir = Path.cwd()
            if proc_name:
                self._proc_log_dir = Path.cwd() / self._proc_name
        else:
            self._console_log_dir = Path(log_dir)
            if proc_name:
                self._proc_log_dir = Path(log_dir).joinpath(self._proc_name)

        # Setup logging dir
        self._console_log_dir.mkdir(parents=True, exist_ok=True)
        if proc_name:
            self._proc_log_dir.mkdir(parents=True, exist_ok=True)
        if self._rm:
            if proc_name:
                shutil.rmtree(self._proc_log_dir)
            shutil.rmtree(self._console_log_dir)

        # Mirror writes
        @self._panda.ppp(&#34;syscalls2&#34;, &#34;on_sys_write_enter&#34;)
        def proc_write_capture_on_sys_write_enter(cpu, pc, fd, buf, cnt):

            try_read = False

            # Capture console output
            if self._console_capture:

                # Fun trick: lazy eval of OSI
                # Based on the idea that a non-POSIX FD will only be used after boot is finished an OSI is functional
                # Note: doesn&#39;t capture boot logs (would require hooking kernel&#39;s printk, not write syscall)
                if (fd == 1) or (fd == 2) or (fd == 3):
                    try_read = True
                else:
                    curr_proc = panda.plugins[&#39;osi&#39;].get_current_process(cpu)
                    file_name_ptr = panda.plugins[&#39;osi_linux&#39;].osi_linux_fd_to_filename(cpu, curr_proc, fd)
                    file_path = panda.ffi.string(file_name_ptr).decode()
                    if (&#34;tty&#34; in file_path):
                        try_read = True

                if try_read:

                    try:
                        data = panda.virtual_memory_read(cpu, buf, cnt)
                    except ValueError:
                        raise RuntimeError(f&#34;Failed to read buffer: addr 0x{buf:016x}&#34;)

                    if fd == 2:
                        self._console_printed_err = True

                    log_file = self._console_log_dir.joinpath(&#34;console.out&#34;)
                    with open(log_file, &#34;ab&#34;) as f:
                        f.write(data)

                    self._files_written.add(str(log_file))

            # Use OSI to capture logs for a named process
            if self._proc_name:

                curr_proc = panda.plugins[&#39;osi&#39;].get_current_process(cpu)
                curr_proc_name = panda.ffi.string(curr_proc.name).decode()

                if self._proc_name == curr_proc_name:

                    if not try_read: # If we didn&#39;t already read this data in once for console capture
                        try:
                            data = panda.virtual_memory_read(cpu, buf, cnt)
                        except ValueError:
                            raise RuntimeError(f&#34;Failed to read buffer: proc \&#39;{curr_proc_name}\&#39;, addr 0x{buf:016x}&#34;)

                    file_name_ptr = panda.plugins[&#39;osi_linux&#39;].osi_linux_fd_to_filename(cpu, curr_proc, fd)
                    file_path = panda.ffi.string(file_name_ptr).decode()

                    # For informational purposes only, collection not reliant on this exact mapping
                    if fd == 1: # POSIX stdout
                        file_path += &#34;.stdout&#34;
                    elif fd == 2: # POSIX stderr
                        file_path += &#34;.stderr&#34;
                        self._proc_printed_err = True

                    log_file = self._proc_log_dir.joinpath(file_path.replace(&#34;//&#34;, &#34;_&#34;).replace(&#34;/&#34;, &#34;_&#34;))
                    with open(log_file, &#34;ab&#34;) as f:
                        f.write(data)

                    self._files_written.add(str(log_file))

    def proc_printed_err(self):
        return self._proc_printed_err

    def console_printed_post_boot_err(self):
        return self._console_printed_err

    def get_files_written(self):
        return self._files_written</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.ProcWriteCapture.console_printed_post_boot_err"><code class="name flex">
<span>def <span class="ident">console_printed_post_boot_err</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def console_printed_post_boot_err(self):
    return self._console_printed_err</code></pre>
</details>
</dd>
<dt id="pandare.extras.ProcWriteCapture.get_files_written"><code class="name flex">
<span>def <span class="ident">get_files_written</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_files_written(self):
    return self._files_written</code></pre>
</details>
</dd>
<dt id="pandare.extras.ProcWriteCapture.proc_printed_err"><code class="name flex">
<span>def <span class="ident">proc_printed_err</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def proc_printed_err(self):
    return self._proc_printed_err</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.extras.ProcWriteCapture"><code class="flex name class">
<span>class <span class="ident">Snake</span></span>
<span>(</span><span>panda, console_capture=False, proc_name=None, log_dir=None, rm_existing_logs=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Set console_capture = True to capture all console output to file, including boot messages.
Set proc_name = "name_of_proc" to, for a named process, capture stdout/stderr and any file writes from the hypervisor, mirror results to log directory.
Can be stacked with console capture.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcWriteCapture():

    &#39;&#39;&#39;
    Set console_capture = True to capture all console output to file, including boot messages.
    Set proc_name = &#34;name_of_proc&#34; to, for a named process, capture stdout/stderr and any file writes from the hypervisor, mirror results to log directory.
    Can be stacked with console capture.
    &#39;&#39;&#39;

    def __init__(self, panda, console_capture = False, proc_name = None, log_dir = None, rm_existing_logs = False):

        self._panda = panda
        self._files_written = set()
        self._rm = rm_existing_logs
        self._console_capture = console_capture
        self._proc_name = proc_name
        self._proc_printed_err = False
        self._console_printed_err = False

        if log_dir == None:
            self._console_log_dir = Path.cwd()
            if proc_name:
                self._proc_log_dir = Path.cwd() / self._proc_name
        else:
            self._console_log_dir = Path(log_dir)
            if proc_name:
                self._proc_log_dir = Path(log_dir).joinpath(self._proc_name)

        # Setup logging dir
        self._console_log_dir.mkdir(parents=True, exist_ok=True)
        if proc_name:
            self._proc_log_dir.mkdir(parents=True, exist_ok=True)
        if self._rm:
            if proc_name:
                shutil.rmtree(self._proc_log_dir)
            shutil.rmtree(self._console_log_dir)

        # Mirror writes
        @self._panda.ppp(&#34;syscalls2&#34;, &#34;on_sys_write_enter&#34;)
        def proc_write_capture_on_sys_write_enter(cpu, pc, fd, buf, cnt):

            try_read = False

            # Capture console output
            if self._console_capture:

                # Fun trick: lazy eval of OSI
                # Based on the idea that a non-POSIX FD will only be used after boot is finished an OSI is functional
                # Note: doesn&#39;t capture boot logs (would require hooking kernel&#39;s printk, not write syscall)
                if (fd == 1) or (fd == 2) or (fd == 3):
                    try_read = True
                else:
                    curr_proc = panda.plugins[&#39;osi&#39;].get_current_process(cpu)
                    file_name_ptr = panda.plugins[&#39;osi_linux&#39;].osi_linux_fd_to_filename(cpu, curr_proc, fd)
                    file_path = panda.ffi.string(file_name_ptr).decode()
                    if (&#34;tty&#34; in file_path):
                        try_read = True

                if try_read:

                    try:
                        data = panda.virtual_memory_read(cpu, buf, cnt)
                    except ValueError:
                        raise RuntimeError(f&#34;Failed to read buffer: addr 0x{buf:016x}&#34;)

                    if fd == 2:
                        self._console_printed_err = True

                    log_file = self._console_log_dir.joinpath(&#34;console.out&#34;)
                    with open(log_file, &#34;ab&#34;) as f:
                        f.write(data)

                    self._files_written.add(str(log_file))

            # Use OSI to capture logs for a named process
            if self._proc_name:

                curr_proc = panda.plugins[&#39;osi&#39;].get_current_process(cpu)
                curr_proc_name = panda.ffi.string(curr_proc.name).decode()

                if self._proc_name == curr_proc_name:

                    if not try_read: # If we didn&#39;t already read this data in once for console capture
                        try:
                            data = panda.virtual_memory_read(cpu, buf, cnt)
                        except ValueError:
                            raise RuntimeError(f&#34;Failed to read buffer: proc \&#39;{curr_proc_name}\&#39;, addr 0x{buf:016x}&#34;)

                    file_name_ptr = panda.plugins[&#39;osi_linux&#39;].osi_linux_fd_to_filename(cpu, curr_proc, fd)
                    file_path = panda.ffi.string(file_name_ptr).decode()

                    # For informational purposes only, collection not reliant on this exact mapping
                    if fd == 1: # POSIX stdout
                        file_path += &#34;.stdout&#34;
                    elif fd == 2: # POSIX stderr
                        file_path += &#34;.stderr&#34;
                        self._proc_printed_err = True

                    log_file = self._proc_log_dir.joinpath(file_path.replace(&#34;//&#34;, &#34;_&#34;).replace(&#34;/&#34;, &#34;_&#34;))
                    with open(log_file, &#34;ab&#34;) as f:
                        f.write(data)

                    self._files_written.add(str(log_file))

    def proc_printed_err(self):
        return self._proc_printed_err

    def console_printed_post_boot_err(self):
        return self._console_printed_err

    def get_files_written(self):
        return self._files_written</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pandare.extras.ProcWriteCapture.console_printed_post_boot_err"><code class="name flex">
<span>def <span class="ident">console_printed_post_boot_err</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def console_printed_post_boot_err(self):
    return self._console_printed_err</code></pre>
</details>
</dd>
<dt id="pandare.extras.ProcWriteCapture.get_files_written"><code class="name flex">
<span>def <span class="ident">get_files_written</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_files_written(self):
    return self._files_written</code></pre>
</details>
</dd>
<dt id="pandare.extras.ProcWriteCapture.proc_printed_err"><code class="name flex">
<span>def <span class="ident">proc_printed_err</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def proc_printed_err(self):
    return self._proc_printed_err</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="panda.re Docs" href="/">
<img src="//panda.re/img/logo.png" alt="logo"> PANDA.re Docs
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pandare" href="../index.html">pandare</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pandare.extras.dwarfdump" href="dwarfdump.html">pandare.extras.dwarfdump</a></code></li>
<li><code><a title="pandare.extras.fileFaker" href="fileFaker.html">pandare.extras.fileFaker</a></code></li>
<li><code><a title="pandare.extras.fileHook" href="fileHook.html">pandare.extras.fileHook</a></code></li>
<li><code><a title="pandare.extras.ioctlFaker" href="ioctlFaker.html">pandare.extras.ioctlFaker</a></code></li>
<li><code><a title="pandare.extras.modeFilter" href="modeFilter.html">pandare.extras.modeFilter</a></code></li>
<li><code><a title="pandare.extras.procTrace" href="procTrace.html">pandare.extras.procTrace</a></code></li>
<li><code><a title="pandare.extras.procWriteCapture" href="procWriteCapture.html">pandare.extras.procWriteCapture</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pandare.extras.FakeFile" href="#pandare.extras.FakeFile">FakeFile</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.FakeFile.close" href="#pandare.extras.FakeFile.close">close</a></code></li>
<li><code><a title="pandare.extras.FakeFile.get_mode" href="#pandare.extras.FakeFile.get_mode">get_mode</a></code></li>
<li><code><a title="pandare.extras.FakeFile.get_size" href="#pandare.extras.FakeFile.get_size">get_size</a></code></li>
<li><code><a title="pandare.extras.FakeFile.read" href="#pandare.extras.FakeFile.read">read</a></code></li>
<li><code><a title="pandare.extras.FakeFile.write" href="#pandare.extras.FakeFile.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.FileFaker" href="#pandare.extras.FileFaker">FileFaker</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.FileFaker.close" href="#pandare.extras.FileFaker.close">close</a></code></li>
<li><code><a title="pandare.extras.FileFaker.replace_file" href="#pandare.extras.FileFaker.replace_file">replace_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.FileHook" href="#pandare.extras.FileHook">FileHook</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.FileHook.rename_file" href="#pandare.extras.FileHook.rename_file">rename_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.IoctlFaker" href="#pandare.extras.IoctlFaker">IoctlFaker</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.IoctlFaker.get_forced_returns" href="#pandare.extras.IoctlFaker.get_forced_returns">get_forced_returns</a></code></li>
<li><code><a title="pandare.extras.IoctlFaker.get_unmodified_returns" href="#pandare.extras.IoctlFaker.get_unmodified_returns">get_unmodified_returns</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.ModeFilter" href="#pandare.extras.ModeFilter">ModeFilter</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.ModeFilter.mode" href="#pandare.extras.ModeFilter.mode">mode</a></code></li>
<li><code><a title="pandare.extras.ModeFilter.mode_filter" href="#pandare.extras.ModeFilter.mode_filter">mode_filter</a></code></li>
<li><code><a title="pandare.extras.ModeFilter.set_mode" href="#pandare.extras.ModeFilter.set_mode">set_mode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.ProcGraph" href="#pandare.extras.ProcGraph">ProcGraph</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.ProcGraph.uninit" href="#pandare.extras.ProcGraph.uninit">uninit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.ProcWriteCapture" href="#pandare.extras.ProcWriteCapture">ProcWriteCapture</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.ProcWriteCapture.console_printed_post_boot_err" href="#pandare.extras.ProcWriteCapture.console_printed_post_boot_err">console_printed_post_boot_err</a></code></li>
<li><code><a title="pandare.extras.ProcWriteCapture.get_files_written" href="#pandare.extras.ProcWriteCapture.get_files_written">get_files_written</a></code></li>
<li><code><a title="pandare.extras.ProcWriteCapture.proc_printed_err" href="#pandare.extras.ProcWriteCapture.proc_printed_err">proc_printed_err</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.extras.ProcWriteCapture" href="#pandare.extras.ProcWriteCapture">ProcWriteCapture</a></code></h4>
<ul class="">
<li><code><a title="pandare.extras.ProcWriteCapture.console_printed_post_boot_err" href="#pandare.extras.ProcWriteCapture.console_printed_post_boot_err">console_printed_post_boot_err</a></code></li>
<li><code><a title="pandare.extras.ProcWriteCapture.get_files_written" href="#pandare.extras.ProcWriteCapture.get_files_written">get_files_written</a></code></li>
<li><code><a title="pandare.extras.ProcWriteCapture.proc_printed_err" href="#pandare.extras.ProcWriteCapture.proc_printed_err">proc_printed_err</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>