<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pandare API documentation</title>
<meta name="description" content="`pandare` (also called PyPANDA) is a Python 3 module built for interacting with the PANDA project.
The module enables driving an execution of a …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<!-- Bootstrap core CSS -->
<!--
<link href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css" rel="stylesheet">
-->
<!-- hand-crafted bootstrap navbar -->
<style>
.bg-light {
background-color: #f8f9fa!important;
}
.navbar {
position: relative;
display: -ms-flexbox;
display: flex;
-ms-flex-wrap: wrap;
flex-wrap: wrap;
-ms-flex-align: center;
align-items: center;
-ms-flex-pack: justify;
justify-content: space-between;
padding: .5rem 1rem;
}
.navbar-expand-lg {
-ms-flex-direction: row;
flex-direction: row;
-ms-flex-wrap: nowrap;
flex-wrap: nowrap;
-ms-flex-pack: start;
justify-content: flex-start;
}
navbar-light .navbar-brand {
color: rgba(0,0,0,.9);
}
.navbar-brand {
display: inline-block;
padding-top: .3125rem;
padding-bottom: .3125rem;
margin-right: 1rem;
font-size: 1.25rem;
line-height: inherit;
white-space: nowrap;
}
.navbar-nav {
display: -ms-flexbox;
display: flex;
-ms-flex-direction: column;
flex-direction: column;
padding-left: 0;
margin-bottom: 0;
list-style: none;
}
.navbar-expand-lg .navbar-nav {
-ms-flex-direction: row;
flex-direction: row;
}
.mr-auto {
margin-right: auto!important;
}
.navbar-expand-lg .navbar-collapse {
display: -ms-flexbox!important;
display: flex!important;
}
.navbar-collapse {
-ms-flex-preferred-size: 100%;
flex-basis: 100%;
-ms-flex-align: center;
align-items: center;
}
.navbar-light .navbar-brand {
color: rgba(0,0,0,.9);
}
.navbar a {
color: #007bff;
text-decoration: none;
background-color: transparent;
-webkit-text-decoration-skip: objects;
}
.navbar-expand-lg .navbar-nav .nav-link {
padding-right: .5rem;
padding-left: .5rem;
}
.navbar .navbar-nav {
margin: 0;
font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
font-size: 1rem;
font-weight: 400;
line-height: 1.5;
color: #212529;
}
.navbar-light .navbar-nav .active>.nav-link, .navbar-light .navbar-nav .nav-link.active, .navbar-light .navbar-nav .nav-link.show, .navbar-light .navbar-nav .show>.nav-link {
color: rgba(0,0,0,.9);
}
.navbar-light .navbar-nav .nav-link {
color: rgba(0,0,0,.5);
}
.nav-link {
display: block;
padding: .5rem 1rem;
}
</style>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-light">
<a class="navbar-brand" href="/">PANDA.re</a>
<div class="collapse navbar-collapse" id="navbarSupportedContent">
<ul class="navbar-nav mr-auto">
<li class="nav-item">
<a class="nav-link" href="//panda.re/">Home</a>
</li>
<li class="nav-item">
<a class="nav-link" target="_new" href="https://github.com/panda-re/panda">Github</a>
</li>
<li class="nav-item ">
<a class="nav-link" href="//panda.re/blog/">Blog</a>
</li>
<li class="nav-item ">
<a class="nav-link active" href="//docs.panda.re">Python Docs</a>
</li>
<li class="nav-item ">
<a class="nav-link" href="//panda.re/invite.php">Slack</a>
</li>
<!-- No resources tab here because we don't have real bootstrap -->
</div>
</nav>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>pandare</code></h1>
</header>
<section id="section-intro">
<p><code><a title="pandare" href="#pandare">pandare</a></code> (also called PyPANDA) is a Python 3 module built for interacting with the PANDA project.
The module enables driving an execution of a virtual machine while also introspecting on its execution using PANDA's callback
and plugin systems.</p>
<p>Most of the commonly used APIs are in <code><a title="pandare.panda" href="panda.html">pandare.panda</a></code>.</p>
<p>Example plugins are available in the <a href="https://github.com/panda-re/panda/tree/master/panda/python/examples">examples directory</a>.</p>
<h1 id="pypanda">PyPANDA</h1>
<p>PyPANDA is a python interface to PANDA. With PyPANDA, you can quickly develop plugins
to analyze behavior of a running system, record a system and analyze replays, or do
nearly anything you can do using PANDA's C/C++ APIs.</p>
<h2 id="installation">Installation</h2>
<p>Follow PANDA's build instructions. The <code>pandare/panda</code> docker container includes the <code><a title="pandare" href="#pandare">pandare</a></code> package. If you setup panda with the <code>install_ubuntu.sh</code> script, it will install PyPANDA for you. Otherwise, when your install instructions tell you to run <code>build.sh</code> be sure to include the <code>--python</code> flag.</p>
<h2 id="example-program">Example program</h2>
<p>This program counts the number of basic blocks executed while running <code>uname -a</code> inside a 32-bit guest.</p>
<pre><code class="language-py">from pandare import Panda
panda = Panda(generic='i386') # Create an instance of panda

# Counter of the number of basic blocks
blocks = 0

# Register a callback to run before_block_exec and increment blocks
@panda.cb_before_block_exec
def before_block_execute(cpustate, transblock):
    global blocks
    blocks += 1

# This 'blocking' function is queued to run in a seperate thread from the main CPU loop
# which allows for it to wait for the guest to complete commands
@panda.queue_blocking
def run_cmd():
    # First revert to the qcow's root snapshot (synchronously)
    panda.revert_sync(&quot;root&quot;)
    # Then type a command via the serial port and print its results
    print(panda.run_serial_cmd(&quot;uname -a&quot;))
    # When the command finishes, terminate the panda.run() call
    panda.end_analysis()

# Start the guest
panda.run()
print(&quot;Finished. Saw a total of {} basic blocks during execution&quot;.format(blocks))
</code></pre>
<h1 id="usage">Usage</h1>
<h2 id="create-an-instance-of-panda">Create an instance of Panda</h2>
<p>The <code><a title="pandare.Panda" href="#pandare.Panda">Panda</a></code> class takes many arguments, but the only crucial argument is a
specificed qcow image. If you wish to get started quickly you may use the <code>pandare.qcows.Qcows</code> module
to automatically download a pre-configured virtual machine for you to use.</p>
<p>For example: <code>panda = Panda(generic='i386')</code></p>
<h2 id="register-a-callback">Register a callback</h2>
<pre><code class="language-py">@panda.cb_before_block_exec
def my_before_block_fn(cpustate, translation_block):
  pc = panda.current_pc(cpustate)
  print(&quot;About to run the block at 0x{:x}&quot;.format(pc))
</code></pre>
<p>The panda object contains decorators named <code>cb_[CALLBACK_NAME]</code> for each PANDA callback.
A decorated function must take the same number of arguments and return the equivalent type
as expected by the original C callback. The <strong><a href="#pandare.Callbacks">list of callbacks</a></strong> is available below.
The decorated functions are called at the appropriate times, similarly to how a PANDA plugin written
in C behaves.</p>
<h2 id="enable-and-disable-callbacks">Enable and disable callbacks</h2>
<p>Python callbacks can be enabled and disabled using their names.
By default, a callback is named after the function that is decorated. For example, the callback describe in</p>
<pre><code class="language-py">@panda.cb_before_block_exec
def my_before_block_fn(cpustate, translation_block):
  ...
</code></pre>
<p>is named <code>my_before_block_fn</code> and can be disabled with <code>panda.disable_callback('my_before_block_fn')</code> and later
enabled with <code>panda.enable_callback('my_before_block_fn')</code>.</p>
<p>Callbacks can be given custom names and disabled at initialization by passing arguments to their decorators:</p>
<pre><code class="language-py">@panda.cb_before_block_exec(name='my_callback', enabled=False)
def my_before_block_fn(cpustate, translation_block):
  ...
panda.enable_callback('my_callback')
</code></pre>
<p>If a callback is decorated with a <code>procname</code> argument, it will only be enabled when that process is running.
To permanently disable such a callback, you can use <code>panda.disable_callback('name', forever=True)</code>.</p>
<p>Note that if you wish to define a function multiple times (e.g., inside a loop), you'll need to give it multiple names
or it will be overwritten.</p>
<pre><code class="language-py">for x in range(10):
  @panda.cb_before_block_exec(name=f&quot;bbe_{x}&quot;)
  def bbe_loop(cpu, tb):
     print(f&quot;Before block exec function #{x}&quot;)
</code></pre>
<h2 id="replaying-recordings">Replaying Recordings</h2>
<pre><code class="language-py">panda = Panda(...)
# Register functions to run on callbacks here
panda.run_replay(&quot;/file/path/here&quot;) # Runs the replay
</code></pre>
<h2 id="load-and-unload-a-c-plugin">Load and unload a C plugin</h2>
<p>A C plugin can be loaded from pypanda easily: <code>panda.load_plugin("stringsearch")</code></p>
<p>C plugins can be passed named arguments using a dictionary: <code>panda.load_plugin("stringsearch", {"name": "jpeg"})</code></p>
<p>Or unnamed arguments using a list: <code>panda.load_plugin("my_plugin", ["arg1", "arg2"])</code></p>
<h2 id="asynchronous-activity">Asynchronous Activity</h2>
<p>When a callback is executing, the guest is suspended until the callback finishes. However, we often want to interact
with guests during our analyses. In these situations, we run code asynchronously to send data into and wait for results
from the guest.</p>
<p>PyPANDA is designed to easily support such analyses with the <code>@panda.queue_blocking</code> decorator.</p>
<p>Consider if you with to run the commands <code>uname -a</code>, then <code>whoami</code> in a guest. If your guest exposes a console over a serial port
(as all the 'generic' qcows we use do), you could run these commands by simply typing them and waiting for a response. But if you were
to do this in a callback, the guest would have no chance to respond to your commands and you'd end up in a deadlock where your callback
code never terminates until the guest executes your command, and the guest will never execute commands until your callback terminates.</p>
<p>Instead, you can queue up blocking functions to run asynchronously as follows:</p>
<pre><code class="language-py">panda = ...

@panda.queue_blocking
def first_cmd():
    print(panda.run_serial_cmd(&quot;uname -a&quot;))

@panda.queue_blocking
def second_cmd():
    print(panda.run_serial_cmd(&quot;whoami&quot;))
    panda.end_analysis()

panda.run()
</code></pre>
<p>Note that the <code>panda.queue_blocking</code> decorator both marks a function as being a blocking function (which allows it to use functions such as <code>panda.run_serial_cmd</code>) and queues it up to run after the call to <code>panda.run()</code></p>
<h2 id="recordings">Recordings</h2>
<p>See <a href="https://github.com/panda-re/panda/tree/master/panda/python/examples/take_recording.py">take_recording.py</a></p>
<p>A replay can be taken with the function <code>panda.record_cmd('cmd_to_run', recording_name='replay_name')</code> which will revert the guest to a <code>root</code> snapshot, type a command, begin a recording, press enter, wait for the command to finish, and then end the replay.
Once a replay is created on disk, it can be analyzed by using <code>panda.run_replay('replay_name')</code>.</p>
<p>Alternatively, you can begin/end the recording through the monitor with <code>panda.run_monitor_cmd('begin_record myname')</code>
and <code>panda.run_monitor_cmd('end_record')</code> and drive the guest using <code>panda.run_serial_cmd</code> in the middle.</p>
<h1 id="typical-use-patterns">Typical Use Patterns</h1>
<h2 id="live-system">Live system</h2>
<p>Example: <a href="https://github.com/panda-re/panda/tree/master/panda/python/examples/asid.py">asid.py</a>.</p>
<ol>
<li>Initialize a panda object based off a generic machine or a qcow you have.</li>
<li>Register functions to run at various PANDA callbacks.</li>
<li>Register and queue up a blocking function to revert the guest to a snapshot, run commands with <code>panda.run_serial_cmd()</code>, and stop the execution with <code>panda.end_analysis()</code></li>
<li>Start the execution with <code>panda.run()</code></li>
</ol>
<h2 id="recordreplay">Record/Replay</h2>
<p>Example: <a href="https://github.com/panda-re/panda/tree/master/panda/python/tests/record_then_replay.py">tests/record_then_replay.py</a>.</p>
<ol>
<li>Initialize a panda object based off a generic machine or a qcow you have.</li>
<li>Register and queue up a blocking function to drive guest execution while recording or with <code>panda.record_cmd</code> then call <code>panda.end_analysis()</code></li>
<li>Register functions to run at various PANDA callbacks.</li>
<li>Analyze the replay with <code>panda.run_replay(filename)</code></li>
</ol>
<h1 id="additional-information">Additional Information</h1>
<h2 id="here-be-dragons">Here be dragons</h2>
<ul>
<li>You can't have multiple instances of panda running at the same time. Once you've created a panda object for a given architecture, you can never create another. Hoewver, you can modify the machine after it's created to run a new analysis as long as you don't change the machine type.</li>
<li>PyPANDA is slower than traditional PANDA. Well-engineered plugins typically have a runtime overhead of ~10% compared to regular PANDA plugins (for up to 10M instructions). To improve performance try disabling callbacks when possible and only enabling them when they are needed.</li>
</ul>
<h2 id="extending-pypanda">Extending PyPANDA</h2>
<p>PyPANDA currently supports interactions (e.g., ppp callbacks) with many PANDA plugins such as <code>taint2</code> and <code>osi</code>. If you wish to extend PyPANDA to support an new plugin, its header file
must be cleaned up such that it can be parsed by CFFI. See <a href="https://github.com/panda-re/panda/tree/master/panda/python/utils/create_panda_datatypes.py">create_panda_datatypes.py</a>
and the magic <code>BEGIN_PYPANDA_NEEDS_THIS</code> strings it searches for.</p>
<h2 id="learn-more">Learn more</h2>
<p>The <a href="https://moyix.net/~moyix/papers/pypanda.pdf">PyPANDA paper</a> was published at the NDSS Binary Analysis Research Workshop in 2021 and includes details on the project's design goals as well as an evaluation of it's usability and performance.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
`pandare` (also called PyPANDA) is a Python 3 module built for interacting with the PANDA project.
The module enables driving an execution of a virtual machine while also introspecting on its execution using PANDA&#39;s callback
and plugin systems.

Most of the commonly used APIs are in `pandare.panda`.

Example plugins are available in the [examples directory](https://github.com/panda-re/panda/tree/master/panda/python/examples).

.. include:: ../../docs/USAGE.md
&#34;&#34;&#34;

from .panda import Panda, blocking
from .pyplugin import PyPlugin

try:
    # plog_reader depends on protobuf autogenerated code
    # if protobuf is missing or the protoc that generated
    # the plog_pb2.py file is incompatible with the python
    # protobuf package, it raises errors.
    from .plog_reader import PLogReader
except ImportError:
    # plog reader isn&#39;t widely used - let&#39;s make this optional
    PLogReader = None

__all__ = [&#39;Panda&#39;, &#39;PLogReader&#39;, &#39;Callbacks&#39;, &#39;PyPlugin&#39;]

__pdoc__ = {}

__pdoc__[&#39;asyncthread&#39;] = False
__pdoc__[&#39;autogen&#39;] = False
__pdoc__[&#39;ffi_importer&#39;] = False
__pdoc__[&#39;plog_pb2&#39;] = False
__pdoc__[&#39;volatility_cli_classes&#39;] = False

# The following code is soley here to allow pdoc to document callbacks
from .autogen.panda_datatypes import get_cb_docs
class Callbacks:
    &#39;&#39;&#39;
    The core callbacks provided by PANDA. Note this is a fake class that only exists for
    documentation.
    Importantly: the arguments listed are the arguments **your callback function will receive** and
    the return value is what **your callback must return**.

    These decorators should be accessed through a handle to a panda object, for example:

        panda = Panda(generic=&#39;x86_64&#39;)

        @panda.cb_before_block_exec
        def my_bbe_callback(cpu, tb):
            print(&#34;Before block exec!&#34;)
        ...
    &#39;&#39;&#39;

    def __init__(self):
        raise RuntimeError(&#34;The callbacks class is only used for documentation. Callback &#34; \
                           &#34;decorators should be accessed through @panda.cb_[calback_name] &#34; \
                           &#34;where panda is the name of your pandare.Panda() object&#34;)

cb_docs = get_cb_docs()
for cb_name, (rv, args, docstring) in cb_docs._asdict().items():
    # Add fake functions to our callbacks class with dynamic docstrings

    if cb_name == &#34;init&#34;:
        continue
    fakename = &#34;@panda.cb_&#34; + cb_name

    # Add no-op function to the class
    setattr(Callbacks, fakename, lambda Your_Function: None)

    # Build argument list and reformat for pdoc from function signature
    args = args.replace(&#34; *&#34;, &#34;* &#34;) # CPUState *env -&gt; CPUState* env
    arglist = []
    for arg in args.split(&#34;,&#34;):
        arg = arg.strip()
        if &#34; &#34; in arg:
            typ = arg.split(&#34; &#34;)[0]
            name = arg[len(typ)+1:]
            arglist.append((typ, name))
        else:
            arglist.append((arg, &#34;&#34;))

    # Try to build argument descriptions too from text by finding lines like &#34;argname: something\n&#34;
    arg_desc = {}
    rv_desc = &#34;&#34;
    next_rv = False

    type_signature = f&#34;{rv} (*&#34; # To identify when we&#39;re done with useful docs

    for line in docstring.split(&#34;\n&#34;):
        # Get arg descriptions
        for (arg_type, arg_name) in arglist:
            if f&#34;{arg_name}:&#34; in line:
                arg_desc[arg_name] = line.split(f&#34;{arg_name}:&#34;)[1].strip()

        # Get return value description
        if line.startswith(&#34;Return value:&#34;):
            next_rv = True
        elif next_rv and &#34;:&#34; in line or type_signature in line:
            # End when we hit something like &#34;Notes: &#34; or &#34;void (*this_callback)...&#34;
            next_rv = False
        elif next_rv:
            rv_desc += line.strip() + &#34; &#34;

    argnames = &#34;\n        &#34;.join(f&#34;{argtype}: {argname}: {arg_desc[argname] if argname in arg_desc else &#39;&#39;}&#34; for (argtype, argname) in arglist)

    # Build docstring
    full_ds = &#34;&#34;

    # Now we want to add the comments from the C header, but we have to avoid
    # including &#34;Arguments:&#34; or pdoc will stop special-formatting our above
    # arguments we worked so hard to get.
    # For now let&#39;s just grab from [name]: up until a line ending with Arguments
    # and also Notes:

    record = False
    for line in docstring.split(&#34;\n&#34;):
        if line.strip().replace(&#34;:&#34;, &#34;&#34;).endswith(&#34;Arguments&#34;):
            record = False

        if &#39;Notes:&#39; in line: # Include Notes: in our ouptut
            record = True
            #full_ds += &#34;\n\n&#34;

        if cb_name+&#34;:&#34; in line:
            start = line.split(cb_name+&#34;:&#34;)[1]
            if len(start):
                start+= &#34; &#34;
            full_ds += start
            record = True
            continue

        if type_signature in line:
            record = False

        if record:
            full_ds += line + &#34; &#34;

    # Now add args and retval
    full_ds += f&#34;&#34;&#34;
    Args:
        {argnames}

    Returns:
        {rv}: {rv_desc if len(rv_desc) else &#39;the type your callback must return&#39;}

    &#34;&#34;&#34;

    __pdoc__[f&#34;Callbacks.{fakename}&#34;] = full_ds</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pandare.arch" href="arch.html">pandare.arch</a></code></dt>
<dd>
<div class="desc"><p>This module contains architecture-specific code …</p></div>
</dd>
<dt><code class="name"><a title="pandare.cosi" href="cosi.html">pandare.cosi</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pandare.extras" href="extras/index.html">pandare.extras</a></code></dt>
<dd>
<div class="desc"><p>Extras are PyPANDA plugins which you can import into other python analyses. Typically
this is done by passing a handle from your script's PANDA object …</p></div>
</dd>
<dt><code class="name"><a title="pandare.panda" href="panda.html">pandare.panda</a></code></dt>
<dd>
<div class="desc"><p>This module simply contains the Panda class.</p></div>
</dd>
<dt><code class="name"><a title="pandare.panda_expect" href="panda_expect.html">pandare.panda_expect</a></code></dt>
<dd>
<div class="desc"><p>Custom library for interacting/expecting data via serial-like FDs</p></div>
</dd>
<dt><code class="name"><a title="pandare.plog_reader" href="plog_reader.html">pandare.plog_reader</a></code></dt>
<dd>
<div class="desc"><p>Module for reading and writing PANDAlog (plog) files from Python.</p></div>
</dd>
<dt><code class="name"><a title="pandare.pyplugin" href="pyplugin.html">pandare.pyplugin</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pandare.pypluginmanager" href="pypluginmanager.html">pandare.pypluginmanager</a></code></dt>
<dd>
<div class="desc"><p>Class to manage loading Panda PyPlugins. See docs/pyplugins.md for details.</p></div>
</dd>
<dt><code class="name"><a title="pandare.qcows" href="qcows.html">pandare.qcows</a></code></dt>
<dd>
<div class="desc"><p>Module to simplify PANDA command line usage. Use python3 -m pandare.qcows to
fetch files necessary to run various generic VMs and generate command …</p></div>
</dd>
<dt><code class="name"><a title="pandare.qcows_internal" href="qcows_internal.html">pandare.qcows_internal</a></code></dt>
<dd>
<div class="desc"><p>Module for fetching generic PANDA images and managing their metadata.</p></div>
</dd>
<dt><code class="name"><a title="pandare.qemu_logging" href="qemu_logging.html">pandare.qemu_logging</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pandare.taint" href="taint/index.html">pandare.taint</a></code></dt>
<dd>
<div class="desc"><p>Structures to support the taint subsystem.</p></div>
</dd>
<dt><code class="name"><a title="pandare.utils" href="utils.html">pandare.utils</a></code></dt>
<dd>
<div class="desc"><p>Misc helper functions</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pandare.Callbacks"><code class="flex name class">
<span>class <span class="ident">Callbacks</span></span>
</code></dt>
<dd>
<div class="desc"><p>The core callbacks provided by PANDA. Note this is a fake class that only exists for
documentation.
Importantly: the arguments listed are the arguments <strong>your callback function will receive</strong> and
the return value is what <strong>your callback must return</strong>.</p>
<p>These decorators should be accessed through a handle to a panda object, for example:</p>
<pre><code>panda = Panda(generic='x86_64')

@panda.cb_before_block_exec
def my_bbe_callback(cpu, tb):
    print("Before block exec!")
...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Callbacks:
    &#39;&#39;&#39;
    The core callbacks provided by PANDA. Note this is a fake class that only exists for
    documentation.
    Importantly: the arguments listed are the arguments **your callback function will receive** and
    the return value is what **your callback must return**.

    These decorators should be accessed through a handle to a panda object, for example:

        panda = Panda(generic=&#39;x86_64&#39;)

        @panda.cb_before_block_exec
        def my_bbe_callback(cpu, tb):
            print(&#34;Before block exec!&#34;)
        ...
    &#39;&#39;&#39;

    def __init__(self):
        raise RuntimeError(&#34;The callbacks class is only used for documentation. Callback &#34; \
                           &#34;decorators should be accessed through @panda.cb_[calback_name] &#34; \
                           &#34;where panda is the name of your pandare.Panda() object&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pandare.Callbacks.@panda.cb_after_block_exec"><code class="name flex">
<span>def <span class="ident">@panda.cb_after_block_exec</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after execution of every basic block. If exitCode &gt; TB_EXIT_IDX1, then the block exited early.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>TranslationBlock*</code></strong></dt>
<dd>tb: the TB we just executed</dd>
<dt><strong><code>uint8_t</code></strong></dt>
<dd>exitCode: why the block execution exited</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_after_block_translate"><code class="name flex">
<span>def <span class="ident">@panda.cb_after_block_translate</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after the translation of each basic block.
Notes: This is a good place to perform extra passes over the generated code (particularly by manipulating the LLVM code). FIXME: How would this actually work? By this point the out ASM has already been generated. Modify the IR and then regenerate?
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>TranslationBlock*</code></strong></dt>
<dd>tb: the TB we just translated</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_after_cpu_exec_enter"><code class="name flex">
<span>def <span class="ident">@panda.cb_after_cpu_exec_enter</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after cpu_exec calls cpu_exec_enter function.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_after_insn_exec"><code class="name flex">
<span>def <span class="ident">@panda.cb_after_insn_exec</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after execution of an instruction identified by the PANDA_CB_AFTER_INSN_TRANSLATE callback
Notes: See <code>insn_exec</code>. Enabled via the PANDA_CB_AFTER_INSN_TRANSLATE callback.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the next guest PC already executed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>unused
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_after_insn_translate"><code class="name flex">
<span>def <span class="ident">@panda.cb_after_insn_translate</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after the translation of each instruction.
Notes: See <code>insn_translate</code>, callbacks are registered via PANDA_CB_AFTER_INSN_EXEC
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the next guest PC we've translated</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true if PANDA should insert instrumentation into the generated code, false otherwise
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_after_loadvm"><code class="name flex">
<span>def <span class="ident">@panda.cb_after_loadvm</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called right after a snapshot has been loaded (either with loadvm or replay initialization), but before any guest code runs.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_after_machine_init"><code class="name flex">
<span>def <span class="ident">@panda.cb_after_machine_init</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called right after the machine has been initialized, but before any guest code runs.
Notes: This callback allows initialization of components that need access to the RAM, CPU object, etc. E.g. for the taint2 plugin, this is the appropriate place to call taint2_enable_taint().
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_asid_changed"><code class="name flex">
<span>def <span class="ident">@panda.cb_asid_changed</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when asid changes.
Notes: The callback is only invoked implemented for x86 and ARM. This should break plugins which rely on it to detect context switches in any other architecture.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>oldval: old asid value</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>newval: new asid value</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true if the asid should be prevented from being changed false otherwise
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_before_block_exec"><code class="name flex">
<span>def <span class="ident">@panda.cb_before_block_exec</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before execution of every basic block.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>TranslationBlock*</code></strong></dt>
<dd>tb: the TB we are about to execute</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_before_block_exec_invalidate_opt"><code class="name flex">
<span>def <span class="ident">@panda.cb_before_block_exec_invalidate_opt</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before execution of every basic block, with the option to invalidate the TB.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>TranslationBlock*</code></strong></dt>
<dd>tb: the TB we are about to execute</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true if we should invalidate the current translation block and retranslate, false otherwise.
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_before_block_translate"><code class="name flex">
<span>def <span class="ident">@panda.cb_before_block_translate</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before translation of each basic block.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC we are about to translate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_before_cpu_exec_exit"><code class="name flex">
<span>def <span class="ident">@panda.cb_before_cpu_exec_exit</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before cpu_exec calls cpu_exec_exit function.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>bool</code></strong></dt>
<dd>ranBlock: true if ran a block since previous cpu_exec_enter</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_before_handle_exception"><code class="name flex">
<span>def <span class="ident">@panda.cb_before_handle_exception</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called just before we are about to handle an exception.
Note: only called for cpu-&gt;exception_index &gt; 0
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>cpu: </dd>
<dt><strong><code>int32_t</code></strong></dt>
<dd>exception_index: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int32_t</code></dt>
<dd>a new exception_index.
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_before_handle_interrupt"><code class="name flex">
<span>def <span class="ident">@panda.cb_before_handle_interrupt</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called just before we are about to handle an interrupt.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>cpu: </dd>
<dt><strong><code>int32_t</code></strong></dt>
<dd>interrupt_request: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int32_t</code></dt>
<dd>new interrupt_rquest
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_before_loadvm"><code class="name flex">
<span>def <span class="ident">@panda.cb_before_loadvm</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called at start of replay, before loadvm is called. This allows us to hook devices' loadvm handlers. Remember to unregister the existing handler for the device first. See the example in the sample plugin.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>void</code></strong></dt>
<dd>: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>unused
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_before_tcg_codegen"><code class="name flex">
<span>def <span class="ident">@panda.cb_before_tcg_codegen</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before host code generation for every basic block. Enables inspection and modification of the TCG block after lifting from guest code.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>TranslationBlock*</code></strong></dt>
<dd>tb: the TB about to be compiled</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>None
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_cpu_restore_state"><code class="name flex">
<span>def <span class="ident">@panda.cb_cpu_restore_state</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called inside of cpu_restore_state(), when there is a CPU fault/exception.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>TranslationBlock*</code></strong></dt>
<dd>tb: the current translation block</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_during_machine_init"><code class="name flex">
<span>def <span class="ident">@panda.cb_during_machine_init</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called in the middle of machine initialization
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>MachineState*</code></strong></dt>
<dd>machine: pointer to the machine state</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>None
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_end_block_exec"><code class="name flex">
<span>def <span class="ident">@panda.cb_end_block_exec</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>This is like after_block_exec except its part of the TCG stream.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>cpu: </dd>
<dt><strong><code>TranslationBlock*</code></strong></dt>
<dd>tb: the TB we are executing</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_guest_hypercall"><code class="name flex">
<span>def <span class="ident">@panda.cb_guest_hypercall</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when a program inside the guest makes a hypercall to pass information from inside the guest to a plugin
Notes: On x86, this is called whenever CPUID is executed. On ARM, the MCR instructions is used. Plugins should check for magic values in the registers to determine if it really is a guest hypercall. Parameters can be passed in other registers. If the plugin processes the hypercall, it should return true so the execution of the normal instruction is skipped.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true if the callback has processed the hypercall, false if the hypercall has been ignored.
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_hd_read"><code class="name flex">
<span>def <span class="ident">@panda.cb_hd_read</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>the type your callback must return</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_hd_write"><code class="name flex">
<span>def <span class="ident">@panda.cb_hd_write</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>the type your callback must return</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_insn_exec"><code class="name flex">
<span>def <span class="ident">@panda.cb_insn_exec</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before execution of any instruction identified by the PANDA_CB_INSN_TRANSLATE callback.
Notes: This instrumentation is implemented by generating a call to a helper function just before the instruction itself is generated. This is fairly expensive, which is why it's only enabled via the PANDA_CB_INSN_TRANSLATE callback.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC we are about to execute</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>unused
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_insn_translate"><code class="name flex">
<span>def <span class="ident">@panda.cb_insn_translate</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before the translation of each instruction.
Notes: This allows a plugin writer to instrument only a small number of instructions, avoiding the performance hit of instrumenting everything. If you do want to instrument every single instruction, just return true. See the documentation for PANDA_CB_INSN_EXEC for more detail.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC we are about to translate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true if PANDA should insert instrumentation into the generated code, false otherwise
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_main_loop_wait"><code class="name flex">
<span>def <span class="ident">@panda.cb_main_loop_wait</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called in IO thread in place where monitor cmds are processed
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>void</code></strong></dt>
<dd>: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>None
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_mmio_after_read"><code class="name flex">
<span>def <span class="ident">@panda.cb_mmio_after_read</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after MMIO memory is read.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>physaddr: the physical address being read from</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>vaddr: the virtual address being read from</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the read</dd>
<dt><strong><code>uint64_t*</code></strong></dt>
<dd>val: the value being read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_mmio_before_write"><code class="name flex">
<span>def <span class="ident">@panda.cb_mmio_before_write</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after MMIO memory is written to.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>physaddr: the physical address being written to</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>vaddr: the virtual address being written to</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the write</dd>
<dt><strong><code>uint64_t*</code></strong></dt>
<dd>val: the value being written</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_monitor"><code class="name flex">
<span>def <span class="ident">@panda.cb_monitor</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when someone uses the plugin_cmd monitor command.
Notes: The command is passed as a single string. No parsing is performed on the string before it is passed to the plugin, so each plugin must parse the string as it deems appropriate (e.g. by using strtok and getopt) to do more complex option processing. It is recommended that each plugin implementing this callback respond to the "help" message by listing the commands supported by the plugin. Note that every loaded plugin will have the opportunity to respond to each plugin_cmd; thus it is a good idea to ensure that your plugin's monitor commands are uniquely named, e.g. by using the plugin name as a prefix ("sample_do_foo" rather than "do_foo").
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>Monitor*</code></strong></dt>
<dd>mon: a pointer to the Monitor</dd>
<dt><strong><code>const</code></strong></dt>
<dd>char* cmd: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>unused
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_phys_mem_after_read"><code class="name flex">
<span>def <span class="ident">@panda.cb_phys_mem_after_read</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after memory is read.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC doing the read</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>addr: the (physical) address being read</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the read</dd>
<dt><strong><code>uint8_t*</code></strong></dt>
<dd>buf: pointer to data just read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_phys_mem_after_write"><code class="name flex">
<span>def <span class="ident">@panda.cb_phys_mem_after_write</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC doing the write</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>addr: the (physical) address being written</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the write</dd>
<dt><strong><code>uint8_t*</code></strong></dt>
<dd>buf: pointer to the data that was written</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_phys_mem_before_read"><code class="name flex">
<span>def <span class="ident">@panda.cb_phys_mem_before_read</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after memory is read.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC doing the read</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>addr: the (physical) address being read</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_phys_mem_before_write"><code class="name flex">
<span>def <span class="ident">@panda.cb_phys_mem_before_write</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC doing the write</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>addr: the (physical) address being written</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the write</dd>
<dt><strong><code>uint8_t*</code></strong></dt>
<dd>buf: pointer to the data that is to be written</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_pre_shutdown"><code class="name flex">
<span>def <span class="ident">@panda.cb_pre_shutdown</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called just before qemu shuts down
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>void</code></strong></dt>
<dd>: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>None
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_qmp"><code class="name flex">
<span>def <span class="ident">@panda.cb_qmp</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when someone sends an unhandled QMP command
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>char*</code></strong></dt>
<dd>command: the command string as json</dd>
<dt><strong><code>char*</code></strong></dt>
<dd>args: the arguments string as json</dd>
<dt><strong><code>char*</code></strong></dt>
<dd>*result: pointer to a json result or NULL</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>the type your callback must return</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_after_dma"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_after_dma</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>const</code></strong></dt>
<dd>uint8_t* buf: </dd>
<dt><strong><code>hwaddr</code></strong></dt>
<dd>addr: address written to in the guest RAM</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: size of transfer</dd>
<dt><strong><code>bool</code></strong></dt>
<dd>is_write: indicates whether the DMA transfer writes to memory</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_before_dma"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_before_dma</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>In replay only. We are about to dma between qemu buffer and guest memory.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>const</code></strong></dt>
<dd>uint8_t* buf: </dd>
<dt><strong><code>hwaddr</code></strong></dt>
<dd>addr: address written to in the guest RAM</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: size of transfer</dd>
<dt><strong><code>bool</code></strong></dt>
<dd>is_write: indicates whether the DMA transfer writes to memory</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_handle_packet"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_handle_packet</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Notes: <code>buf_addr_rec</code> corresponds to the address of the device buffer of the emulated NIC. I.e. it is the address of a VM-host-side buffer. It is useful for implementing network tainting in an OS-agnostic way, in conjunction with taint2_label_io().
FIXME: The <code>buf_addr_rec</code> maps to the <code>uint8_t *buf</code> field of the internal <code>RR_handle_packet_args</code> struct. The field is dumped/loaded to/from the trace without proper serialization/deserialization. As a result, a 64bit build of PANDA will not be able to process traces produced by a 32bit of PANDA, and vice-versa. There are more internal structs that suffer from the same issue. This is an oversight that will eventually be fixed. But as the real impact is minimal (virtually nobody uses 32bit builds), the fix has a very low priority in the bugfix list.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>uint8_t*</code></strong></dt>
<dd>buf: buffer containing packet data</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: num bytes in buffer</dd>
<dt><strong><code>uint8_t</code></strong></dt>
<dd>direction: either <code>PANDA_NET_RX</code> or <code>PANDA_NET_TX</code></dd>
<dt><strong><code>uint64_t</code></strong></dt>
<dd>buf_addr_rec: the address of <code>buf</code> at the time of recording</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_hd_transfer"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_hd_transfer</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>In replay only. Some kind of data transfer involving hard drive.
Notes: Unlike most callbacks, this is neither a "before" or "after" callback. In replay the transfer doesn't really happen. We are <em>at</em> the point at which it happened, really.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>uint32_t</code></strong></dt>
<dd>type: type of transfer
(Hd_transfer_type)</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>src_addr: address for src</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>dest_addr: address for dest</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>num_bytes: size of transfer in bytes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_net_transfer"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_net_transfer</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>In replay only, some kind of data transfer within the network card (currently, only the E1000 is supported).
Notes: Unlike most callbacks, this is neither a "before" or "after" callback. In replay the transfer doesn't really happen. We are <em>at</em> the point at which it happened, really. Also, the src_addr and dest_addr may be for either host (ie. a location in the emulated network device) or guest, depending upon the type.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>uint32_t</code></strong></dt>
<dd>type: type of transfer
(Net_transfer_type)</dd>
<dt><strong><code>uint64_t</code></strong></dt>
<dd>src_addr: address for src</dd>
<dt><strong><code>uint64_t</code></strong></dt>
<dd>dest_addr: address for dest</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>num_bytes: size of transfer in bytes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_serial_read"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_serial_read</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>In replay only, called when a byte read from the serial RX FIFO
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>fifo_addr: address of the data within the fifo (source)</dd>
<dt><strong><code>uint32_t</code></strong></dt>
<dd>port_addr: address of the IO port where data is being read (destination)</dd>
<dt><strong><code>uint8_t</code></strong></dt>
<dd>value: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_serial_receive"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_serial_receive</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>In replay only, called when a byte is received on the serial port.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>fifo_addr: address of the data within the fifo</dd>
<dt><strong><code>uint8_t</code></strong></dt>
<dd>value: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>unused
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_serial_send"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_serial_send</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>In replay only, called when a byte is sent on the serial port.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>fifo_addr: address of the data within the fifo</dd>
<dt><strong><code>uint8_t</code></strong></dt>
<dd>value: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_serial_write"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_serial_write</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>fifo_addr: address of the data within the fifo (source)</dd>
<dt><strong><code>uint32_t</code></strong></dt>
<dd>port_addr: address of the IO port where data is being read (destination)</dd>
<dt><strong><code>uint8_t</code></strong></dt>
<dd>value: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_start_block_exec"><code class="name flex">
<span>def <span class="ident">@panda.cb_start_block_exec</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>This is like before_block_exec except its part of the TCG stream.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>cpu: </dd>
<dt><strong><code>TranslationBlock*</code></strong></dt>
<dd>tb: the TB we are executing</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_top_loop"><code class="name flex">
<span>def <span class="ident">@panda.cb_top_loop</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called at the top of the loop that manages emulation.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>unused
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_unassigned_io_read"><code class="name flex">
<span>def <span class="ident">@panda.cb_unassigned_io_read</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the guest attempts to read from an unmapped peripheral via MMIO
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: </dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: Guest program counter at time of write</dd>
<dt><strong><code>hwaddr</code></strong></dt>
<dd>addr: Physical address written to</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: Size of write</dd>
<dt><strong><code>uint64_t*</code></strong></dt>
<dd>val: Pointer to a buffer that will be passed to the guest as the result of the read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if value read was changed by a PANDA plugin and should be returned False if error-logic (invalid write) should be run
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_unassigned_io_write"><code class="name flex">
<span>def <span class="ident">@panda.cb_unassigned_io_write</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the guest attempts to write to an unmapped peripheral via MMIO
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: </dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: Guest program counter at time of write</dd>
<dt><strong><code>hwaddr</code></strong></dt>
<dd>addr: Physical address written to</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: Size of write</dd>
<dt><strong><code>uint64_t</code></strong></dt>
<dd>val: Data being written, up to 8 bytes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the write should be allowed without error False if normal behavior should be used (error-logic)
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_virt_mem_after_read"><code class="name flex">
<span>def <span class="ident">@panda.cb_virt_mem_after_read</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after memory is read.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC doing the read</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>addr: the (virtual) address being read</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the read</dd>
<dt><strong><code>uint8_t*</code></strong></dt>
<dd>buf: pointer to data just read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_virt_mem_after_write"><code class="name flex">
<span>def <span class="ident">@panda.cb_virt_mem_after_write</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after memory is written.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC doing the write</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>addr: the (virtual) address being written</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the write</dd>
<dt><strong><code>uint8_t*</code></strong></dt>
<dd>buf: pointer to the data that was written</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_virt_mem_before_read"><code class="name flex">
<span>def <span class="ident">@panda.cb_virt_mem_before_read</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before memory is read.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC doing the read</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>addr: the (virtual) address being read</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_virt_mem_before_write"><code class="name flex">
<span>def <span class="ident">@panda.cb_virt_mem_before_write</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before memory is written.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC doing the write</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>addr: the (virtual) address being written</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the write</dd>
<dt><strong><code>uint8_t*</code></strong></dt>
<dd>buf: pointer to the data that is to be written</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.PLogReader"><code class="flex name class">
<span>class <span class="ident">PLogReader</span></span>
<span>(</span><span>fn)</span>
</code></dt>
<dd>
<div class="desc"><p>A class for reading PANDAlog (plog) files. Run directly with <code>python -m
pandare.plog_reader [input.plog]</code> to translate input.plog file to json.</p>
<p>Or the class can be imported and used in a Python script, where it can be iterated over to get
<a href="https://googleapis.dev/python/protobuf/latest/google/protobuf/message.html#google.protobuf.message.Message">google.protobuf.message.Message</a> objects.</p>
<pre><code>with PLogReader('input.plog') as plr:
  for msg in plr:
        if msg.HasField("SomeField"):
          print(msg.SomeField)
        if msg.HasField("OtherField"):
          print(msg.otherField)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PLogReader:
    &#39;&#39;&#39;
    A class for reading PANDAlog (plog) files. Run directly with `python -m  pandare.plog_reader [input.plog]` to translate input.plog file to json.

    Or the class can be imported and used in a Python script, where it can be iterated over to get 
    [google.protobuf.message.Message](https://googleapis.dev/python/protobuf/latest/google/protobuf/message.html#google.protobuf.message.Message) objects.

        with PLogReader(&#39;input.plog&#39;) as plr:
          for msg in plr:
                if msg.HasField(&#34;SomeField&#34;):
                  print(msg.SomeField)
                if msg.HasField(&#34;OtherField&#34;):
                  print(msg.otherField)

    &#39;&#39;&#39;
    def __init__(self, fn):
        self.f = open(fn, &#39;rb&#39;)
        self.version, _, self.dir_pos, _, self.chunk_gsize = struct.unpack(&#39;&lt;IIQII&#39;, self.f.read(24))

        self.f.seek(self.dir_pos)
        self.nchunks, = struct.unpack(&#39;&lt;I&#39;, self.f.read(4)) # number of chunks
        self.chunks = self.f.read(24*self.nchunks)          # chunks buffer
        self.chunk_idx = 0                                  # index of current chunk
        self.chunk_size = 0                                 # size of current chunk
        self.chunk_data = None                              # data of current chunk
        self.chunk_data_idx = 0

    def __iter__(self):
        return self

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.f.close()
        self.f = self.chunk_data = None

    def __next__(self):
        # ran out of chunks
        if not self.chunk_idx &lt; self.nchunks:
            raise StopIteration

        if self.chunk_data is None:
            # unpack ins, pos, nentries for this and the next chunk
            cur = struct.unpack_from(&#39;&lt;QQQ&#39;, self.chunks, 24*self.chunk_idx)
            if self.chunk_idx + 1 &lt; self.nchunks:
                nxt = struct.unpack_from(&#39;&lt;QQQ&#39;, self.chunks, 24*(self.chunk_idx+1))
                zchunk_size = nxt[1] - cur[1]
            else:
                # setting the compressed chunk size to -1 will
                # result in reading the remaining of the file
                zchunk_size = -1

            # read and decompress chunk data
            self.f.seek(cur[1])
            self.chunk_data = zlib.decompress(self.f.read(zchunk_size), 15, self.chunk_gsize)
            self.chunk_size = len(self.chunk_data)
            self.chunk_data_idx = 0

        # parse message - we&#39;re using a fresh message
        # using MergeFromString() is slightly faster than using ParseFromString()
        msg_size, = struct.unpack_from(&#39;&lt;I&#39;, self.chunk_data, self.chunk_data_idx)
        msg = pandare.plog_pb2.LogEntry()
        msg_start = self.chunk_data_idx + 4
        msg_end = msg_start + msg_size
        msg.MergeFromString(self.chunk_data[msg_start:msg_end])

        # update state
        self.chunk_data_idx = msg_end

        if not self.chunk_data_idx &lt; self.chunk_size:
            self.chunk_idx += 1
            self.chunk_size = 0
            self.chunk_data = None
            self.chunk_data_idx = 0

        return msg</code></pre>
</details>
</dd>
<dt id="pandare.Panda"><code class="flex name class">
<span>class <span class="ident">Panda</span></span>
<span>(</span><span>arch='i386', mem='128M', expect_prompt=None, serial_kwargs=None, os_version=None, qcow=None, os='linux', generic=None, raw_monitor=False, extra_args=None, catch_exceptions=True, libpanda_path=None, biospath=None, plugin_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the object used to interact with PANDA. Initializing it creates a virtual machine to interact with.</p>
<p>Construct a new <code><a title="pandare.Panda" href="#pandare.Panda">Panda</a></code> object.
Note that multiple Panda objects cannot coexist in the same Python instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arch</code></strong></dt>
<dd>architecture string (e.g. "i386", "x86_64", "arm", "mips", "mipsel")</dd>
<dt><strong><code>generic</code></strong></dt>
<dd>specify a generic qcow to use from <code>pandare.qcows.SUPPORTED_IMAGES</code> and set all subsequent arguments. Will automatically download qcow if necessary.</dd>
<dt><strong><code>mem</code></strong></dt>
<dd>size of memory for machine (e.g. "128M", "1G")</dd>
<dt><strong><code>expect_prompt</code></strong></dt>
<dd>Regular expression describing the prompt exposed by the guest
on a serial console. Used so we know when a running command has finished
with its output.</dd>
<dt><strong><code>serial_kwargs</code></strong></dt>
<dd>dict of additional arguments to pass to pandare.Expect (see signature of its constructor).
Note that <code>expect_prompt</code> is already passed to Expect as "expectation".
If not explicitly given, "unansi" is set to True (simulates a subset of ANSI codes and attempts to
remove command strings repeated by the shell from the shell output).</dd>
<dt><strong><code>os_version</code></strong></dt>
<dd>analagous to PANDA's -os argument (e.g, linux-32-debian:3.2.0-4-686-pae")</dd>
<dt><strong><code>os</code></strong></dt>
<dd>type of OS (e.g. "linux")</dd>
<dt><strong><code>qcow</code></strong></dt>
<dd>path to a qcow file to load</dd>
<dt><strong><code>catch_exceptions</code></strong></dt>
<dd>Should we catch exceptions raised by python code and end_analysis() and then print a backtrace (Default: True)</dd>
<dt><strong><code>raw_monitor</code></strong></dt>
<dd>When set, don't specify a -monitor. arg Allows for use of
-nographic in args with ctrl-A+C for interactive qemu prompt. Experts only!</dd>
<dt><strong><code>extra_args</code></strong></dt>
<dd>extra arguments to pass to PANDA as either a string or an
array. (e.g. "-nographic" or ["-nographic", "-net", "none"])</dd>
<dt><strong><code>libpanda_path</code></strong></dt>
<dd>path to panda shared object to load</dd>
<dt><strong><code>biospath</code></strong></dt>
<dd>directory that contains "pc-bios" files</dd>
<dt><strong><code>plugin_path</code></strong></dt>
<dd>directory that contains panda plugins</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pandare.Panda" href="#pandare.Panda">Panda</a></code></dt>
<dd>the created panda object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Panda():
    &#39;&#39;&#39;
    This is the object used to interact with PANDA. Initializing it creates a virtual machine to interact with.
    &#39;&#39;&#39;

    def __init__(self, arch=&#34;i386&#34;, mem=&#34;128M&#34;,
            expect_prompt=None, # Regular expression describing the prompt exposed by the guest on a serial console. Used so we know when a running command has finished with its output
            serial_kwargs=None,
            os_version=None,
            qcow=None, # Qcow file to load
            os=&#34;linux&#34;,
            generic=None, # Helper: specify a generic qcow to use and set other arguments. Supported values: arm/ppc/x86_64/i386. Will download qcow automatically
            raw_monitor=False, # When set, don&#39;t specify a -monitor. arg Allows for use of -nographic in args with ctrl-A+C for interactive qemu prompt.
            extra_args=None,
            catch_exceptions=True, # Should we catch and end_analysis() when python code raises an exception?
            libpanda_path=None,
            biospath=None,
            plugin_path=None):
        &#39;&#39;&#39;
        Construct a new `Panda` object.  Note that multiple Panda objects cannot coexist in the same Python instance.
        Args:
            arch: architecture string (e.g. &#34;i386&#34;, &#34;x86_64&#34;, &#34;arm&#34;, &#34;mips&#34;, &#34;mipsel&#34;)
            generic: specify a generic qcow to use from `pandare.qcows.SUPPORTED_IMAGES` and set all subsequent arguments. Will automatically download qcow if necessary.
            mem: size of memory for machine (e.g. &#34;128M&#34;, &#34;1G&#34;)
            expect_prompt: Regular expression describing the prompt exposed by the guest
                    on a serial console. Used so we know when a running command has finished
                    with its output.
            serial_kwargs: dict of additional arguments to pass to pandare.Expect (see signature of its constructor).
                    Note that `expect_prompt` is already passed to Expect as &#34;expectation&#34;.
                    If not explicitly given, &#34;unansi&#34; is set to True (simulates a subset of ANSI codes and attempts to
                    remove command strings repeated by the shell from the shell output).
            os_version: analagous to PANDA&#39;s -os argument (e.g, linux-32-debian:3.2.0-4-686-pae&#34;)
            os: type of OS (e.g. &#34;linux&#34;)
            qcow: path to a qcow file to load
            catch_exceptions: Should we catch exceptions raised by python code and end_analysis() and then print a backtrace (Default: True)
            raw_monitor: When set, don&#39;t specify a -monitor. arg Allows for use of
                    -nographic in args with ctrl-A+C for interactive qemu prompt. Experts only!
            extra_args: extra arguments to pass to PANDA as either a string or an
                    array. (e.g. &#34;-nographic&#34; or [&#34;-nographic&#34;, &#34;-net&#34;, &#34;none&#34;])
            libpanda_path: path to panda shared object to load
            biospath: directory that contains &#34;pc-bios&#34; files
            plugin_path: directory that contains panda plugins
        Returns:
            Panda: the created panda object
        &#39;&#39;&#39;
        self.arch_name = arch
        self.mem = mem
        self.os = os_version
        self.os_type = os
        self.qcow = qcow
        self.plugins = plugin_list(self)
        self.expect_prompt = expect_prompt
        self.lambda_cnt = 0
        self.__sighandler = None
        self.ending = False # True during end_analysis
        self.cdrom = None
        self.catch_exceptions=catch_exceptions
        self.qlog = QEMU_Log_Manager(self)
        self.build_dir = None
        self.plugin_path = plugin_path

        self.serial_unconsumed_data = b&#39;&#39;

        if isinstance(extra_args, str): # Extra args can be a string or array. Use shlex to preserve quoted substrings
            extra_args = shlex_split(extra_args)
        elif extra_args is None:
            extra_args = []

        # If specified, use a generic (x86_64, i386, arm, etc) qcow from MIT and ignore
        if generic:                                 # other args. See details in qcows.py
            print(&#34;using generic &#34; +str(generic))
            q = Qcows.get_qcow_info(generic)
            self.arch_name     = q.arch
            self.os       = q.os
            self.mem      = q.default_mem # Might clobber a specified argument, but required if you want snapshots
            self.qcow     = Qcows.get_qcow(generic)
            self.expect_prompt = q.prompt
            self.cdrom    = q.cdrom
            if q.extra_args:
                extra_args.extend(shlex_split(q.extra_args))

        if self.qcow: # Otherwise we shuld be able to do a replay with no qcow but this is probably broken
            if not (exists(self.qcow)):
                print(&#34;Missing qcow &#39;{}&#39; Please go create that qcow and give it to the PANDA maintainers&#34;.format(self.qcow))

        # panda.arch is a subclass with architecture-specific functions

        self.arch = None # Keep this with the following docstring such that pydoc generats good docs for it; this is a useful variable!
        &#34;&#34;&#34;
        A reference to an auto-instantiated `pandare.arch.PandaArch` subclass (e.g., `pandare.arch.X86Arch`)
        &#34;&#34;&#34;

        if self.arch_name == &#34;i386&#34;:
            self.arch = X86Arch(self)
        elif self.arch_name == &#34;x86_64&#34;:
            self.arch = X86_64Arch(self)
        elif self.arch_name in [&#34;arm&#34;]:
            self.arch = ArmArch(self)
        elif self.arch_name in [&#34;aarch64&#34;]:
            self.arch = Aarch64Arch(self)
        elif self.arch_name in [&#34;mips&#34;, &#34;mipsel&#34;]:
            self.arch = MipsArch(self)
        elif self.arch_name in [&#34;mips64&#34;]:
            self.arch = Mips64Arch(self)
        else:
            raise ValueError(f&#34;Unsupported architecture {self.arch_name}&#34;)
        self.bits, self.endianness, self.register_size = self.arch._determine_bits()

        if libpanda_path:
            environ[&#34;PANDA_LIB&#34;] = self.libpanda_path = libpanda_path
        else:
            build_dir = self.get_build_dir()
            lib_paths = [&#34;libpanda-{0}.so&#34;.format(self.arch_name), &#34;{0}-softmmu/libpanda-{0}.so&#34;.format(self.arch_name)]
            # Select the first path that exists - we&#39;ll have libpanda-{arch}.so for a system install versus arch-softmmu/libpanda-arch.so for a build
            for p in lib_paths:
                if isfile(pjoin(build_dir, p)):
                    self.libpanda_path = pjoin(build_dir, p)
                    break
            else:
                raise RuntimeError(&#34;Couldn&#39;t find libpanda-{0}.so in {1} (in either root or {0}-libpanda directory)&#34;.format(self.arch_name, build_dir))

        self.panda = self.libpanda_path # Necessary for realpath to work inside core-panda, may cause issues?

        self.ffi = self._do_types_import()

        self.libpanda = self.ffi.dlopen(self.libpanda_path)
        self.C = self.ffi.dlopen(None)

        # set OS name if we have one
        if self.os:
            self.set_os_name(self.os)

        # Setup argv for panda
        self.panda_args = [self.panda]

        if biospath is None:
            biospath = realpath(pjoin(self.get_build_dir(), &#34;pc-bios&#34;)) # XXX: necessary for network drivers for arm/mips, so &#39;pc-bios&#39; is a misleading name
        self.panda_args.append(&#34;-L&#34;)
        self.panda_args.append(biospath)

        if self.qcow:
            if self.arch_name == &#39;mips64&#39;:
                # XXX: mips64 needs virtio interface for the qcow
                self.panda_args.extend([&#34;-drive&#34;, f&#34;file={self.qcow},if=virtio&#34;])
            else:
                self.panda_args.append(self.qcow)

        self.panda_args += extra_args

        # Configure memory options
        self.panda_args.extend([&#39;-m&#39;, self.mem])

        # Configure serial - if we have an expect_prompt set. Otherwise how can we know what guest cmds are outputting?
        if self.expect_prompt or (serial_kwargs is not None and serial_kwargs.get(&#39;expectation&#39;)):
            self.serial_file = NamedTemporaryFile(prefix=&#34;pypanda_s&#34;).name
            self.serial_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            expect_kwargs = {&#39;expectation&#39;: self.expect_prompt, &#39;consume_first&#39;: False, &#39;unansi&#39;: True}
            if serial_kwargs:
                expect_kwargs.update(serial_kwargs)
            self.serial_console = Expect(&#39;serial&#39;, **expect_kwargs)
            self.panda_args.extend([&#39;-serial&#39;, &#39;unix:{},server,nowait&#39;.format(self.serial_file)])
        else:
            self.serial_file = None
            self.serial_socket = None
            self.serial_console = None

        # Configure monitor - Always enabled for now
        self.monitor_file = NamedTemporaryFile(prefix=&#34;pypanda_m&#34;).name
        self.monitor_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.raw_monitor = raw_monitor
        if not self.raw_monitor:
            # XXX don&#39;t forget to escape expectation regex parens!
            self.monitor_console = Expect(&#39;monitor&#39;, expectation=rb&#34;\(qemu\) &#34;, consume_first=True)
            self.panda_args.extend([&#39;-monitor&#39;, &#39;unix:{},server,nowait&#39;.format(self.monitor_file)])

        self.running = threading.Event()
        self.started = threading.Event()
        self.initializing = threading.Event()
        self.athread = AsyncThread(self.started) # athread manages actions that need to occur outside qemu&#39;s CPU loop

        # Callbacks
        self.register_cb_decorators()
        self.plugin_register_count = 0
        self.registered_callbacks = {} # name -&gt; {procname: &#34;bash&#34;, enabled: False, callback: None}

        # Register asid_changed CB if and only if a callback requires procname
        self._registered_asid_changed_internal_cb = False
        self._registered_mmap_cb = False

        self._initialized_panda = False
        self.disabled_tb_chaining = False
        self.named_hooks = {}
        self.hook_list = []
        self.hook_list2 = {}
        self.mem_hooks = {}
        self.sr_hooks = []
        self.hypercalls = {}

        # Asid stuff
        self.current_asid_name = None
        self.asid_mapping = {}

        # Shutdown stuff
        self.exception = None # When set to an exn, we&#39;ll raise and exit
        self._in_replay = False

        # cosi
        self.cosi = Cosi(self)

        # main_loop_wait functions and callbacks
        self.main_loop_wait_fnargs = [] # [(fn, args), ...]
        progress (&#34;Panda args: [&#34; + (&#34; &#34;.join(self.panda_args)) + &#34;]&#34;)
    # /__init__

    def get_plugin_path(self):
        if self.plugin_path is None:
            build_dir = self.get_build_dir()
            rel_dir = pjoin(*[build_dir, self.arch_name+&#34;-softmmu&#34;, &#34;panda&#34;, &#34;plugins&#34;])

            if build_dir == &#34;/usr/local/bin/&#34;:
                # Installed - use /usr/local/lib/panda/plugins
                self.plugin_path = f&#34;/usr/local/lib/panda/{self.arch_name}&#34;
            elif isdir(rel_dir):
                self.plugin_path = rel_dir
            else:
                raise ValueError(f&#34;Could not find plugin path. Build dir={build_dir}&#34;)
        return self.plugin_path

    def get_build_dir(self):
        if self.build_dir is None:
            self.build_dir  = find_build_dir(self.arch_name)
            environ[&#34;PANDA_DIR&#34;] = self.build_dir
        return self.build_dir

    def _do_types_import(self):
        &#39;&#39;&#39;
        Import objects from panda_datatypes which are configured by the environment variables(?)
        Check the DATATTYPES_VERSION to detect if panda_datatypes.py has gotten stale.

        Store these objects in self.callback and self.callback_dictionary

        Returns a handle to the FFI object for the libpanda object
        &#39;&#39;&#39;

        required_datatypes_version = 1.1
        version_err = &#34;Your panda_datatypes.py is out of date (has version {} but PANDA &#34; \
                      &#34;requires version {}). Please reinstall pypanda or re-run &#34;\
                      &#34;create_panda_datatypes.py.&#34;
        try:
            from .autogen.panda_datatypes import DATATYPES_VERSION
        except ImportError:
            raise RuntimeError(version_err.format(None, required_datatypes_version))

        if required_datatypes_version != DATATYPES_VERSION:
            raise RuntimeError(version_err.format(DATATYPES_VERSION, required_datatypes_version))


        from importlib import import_module
        from .autogen.panda_datatypes import get_cbs
        panda_arch_support = import_module(f&#34;.autogen.panda_{self.arch_name}_{self.bits}&#34;,package=&#39;pandare&#39;)

        ffi = panda_arch_support.ffi
        self.callback, self.callback_dictionary = get_cbs(ffi)

        return ffi

    def _initialize_panda(self):
        &#39;&#39;&#39;
        After initializing the class, the user has a chance to do something
        (TODO: what? register callbacks? It&#39;s something important...) before we finish initializing
        &#39;&#39;&#39;
        self.libpanda._panda_set_library_mode(True)

        cenvp = self.ffi.new(&#34;char**&#34;, self.ffi.new(&#34;char[]&#34;, b&#34;&#34;))
        len_cargs = self.ffi.cast(&#34;int&#34;, len(self.panda_args))
        panda_args_ffi = [self.ffi.new(&#34;char[]&#34;, bytes(str(i),&#34;utf-8&#34;)) for i in self.panda_args]
        self.libpanda.panda_init(len_cargs, panda_args_ffi, cenvp)

        # Now we&#39;ve run qemu init so we can connect to the sockets for the monitor and serial
        if self.serial_console and not self.serial_console.is_connected():
            self.serial_socket.connect(self.serial_file)
            self.serial_socket.settimeout(None)
            self.serial_console.connect(self.serial_socket)
        if not self.raw_monitor and not self.monitor_console.is_connected():
            self.monitor_socket.connect(self.monitor_file)
            self.monitor_console.connect(self.monitor_socket)

        # Register __main_loop_wait_callback
        self.register_callback(self.callback.main_loop_wait,
                self.callback.main_loop_wait(self.__main_loop_wait_cb), &#39;__main_loop_wait&#39;)

        self._initialized_panda = True

    def __main_loop_wait_cb(self):
        &#39;&#39;&#39;
        __main_loop_wait_cb is called at the start of the main cpu loop in qemu.
        This is a fairly safe place to call into qemu internals but watch out for deadlocks caused
        by your request blocking on the guest&#39;s execution. Here any functions in main_loop_wait_fnargs will be called
        &#39;&#39;&#39;
        try:
            # Then run any and all requested commands
            if len(self.main_loop_wait_fnargs) == 0: return
            #progress(&#34;Entering main_loop_wait_cb&#34;)
            for fnargs in self.main_loop_wait_fnargs:
                (fn, args) = fnargs
                ret = fn(*args)
            self.main_loop_wait_fnargs = []
        except KeyboardInterrupt:
            self.end_analysis()

    def queue_main_loop_wait_fn(self, fn, args=[]):
        &#39;&#39;&#39;
        Queue a function to run at the next main loop
        fn is a function we want to run, args are arguments to apss to it
        &#39;&#39;&#39;
        self.main_loop_wait_fnargs.append((fn, args))

    def exit_cpu_loop(self):
        &#39;&#39;&#39;
        Stop cpu execution at nearest juncture.
        &#39;&#39;&#39;
        self.libpanda.panda_exit_loop = True

    def revert_async(self, snapshot_name): # In the next main loop, revert
        &#39;&#39;&#39;
        Request a snapshot revert, eventually. This is fairly dangerous
        because you don&#39;t know when it finishes. You should be using revert_sync
        from a blocking function instead
        &#39;&#39;&#39;
        if not hasattr(self, &#39;warned_async&#39;):
            self.warned_async = True
            print(&#34;WARNING: panda.revert_async may be deprecated in the near future&#34;)
        if debug:
            progress (&#34;Loading snapshot &#34; + snapshot_name)

        # Stop guest, queue up revert, then continue
        timer_start = time()
        self.vm_stop()
        charptr = self.ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
        self.queue_main_loop_wait_fn(self.libpanda.panda_revert, [charptr])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont)
        if debug:
            self.queue_main_loop_wait_fn(self._finish_timer, [timer_start, &#34;Loaded snapshot&#34;])

    def reset(self):
        &#34;&#34;&#34;In the next main loop, reset to boot&#34;&#34;&#34;
        if debug:
            progress (&#34;Resetting machine to start state&#34;)

        # Stop guest, queue up revert, then continue
        self.vm_stop()
        self.queue_main_loop_wait_fn(self.libpanda.panda_reset)
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont)

    def cont(self):
        &#39;&#39;&#39; Continue execution (run after vm_stop) &#39;&#39;&#39;
        self.libpanda.panda_cont()
        self.running.set()

    def vm_stop(self, code=4):
        &#39;&#39;&#39; Stop execution, default code means RUN_STATE_PAUSED &#39;&#39;&#39;
        self.libpanda.panda_stop(code)

    def snap(self, snapshot_name):
        &#39;&#39;&#39;
        Create snapshot with specified name

        Args:
            snapshot_name (str): name of the snapshot

        Returns:
            None
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Creating snapshot &#34; + snapshot_name)

        # Stop guest execution, queue up a snapshot, then continue
        timer_start = time()
        self.vm_stop()
        charptr = self.ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
        self.queue_main_loop_wait_fn(self.libpanda.panda_snap, [charptr])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont)
        if debug:
            self.queue_main_loop_wait_fn(self._finish_timer, [timer_start, &#34;Saved snapshot&#34;])

    def delvm(self, snapshot_name):
        &#39;&#39;&#39;
        Delete snapshot with specified name
        Args:
            snapshot_name (str): name of the snapshot

        Returns:
            None
        &#39;&#39;&#39;

        if debug:
            progress (&#34;Deleting snapshot &#34; + snapshot_name)

        # Stop guest, queue up delete, then continue
        self.vm_stop()
        charptr = self.ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
        self.queue_main_loop_wait_fn(self.libpanda.panda_delvm, [charptr])

    def _finish_timer(self, start, msg):
        &#39;&#39;&#39; Print how long some (main_loop_wait) task took &#39;&#39;&#39;
        t = time() - start
        print(&#34;{} in {:.08f} seconds&#34;.format(msg, t))


    def enable_tb_chaining(self):
        &#39;&#39;&#39;
        This function enables translation block chaining in QEMU
        &#39;&#39;&#39;
        if debug:
            progress(&#34;Enabling TB chaining&#34;)
        self.disabled_tb_chaining = False
        self.libpanda.panda_enable_tb_chaining()

    def disable_tb_chaining(self):
        &#39;&#39;&#39;
        This function disables translation block chaining in QEMU
        &#39;&#39;&#39;
        if not self.disabled_tb_chaining:
            if debug:
                progress(&#34;Disabling TB chaining&#34;)
            self.disabled_tb_chaining = True
            self.libpanda.panda_disable_tb_chaining()

    def _setup_internal_signal_handler(self, signal_handler=None):
        def SigHandler(SIG,a,b):
            from signal import SIGINT, SIGHUP, SIGTERM
            if SIG == SIGINT:
                self.exit_exception = KeyboardInterrupt
                self.end_analysis()
            elif SIG == SIGHUP:
                self.exit_exception = KeyboardInterrupt
                self.end_analysis()
            elif SIG == SIGTERM:
                self.exit_exception = KeyboardInterrupt
                self.end_analysis()
            else:
                print(f&#34;PyPanda Signal handler received unhandled signal {SIG}&#34;)


        if signal_handler is not None:
            # store custom signal handler if requested1
            self.__sighandler = signal_handler

        if self._initialized_panda:
            # initialize and register signal handler only if panda is initialized
            self.__sighandler = (self.ffi.callback(&#34;void(int,void*,void*)&#34;, SigHandler)
                       if signal_handler is None and self.__sighandler is None
                       else self.ffi.callback(&#34;void(int,void*,void*)&#34;, self.__sighandler))

            self.libpanda.panda_setup_signal_handling(self.__sighandler)


    def run(self):
        &#39;&#39;&#39;
        This function starts our running PANDA instance from Python. At termination this function returns and the script continues to run after it.

        This function starts execution of the guest. It blocks until guest finishes.
        It also initializes panda object, clears main_loop_wait fns, and sets up internal callbacks.

        Args:
            None

        Returns:
            None: When emulation has finished due to guest termination, replay conclusion or a call to `Panda.end_analysis`
        &#39;&#39;&#39;

        if len(self.main_loop_wait_fnargs):
            if debug:
                print(&#34;Clearing prior main_loop_wait fns:&#34;, self.main_loop_wait_fnargs)
            self.main_loop_wait_fnargs = [] # [(fn, args), ...]

        self.ending = False

        if debug:
            progress (&#34;Running&#34;)

        self.initializing.set()
        if not self._initialized_panda:
            self._initialize_panda()
        self.initializing.clear()

        if not self.started.is_set():
            self.started.set()

        self.athread.ending = False

        # Ensure our internal CBs are always enabled
        self.enable_internal_callbacks()
        self._setup_internal_signal_handler()
        self.running.set()
        self.libpanda.panda_run() # Give control to panda
        self.running.clear() # Back from panda&#39;s execution (due to shutdown or monitor quit)
        self.unload_plugins() # Unload pyplugins and C plugins
        self.delete_callbacks() # Unload any registered callbacks
        self.plugins = plugin_list(self)
        # Write PANDALOG, if any
        #self.libpanda.panda_cleanup_record()
        if self._in_replay:
            self.reset()
        if hasattr(self, &#34;exit_exception&#34;):
            saved_exception = self.exit_exception
            del self.exit_exception
            raise saved_exception


    def end_analysis(self):
        &#39;&#39;&#39;
        Stop running machine.

        Call from any thread to unload all plugins and stop all queued functions.
        If called from async thread or a callback, it will also unblock panda.run()

        Note here we use the async class&#39;s internal thread to process these
        without needing to wait for tasks in the main async thread
        &#39;&#39;&#39;
        self.athread.ending = True
        self.ending = True
        self.unload_plugins()
        if self.running.is_set() or self.initializing.is_set():

            # If we were running, stop the execution and check if we crashed
            self.queue_async(self.stop_run, internal=True)

    def record(self, recording_name, snapshot_name=None):
        &#34;&#34;&#34;Begins active recording with name provided.

        Args:
            recording_name (string): name of recording to save.
            snapshot_name (string, optional): Before recording starts restore to this snapshot name. Defaults to None.

        Raises:
            Exception: raises exception if there was an error starting recording.
        &#34;&#34;&#34;
        if snapshot_name == None:
            snapshot_name_ffi = self.ffi.NULL
        else:
            snapshot_name_ffi = self.ffi.new(&#34;char[]&#34;,snapshot_name.encode())
        recording_name_ffi = self.ffi.new(&#34;char[]&#34;, recording_name.encode())
        result = self.libpanda.panda_record_begin(recording_name_ffi,snapshot_name_ffi)
        res_string_enum = self.ffi.string(self.ffi.cast(&#34;RRCTRL_ret&#34;,result))
        if res_string_enum != &#34;RRCTRL_OK&#34;:
           raise Exception(f&#34;record method failed with RTCTL_ret {res_string_enum} ({result})&#34;)

    def end_record(self):
        &#34;&#34;&#34;Stop active recording.

        Raises:
            Exception: raises exception if there was an error stopping recording.
        &#34;&#34;&#34;
        result = self.libpanda.panda_record_end()
        res_string_enum = self.ffi.string(self.ffi.cast(&#34;RRCTRL_ret&#34;,result))
        if res_string_enum != &#34;RRCTRL_OK&#34;:
           raise Exception(f&#34;record method failed with RTCTL_ret {res_string_enum} ({result})&#34;)

    def recording_exists(self, name):
        &#39;&#39;&#39;
        Checks if a recording file exists on disk.

        Args:
            name (str): name of the recording to check for (e.g., `foo` which uses `foo-rr-snp` and `foo-rr-nondet.log`)
        
        Returns:
            boolean: true if file exists, false otherwise
        &#39;&#39;&#39;
        if exists(name + &#34;-rr-snp&#34;) or rr2_contains_member(name, &#34;snapshot&#34;):
            return True

    def run_replay(self, replaypfx):
        &#39;&#39;&#39;
        Load a replay and run it. Starts PANDA execution and returns after end of VM execution.

        Args:
            replaypfx (str): Replay name/path (e.g., &#34;foo&#34; or &#34;./dir/foo&#34;)

        Returns:
            None
        &#39;&#39;&#39;
        if (not isfile(replaypfx+&#34;-rr-snp&#34;) or not isfile(replaypfx+&#34;-rr-nondet.log&#34;)) and not rr2_recording(replaypfx):
            raise ValueError(&#34;Replay files not present to run replay of {}&#34;.format(replaypfx))

        self.ending = False

        if debug:
            progress (&#34;Replaying %s&#34; % replaypfx)

        charptr = self.ffi.new(&#34;char[]&#34;,bytes(replaypfx,&#34;utf-8&#34;))
        self.libpanda.panda_replay_begin(charptr)
        self._in_replay = True
        self.run()
        self._in_replay = False


    def end_replay(self):
        &#39;&#39;&#39;
        Terminates a currently running replay

            Returns:
                None

            Raises:
                Exception: raises exception if no replay is active or termination failed.
        &#39;&#39;&#39;

        if self._in_replay is False:
            raise Exception(&#34;Tried to terminate replay while not in replay mode!&#34;)

        result = self.libpanda.panda_replay_end()

        res_string_enum = self.ffi.string(self.ffi.cast(&#34;RRCTRL_ret&#34;,result))
        if res_string_enum != &#34;RRCTRL_OK&#34;:
           raise Exception(f&#34;ending record method failed with RTCTL_ret {res_string_enum} ({result})&#34;)


    def require(self, name):
        &#39;&#39;&#39;
        Load a C plugin with no arguments. Deprecated. Use load_plugin
        &#39;&#39;&#39;
        self.load_plugin(name, args={})
    
    def _plugin_loaded(self, name):
        name_c = self.ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
        return self.libpanda.panda_get_plugin_by_name(name_c) != self.ffi.NULL

    def load_plugin(self, name, args={}):
        &#39;&#39;&#39;
        Load a C plugin, optionally with arguments

        Args:
            name (str): Name of plugin
            args (dict): Arguments matching key to value. e.g. {&#34;key&#34;: &#34;value&#34;} sets option `key` to `value`.

        Returns:
            None.
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Loading plugin %s&#34; % name),

        argstrs_ffi = []
        if isinstance(args, dict):
            for k,v in args.items():
                this_arg_s = &#34;{}={}&#34;.format(k,v)
                this_arg = self.ffi.new(&#34;char[]&#34;, bytes(this_arg_s, &#34;utf-8&#34;))
                argstrs_ffi.append(this_arg)

            n = len(args.keys())
        elif isinstance(args, list):
            for arg in args:
                this_arg = self.ffi.new(&#34;char[]&#34;, bytes(arg, &#34;utf-8&#34;))
                argstrs_ffi.append(this_arg)
            n = len(args)

        else:
            raise ValueError(&#34;Arguments to load plugin must be a list or dict of key/value pairs&#34;)

        # First set qemu_path so plugins can load (may be unnecessary after the first time)
        assert(self.panda), &#34;Unknown location of PANDA&#34;
        panda_name_ffi = self.ffi.new(&#34;char[]&#34;, bytes(self.panda,&#34;utf-8&#34;))
        self.libpanda.panda_set_qemu_path(panda_name_ffi)

        if len(argstrs_ffi):
            plugin_args = argstrs_ffi
        else:
            plugin_args = self.ffi.NULL

        charptr = self.ffi.new(&#34;char[]&#34;, bytes(name,&#34;utf-8&#34;))
        self.libpanda.panda_require_from_library(charptr, plugin_args, len(argstrs_ffi))
        self._load_plugin_library(name)

    def _procname_changed(self, cpu, name):
        for cb_name, cb in self.registered_callbacks.items():
            if not cb[&#34;procname&#34;]:
                continue
            if name == cb[&#34;procname&#34;] and not cb[&#39;enabled&#39;]:
                self.enable_callback(cb_name)
            if name != cb[&#34;procname&#34;] and cb[&#39;enabled&#39;]:
                self.disable_callback(cb_name)

    def unload_plugin(self, name):
        &#39;&#39;&#39;
        Unload plugin with given name.

        Args:
            name (str): Name of plug

        Returns:
            None
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Unloading plugin %s&#34; % name),
        name_ffi = self.ffi.new(&#34;char[]&#34;, bytes(name,&#34;utf-8&#34;))
        self.libpanda.panda_unload_plugin_by_name(name_ffi)

    def _unload_pyplugins(self):
        # First unload python plugins, should be safe to do anytime
        while len(list(self.registered_callbacks)) &gt; 0:
            try:
                self.delete_callback(list(self.registered_callbacks.keys())[0])
            except IndexError:
                continue
            #self.disable_callback(name)

        # Next, unload any pyplugins
        if hasattr(self, &#34;_pyplugin_manager&#34;):
            self.pyplugins.unload_all()

    def unload_plugins(self):
        &#39;&#39;&#39;
        Disable all python plugins and request to unload all c plugins
        at the next main_loop_wait.

        XXX: If called during shutdown/exit, c plugins won&#39;t be unloaded
        because the next main_loop_wait will never happen. Instead, call
        panda.panda_finish directly (which is done at the end of panda.run())
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Disabling all python plugins, unloading all C plugins&#34;)

        # In next main loop wait, unload all python plugin
        self.queue_main_loop_wait_fn(self._unload_pyplugins)

        # Then unload C plugins. May be unsafe to do except from the top of the main loop (taint segfaults otherwise)
        self.queue_main_loop_wait_fn(self.libpanda.panda_unload_plugins)

    def memsavep(self, file_out):
        &#39;&#39;&#39;
        Calls QEMU memsavep on your specified python file.
        &#39;&#39;&#39;
        # this part was largely copied from https://cffi.readthedocs.io/en/latest/ref.html#support-for-file

        file_out.flush()                 # make sure the file is flushed
        newfd = dup(file_out.fileno())   # make a copy of the file descriptor
        fileptr = self.C.fdopen(newfd, b&#34;w&#34;)
        self.libpanda.panda_memsavep(fileptr)
        self.C.fclose(fileptr)

    def physical_memory_read(self, addr, length, fmt=&#39;bytearray&#39;):
        &#39;&#39;&#39;
        Read guest physical memory. In the specified format. Note that the `ptrlist` format
        returns a list of integers, each of the specified architecture&#39;s pointer size.

        Args:
            addr (int): Address
            length (int): length of array you would like returned
            fmt (str): format for returned array. Options: &#39;bytearray&#39;, &#39;int&#39;, &#39;str&#39;, &#39;ptrlist&#39;

        Returns:
            Union[bytearray, int, str, list[int]]: memory data

        Raises:
            ValueError if memory access fails or fmt is unsupported
        &#39;&#39;&#39;
        return self._memory_read(None, addr, length, physical=True, fmt=fmt)

    def virtual_memory_read(self, cpu, addr, length, fmt=&#39;bytearray&#39;):
        &#39;&#39;&#39;
        Read guest virtual memory.

        Args:
            cpu (CPUState): CPUState structure
            addr (int): Address
            length (int): length of data you would like returned
            fmt: format for returned array. See `physical_memory_read`.

        Returns:
            Union[bytearray, int, str, list[int]]: memory data

        Raises:
            ValueError if memory access fails or fmt is unsupported
        &#39;&#39;&#39;

        return self._memory_read(cpu, addr, length, physical=False, fmt=fmt)

    def _memory_read(self, env, addr, length, physical=False, fmt=&#39;bytearray&#39;):
        &#39;&#39;&#39;
        Read but with an autogen&#39;d buffer
        Supports physical or virtual addresses
        Raises ValueError if read fails
        &#39;&#39;&#39;
        if not isinstance(addr, int):
            raise ValueError(f&#34;Unsupported read from address {repr(addr)}&#34;)

        buf = self.ffi.new(&#34;char[]&#34;, length)

        # Force CFFI to parse addr as an unsigned value. Otherwise we get OverflowErrors
        # when it decides that it&#39;s negative
        ptr_typ = f&#39;uint{self.bits}_t&#39;
        addr_u = int(self.ffi.cast(ptr_typ, addr))

        buf_a = self.ffi.cast(&#34;char*&#34;, buf)
        length_a = self.ffi.cast(&#34;int&#34;, length)
        if physical:
            err = self.libpanda.panda_physical_memory_read_external(addr_u, buf_a, length_a)
        else:
            if &#34;osi_linux&#34; in self.plugins.keys() or self._plugin_loaded(&#34;osi_linux&#34;):
                err = self.plugins[&#34;osi_linux&#34;].osi_linux_virtual_memory_read(env, addr_u, buf_a, length_a)
            else:
                err = self.libpanda.panda_virtual_memory_read_external(env, addr_u, buf_a, length_a)

        if err &lt; 0:
            # TODO: We should support a custom error class instead of a generic ValueError
            raise ValueError(f&#34;Failed to read guest memory at {addr:x} got err={err}&#34;)

        r = self.ffi.unpack(buf, length)
        if fmt == &#39;bytearray&#39;:
            return r
        elif fmt==&#39;int&#39;:
            return int.from_bytes(r, byteorder=self.endianness)  # XXX size better be small enough to pack into an int!
        elif fmt==&#39;str&#39;:
            return self.ffi.string(buf, length)
        elif fmt==&#39;ptrlist&#39;:
            # This one is weird. Chunk the memory into byte-sequences of (self.bits/8) bytes and flip endianness as approperiate
            # return a list
            bytelen = int(self.bits/8)
            if (length % bytelen != 0):
                raise ValueError(f&#34;Memory of size {length} does not evenly divide into {bytelen} byte chunks&#34;)
            chunks = []
            for start in range(0, length, bytelen):
                data = r[start:start+bytelen]
                int_data = int.from_bytes(data, byteorder=self.endianness)
                chunks.append(int_data)
            return chunks

        else:
            raise ValueError(&#34;fmt={} unsupported&#34;.format(fmt))

    def physical_memory_write(self, addr, buf):
        &#39;&#39;&#39;
        Write guest physical memory.

        Args:
            addr (int): Address
            buf (bytestring):  byte string to write into memory

        Returns:
            None

        Raises:
            ValueError if the call to panda.physical_memory_write fails (e.g., if you pass a pointer to an invalid memory region)
        &#39;&#39;&#39;
        self._memory_write(None, addr, buf, physical=True)

    def virtual_memory_write(self, cpu, addr, buf):
        &#39;&#39;&#39;
        Write guest virtual memory.

        Args:
            cpu (CPUState): CPUState structure
            address (int): Address
            buf (bytestr): byte string to write into memory

        Returns:
            None

        Raises:
            ValueError if the call to panda.virtual_memory_write fails (e.g., if you pass a pointer to an unmapped page)
        &#39;&#39;&#39;
        self._memory_write(cpu, addr, buf, physical=False)

    def _memory_write(self, cpu, addr, buf, physical=False):
        &#39;&#39;&#39;
        Write a bytearray into memory at the specified physical/virtual address
        &#39;&#39;&#39;
        length = len(buf)
        c_buf = self.ffi.new(&#34;char[]&#34;,buf)
        buf_a = self.ffi.cast(&#34;char*&#34;, c_buf)
        length_a = self.ffi.cast(&#34;int&#34;, length)

        if not hasattr(self, &#34;_memcb&#34;): # XXX: Why do we enable memcbs for memory writes?
            self.enable_memcb()

        if physical:
            err = self.libpanda.panda_physical_memory_write_external(addr, buf_a, length_a)
        else:
            err = self.libpanda.panda_virtual_memory_write_external(cpu, addr, buf_a, length_a)

        if err &lt; 0:
            raise ValueError(f&#34;Memory write failed with err={err}&#34;) # TODO: make a PANDA Exn class

    def callstack_callers(self, lim, cpu): # XXX move into new directory, &#39;callstack&#39; ?
        &#39;&#39;&#39;
        Helper function for callstack_instr plugin
        Handle conversion and return get_callers from callstack_instr.
        &#39;&#39;&#39;
        if not &#34;callstack_instr&#34; in self.plugins:
            progress(&#34;enabling callstack_instr plugin&#34;)
            self.load_plugin(&#34;callstack_instr&#34;)

        callers = self.ffi.new(&#34;uint%d_t[%d]&#34; % (self.bits, lim))
        n = self.plugins[&#39;callstack_instr&#39;].get_callers(callers, lim, cpu)
        c = []
        for pc in callers:
            c.append(pc)
        return c

    def _load_plugin_library(self, name):
        if hasattr(self,&#34;__did_load_libpanda&#34;):
            libpanda_path_chr = self.ffi.new(&#34;char[]&#34;,bytes(self.libpanda_path, &#34;UTF-8&#34;))
            self.__did_load_libpanda = self.libpanda.panda_load_libpanda(libpanda_path_chr)
        if not name in self.plugins.keys():
            plugin = pjoin(*[self.get_plugin_path(), f&#34;panda_{name}.so&#34;])
            assert(isfile(plugin))
            self.plugins[name] = self.ffi.dlopen(plugin)

    def queue_async(self, f, internal=False):
        &#39;&#39;&#39;
        Explicitly queue work in the asynchronous work queue.

        Args:
            f: A python function with no arguments to be called at a later time. The function should
            be decorated with `@pandare.blocking`. You generally want to use `panda.queue_blocking` over this function.

        Returns:
            None
        &#39;&#39;&#39;

        # this takes the blocking function and handles errors
        @blocking
        def wrapper():
            try:
                f()
            except Exception as e:
                if self.catch_exceptions:
                    self.exit_exception = e
                    self.end_analysis()
                else:
                    raise e

        # Keep the original function name instead of replacing it with &#39;wrapper&#39;
        wrapper.__name__ = f.__name__
        self.athread.queue(wrapper, internal=internal)

    def map_memory(self, name, size, address):

        &#39;&#39;&#39;
        Make a new memory region.

        Args:
            name (str): This is an internal reference name for this region. Must be unique.
            size (int): number of bytes the region should be.
            address (int): start address of region

        Returns:
            None
        &#39;&#39;&#39;

        name_c = self.ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
        size = ceil(size/1024)*1024 # Must be page-aligned
        return self.libpanda.map_memory(name_c, size, address)

    def read_str(self, cpu, ptr, max_length=None):
        &#39;&#39;&#39;
        Helper to read a null-terminated string from guest memory given a pointer and CPU state
        May return an exception if the call to panda.virtual_memory_read fails (e.g., if you pass a
        pointer to an unmapped page)

        Args:
            cpu (CPUState): CPUState structure
            ptr (int): Pointer to start of string
            max_length (int): Optional length to stop reading at

        Returns:
            string: Data read from memory

        &#39;&#39;&#39;
        r = b&#34;&#34;
        idx = 0
        while (max_length is None or idx &lt; max_length):
            next_char = self.virtual_memory_read(cpu, ptr, 1) # If this raises an exn, don&#39;t mask it
            if next_char == b&#34;\x00&#34;:
                break
            r += next_char
            ptr += 1
            idx += 1
        return r.decode(&#34;utf8&#34;, &#34;ignore&#34;)

    def to_unsigned_guest(self, x):
        &#39;&#39;&#39;
        Convert a singed python int to an unsigned int32/unsigned int64
        depending on guest bit-size

        Args:
            x (int): Python integer

        Returns:
            int: Python integer representing x as an unsigned value in the guest&#39;s pointer-size.
        &#39;&#39;&#39;
        import ctypes
        if self.bits == 32:
            return ctypes.c_uint32(x).value
        elif self.bits == 64:
            return ctypes.c_uint64(x).value
        else:
            raise ValueError(&#34;Unsupported number of bits&#34;)

    def from_unsigned_guest(self, x):
        &#39;&#39;&#39;
        Convert an unsigned int32/unsigned int64 from the guest
        (depending on guest bit-size) to a (signed) python int

        Args:
            x (int): Python integer representing an unsigned value in the guest&#39;s pointer-size

        Returns:
            int: Python integer representing x as a signed value
        &#39;&#39;&#39;
        if x &gt;= 2**(self.bits-1): # If highest bit is set, it&#39;s negative
            return (x - 2**self.bits)
        else: # Else it&#39;s positive
            return x

    def queue_blocking(self, func, queue=True):
        &#34;&#34;&#34;
        Decorator to mark a function as `blocking`, and (by default) queue it to run asynchronously.
        This should be used to mark functions that will drive guest execution. Functions will be run
        in the order they are defined. For more precise control, use `panda.queue_async`.


        ```
        @panda.queue_blocking
        def do_something():
            panda.revert_sync(&#39;root&#39;)
            print(panda.run_serial_cmd(&#39;whoami&#39;))
            panda.end_analysis()
        ```

        is equivalent to

        ```
        @blocking
        def run_whoami():
            panda.revert_sync(&#39;root&#39;)
            print(panda.run_serial_cmd(&#39;whoami&#39;))
            panda.end_analysis()

        panda.queue_async(run_whoami)
        ```

        Args:
            func (function): Function to queue
            queue (bool): Should function automatically be queued

        Returns:
            None

        &#34;&#34;&#34;
        f = blocking(func)
        if queue:
            self.queue_async(f)
        return f

    # PyPlugin helpers
    @property
    def pyplugins(self):
        &#34;&#34;&#34;
        A reference to an auto-instantiated `pandare.pyplugin.PyPluginManager` class.
        &#34;&#34;&#34;
        if not hasattr(self, &#34;_pyplugin_manager&#34;):
            from .pypluginmanager import PyPluginManager
            self._pyplugin_manager = PyPluginManager(self)
        return self._pyplugin_manager


    ########################## LIBPANDA FUNCTIONS ########################
    # Methods that directly pass data to/from PANDA with no extra logic beyond argument reformatting.
    def set_pandalog(self, name):
        &#39;&#39;&#39;
        Enable recording to a pandalog (plog) named `name`

        Args:
            name (str): filename to output data to

        Returns:
            None
        &#39;&#39;&#39;
        charptr = self.ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
        self.libpanda.panda_start_pandalog(charptr)

    def enable_memcb(self):
        &#39;&#39;&#39;
        Enable memory callbacks. Must be called for memory callbacks to work.
        pypanda enables this automatically with some callbacks.
        &#39;&#39;&#39;
        self._memcb = True
        self.libpanda.panda_enable_memcb()

    def disable_memcb(self):
        &#39;&#39;&#39;
        Disable memory callbacks. Must be enabled for memory callbacks to work.
        pypanda enables this automatically with some callbacks.
        &#39;&#39;&#39;
        self._memcb = False
        self.libpanda.panda_disable_memcb()

    def virt_to_phys(self, cpu, addr):
        &#39;&#39;&#39;
        Convert virtual address to physical address.

        Args:
            cpu (CPUState): CPUState struct
            addr (int): virtual address to convert

        Return:
            int: physical address
        &#39;&#39;&#39;
        if &#34;osi_linux&#34; in self.plugins.keys() or self._plugin_loaded(&#34;osi_linux&#34;):
            return self.plugins[&#34;osi_linux&#34;].osi_linux_virt_to_phys(cpu, addr)
        else:
            return self.libpanda.panda_virt_to_phys_external(cpu, addr)

    def enable_plugin(self, handle):
        &#39;&#39;&#39;
        Enable plugin.

        Args:
            handle (int): pointer to handle returned by plugin

        Return:
            None
        &#39;&#39;&#39;
        self.libpanda.panda_enable_plugin(handle)

    def disable_plugin(self, handle):
        &#39;&#39;&#39;
        Disable plugin.

        Args:
            handle (int): pointer to handle returned by plugin

        Return:
            None
        &#39;&#39;&#39;
        self.libpanda.panda_disable_plugin(handle)

    def enable_llvm(self):
        &#39;&#39;&#39;
        Enables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
        &#39;&#39;&#39;
        self.libpanda.panda_enable_llvm()

    def disable_llvm(self):
        &#39;&#39;&#39;
        Disables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
        &#39;&#39;&#39;
        self.libpanda.panda_disable_llvm()

    def enable_llvm_helpers(self):
        &#39;&#39;&#39;
        Enables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
        &#39;&#39;&#39;
        self.libpanda.panda_enable_llvm_helpers()

    def disable_llvm_helpers(self):
        &#39;&#39;&#39;
        Disables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
        &#39;&#39;&#39;
        self.libpanda.panda_disable_llvm_helpers()

    def flush_tb(self):
        &#39;&#39;&#39;
        This function requests that the translation block cache be flushed as soon as possible. If running with translation block chaining turned off (e.g. when in LLVM mode or replay mode), this will happen when the current translation block is done executing.
        Flushing the translation block cache is additionally necessary if the plugin makes changes to the way code is translated. For example, by using panda_enable_precise_pc.
        &#39;&#39;&#39;
        return self.libpanda.panda_do_flush_tb()

    def break_exec(self):
        &#39;&#39;&#39;
        If called from a start block exec callback, will cause the emulation to bail *before* executing
        the rest of the current block.
        &#39;&#39;&#39;
        return self.libpanda.panda_do_break_exec()

    def enable_precise_pc(self):
        &#39;&#39;&#39;
        By default, QEMU does not update the program counter after every instruction.
        This function enables precise tracking of the program counter. After enabling precise PC tracking, the program counter will be available in env-&gt;panda_guest_pc and can be assumed to accurately reflect the guest state.
        &#39;&#39;&#39;
        self.libpanda.panda_enable_precise_pc()

    def disable_precise_pc(self):
        &#39;&#39;&#39;
        By default, QEMU does not update the program counter after every instruction.
        This function disables precise tracking of the program counter.
        &#39;&#39;&#39;
        self.libpanda.panda_disable_precise_pc()

    def in_kernel(self, cpustate):
        &#39;&#39;&#39;
        Returns true if the processor is in the privilege level corresponding to kernel mode for any of the PANDA supported architectures.
        Legacy alias for in_kernel_mode().
        &#39;&#39;&#39;
        return self.libpanda.panda_in_kernel_external(cpustate)

    def in_kernel_mode(self, cpustate):
        &#39;&#39;&#39;
        Check if the processor is running in priviliged mode.

        Args:
            cpu (CPUState): CPUState structure

        Returns:
            Bool: If the processor is in the privilege level corresponding to kernel mode
                  for the given architecture
        &#39;&#39;&#39;
        return self.libpanda.panda_in_kernel_mode_external(cpustate)

    def in_kernel_code_linux(self, cpustate):
        &#39;&#39;&#39;
        Check if the processor is running in linux kernelspace.

        Args:
            cpu (CPUState): CPUState structure

        Returns:
            Bool: If the processor is running in Linux kernel space code.
        &#39;&#39;&#39;
        return self.libpanda.panda_in_kernel_code_linux_external(cpustate)

    def g_malloc0(self, size):
        &#39;&#39;&#39;
        Helper function to call glib malloc

        Args:
            size (int): size to call with malloc

        Returns:
            buffer of the requested size from g_malloc
        &#39;&#39;&#39;
        return self.libpanda.g_malloc0(size)

    def current_sp(self, cpu):
        &#39;&#39;&#39;
        Get current stack pointer

        Args:
            cpu (CPUState): CPUState structure

        Return:
            int: Value of stack pointer
        &#39;&#39;&#39;
        return self.libpanda.panda_current_sp_external(cpu)

    def current_pc(self, cpu):
        &#39;&#39;&#39;
        Get current program counter

        Args:
            cpu (CPUState): CPUState structure

        Return:
            integer value of current program counter

        .. Deprecated:: Use panda.arch.get_pc(cpu) instead
        &#39;&#39;&#39;
        return self.libpanda.panda_current_pc(cpu)

    def current_asid(self, cpu):
        &#39;&#39;&#39;
        Get current Application Specific ID

        Args:
            cpu (CPUState): CPUState structure

        Returns:
            integer: value of current ASID
        &#39;&#39;&#39;
        return self.libpanda.panda_current_asid(cpu)
    
    def get_id(self, cpu):
        &#39;&#39;&#39;
        Get current hw_proc_id ID

        Args:
            cpu (CPUState): CPUState structure
        
        Returns:
            integer: value of current hw_proc_id
        &#39;&#39;&#39;
        return self.plugins[&#34;hw_proc_id&#34;].get_id(cpu)

    def disas2(self, code, size):
        &#39;&#39;&#39;
        Call panda_disas to diasassemble an amount of code at a pointer.
        FIXME: seem to not match up to PANDA definition
        &#39;&#39;&#39;
        self.libpanda.panda_disas(code, size)

    def cleanup(self):
        &#39;&#39;&#39;
        Unload all plugins and close pandalog.

        Returns:
            None
        &#39;&#39;&#39;
        self.libpanda.panda_cleanup()

    def was_aborted(self):
        &#39;&#39;&#39;
        Returns true if panda was aborted.
        &#39;&#39;&#39;
        return self.libpanda.panda_was_aborted()

    def get_cpu(self):
        &#39;&#39;&#39;
        This function returns first_cpu CPUState object from QEMU.
        XXX: You rarely want this

        Returns:
            CPUState: cpu
        &#39;&#39;&#39;
        return self.libpanda.get_cpu()

    def garray_len(self, garray):
        &#39;&#39;&#39;
        Convenience function to get array length of glibc array.

        Args:
            g (garray): Pointer to a glibc array
                
        Returns:
            int: length of the array
        &#39;&#39;&#39;
        return self.libpanda.garray_len(garray)

    def panda_finish(self):
        &#39;&#39;&#39;
        Final stage call to underlying panda_finish with initialization.
        &#39;&#39;&#39;
        return self.libpanda.panda_finish()

    def rr_get_guest_instr_count(self):
        &#39;&#39;&#39;
        Returns record/replay guest instruction count.

        Returns:
            int: Current instruction count
        &#39;&#39;&#39;
        return self.libpanda.rr_get_guest_instr_count_external()

    ################### LIBQEMU Functions ############
    #Methods that directly pass data to/from QEMU with no extra logic beyond argument reformatting.
    #All QEMU function can be directly accessed by Python. These are here for convenience.
    # It&#39;s usally better to find a function name and look at the QEMU source for these functions.

    def drive_get(self, blocktype, bus, unit):
        &#39;&#39;&#39;
        Gets DriveInfo struct from user specified information.

        Args:
            blocktype: BlockInterfaceType structure
            bus: integer bus
            unit: integer unit

        Returns:
            DriveInfo struct
        &#39;&#39;&#39;
        return self.libpanda.drive_get(blocktype,bus,unit)

    def sysbus_create_varargs(self, name, addr):
        &#39;&#39;&#39;
        Returns DeviceState struct from user specified information
        Calls sysbus_create_varargs QEMU function.

        Args:
            name (str):
            addr (int): hwaddr

        Returns:
            DeviceState struct
        &#39;&#39;&#39;
        return self.libpanda.sysbus_create_varargs(name,addr, self.ffi.NULL)

    def cpu_class_by_name(self, name, cpu_model):
        &#39;&#39;&#39;
        Gets cpu class from name.
        Calls cpu_class_by_name QEMU function.

        Args:
            name: typename from python string
            cpu_model: string specified cpu model

        Returns:
            ObjectClass struct
        &#39;&#39;&#39;
        return self.libpanda.cpu_class_by_name(name, cpu_model)

    def object_class_by_name(self, name):
        &#39;&#39;&#39;
        Returns class as ObjectClass from name specified.
        Calls object_class_by_name QEMU function.

        Args
            name (str): string defined by user

        Returns:
            struct as specified by name
        &#39;&#39;&#39;
        return self.libpanda.object_class_by_name(name)

    def object_property_set_bool(self, obj, value, name):
        &#39;&#39;&#39;
        Writes a bool value to a property.
        Calls object_property_set_bool QEMU function.

        Args::
            value: the value to be written to the property
            name: the name of the property
            errp: returns an error if this function fails

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.object_property_set_bool(obj,value,name,self.libpanda.error_abort)

    def object_class_get_name(self, objclass):
        &#39;&#39;&#39;
        Gets String QOM typename from object class.
        Calls object_class_get_name QEMU function.

        Args::
            objclass: class to obtain the QOM typename for.

        Returns:
            String QOM typename for klass.
        &#39;&#39;&#39;
        return self.libpanda.object_class_get_name(objclass)

    def object_new(self, name):
        &#39;&#39;&#39;
        Creates a new QEMU object from typename.
        This function will initialize a new object using heap allocated memory.
        The returned object has a reference count of 1, and will be freed when
        the last reference is dropped.
        Calls object_new QEMU function.

        Args:
            name (str): The name of the type of the object to instantiate.

        Returns:
            The newly allocated and instantiated object.
        &#39;&#39;&#39;
        return self.libpanda.object_new(name)

    def object_property_get_bool(self, obj, name):
        &#39;&#39;&#39;
        Pull boolean from object.
        Calls object_property_get_bool QEMU function.

        Args:
            obj: the object
            name: the name of the property

        Returns:
            the value of the property, converted to a boolean, or NULL if an error occurs (including when the property value is not a bool).
        &#39;&#39;&#39;
        return self.libpanda.object_property_get_bool(obj,name,self.libpanda.error_abort)

    def object_property_set_int(self,obj, value, name):
        &#39;&#39;&#39;
        Set integer in QEMU object. Writes an integer value to a property.
        Calls object_property_set_int QEMU function.

        Args:
            value: the value to be written to the property
            name: the name of the property

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.object_property_set_int(obj, value, name, self.libpanda.error_abort)

    def object_property_get_int(self, obj, name):
        &#39;&#39;&#39;
        Gets integer in QEMU object. Reads an integer value from this property.
        Calls object_property_get_int QEMU function.

            Paramaters:
                obj: the object
                name: the name of the property

            Returns:
                the value of the property, converted to an integer, or negative if an error occurs (including when the property value is not an integer).
        &#39;&#39;&#39;
        return self.libpanda.object_property_get_int(obj, name, self.libpanda.error_abort)

    def object_property_set_link(self, obj, val, name):
        &#39;&#39;&#39;
        Writes an object&#39;s canonical path to a property.
        Calls object_property_set_link QEMU function.

        Args:
            value: the value to be written to the property
            name: the name of the property
            errp: returns an error if this function fails

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.object_property_set_link(obj,val,name,self.libpanda.error_abort)

    def object_property_get_link(self, obj, name):
        &#39;&#39;&#39;
        Reads an object&#39;s canonical path to a property.
        Calls object_property_get_link QEMU function.

        Args:
            obj: the object
            name: the name of the property
            errp: returns an error if this function fails

        Returns:
            the value of the property, resolved from a path to an Object, or NULL if an error occurs (including when the property value is not a string or not a valid object path).
        &#39;&#39;&#39;
        return self.libpanda.object_property_get_link(obj,name,self.libpanda.error_abort)

    def object_property_find(self, obj, name):
        &#39;&#39;&#39;
        Look up a property for an object and return its #ObjectProperty if found.
        Calls object_property_find QEMU function.

        Args:
            obj: the object
            name: the name of the property
            errp: returns an error if this function fails

        Returns:
            struct ObjectProperty pointer
        &#39;&#39;&#39;
        return self.libpanda.object_property_find(obj,name, self.ffi.NULL)

    def memory_region_allocate_system_memory(self, mr, obj, name, ram_size):
        &#39;&#39;&#39;
        Allocates Memory region by user specificiation.
        Calls memory_region_allocation_system_memory QEMU function.

        Args:
            mr: MemoryRegion struct
            obj: Object struct
            name (str): Region name
            ram_size (int): RAM size

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.memory_region_allocate_system_memory(mr, obj, name, ram_size)

    def memory_region_add_subregion(self, mr, offset, sr):
        &#39;&#39;&#39;
        Calls memory_region_add_subregion from QEMU.
        memory_region_add_subregion: Add a subregion to a container.

        Adds a subregion at @offset.  The subregion may not overlap with other
        subregions (except for those explicitly marked as overlapping).  A region
        may only be added once as a subregion (unless removed with
        memory_region_del_subregion()); use memory_region_init_alias() if you
        want a region to be a subregion in multiple locations.

        Args:
            mr: the region to contain the new subregion; must be a container initialized with memory_region_init().
            offset: the offset relative to @mr where @subregion is added.
            subregion: the subregion to be added.

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.memory_region_add_subregion(mr,offset,sr)

    def memory_region_init_ram_from_file(self, mr, owner, name, size, share, path):
        &#39;&#39;&#39;
        Calls memory_region_init_ram_from_file from QEMU.
        memory_region_init_ram_from_file:  Initialize RAM memory region with a mmap-ed backend.

        Args:
            mr: the #MemoryRegion to be initialized.
            owner: the object that tracks the region&#39;s reference count
            name: the name of the region.
            size: size of the region.
            share: %true if memory must be mmaped with the MAP_SHARED flag
            path: the path in which to allocate the RAM.
            errp: pointer to Error*, to store an error if it happens.

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.memory_region_init_ram_from_file(mr, owner, name, size, share, path, self.libpanda.error_fatal)

    def create_internal_gic(self, vbi, irqs, gic_vers):
        return self.libpanda.create_internal_gic(vbi, irqs, gic_vers)

    def create_one_flash(self, name, flashbase, flashsize, filename, mr):
        return self.libpanda.create_one_flash(name, flashbase, flashsize, filename, mr)

    def create_external_gic(self, vbi, irqs, gic_vers, secure):
        return self.libpanda.create_external_gic(vbi, irqs, gic_vers, secure)

    def create_virtio_devices(self, vbi, pic):
        return self.libpanda.create_virtio_devices(vbi, pic)

    def arm_load_kernel(self, cpu, bootinfo):
        return self.libpanda.arm_load_kernel(cpu, bootinfo)

    def error_report(self, s):
        return self.libpanda.error_report(s)

    def get_system_memory(self):
        return self.libpanda.get_system_memory()

    def lookup_gic(self,n):
        return self.libpanda.lookup_gic(n)

    ##################### OSI FUNCTIONS ###########
    #Convenience functions to interact with the Operating System Instrospection (OSI) class of plugins.

    def set_os_name(self, os_name):
        &#34;&#34;&#34;
        Set OS target. Equivalent to &#34;-os&#34; flag on the command line. Matches the form of:

            &#34;windows[-_]32[-_]xpsp[23]&#34;,
            &#34;windows[-_]32[-_]2000&#34;,
            &#34;windows[-_]32[-_]7sp[01]&#34;,
            &#34;windows[-_]64[-_]7sp[01]&#34;,
            &#34;linux[-_]32[-_].+&#34;,
            &#34;linux[-_]64[-_].+&#34;,
            &#34;freebsd[-_]32[-_].+&#34;,
            &#34;freebsd[-_]64[-_].+&#34;,

            Args:
                os_name (str): Name that matches the format for the os flag.

            Returns:
                None
        &#34;&#34;&#34;
        print (&#34;os_name=[%s]&#34; % os_name)
        os_name_new = self.ffi.new(&#34;char[]&#34;, bytes(os_name, &#34;utf-8&#34;))
        self.libpanda.panda_set_os_name(os_name_new)

    def get_os_family(self):
        &#39;&#39;&#39;
        Get the current OS family name. Valid values are the entries in `OSFamilyEnum`

        Returns:
            string: one of OS_UNKNOWN, OS_WINDOWS, OS_LINUX, OS_FREEBSD
        &#39;&#39;&#39;

        family_num = self.libpanda.panda_os_familyno
        family_name = self.ffi.string(self.ffi.cast(&#34;PandaOsFamily&#34;, family_num))
        return family_name
    
    def get_file_name(self, cpu, fd):
        &#39;&#39;&#39;
        Get the name of a file from a file descriptor.

        Returns:
            string: file name
            None: on failure
        &#39;&#39;&#39;
        proc = self.plugins[&#39;osi&#39;].get_current_process(cpu)
        if proc == self.ffi.NULL:
            return None
        try:
            fname_ptr = self.plugins[&#39;osi_linux&#39;].osi_linux_fd_to_filename(cpu, proc, fd)
        except OverflowError:
            return None
        if fname_ptr == self.ffi.NULL:
            return None
        return self.ffi.string(fname_ptr)

    def get_current_process(self, cpu):
        &#39;&#39;&#39;
        Get the current process as an OsiProc struct.

        Returns:
            string: process name
            None: on failure
        &#39;&#39;&#39;
        proc = self.plugins[&#39;osi&#39;].get_current_process(cpu)
        if proc == self.ffi.NULL:
            return None
        return proc

    def get_mappings(self, cpu):
        &#39;&#39;&#39;
        Get all active memory mappings in the system.

        Requires: OSI

        Args:
            cpu: CPUState struct

        Returns:
            pandare.utils.GArrayIterator: iterator of OsiModule structures
        &#39;&#39;&#39;
        current = self.plugins[&#39;osi&#39;].get_current_process(cpu)
        maps = self.plugins[&#39;osi&#39;].get_mappings(cpu, current)
        map_len = self.garray_len(maps)
        return GArrayIterator(self.plugins[&#39;osi&#39;].get_one_module, maps, map_len, self.plugins[&#39;osi&#39;].cleanup_garray)

    def get_mapping_by_addr(self, cpu, addr):
        &#39;&#39;&#39;
        Return the OSI mapping that matches the address specified.

        Requires: OSI

        Args:
            cpu: CPUState struct
            addr: int

        Returns:
            OsiModule: dataclass representation of OsiModule structure with strings converted to python strings
                Note that the strings will be None if their pointer was null
            None: on failure
        &#39;&#39;&#39;
        @dataclass
        class OsiModule:
            &#39;&#39;&#39;dataclass representation of OsiModule structu&#39;&#39;&#39;
            base: int
            file: str
            modd: int
            name: str
            size: int
        mappings = self.get_mappings(cpu)
        for m in mappings:
            if m == self.ffi.NULL:
                continue
            if addr &gt;= m.base and addr &lt; m.base+m.size:
                if m.name != self.ffi.NULL:
                    name = self.ffi.string(m.name).decode(&#34;utf-8&#34;)
                else:
                    name = None
                if m.file != self.ffi.NULL:
                    file = self.ffi.string(m.file).decode(&#34;utf-8&#34;)
                else:
                    file = None
                return OsiModule(m.base, file, m.modd, name, m.size)
        return None

    def get_processes(self, cpu):
        &#39;&#39;&#39;
        Get all running processes in the system. Includes kernel modules on Linux.

        Requires: OSI

        Args:
            cpu: CPUState struct

        Returns:
            pandare.utils.GArrayIterator: iterator of OsiProc structures
        &#39;&#39;&#39;
        processes = self.plugins[&#39;osi&#39;].get_processes(cpu)
        processes_len = self.garray_len(processes)
        return GArrayIterator(self.plugins[&#39;osi&#39;].get_one_proc, processes, processes_len, self.plugins[&#39;osi&#39;].cleanup_garray)

    def get_processes_dict(self, cpu):
        &#39;&#39;&#39;
        Get all running processes for the system at this moment in time as a dictionary.

        The dictionary maps proceses by their PID. Each mapping returns a dictionary containing the process name, its pid,
        and its parent pid (ppid).

        Requires: OSI

        Args:
            cpu: CPUState struct

        Returns:
            Dict: processes as described above
        &#39;&#39;&#39;

        procs = {} #pid: {name: X, pid: Y, parent_pid: Z})

        for proc in self.get_processes(cpu):
            assert(proc != self.ffi.NULL)
            assert(proc.pid not in procs)
            procs[proc.pid] = {&#39;name&#39;: self.ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;),
                               &#39;pid&#39;: proc.pid,
                               &#39;parent_pid&#39;: proc.ppid,
                               &#39;create_time&#39;: proc.create_time}
            assert(not (proc.pid != 0 and proc.pid == proc.ppid)) # No cycles allowed other than at 0
        return procs

    def get_process_name(self, cpu):
        &#39;&#39;&#39;
        Get the name of the current process. May return None if OSI cannot identify the current process
        &#39;&#39;&#39;
        proc = self.plugins[&#39;osi&#39;].get_current_process(cpu)
        if proc == self.ffi.NULL or proc.name == self.ffi.NULL:
            return None

        procname = self.ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;)
        return self.ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;)


    ################## PYPERIPHERAL FUNCTIONS #####################
    # Pyperipherals are objects which handle mmio read/writes using the PANDA callback infrastructure.
    # Under the hood, they use the cb_unassigned_io_read/cb_unassigned_io_write callbacks.
    # A python peripheral itself is an object which exposes the following functions:
    #     write_memory(self, address, size, value)
    #     read_memory(self, address, size)
    # And has at least the following attributes:
    #     address
    #     size

    # One example for such a python object are avatar2&#39;s AvatarPeripheral.
    def _addr_to_pyperipheral(self, address):
        &#34;&#34;&#34;
        Returns the python peripheral for a given address, or None if no
        peripheral is registered for that address
        &#34;&#34;&#34;

        for pp in self.pyperipherals:
            if pp.address &lt;= address &lt; pp.address + pp.size:
                return pp
        return None

    def _validate_object(self, object):
        # This function makes sure that the object exposes the right interfaces

        if not hasattr(object, &#34;address&#34;) or not isinstance(object.address, int):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing or non-int `address` attribute&#34;
                ).format(str(object.__repr__()))
            )

        if not hasattr(object, &#34;size&#34;) or not isinstance(object.size, int):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing or non-int `address` attribute&#34;
                ).format(object.__repr__())
            )

        if not hasattr(object, &#34;read_memory&#34;):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing read_memory function&#34;
                ).format(object.__repr__())
            )

        params = list(signature(object.read_memory).parameters)
        if params[0] != &#34;address&#34; or params[1] != &#34;size&#34;:
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Invalid function signature for read_memory&#34;
                ).format(object.__repr__())
            )

        if not hasattr(object, &#34;write_memory&#34;):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing write_memory function&#34;
                ).format(object.__repr__())
            )

        params = list(signature(object.write_memory).parameters)
        if params[0] != &#34;address&#34; or params[1] != &#34;size&#34; or params[2] != &#34;value&#34;:
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Invalid function signature for write_memory&#34;
                ).format(object.__repr__())
            )

        # Ensure object is not overlapping with any other pyperipheral
        if (
            self._addr_to_pyperipheral(object.address) is not None
            or self._addr_to_pyperipheral(object.address + object.size) is not None
        ):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34; &#34;Overlapping memories!&#34;
                ).format(object.__repr__())
            )

        return True

    def pyperiph_read_cb(self, cpu, pc, physaddr, size, val_ptr):
        pp = self._addr_to_pyperipheral(physaddr)
        if pp is None:
            return False

        val = pp.read_memory(physaddr, size)
        buf = self.ffi.buffer(val_ptr, size)

        fmt = &#34;{}{}&#34;.format(self._end2fmt[self.endianness], self._num2fmt[size])

        pack_into(fmt, buf, 0, val)

        return True

    def pyperiph_write_cb(self, cpu, pc, physaddr, size, val):
        pp = self._addr_to_pyperipheral(physaddr)
        if pp is None:
            return False

        pp.write_memory(physaddr, size, val)
        return True

    def register_pyperipheral(self, object):
        &#34;&#34;&#34;
        Registers a python peripheral, and the necessary attributes to the
        panda-object, if not present yet.
        &#34;&#34;&#34;

        # if we are the first pyperipheral, register the pp-dict
        if not hasattr(self, &#34;pyperipherals&#34;):
            self.pyperipherals = []
            self.pyperipherals_registered_cb = False
            self._num2fmt = {1: &#34;B&#34;, 2: &#34;H&#34;, 4: &#34;I&#34;, 8: &#34;Q&#34;}
            self._end2fmt = {&#34;little&#34;: &#34;&lt;&#34;, &#34;big&#34;: &#34;&gt;&#34;}

        self._validate_object(object)

        if self.pyperipherals_registered_cb is False:
            self.register_callback(
                self.callback.unassigned_io_read,
                self.callback.unassigned_io_read(self.pyperiph_read_cb),
                &#34;pyperipheral_read_callback&#34;,
            )

            self.register_callback(
                self.callback.unassigned_io_write,
                self.callback.unassigned_io_write(self.pyperiph_write_cb),
                &#34;pyperipheral_write_callback&#34;,
            )

            self.pyperipherals_registered_cb = True

        self.pyperipherals.append(object)

    def unregister_pyperipheral(self, pyperiph):
        &#34;&#34;&#34;
        deregisters a python peripheral.
        The pyperiph parameter can be either an object, or an address
        Returns true if the pyperipheral was successfully removed, else false.
        &#34;&#34;&#34;

        if isinstance(pyperiph, int) is True:
            pp = self._addr_to_pyperipheral(pyperiph)
            if pp is None:
                return False
        else:
            if pyperiph not in self.pyperipherals:
                return False
            pp = pyperiph

        self.pyperipherals.remove(pp)

        # If we dont have any pyperipherals left, unregister callbacks
        if len(self.pyperipherals) == 0:
            self.disable_callback(&#34;pyperipheral_read_callback&#34;, forever=True)
            self.disable_callback(&#34;pyperipheral_write_callback&#34;, forever=True)
            self.pyperipherals_registered_cb = False
        return True
    

    ############## TAINT FUNCTIONS ###############
    # Convenience methods for interacting with the taint subsystem.

    def taint_enabled(self):
        &#39;&#39;&#39;
        Checks to see if taint2 plugin has been loaded
        &#39;&#39;&#39;
        return self._plugin_loaded(&#34;taint2&#34;) and self.plugins[&#34;taint2&#34;].taint2_enabled()

    def taint_enable(self):
        &#39;&#39;&#39;
        Enable taint.
        &#39;&#39;&#39;
        self.plugins[&#34;taint2&#34;].taint2_enable_taint()
    
    def _assert_taint_enabled(self):
        if not self.taint_enabled():
            raise Exception(&#34;taint2 must be loaded before tainting values&#34;)

    def taint_label_reg(self, reg_num, label):
        &#39;&#39;&#39;
        Labels taint register reg_num with label.
        &#39;&#39;&#39;
        self._assert_taint_enabled()
        for i in range(self.register_size):
            self.plugins[&#34;taint2&#34;].taint2_label_reg(reg_num, i, label)

    def taint_label_ram(self, addr, label):
        &#39;&#39;&#39;
        Labels ram at address with label.
        &#39;&#39;&#39;
        self._assert_taint_enabled()
        self.plugins[&#34;taint2&#34;].taint2_label_ram(addr, label)

    def taint_check_reg(self, reg_num):
        &#39;&#39;&#39;
        Checks if register reg_num is tainted. Returns boolean.
        &#39;&#39;&#39;
        self._assert_taint_enabled()
        for offset in range(self.register_size):
            if self.plugins[&#39;taint2&#39;].taint2_query_reg(reg_num, offset) &gt; 0:
                return True
        return False

    def taint_check_ram(self, addr):
        &#39;&#39;&#39;
        returns boolean representing if physical address is tainted.
        &#39;&#39;&#39;
        self._assert_taint_enabled()
        return self.plugins[&#39;taint2&#39;].taint2_query_ram(addr) &gt; 0

    def taint_get_reg(self, reg_num):
        &#39;&#39;&#39;
        Returns array of results, one for each byte in this register
        None if no taint.  QueryResult struct otherwise
        &#39;&#39;&#39;
        self._assert_taint_enabled()
        res = []
        for offset in range(self.register_size):
            if self.plugins[&#39;taint2&#39;].taint2_query_reg(reg_num, offset) &gt; 0:
                query_res = self.ffi.new(&#34;QueryResult *&#34;)
                self.plugins[&#39;taint2&#39;].taint2_query_reg_full(reg_num, offset, query_res)
                tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;], self.ffi)
                res.append(tq)
            else:
                res.append(None)
        return res

    def taint_get_ram(self, addr):
        &#39;&#39;&#39;
        returns array of results, one for each byte in this register
        None if no taint.  QueryResult struct otherwise
        &#39;&#39;&#39;
        self._assert_taint_enabled()
        if self.plugins[&#39;taint2&#39;].taint2_query_ram(addr) &gt; 0:
            query_res = self.ffi.new(&#34;QueryResult *&#34;)
            self.plugins[&#39;taint2&#39;].taint2_query_ram_full(addr, query_res)
            tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;], self.ffi)
            return tq
        else:
            return None

    def taint_check_laddr(self, addr, off):
        &#39;&#39;&#39;
        returns boolean result checking if this laddr is tainted
        &#39;&#39;&#39;
        self._assert_taint_enabled()
        return self.plugins[&#39;taint2&#39;].taint2_query_laddr(addr, off) &gt; 0

    def taint_get_laddr(self, addr, offset):
        &#39;&#39;&#39;
        returns array of results, one for each byte in this laddr
        None if no taint.  QueryResult struct otherwise
        &#39;&#39;&#39;
        self._assert_taint_enabled()
        if self.plugins[&#39;taint2&#39;].taint2_query_laddr(addr, offset) &gt; 0:
            query_res = self.ffi.new(&#34;QueryResult *&#34;)
            self.plugins[&#39;taint2&#39;].taint2_query_laddr_full(addr, offset, query_res)
            tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;], self.ffi)
            return tq
        else:
            return None
    
    def address_to_ram_offset(self, hwaddr, is_write):
        &#39;&#39;&#39;
        Convert physical address to ram offset

        Args:
            hwaddr (int): physical address
            is_write (bool): boolean representing if this is a write

        Returns:
            ram offset (int)

        Raises:
            ValueError if memory access fails or fmt is unsupported
        &#39;&#39;&#39;
        
        out = self.ffi.new(&#34;ram_addr_t*&#34;, self.ffi.cast(&#34;ram_addr_t&#34;, 0))
        value = self.libpanda.PandaPhysicalAddressToRamOffset_external(out, hwaddr, is_write)
        if value != 0:
            raise ValueError(f&#34;address_to_ram_offset returned {value}&#34;)
        return out[0]

    # enables symbolic tracing
    def taint_sym_enable(self):
        &#34;&#34;&#34;
        Inform python that taint is enabled.
        &#34;&#34;&#34;
        if not self.taint_enabled():
            self.taint_enable()
            progress(&#34;taint symbolic not enabled -- enabling&#34;)
        self.plugins[&#34;taint2&#34;].taint2_enable_sym()
    
    def _assert_taint_sym_enabled(self):
        self._assert_taint_enabled()
        self.plugins[&#39;taint2&#39;].taint2_enable_sym()

    def taint_sym_label_ram(self, addr, label):
        self._assert_taint_sym_enabled()
        self.plugins[&#39;taint2&#39;].taint2_sym_label_ram(addr,label)

    def taint_sym_label_reg(self, reg_num, label):
        # label all bytes in this register.
        # or at least four of them
        # XXX label must increment by panda.register_size after the call
        self._assert_taint_sym_enabled()
        self.taint_sym_enable()
        for i in range(self.register_size):
            self.plugins[&#39;taint2&#39;].taint2_sym_label_reg(reg_num, i, label+i)
    
    # Deserialize a z3 solver
    # Lazy import z3. 
    def string_to_solver(self, string: str):
        from z3 import Solver
        s = Solver()
        s.from_string(string)
        return s

    # Get the first condition in serialized solver str
    def string_to_condition(self, string: str):
        s = self.string_to_solver(string)
        asrts = s.assertions()
        if len(asrts) == 0:
            return None 
        return asrts[0]

    # Get the expr in serialized solver str
    # (https://github.com/Z3Prover/z3/issues/2674) 
    def string_to_expr(self, string: str):
        eq = self.string_to_condition(string)
        if eq and len(eq.children()) &gt; 0:
            return eq.children()[0]
        return None

    # Query the ram addr with given size
    def taint_sym_query_ram(self, addr, size=1):
        # Prepare ptr for returned string
        str_ptr_ffi = self.ffi.new(&#39;char**&#39;)
        # Prepare ptr for string size
        n_ptr_ffi = self.ffi.new(&#39;uint32_t *&#39;, 0)

        self.plugins[&#39;taint2&#39;].taint2_sym_query_ram(addr, size, n_ptr_ffi, str_ptr_ffi)
        # Unpack size
        n = self.ffi.unpack(n_ptr_ffi, 1)[0]
        if n == 0:
            return None
        # Unpack cstr
        str_ptr = self.ffi.unpack(str_ptr_ffi, 1)[0]
        str_bs = self.ffi.unpack(str_ptr, n)
        expr_str = str(str_bs, &#39;utf-8&#39;)
        return self.string_to_expr(expr_str)

    # Query all bytes in this register.
    def taint_sym_query_reg(self, addr):
        # Prepare ptr for returned string
        str_ptr_ffi = self.ffi.new(&#39;char**&#39;)
        # Prepare ptr for string size
        n_ptr_ffi = self.ffi.new(&#39;uint32_t *&#39;, 0)

        self.plugins[&#39;taint2&#39;].taint2_sym_query_reg(addr, n_ptr_ffi, str_ptr_ffi)
        # Unpack size
        n = self.ffi.unpack(n_ptr_ffi, 1)[0]
        if n == 0:
            return None
        # Unpack cstr
        str_ptr = self.ffi.unpack(str_ptr_ffi, 1)[0]
        str_bs = self.ffi.unpack(str_ptr, n)
        expr_str = str(str_bs, &#39;utf-8&#39;)
        return self.string_to_expr(expr_str)

    def taint_sym_path_constraints(self):
        # Prepare ptr for returned string
        str_ptr_ffi = self.ffi.new(&#39;char**&#39;)
        # Prepare ptr for string size
        n_ptr_ffi = self.ffi.new(&#39;uint32_t *&#39;, 0)

        self.plugins[&#39;taint2&#39;].taint2_sym_path_constraints(n_ptr_ffi, str_ptr_ffi)
        # Unpack size
        n = self.ffi.unpack(n_ptr_ffi, 1)[0]
        if n == 0:
            return []
        # Unpack cstr
        str_ptr = self.ffi.unpack(str_ptr_ffi, 1)[0]
        str_bs = self.ffi.unpack(str_ptr, n)
        expr_str = str(str_bs, &#39;utf-8&#39;)
        solver = self.string_to_solver(expr_str)
        return solver.assertions() if solver != None else []

    def taint_sym_branch_meta(self):
        branch_meta_ptr_ffi = self.ffi.new(&#39;SymbolicBranchMeta **&#39;)
        n_ptr_ffi = self.ffi.new(&#39;uint32_t *&#39;, 0)

        self.plugins[&#39;taint2&#39;].taint2_sym_branch_meta(n_ptr_ffi, branch_meta_ptr_ffi)
        # Unpack size
        n = self.ffi.unpack(n_ptr_ffi, 1)[0]
        if n == 0:
            return []
        meta_ptr = self.ffi.unpack(branch_meta_ptr_ffi, 1)[0]
        metas_ffi = self.ffi.unpack(meta_ptr, n)
        # Meta only has a pc field now
        metas = [
            meta_ffi.pc
            for meta_ffi in metas_ffi
        ]
        return metas



    ############ Volatility mixins
    &#34;&#34;&#34;
    Utilities to integrate Volatility with PANDA. Highly experimental.
    &#34;&#34;&#34;

    def make_panda_file_handler(self, debug=False):
        &#39;&#39;&#39;
        Constructs a file and file handler that volatility can&#39;t ignore to back by PANDA physical memory
        &#39;&#39;&#39;
        from urllib.request import BaseHandler
        if &#39;PandaFileHandler&#39; in globals():  # already initialized
            return
        panda = self

        class PandaFile(object):
            def __init__(self, length, panda):
                self.pos = 0
                self.length = length
                self.closed = False
                self.mode = &#34;rb&#34;
                self.name = &#34;/tmp/panda.panda&#34;
                self.panda = panda
                self.classname = type(self).__name__

            def readable(self):
                return self.closed

            def read(self, size=1):
                if self.panda.bits == 32 and self.panda.arch_name == &#34;i386&#34;:
                    data = self.panda.physical_memory_read(
                        self.pos &amp; 0xfffffff, size)
                else:
                    data = self.panda.physical_memory_read(self.pos, size)
                if debug:
                    print(self.classname+&#34;: Reading &#34; +
                          str(size)+&#34; bytes from &#34;+hex(self.pos))
                self.pos += size
                return data

            def peek(self, size=1):
                return self.panda.physical_memory_read(self.pos, size)

            def seek(self, pos, whence=0):
                if whence == 0:
                    self.pos = pos
                elif whence == 1:
                    self.pos += pos
                else:
                    self.pos = self.length - pos
                if self.pos &gt; self.length:
                    print(self.classname+&#34;: We&#39;ve gone off the deep end&#34;)
                if debug:
                    print(self.classname+&#34; Seeking to address &#34;+hex(self.pos))

            def tell(self):
                return self.pos

            def close(self):
                self.closed = True

        class PandaFileHandler(BaseHandler):
            def default_open(self, req):
                if &#39;panda.panda&#39; in req.full_url:
                    length = panda.libpanda.ram_size
                    if length &gt; 0xc0000000:
                        length += 0x40000000  # 3GB hole
                    if debug:
                        print(type(self).__name__ +
                              &#34;: initializing PandaFile with length=&#34;+hex(length))
                    return PandaFile(length=length, panda=panda)
                else:
                    return None

            def file_close(self):
                return True

        globals()[&#34;PandaFileHandler&#34;] = PandaFileHandler

    def get_volatility_symbols(self, debug=False):
        try:
            from .volatility_cli_classes import CommandLineMoreEfficient
            from volatility.framework import contexts
            from volatility.framework.layers.linear import LinearlyMappedLayer
            from volatility.framework.automagic import linux
        except ImportError:
            print(&#34;Warning: Failed to import volatility&#34;)
            return None
        if &#34;linux&#34; in self.os_type:
            if not hasattr(self, &#34;_vmlinux&#34;):
                self.make_panda_file_handler(debug=debug)
                constructed_original = CommandLineMoreEfficient().run()
                linux.LinuxUtilities.aslr_mask_symbol_table(
                    constructed_original.context, constructed_original.config[&#39;vmlinux&#39;], constructed_original.config[&#39;primary&#39;])
                self._vmlinux = contexts.Module(
                    constructed_original.context, constructed_original.config[&#39;vmlinux&#39;], constructed_original.config[&#39;primary&#39;], 0)
            else:
                LinearlyMappedLayer.read.cache_clear()  # smearing technique
            return self._vmlinux
        else:
            print(&#34;Unsupported.&#34;)
            return None

    def run_volatility(self, plugin, debug=False):
        try:
            from .volatility_cli_classes import CommandLineRunFullCommand, StringTextRenderer
        except ImportError:
            print(&#34;Warning: Failed to import volatility&#34;)
            return None
        self.make_panda_file_handler(debug=debug)
        cmd = CommandLineRunFullCommand().run(&#34;-q -f panda.panda &#34; + plugin)
        output = StringTextRenderer().render(cmd.run())
        return output

    ########## BLOCKING MIXINS ############
    &#39;&#39;&#39;
    Utilities to provide blocking interactions with PANDA. This includes serial and monitor interactions as well as file copy to the guest.
    XXX: Do not call any of the following from the main thread- they depend on the CPU loop running
    &#39;&#39;&#39;
    @blocking
    def stop_run(self):
        &#39;&#39;&#39;
        From a blocking thread, request vl.c loop to break. Returns control flow in main thread.
        In other words, once this is called, panda.run() will finish and your main thread will continue.
        If you also want to unload plugins, use end_analysis instead

        XXX: This doesn&#39;t work in replay mode
        &#39;&#39;&#39;
        self.libpanda.panda_break_vl_loop_req = True

    @blocking
    def run_serial_cmd(self, cmd, no_timeout=False, timeout=None):
        &#39;&#39;&#39;
        Run a command inside the guest through a terminal exposed over a serial port. Can only be used if your guest is configured in this way

        Guest output will be analyzed until we see the expect_prompt regex printed (i.e., the PS1 prompt)

        Args:
            cmd: command to run.
            timeout: maximum time to wait for the command to finish
            no_timeout: if set, don&#39;t ever timeout

        Returns:
            String: all the output (stdout + stderr) printed after typing your command and pressing enter until the next prompt was printed.
        &#39;&#39;&#39;

        if timeout is None:
            timeout = 30

        if self.serial_console is None:
            raise RuntimeError(&#34;Cannot run serial commands without providing PANDA an expect_prompt&#34;)
        self.running.wait() # Can only run serial when guest is running
        self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
        if no_timeout:
            result = self.serial_console.expect(timeout=9999) # &#34;Don&#39;t ever timeout&#34; above is a bit of an exaggeration
        else:
            result = self.serial_console.expect(timeout=timeout)
        return result

    @blocking
    def serial_read_until(self, byte_sequence):
        if len(self.serial_unconsumed_data) &gt; 0:
            found_idx = self.serial_unconsumed_data.find(byte_sequence)
            if found_idx &gt;= 0:
                match = self.serial_unconsumed_data[ : found_idx]
                self.serial_unconsumed_data = self.serial_unconsumed_data[found_idx + 1 : ]
                return match
        while self.serial_socket != None:
            try:
                readable, _, _ = select.select([self.serial_socket], [], [], 0.5)
                if len(readable) == 0:
                    continue
                data = self.serial_socket.recv(65535)
            except Exception as e:
                if &#39;[Errno 11]&#39; in str(e) or &#39;[Errno 35]&#39; in str(e):
                    # EAGAIN
                    continue
                raise Exception(&#34;Data Read Error: {}&#34;.format(e.message))
            if not data:
                raise Exception(&#39;Connection Closed by Server&#39;)

            self.serial_unconsumed_data += data
            found_idx = self.serial_unconsumed_data.find(byte_sequence)
            if found_idx &gt;= 0:
                match = self.serial_unconsumed_data[ : found_idx]
                self.serial_unconsumed_data = self.serial_unconsumed_data[found_idx + 1 : ]
                return match
        return None
            
    
    @blocking
    def run_serial_cmd_async(self, cmd, delay=1):
        &#39;&#39;&#39;
        Type a command and press enter in the guest. Return immediately. No results available
        Only use this if you know what you&#39;re doing!
        &#39;&#39;&#39;
        self.running.wait() # Can only run serial when guest is running
        self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
        if delay:
            sleep(delay) # Ensure it has a chance to run

    @blocking
    def type_serial_cmd(self, cmd):
        #Can send message into socket without guest running (no self.running.wait())
        if isinstance(cmd, str):
            cmd = cmd.encode(&#39;utf8&#39;)
        self.serial_console.send(cmd) # send, not sendline

    def finish_serial_cmd(self):
        result = self.serial_console.send_eol()
        result = self.serial_console.expect()
        return result

    @blocking
    def run_monitor_cmd(self, cmd):
        self.monitor_console.sendline(cmd.encode(&#34;utf8&#34;))
        result = self.monitor_console.expect()
        return result

    @blocking
    def revert_sync(self, snapshot_name):
        &#39;&#39;&#39;
        Args:
            snapshot_name: name of snapshot in the current qcow to load

        Returns:
            String: error message. Empty on success.
        &#39;&#39;&#39;
        result = self.run_monitor_cmd(&#34;loadvm {}&#34;.format(snapshot_name))
        # On success we should get no result

        if result.startswith(&#34;Length mismatch&#34;):
            raise RuntimeError(&#34;QEMU machine&#39;s RAM size doesn&#39;t match snapshot RAM size!&#34;)

        if &#34;does not have the requested snapshot&#34; in result:
            raise ValueError(f&#34;Snapshot &#39;{snapshot_name}&#39; not present in {self.qcow}&#34;)

        result = result.strip()
        if len(result):
            warn(f&#34;snapshot load returned error {result}&#34;)

        return result

    @blocking
    def delvm_sync(self, snapshot_name):
        self.run_monitor_cmd(&#34;delvm {}&#34;.format(snapshot_name))

    @blocking
    def copy_to_guest(self, copy_directory, iso_name=None, absolute_paths=False, setup_script=&#34;setup.sh&#34;, timeout=None, cdrom=None):
        &#39;&#39;&#39;

        Copy a directory from the host into the guest by
        1) Creating an .iso image of the directory on the host
        2) Run a bash command to mount it at the exact same path + .ro and then copy the files to the provided path
        3) If the directory contains setup.sh, run it

        Args:
            copy_directory: Local directory to copy into guest
            iso_name: Name of iso file that will be generated. Defaults to [copy_directory].iso
            absolute_paths: is copy_directory an absolute or relative path
            seutp_script: name of a script which, if present inside copy_directory, will be automatically run after the copy
            timeout: maximum time each copy command will be allowed to run for, will use the `run_serial_cmd` default value unless another is provided

        Returns:
            None
        &#39;&#39;&#39;

        if not iso_name:
            iso_name = copy_directory + &#39;.iso&#39;
        make_iso(copy_directory, iso_name)

        if not absolute_paths:
            copy_directory = path.split(copy_directory)[-1] # Copy directory relative, not absolutely


        # Drive the guest to mount the drive
        # setup_sh:
        #   Make sure cdrom didn&#39;t automount
        #   Make sure guest path mirrors host path
        #   if there is a setup.sh script in the directory,
        #   then run that setup.sh script first (good for scripts that need to
        #   prep guest environment before script runs)
        mount_dir = shlex_quote(copy_directory)

        mkdir_result = self.run_serial_cmd(f&#34;mkdir -p {mount_dir} {mount_dir}.ro &amp;&amp; echo \&#34;mkdir_ok\&#34;; echo \&#34;exit code $?\&#34;&#34;, timeout=timeout)

        if &#39;mkdir_ok&#39; not in mkdir_result:
            raise RuntimeError(f&#34;Failed to create mount directories inside guest: {mkdir_result}&#34;)

        # Tell panda to we insert the CD drive
        # TODO: the cd-drive name should be a config option, see the values in qcow.py

        cd_drive_name = cdrom
        if cdrom is None:
            if self.cdrom is not None:
                cd_drive_name = self.cdrom
            else:
                cd_drive_name = &#34;ide1-cd0&#34;

        errs = self.run_monitor_cmd(&#34;change {} \&#34;{}\&#34;&#34;.format(cd_drive_name, iso_name))
        if len(errs):
            warn(f&#34;Warning encountered when connecting media to guest: {errs}&#34;)

        try:
            mount_status = &#34;bad&#34;
            for _ in range(10):
                if &#39;mount_ok&#39; in mount_status:
                    break
                mount_status = self.run_serial_cmd(f&#34;mount /dev/cdrom {mount_dir}.ro &amp;&amp; echo &#39;mount_ok&#39; || (umount /dev/cdrom; echo &#39;bad&#39;)&#34;, timeout=timeout)
                sleep(1)
            else:
                # Didn&#39;t ever break
                raise RuntimeError(f&#34;Failed to mount media inside guest: {mount_status}&#34;)

            # Note the . after our src/. directory - that&#39;s special syntax for cp -a
            copy_result = self.run_serial_cmd(f&#34;cp -a {mount_dir}.ro/. {mount_dir} &amp;&amp; echo &#39;copyok&#39;&#34;, timeout=timeout)
            
            # NB: exact match here causing issues so making things more flexible
            if not (&#39;copyok&#39; in copy_result):
                raise RuntimeError(f&#34;Copy to rw directory failed: {copy_result}&#34;)

        finally:
            # Ensure we disconnect the CD drive after the mount + copy, even if it fails
            self.run_serial_cmd(&#34;umount /dev/cdrom&#34;) # This can fail and that&#39;s okay, we&#39;ll forece eject
            sleep(1)
            errs = self.run_monitor_cmd(f&#34;eject -f {cd_drive_name}&#34;)
            if len(errs):
                warn(f&#34;Warning encountered when disconnecting media from guest: {errs}&#34;)

        if isfile(pjoin(copy_directory, setup_script)):
            setup_result = self.run_serial_cmd(f&#34;{mount_dir}/{setup_script}&#34;, timeout=timeout)
            progress(f&#34;[Setup command]: {setup_result}&#34;)

    @blocking
    def record_cmd(self, guest_command, copy_directory=None, iso_name=None, setup_command=None, recording_name=&#34;recording&#34;, snap_name=&#34;root&#34;, ignore_errors=False):
        &#39;&#39;&#39;
        Take a recording as follows:
            0) Revert to the specified snapshot name if one is set. By default &#39;root&#39;. Set to `None` if you have already set up the guest and are ready to record with no revert
            1) Create an ISO of files that need to be copied into the guest if copy_directory is specified. Copy them in
            2) Run the setup_command in the guest, if provided
            3) Type the command you wish to record but do not press enter to begin execution. This avoids the recording capturing the command being typed
            4) Begin the recording (name controlled by recording_name)
            5) Press enter in the guest to begin the command. Wait until it finishes.
            6) End the recording
        &#39;&#39;&#39;
        # 0) Revert to the specified snapshot
        if snap_name is not None:
            self.revert_sync(snap_name) # Can&#39;t use self.revert because that would would run async and we&#39;d keep going before the revert happens

        # 1) Make copy_directory into an iso and copy it into the guest - It will end up at the exact same path
        if copy_directory: # If there&#39;s a directory, build an ISO and put it in the cddrive
            # Make iso
            self.copy_to_guest(copy_directory, iso_name)

        # 2) Run setup_command, if provided before we start the recording (good place to CD or install, etc)
        if setup_command:
            print(f&#34;Running setup command {setup_command}&#34;)
            r = self.run_serial_cmd(setup_command)
            print(f&#34;Setup command results: {r}&#34;)

        # 3) type commmand (note we type command, start recording, finish command)
        self.type_serial_cmd(guest_command)

        # 4) start recording
        self.run_monitor_cmd(&#34;begin_record {}&#34;.format(recording_name))

        # 5) finish command
        result = self.finish_serial_cmd()

        if debug:
            progress(&#34;Result of `{}`:&#34;.format(guest_command))
            print(&#34;\t&#34;+&#34;\n\t&#34;.join(result.split(&#34;\n&#34;))+&#34;\n&#34;)

        if &#34;No such file or directory&#34; in result and not ignore_errors:
            print(&#34;Bad output running command: {}&#34;.format(result))
            raise RuntimeError(&#34;Command not found while taking recording&#34;)

        if &#34;cannot execute binary file&#34; in result and not ignore_errors:
            print(&#34;Bad output running command: {}&#34;.format(result))
            raise RuntimeError(&#34;Could not execute binary while taking recording&#34;)

        # 6) End recording
        self.run_monitor_cmd(&#34;end_record&#34;)

        print(&#34;Finished recording&#34;)

    @blocking
    def interact(self, confirm_quit=True):
        &#39;&#39;&#39;
        Expose console interactively until user types pandaquit
        Must be run in blocking thread.

        TODO: This should probably repace self.serial_console with something
        that directly renders output to the user. Then we don&#39;t have to handle
        buffering and other problems. But we will need to re-enable the serial_console
        interface after this returns
        &#39;&#39;&#39;
        print(&#34;PANDA: entering interactive mode. Type pandaquit to exit&#34;)
        prompt = self.expect_prompt.decode(&#34;utf8&#34;) if self.expect_prompt and isinstance(self.expect_prompt, bytes) else &#34;$ &#34;
        if not prompt.endswith(&#34; &#34;): prompt += &#34; &#34;
        while True:
            cmd = input(prompt) # TODO: Strip all control characters - Ctrl-L breaks things
            if cmd.strip() == &#39;pandaquit&#39;:
                if confirm_quit:
                    q = input(&#34;PANDA: Quitting interactive mode. Are you sure? (y/n) &#34;)
                    if len(q) and q.lower()[0] == &#39;y&#39;:
                        break
                    else:
                        continue
                else: # No confirm - just break
                    break
            r = self.run_serial_cmd(cmd) # XXX: may timeout
            print(r)

    @blocking
    def do_panda_finish(self):
        &#39;&#39;&#39;
        Call panda_finish. Note this isn&#39;t really blocking - the
        guest should have exited by now, but queue this after
        (blocking) shutdown commands in our internal async queue
        so it must also be labeled as blocking.
        &#39;&#39;&#39;
#        assert (not self.running.is_set()), &#34;Can&#39;t finish while still running&#34;
        self.panda_finish()

    ################## CALLBACK FUNCTIONS ################
    # Mixin for handling callbacks and generation of decorators that allow users to register their own callbacks
    # such as panda.cb_before_block_exec()
    def register_cb_decorators(self):
        &#39;&#39;&#39;
        Setup callbacks and generate self.cb_XYZ functions for cb decorators
        XXX Don&#39;t add any other methods with names starting with &#39;cb_&#39;
        Callbacks can be called as @panda.cb_XYZ in which case they&#39;ll take default arguments and be named the same as the decorated function
        Or they can be called as @panda.cb_XYZ(name=&#39;A&#39;, procname=&#39;B&#39;, enabled=True). Defaults: name is function name, procname=None, enabled=True unless procname set
        &#39;&#39;&#39;
        for cb_name, pandatype in zip(self.callback._fields, self.callback):
            def closure(closed_cb_name, closed_pandatype): # Closure on cb_name and pandatype
                def f(*args, **kwargs):
                    if len(args): # Called as @panda.cb_XYZ without ()s- no arguments to decorator but we get the function name instead
                        # Call our decorator with only a name argument ON the function itself
                        fun = args[0]
                        return self._generated_callback(closed_pandatype, **{&#34;name&#34;: fun.__name__})(fun)
                    else:
                        # Otherwise, we were called as @panda.cb_XYZ() with potential args - Just return the decorator and it&#39;s applied to the function
                        return self._generated_callback(closed_pandatype, *args, **kwargs)
                return f

            setattr(self, &#39;cb_&#39;+cb_name, closure(cb_name, pandatype))

    def _generated_callback(self, pandatype, name=None, procname=None, enabled=True):
        &#39;&#39;&#39;
        Actual implementation of self.cb_XYZ. pandatype is pcb.XYZ
        name must uniquely describe a callback
        if procname is specified, callback will only be enabled when that asid is running (requires OSI support)
        &#39;&#39;&#39;

        if procname:
            enabled = False # Process won&#39;t be running at time 0 (probably)
            self._register_internal_asid_changed_cb()

        def decorator(fun):
            local_name = name  # We need a new varaible otherwise we have scoping issues with _generated_callback&#39;s name
            if name is None:
                local_name = fun.__name__

            # 0 works for all callbacks except void. We check later on
            # to see if we need to return None otherwise we return 0
            return_from_exception = 0

            def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
                if not hasattr(self, &#34;exit_exception&#34;):
                    try:
                        r = fun(*args, **kwargs)
                        #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                        #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                        #print(fun, r) # Stuck with TypeError in _run_and_catch? Enable this to find where the bug is.
                        if return_type:
                            try:
                                return self.ffi.cast(return_type, r)
                            except TypeError:
                                # consider throwing an exception
                                return self.ffi.cast(return_type, 0)
                    except Exception as e:
                        # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                        # machine exits.
                        if self.catch_exceptions:
                            self.exit_exception = e
                            self.end_analysis()
                        else:
                            raise e
                        if return_type is not None:
                            return self.ffi.cast(return_type, 0)

            cast_rc = pandatype(_run_and_catch)
            return_type = self.ffi.typeof(cast_rc).result
            
            if return_type.cname == &#34;void&#34;:
                return_type = None

            self.register_callback(pandatype, cast_rc, local_name, enabled=enabled, procname=procname)
            def wrapper(*args, **kw):
                return _run_and_catch(*args, **kw)
            return wrapper
        return decorator

    def _register_internal_asid_changed_cb(self):
        &#39;&#39;&#39;
        Call this function if you need procname filtering for callbacks. It enables
        an internal callback on asid_changed (and sometimes an after_block_exec cb)
        which will deteremine when the process name changes and enable/disable other callbacks
        that filter on process name.
        &#39;&#39;&#39;
        if self._registered_asid_changed_internal_cb: # Already registered these callbacks
            return

        @self.ppp(&#34;syscalls2&#34;, &#34;on_sys_brk_enter&#34;)
        def on_sys_brk_enter(cpu, pc, brk):
            name = self.get_process_name(cpu)
            asid = self.libpanda.panda_current_asid(cpu)
            if self.asid_mapping.get(asid, None) != name:
                self.asid_mapping[asid] = name
                self._procname_changed(cpu, name)

        @self.callback.after_block_exec
        def __get_pending_procname_change(cpu, tb, exit_code):
            if exit_code: # Didn&#39;t actually execute block
                return None
            if not self.in_kernel(cpu): # Once we&#39;re out of kernel code, grab procname
                process = self.plugins[&#39;osi&#39;].get_current_process(cpu)
                if process != self.ffi.NULL:
                    name = self.ffi.string(process.name).decode(&#34;utf8&#34;, &#34;ignore&#34;)
                else:
                    return None # Couldn&#39;t figure out the process
                asid = self.libpanda.panda_current_asid(cpu)
                self.asid_mapping[asid] = name
                self._procname_changed(cpu, name)
                self.disable_callback(&#39;__get_pending_procname_change&#39;) # Disabled to begin


        # Local function def
        @self.callback.asid_changed
        def __asid_changed(cpustate, old_asid, new_asid):
            &#39;&#39;&#39;
            When the ASID changes, check if we know its procname (in self.asid_mapping),
            if so, call panda._procname_changed(cpu, name). Otherwise, we enable __get_pending_procname_change CB, which
            waits until the procname changes. Then we grab the new procname, update self.asid_mapping and call
            panda._procname_changed(cpu, name)
            &#39;&#39;&#39;
            if old_asid == new_asid:
                return 0

            if new_asid not in self.asid_mapping: # We don&#39;t know this ASID-&gt;procname - turn on __get_pending_procname_change
                if not self.is_callback_enabled(&#39;__get_pending_procname_change&#39;):
                    self.enable_callback(&#39;__get_pending_procname_change&#39;)
            else: # We do know this ASID-&gt;procname, just call procname_changed
                self._procname_changed(cpustate, self.asid_mapping[new_asid])

            return 0

        self.register_callback(self.callback.asid_changed, __asid_changed, &#34;__asid_changed&#34;) # Always call on ASID change

        # This internal callback is only enabled on-demand (later) when we need to figure out ASID-&gt;procname mappings
        self.register_callback(self.callback.after_block_exec, __get_pending_procname_change, &#34;__get_pending_procname_change&#34;, enabled=False)

        self._registered_asid_changed_internal_cb = True

    def register_callback(self, callback, function, name, enabled=True, procname=None):
        # CB   = self.callback.main_loop_wait
        # func = main_loop_wait_cb
        # name = main_loop_wait

        if name in self.registered_callbacks:
            print(f&#34;Warning: replacing existing callback &#39;{name}&#39; since it was re-registered&#34;)
            self.delete_callback(name)

        cb = self.callback_dictionary[callback]

        # Generate a unique handle for each callback type using the number of previously registered CBs of that type added to a constant
        self.plugin_register_count += 1
        handle = self.ffi.cast(&#39;void *&#39;, self.plugin_register_count)

        # XXX: We should have another layer of indirection here so we can catch
        #      exceptions raised during execution of the CB and abort analysis
        pcb = self.ffi.new(&#34;panda_cb *&#34;, {cb.name:function})

        if debug:
            progress(&#34;Registered function &#39;{}&#39; to run on callback {}&#34;.format(name, cb.name))

        self.libpanda.panda_register_callback_helper(handle, cb.number, pcb)
        self.registered_callbacks[name] = {&#34;procname&#34;: procname, &#34;enabled&#34;: True, &#34;callback&#34;: cb,
                           &#34;handle&#34;: handle, &#34;pcb&#34;: pcb, &#34;function&#34;: function} # XXX: if function is not saved here it gets GC&#39;d and everything breaks! Watch out!

        if not enabled: # Note the registered_callbacks dict starts with enabled true and then we update it to false as necessary here
            self.disable_callback(name)

        if &#34;block&#34; in cb.name and &#34;start&#34; not in cb.name and &#34;end&#34; not in cb.name:
            if not self.disabled_tb_chaining:
                print(&#34;Warning: disabling TB chaining to support {} callback&#34;.format(cb.name))
                self.disable_tb_chaining()


    def is_callback_enabled(self, name):
        if name not in self.registered_callbacks.keys():
            raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))
        return self.registered_callbacks[name][&#39;enabled&#39;]

    def enable_internal_callbacks(self):
        &#39;&#39;&#39;
        Enable all our internal callbacks that start with __ such as __main_loop_wait
        and __asid_changed. Important in case user has done a panda.end_analysis()
        and then (re)called run
        &#39;&#39;&#39;
        for name in self.registered_callbacks.keys():
            if name.startswith(&#34;__&#34;) and not self.registered_callbacks[name][&#39;enabled&#39;]:
                self.enable_callback(name)

    def enable_all_callbacks(self):
        &#39;&#39;&#39;
        Enable all python callbacks that have been disabled
        &#39;&#39;&#39;
        for name in self.registered_callbacks.keys():
            self.enable_callback(name)

    def enable_callback(self, name):
        &#39;&#39;&#39;
        Enable a panda plugin using its handle and cb.number as a unique ID
        &#39;&#39;&#39;

        # During shutdown callback may be deleted before a request to enable comes through
        if self.ending:
            return

        if name not in self.registered_callbacks.keys():
            raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))

        self.registered_callbacks[name][&#39;enabled&#39;] = True
        handle = self.registered_callbacks[name][&#39;handle&#39;]
        cb = self.registered_callbacks[name][&#39;callback&#39;]
        pcb = self.registered_callbacks[name][&#39;pcb&#39;]
        #progress(&#34;Enabling callback &#39;{}&#39; on &#39;{}&#39; handle = {}&#34;.format(name, cb.name, handle))
        self.libpanda.panda_enable_callback_helper(handle, cb.number, pcb)

    def disable_callback(self, name, forever=False):
        &#39;&#39;&#39;
        Disable a panda plugin using its handle and cb.number as a unique ID
        If forever is specified, we&#39;ll never reenable the call- useful when
        you want to really turn off something with a procname filter.
        &#39;&#39;&#39;
        # During shutdown callback may be deleted before a request to enable comes through
        if self.ending:
            return

        if name not in self.registered_callbacks.keys():
            raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))
        self.registered_callbacks[name][&#39;enabled&#39;] = False
        handle = self.registered_callbacks[name][&#39;handle&#39;]
        cb = self.registered_callbacks[name][&#39;callback&#39;]
        pcb = self.registered_callbacks[name][&#39;pcb&#39;]
        #progress(&#34;Disabling callback &#39;{}&#39; on &#39;{}&#39; handle={}&#34;.format(name, cb.name, handle))
        self.libpanda.panda_disable_callback_helper(handle, cb.number, pcb)

        if forever:
            del self.registered_callbacks[name]

    def delete_callback(self, name):
        &#39;&#39;&#39;
        Completely delete a registered panda callback by name
        &#39;&#39;&#39;
        if name not in self.registered_callbacks.keys():
            raise ValueError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))

        handle = self.registered_callbacks[name][&#39;handle&#39;]
        self.libpanda.panda_unregister_callbacks(handle)
        if not hasattr(self,&#34;old_cb_list&#34;):
            self.old_cb_list = []
        self.old_cb_list.append(self.registered_callbacks[name])
        del self.registered_callbacks[name][&#39;handle&#39;]
        del self.registered_callbacks[name]

    def delete_callbacks(self):
        #for name in self.registered_callbacks.keys():
        while len(self.registered_callbacks.keys()) &gt; 0:
            self.delete_callback(list(self.registered_callbacks.keys())[0])

        # Disable PPP callbacks
        for name in list(self.ppp_registered_cbs) if hasattr(self, &#39;ppp_registered_cbs&#39;) else []:
            self.disable_ppp(name)

    ###########################
    ### PPP-style callbacks ###
    ###########################

    def ppp(self, plugin_name, attr, name=None, autoload=True):
        &#39;&#39;&#39;
        Decorator for plugin-to-plugin interface. Note this isn&#39;t in decorators.py
        becuase it uses the panda object.

        Example usage to register my_run with syscalls2 as a &#39;on_sys_open_return&#39;
        @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;)
        def my_fun(cpu, pc, filename, flags, mode):
            ...
        &#39;&#39;&#39;

        if plugin_name not in self.plugins and autoload: # Could automatically load it?
            print(f&#34;PPP automatically loaded plugin {plugin_name}&#34;)

        if not hasattr(self, &#34;ppp_registered_cbs&#34;):
            self.ppp_registered_cbs = {}
            # We use this to traak fn_names-&gt;fn_pointers so we can later disable by name

            # XXX: if  we don&#39;t save the cffi generated callbacks somewhere in Python,
            # they may get garbage collected even though the c-code could still has a
            # reference to them  which will lead to a crash. If we stop using this to track
            # function names, we need to keep it or something similar to ensure the reference
            # count remains &gt;0 in python

        def decorator(fun):
            local_name = name  # We need a new varaible otherwise we have scoping issues, maybe
            if local_name is None:
                local_name = fun.__name__

            def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
                if not hasattr(self, &#34;exit_exception&#34;):
                    try:
                        r = fun(*args, **kwargs)
                        #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                        #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                        if return_type is not None:
                            try:
                                return self.ffi.cast(return_type, r)
                            except TypeError:
                                # consider throwing an exception
                                return self.ffi.cast(return_type, 0)
                    except Exception as e:
                        # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                        # machine exits.
                        if self.catch_exceptions:
                            self.exit_exception = e
                            self.end_analysis()
                        else:
                            raise e
                        # this works in all current callback cases. CFFI auto-converts to void, bool, int, and int32_t
                        if return_type is not None:
                            return self.ffi.cast(return_type, 0)

            cast_rc = self.ffi.callback(attr+&#34;_t&#34;)(_run_and_catch)  # Wrap the python fn in a c-callback.
            return_type = self.ffi.typeof(cast_rc).result
            
            if return_type.cname == &#34;void&#34;:
                return_type = None

            if local_name == &#34;&lt;lambda&gt;&#34;:
                local_name = f&#34;&lt;lambda_{self.lambda_cnt}&gt;&#34;
                self.lambda_cnt += 1

            if local_name in self.ppp_registered_cbs:
                print(f&#34;Warning: replacing existing PPP callback &#39;{local_name}&#39; since it was re-registered&#34;)
                self.disable_ppp(local_name)

            assert (local_name not in self.ppp_registered_cbs), f&#34;Two callbacks with conflicting name: {local_name}&#34;

            # Ensure function isn&#39;t garbage collected, and keep the name-&gt;(fn, plugin_name, attr) map for disabling
            self.ppp_registered_cbs[local_name] = (cast_rc, plugin_name, attr)

            getattr(self.plugins[plugin_name], f&#39;ppp_add_cb_{attr}&#39;)(cast_rc) # All PPP  cbs start with this string.
            return cast_rc
        return decorator


    def disable_ppp(self, name):
        &#39;&#39;&#39;
        Disable a ppp-style callback by name.
        Unlike regular panda callbacks which can be enabled/disabled/deleted, PPP callbacks are only enabled/deleted (which we call disabled)

        Example usage to register my_run with syscalls2 as a &#39;on_sys_open_return&#39; and then disable:
        ```
        @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;)
        def my_fun(cpu, pc, filename, flags, mode):
            ...

        panda.disable_ppp(&#34;my_fun&#34;)
        ```

        -- OR --

        ```
        @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;, name=&#34;custom&#34;)
        def my_fun(cpu, pc, filename, flags, mode):
            ...
        ```

        panda.disable_ppp(&#34;custom&#34;)
        &#39;&#39;&#39;

        (f, plugin_name, attr) = self.ppp_registered_cbs[name]
        getattr(self.plugins[plugin_name], f&#39;ppp_remove_cb_{attr}&#39;)(f) # All PPP cbs start with this string.
        del self.ppp_registered_cbs[name] # It&#39;s now safe to be garbage collected

    ########## GDB MIXINS ##############
    &#34;&#34;&#34;
    Provides the ability to interact with a QEMU attached gdb session by setting and clearing breakpoints. Experimental.
    &#34;&#34;&#34;

    def set_breakpoint(self, cpu, pc):
        &#39;&#39;&#39;
        Set a GDB breakpoint such that when the guest hits PC, execution is paused and an attached
        GDB instance can introspect on guest memory. Requires starting panda with -s, at least for now
        &#39;&#39;&#39;
        BP_GDB = 0x10
        self.libpanda.cpu_breakpoint_insert(cpu, pc, BP_GDB, self.ffi.NULL)

    def clear_breakpoint(self, cpu, pc):
        &#39;&#39;&#39;
        Remove a breakpoint
        &#39;&#39;&#39;
        BP_GDB = 0x10
        self.libpanda.cpu_breakpoint_remove(cpu, pc, BP_GDB)

    ############# HOOKING MIXINS ###############

    def hook(self, addr, enabled=True, kernel=None, asid=None, cb_type=&#34;start_block_exec&#34;):
        &#39;&#39;&#39;
        Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
        the function will be called with args (CPUState, TranslationBlock)
        &#39;&#39;&#39;

        def decorator(fun):
            if cb_type == &#34;before_tcg_codegen&#34; or cb_type == &#34;after_block_translate&#34; or cb_type == &#34;before_block_exec&#34; or cb_type == &#34;start_block_exec&#34; or cb_type == &#34;end_block_exec&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , struct hook *)&#34;)
            elif cb_type == &#34;after_block_exec&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , uint8_t, struct hook *)&#34;)
            elif cb_type == &#34;before_block_translate&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState* env, target_ptr_t pc, struct hook*)&#34;)
            elif cb_type == &#34;before_block_exec_invalidate_opt&#34;:
                hook_cb_type = self.ffi.callback(&#34;bool(CPUState* env, TranslationBlock*, struct hook*)&#34;)
            else:
                print(&#34;function type not supported&#34;)
                return
            type_num = getattr(self.libpanda, &#34;PANDA_CB_&#34;+cb_type.upper())

            if debug:
                print(&#34;Registering breakpoint at 0x{:x} -&gt; {} == {}&#34;.format(addr, fun, &#39;cdata_cb&#39;))
            
            def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
                if not hasattr(self, &#34;exit_exception&#34;):
                    try:
                        r = fun(*args, **kwargs)
                        #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                        #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                        #print(fun, r) # Stuck with TypeError in _run_and_catch? Enable this to find where the bug is.
                        return r
                    except Exception as e:
                        # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                        # machine exits.
                        if self.catch_exceptions:
                            self.exit_exception = e
                            self.end_analysis()
                        else:
                            raise e
                        return 0

            # Inform the plugin that it has a new breakpoint at addr
            hook_cb_passed = hook_cb_type(_run_and_catch)
            new_hook = self.ffi.new(&#34;struct hook*&#34;)
            new_hook.type = type_num
            new_hook.addr = addr
            if kernel or asid is None:
                new_hook.asid = 0
            else:
                new_hook.asid = asid

            setattr(new_hook.cb,cb_type, hook_cb_passed)
            if kernel:
                new_hook.km = self.libpanda.MODE_KERNEL_ONLY
            elif kernel == False:
                new_hook.km = self.libpanda.MODE_USER_ONLY
            else:
                new_hook.km = self.libpanda.MODE_ANY
            new_hook.enabled = enabled

            self.plugins[&#39;hooks&#39;].add_hook(new_hook)
            self.hook_list.append((new_hook, hook_cb_passed))

            def wrapper(*args, **kw):
                return _run_and_catch(args,kw)
            return wrapper
        return decorator

    def hook_symbol_resolution(self, libraryname, symbol, name=None):
        &#39;&#39;&#39;
        Decorate a function to setup a hook: when a guest process resolves a symbol
        the function will be called with args (CPUState, struct hook_symbol_resolve, struct symbol, OsiModule)

        Args:
            libraryname (string): Name of library containing symbol to be hooked. May be None to match any.
            symbol (string, int): Name of symbol or offset into library to hook
            name (string): name of hook, defaults to function name

        Returns:
            None: Decorated function is called when guest resolves the specified symbol in the specified library.
        &#39;&#39;&#39;
        #Mostly based on hook_symbol below
        def decorator(fun):
            sh = self.ffi.new(&#34;struct hook_symbol_resolve*&#34;)
            sh.hook_offset = False
            if symbol is not None:
                if isinstance(symbol, int):
                    sh.offset = symbol
                    sh.hook_offset = True
                    symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
                else:
                    symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(symbol,&#34;utf-8&#34;))
            else:
                symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
            self.ffi.memmove(sh.name,symbolname_ffi,len(symbolname_ffi))

            if libraryname is not None:
                libname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(libraryname,&#34;utf-8&#34;))
            else:
                libname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
            self.ffi.memmove(sh.section,libname_ffi,len(libname_ffi))

            #sh.id #not used here
            sh.enabled = True
            def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
                if not hasattr(self, &#34;exit_exception&#34;):
                    try:
                        r = fun(*args, **kwargs)
                        return r
                    except Exception as e:
                        # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                        # machine exits.
                        if self.catch_exceptions:
                            self.exit_exception = e
                            self.end_analysis()
                        else:
                            raise e
                        return None

            sr_hook_cb_type = self.ffi.callback(&#34;void (struct hook_symbol_resolve *sh, struct symbol s, target_ulong asid)&#34;)
            sr_hook_cb_ptr = sr_hook_cb_type(_run_and_catch)
            sh.cb = sr_hook_cb_ptr
            hook_ptr = self.plugins[&#39;dynamic_symbols&#39;].hook_symbol_resolution(sh)
            self.sr_hooks.append((sh, sr_hook_cb_ptr, hook_ptr))

            def wrapper(*args, **kw):
                _run_and_catch(args,kw)
            return wrapper
        return decorator

    def hook_symbol(self, libraryname, symbol, kernel=False, name=None, cb_type=&#34;start_block_exec&#34;):
        &#39;&#39;&#39;
        Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
        the function will be called with args (CPUState, TranslationBlock, struct hook)

        Args:
            libraryname (string): Name of library containing symbol to be hooked. May be None to match any.
            symbol (string, int): Name of symbol or offset into library to hook
            kernel (bool): if hook should be applied exclusively in kernel mode
            name (string): name of hook, defaults to function name
            cb_type (string): callback-type, defaults to start_block_exec

        Returns:
            None: Decorated function is called when (before/after is determined by cb_type) guest goes to call
                  the specified symbol in the specified library.
        &#39;&#39;&#39;

        def decorator(fun):
            if cb_type == &#34;before_tcg_codegen&#34; or cb_type == &#34;after_block_translate&#34; or cb_type == &#34;before_block_exec&#34; or cb_type == &#34;start_block_exec&#34; or cb_type == &#34;end_block_exec&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , struct hook *)&#34;)
            elif cb_type == &#34;after_block_exec&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , uint8_t, struct hook *)&#34;)
            elif cb_type == &#34;before_block_translate&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState* env, target_ptr_t pc, struct hook*)&#34;)
            elif cb_type == &#34;before_block_exec_invalidate_opt&#34;:
                hook_cb_type = self.ffi.callback(&#34;bool(CPUState* env, TranslationBlock*, struct hook*)&#34;)
            else:
                print(&#34;function type not supported&#34;)
                return

            def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
                if not hasattr(self, &#34;exit_exception&#34;):
                    try:
                        r = fun(*args, **kwargs)
                        return r
                    except Exception as e:
                        # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                        # machine exits.
                        if self.catch_exceptions:
                            self.exit_exception = e
                            self.end_analysis()
                        else:
                            raise e
                        if cb_type == &#34;before_block_exec_invalidate_opt&#34;:
                            return False
                        return None


            # Inform the plugin that it has a new breakpoint at addr
            hook_cb_passed = hook_cb_type(_run_and_catch)
            new_hook = self.ffi.new(&#34;struct symbol_hook*&#34;)
            type_num = getattr(self.libpanda, &#34;PANDA_CB_&#34;+cb_type.upper())
            new_hook.type = type_num
            if libraryname is not None:
                libname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(libraryname,&#34;utf-8&#34;))
            else:
                libname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
            self.ffi.memmove(new_hook.section,libname_ffi,len(libname_ffi))

            new_hook.hook_offset = False
            if symbol is not None:
                if isinstance(symbol, int):
                    new_hook.offset = symbol
                    new_hook.hook_offset = True
                    symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
                else:
                    symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(symbol,&#34;utf-8&#34;))
                    new_hook.hook_offset = False
            else:
                symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
            self.ffi.memmove(new_hook.name,symbolname_ffi,len(symbolname_ffi))
            setattr(new_hook.cb,cb_type, hook_cb_passed)
            hook_ptr = self.plugins[&#39;hooks&#39;].add_symbol_hook(new_hook)
            if name is not None:
                self.named_hooks[name] = hook_ptr
            self.hook_list.append((fun, new_hook,hook_cb_passed, hook_ptr))

            def wrapper(*args, **kw):
                _run_and_catch(args,kw)
            return wrapper
        return decorator

    def get_best_matching_symbol(self, cpu, pc=None, asid=None):
        &#39;&#39;&#39;
        Use the dynamic symbols plugin to get the best matching symbol for a given program counter.

        Args:
            cpu (CPUState): CPUState structure
            pc (int): program counter, defaults to current
            asid (int): ASID, defaults to current
        &#39;&#39;&#39;
        if asid is None:
            asid = self.current_asid(cpu)
        if pc is None:
            pc = self.current_pc(cpu)
        return self.plugins[&#39;dynamic_symbols&#39;].get_best_matching_symbol(cpu, pc, asid)


    ################### Hooks2 Functions ############
    # Provides the ability to interact with the hooks2 plugin and receive callbacks based on user-provided criteria.

    def enable_hook2(self,hook_name):
        &#39;&#39;&#39;
        Set a hook2-plugin hook&#39;s status to active.

        .. Deprecated:: Use the hooks plugin instead.
        &#39;&#39;&#39;
        if hook_name in self.hook_list2:
            self.plugins[&#39;hooks2&#39;].enable_hooks2(self.hook_list2[hook_name])
        else:
            print(&#34;ERROR: Your hook name was not in the hook list&#34;)

    def disable_hook2(self,hook_name):
        &#39;&#39;&#39;
        Set a hook2-plugin hook&#39;s status to inactive.

        .. Deprecated:: Use the hooks plugin instead.
        &#39;&#39;&#39;
        if hook_name in self.hook_list2:
            self.plugins[&#39;hooks2&#39;].disable_hooks2(self.hook_list2[hook_name])
        else:
            print(&#34;ERROR: Your hook name was not in the hook list&#34;)

    def hook2(self,name, kernel=True, procname=None, libname=None, trace_start=0, trace_stop=0, range_begin=0, range_end=0):
        &#39;&#39;&#39;
        Decorator to create a hook with the hooks2 plugin.

        .. Deprecated:: Use the hooks plugin instead.
        &#39;&#39;&#39;

        if procname == None:
            procname = self.ffi.NULL
        if libname == None:
            libname = self.ffi.NULL


        if procname != self.ffi.NULL:
            procname = self.ffi.new(&#34;char[]&#34;,bytes(procname,&#34;utf-8&#34;))
        if libname != self.ffi.NULL:
            libname = self.ffi.new(&#34;char[]&#34;,bytes(libname,&#34;utf-8&#34;))
        &#39;&#39;&#39;
        Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
        the function will be called with args (CPUState, TranslationBlock)
        &#39;&#39;&#39;
        def decorator(fun):
            # Ultimately, our hook resolves as a before_block_exec_invalidate_opt callback so we must match its args
            hook_cb_type = self.ffi.callback(&#34;bool (CPUState*, TranslationBlock*, void*)&#34;)
            # Inform the plugin that it has a new breakpoint at addr

            def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
                if not hasattr(self, &#34;exit_exception&#34;):
                    try:
                        r = fun(*args, **kwargs)
                        #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                        #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                        #print(fun, r) # Stuck with TypeError in _run_and_catch? Enable this to find where the bug is.
                        return r
                    except Exception as e:
                        # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                        # machine exits.
                        if self.catch_exceptions:
                            self.exit_exception = e
                            self.end_analysis()
                        else:
                            raise e
                        return True


            hook_cb_passed = hook_cb_type(_run_and_catch)
            if not hasattr(self, &#34;hook_gc_list&#34;):
                self.hook_gc_list = [hook_cb_passed]
            else:
                self.hook_gc_list.append(hook_cb_passed)

            # I don&#39;t know what this is/does
            cb_data =self.ffi.NULL
            hook_number = self.plugins[&#39;hooks2&#39;].add_hooks2(hook_cb_passed, cb_data, kernel, \
                procname, libname, trace_start, trace_stop, range_begin,range_end)

            self.hook_list2[name] = hook_number

            def wrapper(*args, **kw):
                return _run_and_catch(*args, **kw)
            return wrapper
        return decorator

    def hook2_single_insn(self, name, pc, kernel=False, procname=None, libname=None):
        &#39;&#39;&#39;
        Helper function to hook a single instruction with the hooks2 plugin.

        .. Deprecated:: Use the hooks plugin instead.
        &#39;&#39;&#39;
        if procname == None:
            procname = self.ffi.NULL
        if libname == None:
            libname = self.ffi.NULL
        return self.hook2(name, kernel=kernel, procname=procname,libname=libname,range_begin=pc, range_end=pc)

    # MEM HOOKS
    def _hook_mem(self, start_address, end_address, before, after, read, write, virtual, physical, enabled):
        def decorator(fun):
            mem_hook_cb_type = self.ffi.callback(&#34;mem_hook_func_t&#34;)
            # Inform the plugin that it has a new breakpoint at addr
            
            def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
                if not hasattr(self, &#34;exit_exception&#34;):
                    try:
                        r = fun(*args, **kwargs)
                        return r
                    except Exception as e:
                        # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                        # machine exits.
                        if self.catch_exceptions:
                            self.exit_exception = e
                            self.end_analysis()
                        else:
                            raise e
                        return None

            hook_cb_passed = mem_hook_cb_type(_run_and_catch)
            mem_reg = self.ffi.new(&#34;struct memory_hooks_region*&#34;)
            mem_reg.start_address = start_address
            mem_reg.stop_address = end_address
            mem_reg.on_before = before
            mem_reg.on_after = after
            mem_reg.on_read = read
            mem_reg.on_write = write
            mem_reg.on_virtual = virtual
            mem_reg.on_physical = physical
            mem_reg.enabled = enabled
            mem_reg.cb = hook_cb_passed

            hook = self.plugins[&#39;mem_hooks&#39;].add_mem_hook(mem_reg)

            self.mem_hooks[hook] = [mem_reg, hook_cb_passed]


            def wrapper(*args, **kw):
                _run_and_catch(args,kw)


            return wrapper
        return decorator

    def hook_mem(self, start_address, end_address, on_before, on_after, on_read, on_write, on_virtual, on_physical, enabled):
        &#39;&#39;&#39;
        Decorator to hook a memory range with the mem_hooks plugin

        .. todo:: Fully document mem-hook decorators
        &#39;&#39;&#39;
        return self._hook_mem(start_address,end_address,on_before,on_after,on_read, on_write, on_virtual, on_physical, enabled)

    def hook_phys_mem_read(self, start_address, end_address, on_before=True, on_after=False, enabled=True):
        &#39;&#39;&#39;
        Decorator to hook physical memory reads with the mem_hooks plugin
        &#39;&#39;&#39;
        return self._hook_mem(start_address,end_address,on_before,on_after, True, False, False, True, True)

    def hook_phys_mem_write(self, start_address, end_address, on_before=True, on_after=False):
        &#39;&#39;&#39;
        Decorator to hook physical memory writes with the mem_hooks plugin
        &#39;&#39;&#39;
        return self._hook_mem(start_address,end_address,on_before,on_after, False, True, False, True, True)

    def hook_virt_mem_read(self, start_address, end_address, on_before=True, on_after=False):
        &#39;&#39;&#39;
        Decorator to hook virtual memory reads with the mem_hooks plugin
        &#39;&#39;&#39;
        return self._hook_mem(start_address,end_address,on_before,on_after, True, False, True, False, True)

    def hook_virt_mem_write(self, start_address, end_address, on_before=True, on_after=False):
        &#39;&#39;&#39;
        Decorator to hook virtual memory writes with the mem_hooks plugin
        &#39;&#39;&#39;
        return self._hook_mem(start_address,end_address,on_before,on_after, False, True, True, False, True)
    
    # HYPERCALLS
    def hypercall(self, magic):
        def decorator(fun):
            hypercall_cb_type = self.ffi.callback(&#34;hypercall_t&#34;)
            
            def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
                if not hasattr(self, &#34;exit_exception&#34;):
                    try:
                        r = fun(*args, **kwargs)
                        return r
                    except Exception as e:
                        # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                        # machine exits.
                        if self.catch_exceptions:
                            self.exit_exception = e
                            self.end_analysis()
                        else:
                            raise e
                        return None

            hook_cb_passed = hypercall_cb_type(_run_and_catch)
            if type(magic) is int:
                self.plugins[&#39;hypercaller&#39;].register_hypercall(magic, hook_cb_passed)
            elif type(magic) is list:
                for m in magic:
                    if type(m) is int:
                        self.plugins[&#39;hypercaller&#39;].register_hypercall(m, hook_cb_passed)
                    else:
                        raise TypeError(&#34;Magic list must consist of integers&#34;)
            else:
                raise TypeError(&#34;Magics must be either an int or list of ints&#34;)

            def wrapper(*args, **kw):
                _run_and_catch(args,kw)
            self.hypercalls[wrapper] = [hook_cb_passed,magic]
            return wrapper
        return decorator
    
    def disable_hypercall(self, fn):
        if fn in self.hypercalls:
            magic = self.hypercalls[fn][1]
            if type(magic) is int:
                self.plugins[&#39;hypercaller&#39;].unregister_hypercall(magic)
            elif type(magic) is list:
                for m in magic:
                    self.plugins[&#39;hypercaller&#39;].unregister_hypercall(m)
        else:
            breakpoint()
            print(&#34;ERROR: Your hypercall was not in the hook list&#34;)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pandare.Panda.arch"><code class="name">var <span class="ident">arch</span></code></dt>
<dd>
<div class="desc"><p>A reference to an auto-instantiated <code><a title="pandare.arch.PandaArch" href="arch.html#pandare.arch.PandaArch">PandaArch</a></code> subclass (e.g., <code><a title="pandare.arch.X86Arch" href="arch.html#pandare.arch.X86Arch">X86Arch</a></code>)</p></div>
</dd>
<dt id="pandare.Panda.pyplugins"><code class="name">var <span class="ident">pyplugins</span></code></dt>
<dd>
<div class="desc"><p>A reference to an auto-instantiated <code>pandare.pyplugin.PyPluginManager</code> class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pyplugins(self):
    &#34;&#34;&#34;
    A reference to an auto-instantiated `pandare.pyplugin.PyPluginManager` class.
    &#34;&#34;&#34;
    if not hasattr(self, &#34;_pyplugin_manager&#34;):
        from .pypluginmanager import PyPluginManager
        self._pyplugin_manager = PyPluginManager(self)
    return self._pyplugin_manager</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pandare.Panda.address_to_ram_offset"><code class="name flex">
<span>def <span class="ident">address_to_ram_offset</span></span>(<span>self, hwaddr, is_write)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert physical address to ram offset</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hwaddr</code></strong> :&ensp;<code>int</code></dt>
<dd>physical address</dd>
<dt><strong><code>is_write</code></strong> :&ensp;<code>bool</code></dt>
<dd>boolean representing if this is a write</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ram offset (int)</p>
<h2 id="raises">Raises</h2>
<p>ValueError if memory access fails or fmt is unsupported</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def address_to_ram_offset(self, hwaddr, is_write):
    &#39;&#39;&#39;
    Convert physical address to ram offset

    Args:
        hwaddr (int): physical address
        is_write (bool): boolean representing if this is a write

    Returns:
        ram offset (int)

    Raises:
        ValueError if memory access fails or fmt is unsupported
    &#39;&#39;&#39;
    
    out = self.ffi.new(&#34;ram_addr_t*&#34;, self.ffi.cast(&#34;ram_addr_t&#34;, 0))
    value = self.libpanda.PandaPhysicalAddressToRamOffset_external(out, hwaddr, is_write)
    if value != 0:
        raise ValueError(f&#34;address_to_ram_offset returned {value}&#34;)
    return out[0]</code></pre>
</details>
</dd>
<dt id="pandare.Panda.arm_load_kernel"><code class="name flex">
<span>def <span class="ident">arm_load_kernel</span></span>(<span>self, cpu, bootinfo)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arm_load_kernel(self, cpu, bootinfo):
    return self.libpanda.arm_load_kernel(cpu, bootinfo)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.break_exec"><code class="name flex">
<span>def <span class="ident">break_exec</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If called from a start block exec callback, will cause the emulation to bail <em>before</em> executing
the rest of the current block.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def break_exec(self):
    &#39;&#39;&#39;
    If called from a start block exec callback, will cause the emulation to bail *before* executing
    the rest of the current block.
    &#39;&#39;&#39;
    return self.libpanda.panda_do_break_exec()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.callstack_callers"><code class="name flex">
<span>def <span class="ident">callstack_callers</span></span>(<span>self, lim, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function for callstack_instr plugin
Handle conversion and return get_callers from callstack_instr.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def callstack_callers(self, lim, cpu): # XXX move into new directory, &#39;callstack&#39; ?
    &#39;&#39;&#39;
    Helper function for callstack_instr plugin
    Handle conversion and return get_callers from callstack_instr.
    &#39;&#39;&#39;
    if not &#34;callstack_instr&#34; in self.plugins:
        progress(&#34;enabling callstack_instr plugin&#34;)
        self.load_plugin(&#34;callstack_instr&#34;)

    callers = self.ffi.new(&#34;uint%d_t[%d]&#34; % (self.bits, lim))
    n = self.plugins[&#39;callstack_instr&#39;].get_callers(callers, lim, cpu)
    c = []
    for pc in callers:
        c.append(pc)
    return c</code></pre>
</details>
</dd>
<dt id="pandare.Panda.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Unload all plugins and close pandalog.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup(self):
    &#39;&#39;&#39;
    Unload all plugins and close pandalog.

    Returns:
        None
    &#39;&#39;&#39;
    self.libpanda.panda_cleanup()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.clear_breakpoint"><code class="name flex">
<span>def <span class="ident">clear_breakpoint</span></span>(<span>self, cpu, pc)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a breakpoint</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_breakpoint(self, cpu, pc):
    &#39;&#39;&#39;
    Remove a breakpoint
    &#39;&#39;&#39;
    BP_GDB = 0x10
    self.libpanda.cpu_breakpoint_remove(cpu, pc, BP_GDB)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.cont"><code class="name flex">
<span>def <span class="ident">cont</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Continue execution (run after vm_stop)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cont(self):
    &#39;&#39;&#39; Continue execution (run after vm_stop) &#39;&#39;&#39;
    self.libpanda.panda_cont()
    self.running.set()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.copy_to_guest"><code class="name flex">
<span>def <span class="ident">copy_to_guest</span></span>(<span>self, copy_directory, iso_name=None, absolute_paths=False, setup_script='setup.sh', timeout=None, cdrom=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy a directory from the host into the guest by
1) Creating an .iso image of the directory on the host
2) Run a bash command to mount it at the exact same path + .ro and then copy the files to the provided path
3) If the directory contains setup.sh, run it</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>copy_directory</code></strong></dt>
<dd>Local directory to copy into guest</dd>
<dt><strong><code>iso_name</code></strong></dt>
<dd>Name of iso file that will be generated. Defaults to [copy_directory].iso</dd>
<dt><strong><code>absolute_paths</code></strong></dt>
<dd>is copy_directory an absolute or relative path</dd>
<dt><strong><code>seutp_script</code></strong></dt>
<dd>name of a script which, if present inside copy_directory, will be automatically run after the copy</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>maximum time each copy command will be allowed to run for, will use the <code>run_serial_cmd</code> default value unless another is provided</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def copy_to_guest(self, copy_directory, iso_name=None, absolute_paths=False, setup_script=&#34;setup.sh&#34;, timeout=None, cdrom=None):
    &#39;&#39;&#39;

    Copy a directory from the host into the guest by
    1) Creating an .iso image of the directory on the host
    2) Run a bash command to mount it at the exact same path + .ro and then copy the files to the provided path
    3) If the directory contains setup.sh, run it

    Args:
        copy_directory: Local directory to copy into guest
        iso_name: Name of iso file that will be generated. Defaults to [copy_directory].iso
        absolute_paths: is copy_directory an absolute or relative path
        seutp_script: name of a script which, if present inside copy_directory, will be automatically run after the copy
        timeout: maximum time each copy command will be allowed to run for, will use the `run_serial_cmd` default value unless another is provided

    Returns:
        None
    &#39;&#39;&#39;

    if not iso_name:
        iso_name = copy_directory + &#39;.iso&#39;
    make_iso(copy_directory, iso_name)

    if not absolute_paths:
        copy_directory = path.split(copy_directory)[-1] # Copy directory relative, not absolutely


    # Drive the guest to mount the drive
    # setup_sh:
    #   Make sure cdrom didn&#39;t automount
    #   Make sure guest path mirrors host path
    #   if there is a setup.sh script in the directory,
    #   then run that setup.sh script first (good for scripts that need to
    #   prep guest environment before script runs)
    mount_dir = shlex_quote(copy_directory)

    mkdir_result = self.run_serial_cmd(f&#34;mkdir -p {mount_dir} {mount_dir}.ro &amp;&amp; echo \&#34;mkdir_ok\&#34;; echo \&#34;exit code $?\&#34;&#34;, timeout=timeout)

    if &#39;mkdir_ok&#39; not in mkdir_result:
        raise RuntimeError(f&#34;Failed to create mount directories inside guest: {mkdir_result}&#34;)

    # Tell panda to we insert the CD drive
    # TODO: the cd-drive name should be a config option, see the values in qcow.py

    cd_drive_name = cdrom
    if cdrom is None:
        if self.cdrom is not None:
            cd_drive_name = self.cdrom
        else:
            cd_drive_name = &#34;ide1-cd0&#34;

    errs = self.run_monitor_cmd(&#34;change {} \&#34;{}\&#34;&#34;.format(cd_drive_name, iso_name))
    if len(errs):
        warn(f&#34;Warning encountered when connecting media to guest: {errs}&#34;)

    try:
        mount_status = &#34;bad&#34;
        for _ in range(10):
            if &#39;mount_ok&#39; in mount_status:
                break
            mount_status = self.run_serial_cmd(f&#34;mount /dev/cdrom {mount_dir}.ro &amp;&amp; echo &#39;mount_ok&#39; || (umount /dev/cdrom; echo &#39;bad&#39;)&#34;, timeout=timeout)
            sleep(1)
        else:
            # Didn&#39;t ever break
            raise RuntimeError(f&#34;Failed to mount media inside guest: {mount_status}&#34;)

        # Note the . after our src/. directory - that&#39;s special syntax for cp -a
        copy_result = self.run_serial_cmd(f&#34;cp -a {mount_dir}.ro/. {mount_dir} &amp;&amp; echo &#39;copyok&#39;&#34;, timeout=timeout)
        
        # NB: exact match here causing issues so making things more flexible
        if not (&#39;copyok&#39; in copy_result):
            raise RuntimeError(f&#34;Copy to rw directory failed: {copy_result}&#34;)

    finally:
        # Ensure we disconnect the CD drive after the mount + copy, even if it fails
        self.run_serial_cmd(&#34;umount /dev/cdrom&#34;) # This can fail and that&#39;s okay, we&#39;ll forece eject
        sleep(1)
        errs = self.run_monitor_cmd(f&#34;eject -f {cd_drive_name}&#34;)
        if len(errs):
            warn(f&#34;Warning encountered when disconnecting media from guest: {errs}&#34;)

    if isfile(pjoin(copy_directory, setup_script)):
        setup_result = self.run_serial_cmd(f&#34;{mount_dir}/{setup_script}&#34;, timeout=timeout)
        progress(f&#34;[Setup command]: {setup_result}&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.cpu_class_by_name"><code class="name flex">
<span>def <span class="ident">cpu_class_by_name</span></span>(<span>self, name, cpu_model)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets cpu class from name.
Calls cpu_class_by_name QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>typename from python string</dd>
<dt><strong><code>cpu_model</code></strong></dt>
<dd>string specified cpu model</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ObjectClass struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cpu_class_by_name(self, name, cpu_model):
    &#39;&#39;&#39;
    Gets cpu class from name.
    Calls cpu_class_by_name QEMU function.

    Args:
        name: typename from python string
        cpu_model: string specified cpu model

    Returns:
        ObjectClass struct
    &#39;&#39;&#39;
    return self.libpanda.cpu_class_by_name(name, cpu_model)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.create_external_gic"><code class="name flex">
<span>def <span class="ident">create_external_gic</span></span>(<span>self, vbi, irqs, gic_vers, secure)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_external_gic(self, vbi, irqs, gic_vers, secure):
    return self.libpanda.create_external_gic(vbi, irqs, gic_vers, secure)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.create_internal_gic"><code class="name flex">
<span>def <span class="ident">create_internal_gic</span></span>(<span>self, vbi, irqs, gic_vers)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_internal_gic(self, vbi, irqs, gic_vers):
    return self.libpanda.create_internal_gic(vbi, irqs, gic_vers)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.create_one_flash"><code class="name flex">
<span>def <span class="ident">create_one_flash</span></span>(<span>self, name, flashbase, flashsize, filename, mr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_one_flash(self, name, flashbase, flashsize, filename, mr):
    return self.libpanda.create_one_flash(name, flashbase, flashsize, filename, mr)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.create_virtio_devices"><code class="name flex">
<span>def <span class="ident">create_virtio_devices</span></span>(<span>self, vbi, pic)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_virtio_devices(self, vbi, pic):
    return self.libpanda.create_virtio_devices(vbi, pic)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.current_asid"><code class="name flex">
<span>def <span class="ident">current_asid</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get current Application Specific ID</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>integer</code></dt>
<dd>value of current ASID</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def current_asid(self, cpu):
    &#39;&#39;&#39;
    Get current Application Specific ID

    Args:
        cpu (CPUState): CPUState structure

    Returns:
        integer: value of current ASID
    &#39;&#39;&#39;
    return self.libpanda.panda_current_asid(cpu)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.current_pc"><code class="name flex">
<span>def <span class="ident">current_pc</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get current program counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
</dl>
<h2 id="return">Return</h2>
<p>integer value of current program counter</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated:&ensp;Use panda.arch.get_pc(cpu) instead</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def current_pc(self, cpu):
    &#39;&#39;&#39;
    Get current program counter

    Args:
        cpu (CPUState): CPUState structure

    Return:
        integer value of current program counter

    .. Deprecated:: Use panda.arch.get_pc(cpu) instead
    &#39;&#39;&#39;
    return self.libpanda.panda_current_pc(cpu)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.current_sp"><code class="name flex">
<span>def <span class="ident">current_sp</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get current stack pointer</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
</dl>
<h2 id="return">Return</h2>
<p>int: Value of stack pointer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def current_sp(self, cpu):
    &#39;&#39;&#39;
    Get current stack pointer

    Args:
        cpu (CPUState): CPUState structure

    Return:
        int: Value of stack pointer
    &#39;&#39;&#39;
    return self.libpanda.panda_current_sp_external(cpu)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.delete_callback"><code class="name flex">
<span>def <span class="ident">delete_callback</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Completely delete a registered panda callback by name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_callback(self, name):
    &#39;&#39;&#39;
    Completely delete a registered panda callback by name
    &#39;&#39;&#39;
    if name not in self.registered_callbacks.keys():
        raise ValueError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))

    handle = self.registered_callbacks[name][&#39;handle&#39;]
    self.libpanda.panda_unregister_callbacks(handle)
    if not hasattr(self,&#34;old_cb_list&#34;):
        self.old_cb_list = []
    self.old_cb_list.append(self.registered_callbacks[name])
    del self.registered_callbacks[name][&#39;handle&#39;]
    del self.registered_callbacks[name]</code></pre>
</details>
</dd>
<dt id="pandare.Panda.delete_callbacks"><code class="name flex">
<span>def <span class="ident">delete_callbacks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_callbacks(self):
    #for name in self.registered_callbacks.keys():
    while len(self.registered_callbacks.keys()) &gt; 0:
        self.delete_callback(list(self.registered_callbacks.keys())[0])

    # Disable PPP callbacks
    for name in list(self.ppp_registered_cbs) if hasattr(self, &#39;ppp_registered_cbs&#39;) else []:
        self.disable_ppp(name)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.delvm"><code class="name flex">
<span>def <span class="ident">delvm</span></span>(<span>self, snapshot_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete snapshot with specified name</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>snapshot_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the snapshot</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delvm(self, snapshot_name):
    &#39;&#39;&#39;
    Delete snapshot with specified name
    Args:
        snapshot_name (str): name of the snapshot

    Returns:
        None
    &#39;&#39;&#39;

    if debug:
        progress (&#34;Deleting snapshot &#34; + snapshot_name)

    # Stop guest, queue up delete, then continue
    self.vm_stop()
    charptr = self.ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
    self.queue_main_loop_wait_fn(self.libpanda.panda_delvm, [charptr])</code></pre>
</details>
</dd>
<dt id="pandare.Panda.delvm_sync"><code class="name flex">
<span>def <span class="ident">delvm_sync</span></span>(<span>self, snapshot_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def delvm_sync(self, snapshot_name):
    self.run_monitor_cmd(&#34;delvm {}&#34;.format(snapshot_name))</code></pre>
</details>
</dd>
<dt id="pandare.Panda.disable_callback"><code class="name flex">
<span>def <span class="ident">disable_callback</span></span>(<span>self, name, forever=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable a panda plugin using its handle and cb.number as a unique ID
If forever is specified, we'll never reenable the call- useful when
you want to really turn off something with a procname filter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_callback(self, name, forever=False):
    &#39;&#39;&#39;
    Disable a panda plugin using its handle and cb.number as a unique ID
    If forever is specified, we&#39;ll never reenable the call- useful when
    you want to really turn off something with a procname filter.
    &#39;&#39;&#39;
    # During shutdown callback may be deleted before a request to enable comes through
    if self.ending:
        return

    if name not in self.registered_callbacks.keys():
        raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))
    self.registered_callbacks[name][&#39;enabled&#39;] = False
    handle = self.registered_callbacks[name][&#39;handle&#39;]
    cb = self.registered_callbacks[name][&#39;callback&#39;]
    pcb = self.registered_callbacks[name][&#39;pcb&#39;]
    #progress(&#34;Disabling callback &#39;{}&#39; on &#39;{}&#39; handle={}&#34;.format(name, cb.name, handle))
    self.libpanda.panda_disable_callback_helper(handle, cb.number, pcb)

    if forever:
        del self.registered_callbacks[name]</code></pre>
</details>
</dd>
<dt id="pandare.Panda.disable_hook2"><code class="name flex">
<span>def <span class="ident">disable_hook2</span></span>(<span>self, hook_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a hook2-plugin hook's status to inactive.</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated:&ensp;Use the hooks plugin instead.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_hook2(self,hook_name):
    &#39;&#39;&#39;
    Set a hook2-plugin hook&#39;s status to inactive.

    .. Deprecated:: Use the hooks plugin instead.
    &#39;&#39;&#39;
    if hook_name in self.hook_list2:
        self.plugins[&#39;hooks2&#39;].disable_hooks2(self.hook_list2[hook_name])
    else:
        print(&#34;ERROR: Your hook name was not in the hook list&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.disable_hypercall"><code class="name flex">
<span>def <span class="ident">disable_hypercall</span></span>(<span>self, fn)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_hypercall(self, fn):
    if fn in self.hypercalls:
        magic = self.hypercalls[fn][1]
        if type(magic) is int:
            self.plugins[&#39;hypercaller&#39;].unregister_hypercall(magic)
        elif type(magic) is list:
            for m in magic:
                self.plugins[&#39;hypercaller&#39;].unregister_hypercall(m)
    else:
        breakpoint()
        print(&#34;ERROR: Your hypercall was not in the hook list&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.disable_llvm"><code class="name flex">
<span>def <span class="ident">disable_llvm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_llvm(self):
    &#39;&#39;&#39;
    Disables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
    &#39;&#39;&#39;
    self.libpanda.panda_disable_llvm()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.disable_llvm_helpers"><code class="name flex">
<span>def <span class="ident">disable_llvm_helpers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_llvm_helpers(self):
    &#39;&#39;&#39;
    Disables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
    &#39;&#39;&#39;
    self.libpanda.panda_disable_llvm_helpers()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.disable_memcb"><code class="name flex">
<span>def <span class="ident">disable_memcb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable memory callbacks. Must be enabled for memory callbacks to work.
pypanda enables this automatically with some callbacks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_memcb(self):
    &#39;&#39;&#39;
    Disable memory callbacks. Must be enabled for memory callbacks to work.
    pypanda enables this automatically with some callbacks.
    &#39;&#39;&#39;
    self._memcb = False
    self.libpanda.panda_disable_memcb()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.disable_plugin"><code class="name flex">
<span>def <span class="ident">disable_plugin</span></span>(<span>self, handle)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable plugin.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>handle</code></strong> :&ensp;<code>int</code></dt>
<dd>pointer to handle returned by plugin</dd>
</dl>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_plugin(self, handle):
    &#39;&#39;&#39;
    Disable plugin.

    Args:
        handle (int): pointer to handle returned by plugin

    Return:
        None
    &#39;&#39;&#39;
    self.libpanda.panda_disable_plugin(handle)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.disable_ppp"><code class="name flex">
<span>def <span class="ident">disable_ppp</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable a ppp-style callback by name.
Unlike regular panda callbacks which can be enabled/disabled/deleted, PPP callbacks are only enabled/deleted (which we call disabled)</p>
<p>Example usage to register my_run with syscalls2 as a 'on_sys_open_return' and then disable:</p>
<pre><code>@ppp(&quot;syscalls2&quot;, &quot;on_sys_open_return&quot;)
def my_fun(cpu, pc, filename, flags, mode):
    ...

panda.disable_ppp(&quot;my_fun&quot;)
</code></pre>
<p>&ndash; OR &ndash;</p>
<pre><code>@ppp(&quot;syscalls2&quot;, &quot;on_sys_open_return&quot;, name=&quot;custom&quot;)
def my_fun(cpu, pc, filename, flags, mode):
    ...
</code></pre>
<p>panda.disable_ppp("custom")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_ppp(self, name):
    &#39;&#39;&#39;
    Disable a ppp-style callback by name.
    Unlike regular panda callbacks which can be enabled/disabled/deleted, PPP callbacks are only enabled/deleted (which we call disabled)

    Example usage to register my_run with syscalls2 as a &#39;on_sys_open_return&#39; and then disable:
    ```
    @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;)
    def my_fun(cpu, pc, filename, flags, mode):
        ...

    panda.disable_ppp(&#34;my_fun&#34;)
    ```

    -- OR --

    ```
    @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;, name=&#34;custom&#34;)
    def my_fun(cpu, pc, filename, flags, mode):
        ...
    ```

    panda.disable_ppp(&#34;custom&#34;)
    &#39;&#39;&#39;

    (f, plugin_name, attr) = self.ppp_registered_cbs[name]
    getattr(self.plugins[plugin_name], f&#39;ppp_remove_cb_{attr}&#39;)(f) # All PPP cbs start with this string.
    del self.ppp_registered_cbs[name] # It&#39;s now safe to be garbage collected</code></pre>
</details>
</dd>
<dt id="pandare.Panda.disable_precise_pc"><code class="name flex">
<span>def <span class="ident">disable_precise_pc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>By default, QEMU does not update the program counter after every instruction.
This function disables precise tracking of the program counter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_precise_pc(self):
    &#39;&#39;&#39;
    By default, QEMU does not update the program counter after every instruction.
    This function disables precise tracking of the program counter.
    &#39;&#39;&#39;
    self.libpanda.panda_disable_precise_pc()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.disable_tb_chaining"><code class="name flex">
<span>def <span class="ident">disable_tb_chaining</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function disables translation block chaining in QEMU</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_tb_chaining(self):
    &#39;&#39;&#39;
    This function disables translation block chaining in QEMU
    &#39;&#39;&#39;
    if not self.disabled_tb_chaining:
        if debug:
            progress(&#34;Disabling TB chaining&#34;)
        self.disabled_tb_chaining = True
        self.libpanda.panda_disable_tb_chaining()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.disas2"><code class="name flex">
<span>def <span class="ident">disas2</span></span>(<span>self, code, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Call panda_disas to diasassemble an amount of code at a pointer.
FIXME: seem to not match up to PANDA definition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disas2(self, code, size):
    &#39;&#39;&#39;
    Call panda_disas to diasassemble an amount of code at a pointer.
    FIXME: seem to not match up to PANDA definition
    &#39;&#39;&#39;
    self.libpanda.panda_disas(code, size)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.do_panda_finish"><code class="name flex">
<span>def <span class="ident">do_panda_finish</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Call panda_finish. Note this isn't really blocking - the
guest should have exited by now, but queue this after
(blocking) shutdown commands in our internal async queue
so it must also be labeled as blocking.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @blocking
    def do_panda_finish(self):
        &#39;&#39;&#39;
        Call panda_finish. Note this isn&#39;t really blocking - the
        guest should have exited by now, but queue this after
        (blocking) shutdown commands in our internal async queue
        so it must also be labeled as blocking.
        &#39;&#39;&#39;
#        assert (not self.running.is_set()), &#34;Can&#39;t finish while still running&#34;
        self.panda_finish()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.drive_get"><code class="name flex">
<span>def <span class="ident">drive_get</span></span>(<span>self, blocktype, bus, unit)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets DriveInfo struct from user specified information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>blocktype</code></strong></dt>
<dd>BlockInterfaceType structure</dd>
<dt><strong><code>bus</code></strong></dt>
<dd>integer bus</dd>
<dt><strong><code>unit</code></strong></dt>
<dd>integer unit</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DriveInfo struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drive_get(self, blocktype, bus, unit):
    &#39;&#39;&#39;
    Gets DriveInfo struct from user specified information.

    Args:
        blocktype: BlockInterfaceType structure
        bus: integer bus
        unit: integer unit

    Returns:
        DriveInfo struct
    &#39;&#39;&#39;
    return self.libpanda.drive_get(blocktype,bus,unit)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.enable_all_callbacks"><code class="name flex">
<span>def <span class="ident">enable_all_callbacks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable all python callbacks that have been disabled</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_all_callbacks(self):
    &#39;&#39;&#39;
    Enable all python callbacks that have been disabled
    &#39;&#39;&#39;
    for name in self.registered_callbacks.keys():
        self.enable_callback(name)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.enable_callback"><code class="name flex">
<span>def <span class="ident">enable_callback</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable a panda plugin using its handle and cb.number as a unique ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_callback(self, name):
    &#39;&#39;&#39;
    Enable a panda plugin using its handle and cb.number as a unique ID
    &#39;&#39;&#39;

    # During shutdown callback may be deleted before a request to enable comes through
    if self.ending:
        return

    if name not in self.registered_callbacks.keys():
        raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))

    self.registered_callbacks[name][&#39;enabled&#39;] = True
    handle = self.registered_callbacks[name][&#39;handle&#39;]
    cb = self.registered_callbacks[name][&#39;callback&#39;]
    pcb = self.registered_callbacks[name][&#39;pcb&#39;]
    #progress(&#34;Enabling callback &#39;{}&#39; on &#39;{}&#39; handle = {}&#34;.format(name, cb.name, handle))
    self.libpanda.panda_enable_callback_helper(handle, cb.number, pcb)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.enable_hook2"><code class="name flex">
<span>def <span class="ident">enable_hook2</span></span>(<span>self, hook_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a hook2-plugin hook's status to active.</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated:&ensp;Use the hooks plugin instead.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_hook2(self,hook_name):
    &#39;&#39;&#39;
    Set a hook2-plugin hook&#39;s status to active.

    .. Deprecated:: Use the hooks plugin instead.
    &#39;&#39;&#39;
    if hook_name in self.hook_list2:
        self.plugins[&#39;hooks2&#39;].enable_hooks2(self.hook_list2[hook_name])
    else:
        print(&#34;ERROR: Your hook name was not in the hook list&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.enable_internal_callbacks"><code class="name flex">
<span>def <span class="ident">enable_internal_callbacks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable all our internal callbacks that start with __ such as __main_loop_wait
and __asid_changed. Important in case user has done a panda.end_analysis()
and then (re)called run</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_internal_callbacks(self):
    &#39;&#39;&#39;
    Enable all our internal callbacks that start with __ such as __main_loop_wait
    and __asid_changed. Important in case user has done a panda.end_analysis()
    and then (re)called run
    &#39;&#39;&#39;
    for name in self.registered_callbacks.keys():
        if name.startswith(&#34;__&#34;) and not self.registered_callbacks[name][&#39;enabled&#39;]:
            self.enable_callback(name)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.enable_llvm"><code class="name flex">
<span>def <span class="ident">enable_llvm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_llvm(self):
    &#39;&#39;&#39;
    Enables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
    &#39;&#39;&#39;
    self.libpanda.panda_enable_llvm()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.enable_llvm_helpers"><code class="name flex">
<span>def <span class="ident">enable_llvm_helpers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_llvm_helpers(self):
    &#39;&#39;&#39;
    Enables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
    &#39;&#39;&#39;
    self.libpanda.panda_enable_llvm_helpers()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.enable_memcb"><code class="name flex">
<span>def <span class="ident">enable_memcb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable memory callbacks. Must be called for memory callbacks to work.
pypanda enables this automatically with some callbacks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_memcb(self):
    &#39;&#39;&#39;
    Enable memory callbacks. Must be called for memory callbacks to work.
    pypanda enables this automatically with some callbacks.
    &#39;&#39;&#39;
    self._memcb = True
    self.libpanda.panda_enable_memcb()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.enable_plugin"><code class="name flex">
<span>def <span class="ident">enable_plugin</span></span>(<span>self, handle)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable plugin.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>handle</code></strong> :&ensp;<code>int</code></dt>
<dd>pointer to handle returned by plugin</dd>
</dl>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_plugin(self, handle):
    &#39;&#39;&#39;
    Enable plugin.

    Args:
        handle (int): pointer to handle returned by plugin

    Return:
        None
    &#39;&#39;&#39;
    self.libpanda.panda_enable_plugin(handle)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.enable_precise_pc"><code class="name flex">
<span>def <span class="ident">enable_precise_pc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>By default, QEMU does not update the program counter after every instruction.
This function enables precise tracking of the program counter. After enabling precise PC tracking, the program counter will be available in env-&gt;panda_guest_pc and can be assumed to accurately reflect the guest state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_precise_pc(self):
    &#39;&#39;&#39;
    By default, QEMU does not update the program counter after every instruction.
    This function enables precise tracking of the program counter. After enabling precise PC tracking, the program counter will be available in env-&gt;panda_guest_pc and can be assumed to accurately reflect the guest state.
    &#39;&#39;&#39;
    self.libpanda.panda_enable_precise_pc()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.enable_tb_chaining"><code class="name flex">
<span>def <span class="ident">enable_tb_chaining</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function enables translation block chaining in QEMU</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_tb_chaining(self):
    &#39;&#39;&#39;
    This function enables translation block chaining in QEMU
    &#39;&#39;&#39;
    if debug:
        progress(&#34;Enabling TB chaining&#34;)
    self.disabled_tb_chaining = False
    self.libpanda.panda_enable_tb_chaining()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.end_analysis"><code class="name flex">
<span>def <span class="ident">end_analysis</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop running machine.</p>
<p>Call from any thread to unload all plugins and stop all queued functions.
If called from async thread or a callback, it will also unblock panda.run()</p>
<p>Note here we use the async class's internal thread to process these
without needing to wait for tasks in the main async thread</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_analysis(self):
    &#39;&#39;&#39;
    Stop running machine.

    Call from any thread to unload all plugins and stop all queued functions.
    If called from async thread or a callback, it will also unblock panda.run()

    Note here we use the async class&#39;s internal thread to process these
    without needing to wait for tasks in the main async thread
    &#39;&#39;&#39;
    self.athread.ending = True
    self.ending = True
    self.unload_plugins()
    if self.running.is_set() or self.initializing.is_set():

        # If we were running, stop the execution and check if we crashed
        self.queue_async(self.stop_run, internal=True)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.end_record"><code class="name flex">
<span>def <span class="ident">end_record</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop active recording.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>raises exception if there was an error stopping recording.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_record(self):
    &#34;&#34;&#34;Stop active recording.

    Raises:
        Exception: raises exception if there was an error stopping recording.
    &#34;&#34;&#34;
    result = self.libpanda.panda_record_end()
    res_string_enum = self.ffi.string(self.ffi.cast(&#34;RRCTRL_ret&#34;,result))
    if res_string_enum != &#34;RRCTRL_OK&#34;:
       raise Exception(f&#34;record method failed with RTCTL_ret {res_string_enum} ({result})&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.end_replay"><code class="name flex">
<span>def <span class="ident">end_replay</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Terminates a currently running replay</p>
<pre><code>Returns:
    None

Raises:
    Exception: raises exception if no replay is active or termination failed.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_replay(self):
    &#39;&#39;&#39;
    Terminates a currently running replay

        Returns:
            None

        Raises:
            Exception: raises exception if no replay is active or termination failed.
    &#39;&#39;&#39;

    if self._in_replay is False:
        raise Exception(&#34;Tried to terminate replay while not in replay mode!&#34;)

    result = self.libpanda.panda_replay_end()

    res_string_enum = self.ffi.string(self.ffi.cast(&#34;RRCTRL_ret&#34;,result))
    if res_string_enum != &#34;RRCTRL_OK&#34;:
       raise Exception(f&#34;ending record method failed with RTCTL_ret {res_string_enum} ({result})&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.error_report"><code class="name flex">
<span>def <span class="ident">error_report</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_report(self, s):
    return self.libpanda.error_report(s)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.exit_cpu_loop"><code class="name flex">
<span>def <span class="ident">exit_cpu_loop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop cpu execution at nearest juncture.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit_cpu_loop(self):
    &#39;&#39;&#39;
    Stop cpu execution at nearest juncture.
    &#39;&#39;&#39;
    self.libpanda.panda_exit_loop = True</code></pre>
</details>
</dd>
<dt id="pandare.Panda.finish_serial_cmd"><code class="name flex">
<span>def <span class="ident">finish_serial_cmd</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish_serial_cmd(self):
    result = self.serial_console.send_eol()
    result = self.serial_console.expect()
    return result</code></pre>
</details>
</dd>
<dt id="pandare.Panda.flush_tb"><code class="name flex">
<span>def <span class="ident">flush_tb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function requests that the translation block cache be flushed as soon as possible. If running with translation block chaining turned off (e.g. when in LLVM mode or replay mode), this will happen when the current translation block is done executing.
Flushing the translation block cache is additionally necessary if the plugin makes changes to the way code is translated. For example, by using panda_enable_precise_pc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush_tb(self):
    &#39;&#39;&#39;
    This function requests that the translation block cache be flushed as soon as possible. If running with translation block chaining turned off (e.g. when in LLVM mode or replay mode), this will happen when the current translation block is done executing.
    Flushing the translation block cache is additionally necessary if the plugin makes changes to the way code is translated. For example, by using panda_enable_precise_pc.
    &#39;&#39;&#39;
    return self.libpanda.panda_do_flush_tb()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.from_unsigned_guest"><code class="name flex">
<span>def <span class="ident">from_unsigned_guest</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an unsigned int32/unsigned int64 from the guest
(depending on guest bit-size) to a (signed) python int</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>Python integer representing an unsigned value in the guest's pointer-size</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Python integer representing x as a signed value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_unsigned_guest(self, x):
    &#39;&#39;&#39;
    Convert an unsigned int32/unsigned int64 from the guest
    (depending on guest bit-size) to a (signed) python int

    Args:
        x (int): Python integer representing an unsigned value in the guest&#39;s pointer-size

    Returns:
        int: Python integer representing x as a signed value
    &#39;&#39;&#39;
    if x &gt;= 2**(self.bits-1): # If highest bit is set, it&#39;s negative
        return (x - 2**self.bits)
    else: # Else it&#39;s positive
        return x</code></pre>
</details>
</dd>
<dt id="pandare.Panda.g_malloc0"><code class="name flex">
<span>def <span class="ident">g_malloc0</span></span>(<span>self, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to call glib malloc</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>size to call with malloc</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>buffer of the requested size from g_malloc</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g_malloc0(self, size):
    &#39;&#39;&#39;
    Helper function to call glib malloc

    Args:
        size (int): size to call with malloc

    Returns:
        buffer of the requested size from g_malloc
    &#39;&#39;&#39;
    return self.libpanda.g_malloc0(size)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.garray_len"><code class="name flex">
<span>def <span class="ident">garray_len</span></span>(<span>self, garray)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience function to get array length of glibc array.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>g</code></strong> :&ensp;<code>garray</code></dt>
<dd>Pointer to a glibc array</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>length of the array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def garray_len(self, garray):
    &#39;&#39;&#39;
    Convenience function to get array length of glibc array.

    Args:
        g (garray): Pointer to a glibc array
            
    Returns:
        int: length of the array
    &#39;&#39;&#39;
    return self.libpanda.garray_len(garray)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.get_best_matching_symbol"><code class="name flex">
<span>def <span class="ident">get_best_matching_symbol</span></span>(<span>self, cpu, pc=None, asid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Use the dynamic symbols plugin to get the best matching symbol for a given program counter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
<dt><strong><code>pc</code></strong> :&ensp;<code>int</code></dt>
<dd>program counter, defaults to current</dd>
<dt><strong><code>asid</code></strong> :&ensp;<code>int</code></dt>
<dd>ASID, defaults to current</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_best_matching_symbol(self, cpu, pc=None, asid=None):
    &#39;&#39;&#39;
    Use the dynamic symbols plugin to get the best matching symbol for a given program counter.

    Args:
        cpu (CPUState): CPUState structure
        pc (int): program counter, defaults to current
        asid (int): ASID, defaults to current
    &#39;&#39;&#39;
    if asid is None:
        asid = self.current_asid(cpu)
    if pc is None:
        pc = self.current_pc(cpu)
    return self.plugins[&#39;dynamic_symbols&#39;].get_best_matching_symbol(cpu, pc, asid)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.get_build_dir"><code class="name flex">
<span>def <span class="ident">get_build_dir</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_build_dir(self):
    if self.build_dir is None:
        self.build_dir  = find_build_dir(self.arch_name)
        environ[&#34;PANDA_DIR&#34;] = self.build_dir
    return self.build_dir</code></pre>
</details>
</dd>
<dt id="pandare.Panda.get_cpu"><code class="name flex">
<span>def <span class="ident">get_cpu</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function returns first_cpu CPUState object from QEMU.
XXX: You rarely want this</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CPUState</code></dt>
<dd>cpu</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cpu(self):
    &#39;&#39;&#39;
    This function returns first_cpu CPUState object from QEMU.
    XXX: You rarely want this

    Returns:
        CPUState: cpu
    &#39;&#39;&#39;
    return self.libpanda.get_cpu()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.get_current_process"><code class="name flex">
<span>def <span class="ident">get_current_process</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the current process as an OsiProc struct.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>process name</dd>
<dt><code>None</code></dt>
<dd>on failure</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_process(self, cpu):
    &#39;&#39;&#39;
    Get the current process as an OsiProc struct.

    Returns:
        string: process name
        None: on failure
    &#39;&#39;&#39;
    proc = self.plugins[&#39;osi&#39;].get_current_process(cpu)
    if proc == self.ffi.NULL:
        return None
    return proc</code></pre>
</details>
</dd>
<dt id="pandare.Panda.get_file_name"><code class="name flex">
<span>def <span class="ident">get_file_name</span></span>(<span>self, cpu, fd)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the name of a file from a file descriptor.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>file name</dd>
<dt><code>None</code></dt>
<dd>on failure</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_file_name(self, cpu, fd):
    &#39;&#39;&#39;
    Get the name of a file from a file descriptor.

    Returns:
        string: file name
        None: on failure
    &#39;&#39;&#39;
    proc = self.plugins[&#39;osi&#39;].get_current_process(cpu)
    if proc == self.ffi.NULL:
        return None
    try:
        fname_ptr = self.plugins[&#39;osi_linux&#39;].osi_linux_fd_to_filename(cpu, proc, fd)
    except OverflowError:
        return None
    if fname_ptr == self.ffi.NULL:
        return None
    return self.ffi.string(fname_ptr)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.get_id"><code class="name flex">
<span>def <span class="ident">get_id</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get current hw_proc_id ID</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>integer</code></dt>
<dd>value of current hw_proc_id</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id(self, cpu):
    &#39;&#39;&#39;
    Get current hw_proc_id ID

    Args:
        cpu (CPUState): CPUState structure
    
    Returns:
        integer: value of current hw_proc_id
    &#39;&#39;&#39;
    return self.plugins[&#34;hw_proc_id&#34;].get_id(cpu)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.get_mapping_by_addr"><code class="name flex">
<span>def <span class="ident">get_mapping_by_addr</span></span>(<span>self, cpu, addr)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the OSI mapping that matches the address specified.</p>
<p>Requires: OSI</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong></dt>
<dd>CPUState struct</dd>
<dt><strong><code>addr</code></strong></dt>
<dd>int</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>OsiModule</code></dt>
<dd>dataclass representation of OsiModule structure with strings converted to python strings
Note that the strings will be None if their pointer was null</dd>
<dt><code>None</code></dt>
<dd>on failure</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mapping_by_addr(self, cpu, addr):
    &#39;&#39;&#39;
    Return the OSI mapping that matches the address specified.

    Requires: OSI

    Args:
        cpu: CPUState struct
        addr: int

    Returns:
        OsiModule: dataclass representation of OsiModule structure with strings converted to python strings
            Note that the strings will be None if their pointer was null
        None: on failure
    &#39;&#39;&#39;
    @dataclass
    class OsiModule:
        &#39;&#39;&#39;dataclass representation of OsiModule structu&#39;&#39;&#39;
        base: int
        file: str
        modd: int
        name: str
        size: int
    mappings = self.get_mappings(cpu)
    for m in mappings:
        if m == self.ffi.NULL:
            continue
        if addr &gt;= m.base and addr &lt; m.base+m.size:
            if m.name != self.ffi.NULL:
                name = self.ffi.string(m.name).decode(&#34;utf-8&#34;)
            else:
                name = None
            if m.file != self.ffi.NULL:
                file = self.ffi.string(m.file).decode(&#34;utf-8&#34;)
            else:
                file = None
            return OsiModule(m.base, file, m.modd, name, m.size)
    return None</code></pre>
</details>
</dd>
<dt id="pandare.Panda.get_mappings"><code class="name flex">
<span>def <span class="ident">get_mappings</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all active memory mappings in the system.</p>
<p>Requires: OSI</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong></dt>
<dd>CPUState struct</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pandare.utils.GArrayIterator" href="utils.html#pandare.utils.GArrayIterator">GArrayIterator</a></code></dt>
<dd>iterator of OsiModule structures</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mappings(self, cpu):
    &#39;&#39;&#39;
    Get all active memory mappings in the system.

    Requires: OSI

    Args:
        cpu: CPUState struct

    Returns:
        pandare.utils.GArrayIterator: iterator of OsiModule structures
    &#39;&#39;&#39;
    current = self.plugins[&#39;osi&#39;].get_current_process(cpu)
    maps = self.plugins[&#39;osi&#39;].get_mappings(cpu, current)
    map_len = self.garray_len(maps)
    return GArrayIterator(self.plugins[&#39;osi&#39;].get_one_module, maps, map_len, self.plugins[&#39;osi&#39;].cleanup_garray)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.get_os_family"><code class="name flex">
<span>def <span class="ident">get_os_family</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the current OS family name. Valid values are the entries in <code>OSFamilyEnum</code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>one of OS_UNKNOWN, OS_WINDOWS, OS_LINUX, OS_FREEBSD</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_os_family(self):
    &#39;&#39;&#39;
    Get the current OS family name. Valid values are the entries in `OSFamilyEnum`

    Returns:
        string: one of OS_UNKNOWN, OS_WINDOWS, OS_LINUX, OS_FREEBSD
    &#39;&#39;&#39;

    family_num = self.libpanda.panda_os_familyno
    family_name = self.ffi.string(self.ffi.cast(&#34;PandaOsFamily&#34;, family_num))
    return family_name</code></pre>
</details>
</dd>
<dt id="pandare.Panda.get_plugin_path"><code class="name flex">
<span>def <span class="ident">get_plugin_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_plugin_path(self):
    if self.plugin_path is None:
        build_dir = self.get_build_dir()
        rel_dir = pjoin(*[build_dir, self.arch_name+&#34;-softmmu&#34;, &#34;panda&#34;, &#34;plugins&#34;])

        if build_dir == &#34;/usr/local/bin/&#34;:
            # Installed - use /usr/local/lib/panda/plugins
            self.plugin_path = f&#34;/usr/local/lib/panda/{self.arch_name}&#34;
        elif isdir(rel_dir):
            self.plugin_path = rel_dir
        else:
            raise ValueError(f&#34;Could not find plugin path. Build dir={build_dir}&#34;)
    return self.plugin_path</code></pre>
</details>
</dd>
<dt id="pandare.Panda.get_process_name"><code class="name flex">
<span>def <span class="ident">get_process_name</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the name of the current process. May return None if OSI cannot identify the current process</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_process_name(self, cpu):
    &#39;&#39;&#39;
    Get the name of the current process. May return None if OSI cannot identify the current process
    &#39;&#39;&#39;
    proc = self.plugins[&#39;osi&#39;].get_current_process(cpu)
    if proc == self.ffi.NULL or proc.name == self.ffi.NULL:
        return None

    procname = self.ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;)
    return self.ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.get_processes"><code class="name flex">
<span>def <span class="ident">get_processes</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all running processes in the system. Includes kernel modules on Linux.</p>
<p>Requires: OSI</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong></dt>
<dd>CPUState struct</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pandare.utils.GArrayIterator" href="utils.html#pandare.utils.GArrayIterator">GArrayIterator</a></code></dt>
<dd>iterator of OsiProc structures</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_processes(self, cpu):
    &#39;&#39;&#39;
    Get all running processes in the system. Includes kernel modules on Linux.

    Requires: OSI

    Args:
        cpu: CPUState struct

    Returns:
        pandare.utils.GArrayIterator: iterator of OsiProc structures
    &#39;&#39;&#39;
    processes = self.plugins[&#39;osi&#39;].get_processes(cpu)
    processes_len = self.garray_len(processes)
    return GArrayIterator(self.plugins[&#39;osi&#39;].get_one_proc, processes, processes_len, self.plugins[&#39;osi&#39;].cleanup_garray)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.get_processes_dict"><code class="name flex">
<span>def <span class="ident">get_processes_dict</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all running processes for the system at this moment in time as a dictionary.</p>
<p>The dictionary maps proceses by their PID. Each mapping returns a dictionary containing the process name, its pid,
and its parent pid (ppid).</p>
<p>Requires: OSI</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong></dt>
<dd>CPUState struct</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>processes as described above</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_processes_dict(self, cpu):
    &#39;&#39;&#39;
    Get all running processes for the system at this moment in time as a dictionary.

    The dictionary maps proceses by their PID. Each mapping returns a dictionary containing the process name, its pid,
    and its parent pid (ppid).

    Requires: OSI

    Args:
        cpu: CPUState struct

    Returns:
        Dict: processes as described above
    &#39;&#39;&#39;

    procs = {} #pid: {name: X, pid: Y, parent_pid: Z})

    for proc in self.get_processes(cpu):
        assert(proc != self.ffi.NULL)
        assert(proc.pid not in procs)
        procs[proc.pid] = {&#39;name&#39;: self.ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;),
                           &#39;pid&#39;: proc.pid,
                           &#39;parent_pid&#39;: proc.ppid,
                           &#39;create_time&#39;: proc.create_time}
        assert(not (proc.pid != 0 and proc.pid == proc.ppid)) # No cycles allowed other than at 0
    return procs</code></pre>
</details>
</dd>
<dt id="pandare.Panda.get_system_memory"><code class="name flex">
<span>def <span class="ident">get_system_memory</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_system_memory(self):
    return self.libpanda.get_system_memory()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.get_volatility_symbols"><code class="name flex">
<span>def <span class="ident">get_volatility_symbols</span></span>(<span>self, debug=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_volatility_symbols(self, debug=False):
    try:
        from .volatility_cli_classes import CommandLineMoreEfficient
        from volatility.framework import contexts
        from volatility.framework.layers.linear import LinearlyMappedLayer
        from volatility.framework.automagic import linux
    except ImportError:
        print(&#34;Warning: Failed to import volatility&#34;)
        return None
    if &#34;linux&#34; in self.os_type:
        if not hasattr(self, &#34;_vmlinux&#34;):
            self.make_panda_file_handler(debug=debug)
            constructed_original = CommandLineMoreEfficient().run()
            linux.LinuxUtilities.aslr_mask_symbol_table(
                constructed_original.context, constructed_original.config[&#39;vmlinux&#39;], constructed_original.config[&#39;primary&#39;])
            self._vmlinux = contexts.Module(
                constructed_original.context, constructed_original.config[&#39;vmlinux&#39;], constructed_original.config[&#39;primary&#39;], 0)
        else:
            LinearlyMappedLayer.read.cache_clear()  # smearing technique
        return self._vmlinux
    else:
        print(&#34;Unsupported.&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="pandare.Panda.hook"><code class="name flex">
<span>def <span class="ident">hook</span></span>(<span>self, addr, enabled=True, kernel=None, asid=None, cb_type='start_block_exec')</span>
</code></dt>
<dd>
<div class="desc"><p>Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
the function will be called with args (CPUState, TranslationBlock)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook(self, addr, enabled=True, kernel=None, asid=None, cb_type=&#34;start_block_exec&#34;):
    &#39;&#39;&#39;
    Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
    the function will be called with args (CPUState, TranslationBlock)
    &#39;&#39;&#39;

    def decorator(fun):
        if cb_type == &#34;before_tcg_codegen&#34; or cb_type == &#34;after_block_translate&#34; or cb_type == &#34;before_block_exec&#34; or cb_type == &#34;start_block_exec&#34; or cb_type == &#34;end_block_exec&#34;:
            hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , struct hook *)&#34;)
        elif cb_type == &#34;after_block_exec&#34;:
            hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , uint8_t, struct hook *)&#34;)
        elif cb_type == &#34;before_block_translate&#34;:
            hook_cb_type = self.ffi.callback(&#34;void(CPUState* env, target_ptr_t pc, struct hook*)&#34;)
        elif cb_type == &#34;before_block_exec_invalidate_opt&#34;:
            hook_cb_type = self.ffi.callback(&#34;bool(CPUState* env, TranslationBlock*, struct hook*)&#34;)
        else:
            print(&#34;function type not supported&#34;)
            return
        type_num = getattr(self.libpanda, &#34;PANDA_CB_&#34;+cb_type.upper())

        if debug:
            print(&#34;Registering breakpoint at 0x{:x} -&gt; {} == {}&#34;.format(addr, fun, &#39;cdata_cb&#39;))
        
        def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
            if not hasattr(self, &#34;exit_exception&#34;):
                try:
                    r = fun(*args, **kwargs)
                    #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                    #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                    #print(fun, r) # Stuck with TypeError in _run_and_catch? Enable this to find where the bug is.
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    if self.catch_exceptions:
                        self.exit_exception = e
                        self.end_analysis()
                    else:
                        raise e
                    return 0

        # Inform the plugin that it has a new breakpoint at addr
        hook_cb_passed = hook_cb_type(_run_and_catch)
        new_hook = self.ffi.new(&#34;struct hook*&#34;)
        new_hook.type = type_num
        new_hook.addr = addr
        if kernel or asid is None:
            new_hook.asid = 0
        else:
            new_hook.asid = asid

        setattr(new_hook.cb,cb_type, hook_cb_passed)
        if kernel:
            new_hook.km = self.libpanda.MODE_KERNEL_ONLY
        elif kernel == False:
            new_hook.km = self.libpanda.MODE_USER_ONLY
        else:
            new_hook.km = self.libpanda.MODE_ANY
        new_hook.enabled = enabled

        self.plugins[&#39;hooks&#39;].add_hook(new_hook)
        self.hook_list.append((new_hook, hook_cb_passed))

        def wrapper(*args, **kw):
            return _run_and_catch(args,kw)
        return wrapper
    return decorator</code></pre>
</details>
</dd>
<dt id="pandare.Panda.hook2"><code class="name flex">
<span>def <span class="ident">hook2</span></span>(<span>self, name, kernel=True, procname=None, libname=None, trace_start=0, trace_stop=0, range_begin=0, range_end=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to create a hook with the hooks2 plugin.</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated:&ensp;Use the hooks plugin instead.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook2(self,name, kernel=True, procname=None, libname=None, trace_start=0, trace_stop=0, range_begin=0, range_end=0):
    &#39;&#39;&#39;
    Decorator to create a hook with the hooks2 plugin.

    .. Deprecated:: Use the hooks plugin instead.
    &#39;&#39;&#39;

    if procname == None:
        procname = self.ffi.NULL
    if libname == None:
        libname = self.ffi.NULL


    if procname != self.ffi.NULL:
        procname = self.ffi.new(&#34;char[]&#34;,bytes(procname,&#34;utf-8&#34;))
    if libname != self.ffi.NULL:
        libname = self.ffi.new(&#34;char[]&#34;,bytes(libname,&#34;utf-8&#34;))
    &#39;&#39;&#39;
    Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
    the function will be called with args (CPUState, TranslationBlock)
    &#39;&#39;&#39;
    def decorator(fun):
        # Ultimately, our hook resolves as a before_block_exec_invalidate_opt callback so we must match its args
        hook_cb_type = self.ffi.callback(&#34;bool (CPUState*, TranslationBlock*, void*)&#34;)
        # Inform the plugin that it has a new breakpoint at addr

        def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
            if not hasattr(self, &#34;exit_exception&#34;):
                try:
                    r = fun(*args, **kwargs)
                    #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                    #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                    #print(fun, r) # Stuck with TypeError in _run_and_catch? Enable this to find where the bug is.
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    if self.catch_exceptions:
                        self.exit_exception = e
                        self.end_analysis()
                    else:
                        raise e
                    return True


        hook_cb_passed = hook_cb_type(_run_and_catch)
        if not hasattr(self, &#34;hook_gc_list&#34;):
            self.hook_gc_list = [hook_cb_passed]
        else:
            self.hook_gc_list.append(hook_cb_passed)

        # I don&#39;t know what this is/does
        cb_data =self.ffi.NULL
        hook_number = self.plugins[&#39;hooks2&#39;].add_hooks2(hook_cb_passed, cb_data, kernel, \
            procname, libname, trace_start, trace_stop, range_begin,range_end)

        self.hook_list2[name] = hook_number

        def wrapper(*args, **kw):
            return _run_and_catch(*args, **kw)
        return wrapper
    return decorator</code></pre>
</details>
</dd>
<dt id="pandare.Panda.hook2_single_insn"><code class="name flex">
<span>def <span class="ident">hook2_single_insn</span></span>(<span>self, name, pc, kernel=False, procname=None, libname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to hook a single instruction with the hooks2 plugin.</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated:&ensp;Use the hooks plugin instead.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook2_single_insn(self, name, pc, kernel=False, procname=None, libname=None):
    &#39;&#39;&#39;
    Helper function to hook a single instruction with the hooks2 plugin.

    .. Deprecated:: Use the hooks plugin instead.
    &#39;&#39;&#39;
    if procname == None:
        procname = self.ffi.NULL
    if libname == None:
        libname = self.ffi.NULL
    return self.hook2(name, kernel=kernel, procname=procname,libname=libname,range_begin=pc, range_end=pc)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.hook_mem"><code class="name flex">
<span>def <span class="ident">hook_mem</span></span>(<span>self, start_address, end_address, on_before, on_after, on_read, on_write, on_virtual, on_physical, enabled)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to hook a memory range with the mem_hooks plugin</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Fully document mem-hook decorators</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook_mem(self, start_address, end_address, on_before, on_after, on_read, on_write, on_virtual, on_physical, enabled):
    &#39;&#39;&#39;
    Decorator to hook a memory range with the mem_hooks plugin

    .. todo:: Fully document mem-hook decorators
    &#39;&#39;&#39;
    return self._hook_mem(start_address,end_address,on_before,on_after,on_read, on_write, on_virtual, on_physical, enabled)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.hook_phys_mem_read"><code class="name flex">
<span>def <span class="ident">hook_phys_mem_read</span></span>(<span>self, start_address, end_address, on_before=True, on_after=False, enabled=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to hook physical memory reads with the mem_hooks plugin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook_phys_mem_read(self, start_address, end_address, on_before=True, on_after=False, enabled=True):
    &#39;&#39;&#39;
    Decorator to hook physical memory reads with the mem_hooks plugin
    &#39;&#39;&#39;
    return self._hook_mem(start_address,end_address,on_before,on_after, True, False, False, True, True)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.hook_phys_mem_write"><code class="name flex">
<span>def <span class="ident">hook_phys_mem_write</span></span>(<span>self, start_address, end_address, on_before=True, on_after=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to hook physical memory writes with the mem_hooks plugin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook_phys_mem_write(self, start_address, end_address, on_before=True, on_after=False):
    &#39;&#39;&#39;
    Decorator to hook physical memory writes with the mem_hooks plugin
    &#39;&#39;&#39;
    return self._hook_mem(start_address,end_address,on_before,on_after, False, True, False, True, True)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.hook_symbol"><code class="name flex">
<span>def <span class="ident">hook_symbol</span></span>(<span>self, libraryname, symbol, kernel=False, name=None, cb_type='start_block_exec')</span>
</code></dt>
<dd>
<div class="desc"><p>Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
the function will be called with args (CPUState, TranslationBlock, struct hook)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>libraryname</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of library containing symbol to be hooked. May be None to match any.</dd>
<dt><strong><code>symbol</code></strong> :&ensp;<code>string, int</code></dt>
<dd>Name of symbol or offset into library to hook</dd>
<dt><strong><code>kernel</code></strong> :&ensp;<code>bool</code></dt>
<dd>if hook should be applied exclusively in kernel mode</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>name of hook, defaults to function name</dd>
<dt><strong><code>cb_type</code></strong> :&ensp;<code>string</code></dt>
<dd>callback-type, defaults to start_block_exec</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>Decorated function is called when (before/after is determined by cb_type) guest goes to call
the specified symbol in the specified library.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook_symbol(self, libraryname, symbol, kernel=False, name=None, cb_type=&#34;start_block_exec&#34;):
    &#39;&#39;&#39;
    Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
    the function will be called with args (CPUState, TranslationBlock, struct hook)

    Args:
        libraryname (string): Name of library containing symbol to be hooked. May be None to match any.
        symbol (string, int): Name of symbol or offset into library to hook
        kernel (bool): if hook should be applied exclusively in kernel mode
        name (string): name of hook, defaults to function name
        cb_type (string): callback-type, defaults to start_block_exec

    Returns:
        None: Decorated function is called when (before/after is determined by cb_type) guest goes to call
              the specified symbol in the specified library.
    &#39;&#39;&#39;

    def decorator(fun):
        if cb_type == &#34;before_tcg_codegen&#34; or cb_type == &#34;after_block_translate&#34; or cb_type == &#34;before_block_exec&#34; or cb_type == &#34;start_block_exec&#34; or cb_type == &#34;end_block_exec&#34;:
            hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , struct hook *)&#34;)
        elif cb_type == &#34;after_block_exec&#34;:
            hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , uint8_t, struct hook *)&#34;)
        elif cb_type == &#34;before_block_translate&#34;:
            hook_cb_type = self.ffi.callback(&#34;void(CPUState* env, target_ptr_t pc, struct hook*)&#34;)
        elif cb_type == &#34;before_block_exec_invalidate_opt&#34;:
            hook_cb_type = self.ffi.callback(&#34;bool(CPUState* env, TranslationBlock*, struct hook*)&#34;)
        else:
            print(&#34;function type not supported&#34;)
            return

        def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
            if not hasattr(self, &#34;exit_exception&#34;):
                try:
                    r = fun(*args, **kwargs)
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    if self.catch_exceptions:
                        self.exit_exception = e
                        self.end_analysis()
                    else:
                        raise e
                    if cb_type == &#34;before_block_exec_invalidate_opt&#34;:
                        return False
                    return None


        # Inform the plugin that it has a new breakpoint at addr
        hook_cb_passed = hook_cb_type(_run_and_catch)
        new_hook = self.ffi.new(&#34;struct symbol_hook*&#34;)
        type_num = getattr(self.libpanda, &#34;PANDA_CB_&#34;+cb_type.upper())
        new_hook.type = type_num
        if libraryname is not None:
            libname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(libraryname,&#34;utf-8&#34;))
        else:
            libname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
        self.ffi.memmove(new_hook.section,libname_ffi,len(libname_ffi))

        new_hook.hook_offset = False
        if symbol is not None:
            if isinstance(symbol, int):
                new_hook.offset = symbol
                new_hook.hook_offset = True
                symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
            else:
                symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(symbol,&#34;utf-8&#34;))
                new_hook.hook_offset = False
        else:
            symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
        self.ffi.memmove(new_hook.name,symbolname_ffi,len(symbolname_ffi))
        setattr(new_hook.cb,cb_type, hook_cb_passed)
        hook_ptr = self.plugins[&#39;hooks&#39;].add_symbol_hook(new_hook)
        if name is not None:
            self.named_hooks[name] = hook_ptr
        self.hook_list.append((fun, new_hook,hook_cb_passed, hook_ptr))

        def wrapper(*args, **kw):
            _run_and_catch(args,kw)
        return wrapper
    return decorator</code></pre>
</details>
</dd>
<dt id="pandare.Panda.hook_symbol_resolution"><code class="name flex">
<span>def <span class="ident">hook_symbol_resolution</span></span>(<span>self, libraryname, symbol, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorate a function to setup a hook: when a guest process resolves a symbol
the function will be called with args (CPUState, struct hook_symbol_resolve, struct symbol, OsiModule)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>libraryname</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of library containing symbol to be hooked. May be None to match any.</dd>
<dt><strong><code>symbol</code></strong> :&ensp;<code>string, int</code></dt>
<dd>Name of symbol or offset into library to hook</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>name of hook, defaults to function name</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>Decorated function is called when guest resolves the specified symbol in the specified library.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook_symbol_resolution(self, libraryname, symbol, name=None):
    &#39;&#39;&#39;
    Decorate a function to setup a hook: when a guest process resolves a symbol
    the function will be called with args (CPUState, struct hook_symbol_resolve, struct symbol, OsiModule)

    Args:
        libraryname (string): Name of library containing symbol to be hooked. May be None to match any.
        symbol (string, int): Name of symbol or offset into library to hook
        name (string): name of hook, defaults to function name

    Returns:
        None: Decorated function is called when guest resolves the specified symbol in the specified library.
    &#39;&#39;&#39;
    #Mostly based on hook_symbol below
    def decorator(fun):
        sh = self.ffi.new(&#34;struct hook_symbol_resolve*&#34;)
        sh.hook_offset = False
        if symbol is not None:
            if isinstance(symbol, int):
                sh.offset = symbol
                sh.hook_offset = True
                symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
            else:
                symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(symbol,&#34;utf-8&#34;))
        else:
            symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
        self.ffi.memmove(sh.name,symbolname_ffi,len(symbolname_ffi))

        if libraryname is not None:
            libname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(libraryname,&#34;utf-8&#34;))
        else:
            libname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
        self.ffi.memmove(sh.section,libname_ffi,len(libname_ffi))

        #sh.id #not used here
        sh.enabled = True
        def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
            if not hasattr(self, &#34;exit_exception&#34;):
                try:
                    r = fun(*args, **kwargs)
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    if self.catch_exceptions:
                        self.exit_exception = e
                        self.end_analysis()
                    else:
                        raise e
                    return None

        sr_hook_cb_type = self.ffi.callback(&#34;void (struct hook_symbol_resolve *sh, struct symbol s, target_ulong asid)&#34;)
        sr_hook_cb_ptr = sr_hook_cb_type(_run_and_catch)
        sh.cb = sr_hook_cb_ptr
        hook_ptr = self.plugins[&#39;dynamic_symbols&#39;].hook_symbol_resolution(sh)
        self.sr_hooks.append((sh, sr_hook_cb_ptr, hook_ptr))

        def wrapper(*args, **kw):
            _run_and_catch(args,kw)
        return wrapper
    return decorator</code></pre>
</details>
</dd>
<dt id="pandare.Panda.hook_virt_mem_read"><code class="name flex">
<span>def <span class="ident">hook_virt_mem_read</span></span>(<span>self, start_address, end_address, on_before=True, on_after=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to hook virtual memory reads with the mem_hooks plugin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook_virt_mem_read(self, start_address, end_address, on_before=True, on_after=False):
    &#39;&#39;&#39;
    Decorator to hook virtual memory reads with the mem_hooks plugin
    &#39;&#39;&#39;
    return self._hook_mem(start_address,end_address,on_before,on_after, True, False, True, False, True)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.hook_virt_mem_write"><code class="name flex">
<span>def <span class="ident">hook_virt_mem_write</span></span>(<span>self, start_address, end_address, on_before=True, on_after=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to hook virtual memory writes with the mem_hooks plugin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook_virt_mem_write(self, start_address, end_address, on_before=True, on_after=False):
    &#39;&#39;&#39;
    Decorator to hook virtual memory writes with the mem_hooks plugin
    &#39;&#39;&#39;
    return self._hook_mem(start_address,end_address,on_before,on_after, False, True, True, False, True)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.hypercall"><code class="name flex">
<span>def <span class="ident">hypercall</span></span>(<span>self, magic)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hypercall(self, magic):
    def decorator(fun):
        hypercall_cb_type = self.ffi.callback(&#34;hypercall_t&#34;)
        
        def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
            if not hasattr(self, &#34;exit_exception&#34;):
                try:
                    r = fun(*args, **kwargs)
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    if self.catch_exceptions:
                        self.exit_exception = e
                        self.end_analysis()
                    else:
                        raise e
                    return None

        hook_cb_passed = hypercall_cb_type(_run_and_catch)
        if type(magic) is int:
            self.plugins[&#39;hypercaller&#39;].register_hypercall(magic, hook_cb_passed)
        elif type(magic) is list:
            for m in magic:
                if type(m) is int:
                    self.plugins[&#39;hypercaller&#39;].register_hypercall(m, hook_cb_passed)
                else:
                    raise TypeError(&#34;Magic list must consist of integers&#34;)
        else:
            raise TypeError(&#34;Magics must be either an int or list of ints&#34;)

        def wrapper(*args, **kw):
            _run_and_catch(args,kw)
        self.hypercalls[wrapper] = [hook_cb_passed,magic]
        return wrapper
    return decorator</code></pre>
</details>
</dd>
<dt id="pandare.Panda.in_kernel"><code class="name flex">
<span>def <span class="ident">in_kernel</span></span>(<span>self, cpustate)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the processor is in the privilege level corresponding to kernel mode for any of the PANDA supported architectures.
Legacy alias for in_kernel_mode().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_kernel(self, cpustate):
    &#39;&#39;&#39;
    Returns true if the processor is in the privilege level corresponding to kernel mode for any of the PANDA supported architectures.
    Legacy alias for in_kernel_mode().
    &#39;&#39;&#39;
    return self.libpanda.panda_in_kernel_external(cpustate)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.in_kernel_code_linux"><code class="name flex">
<span>def <span class="ident">in_kernel_code_linux</span></span>(<span>self, cpustate)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the processor is running in linux kernelspace.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Bool</code></dt>
<dd>If the processor is running in Linux kernel space code.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_kernel_code_linux(self, cpustate):
    &#39;&#39;&#39;
    Check if the processor is running in linux kernelspace.

    Args:
        cpu (CPUState): CPUState structure

    Returns:
        Bool: If the processor is running in Linux kernel space code.
    &#39;&#39;&#39;
    return self.libpanda.panda_in_kernel_code_linux_external(cpustate)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.in_kernel_mode"><code class="name flex">
<span>def <span class="ident">in_kernel_mode</span></span>(<span>self, cpustate)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the processor is running in priviliged mode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Bool</code></dt>
<dd>If the processor is in the privilege level corresponding to kernel mode
for the given architecture</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_kernel_mode(self, cpustate):
    &#39;&#39;&#39;
    Check if the processor is running in priviliged mode.

    Args:
        cpu (CPUState): CPUState structure

    Returns:
        Bool: If the processor is in the privilege level corresponding to kernel mode
              for the given architecture
    &#39;&#39;&#39;
    return self.libpanda.panda_in_kernel_mode_external(cpustate)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.interact"><code class="name flex">
<span>def <span class="ident">interact</span></span>(<span>self, confirm_quit=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Expose console interactively until user types pandaquit
Must be run in blocking thread.</p>
<p>TODO: This should probably repace self.serial_console with something
that directly renders output to the user. Then we don't have to handle
buffering and other problems. But we will need to re-enable the serial_console
interface after this returns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def interact(self, confirm_quit=True):
    &#39;&#39;&#39;
    Expose console interactively until user types pandaquit
    Must be run in blocking thread.

    TODO: This should probably repace self.serial_console with something
    that directly renders output to the user. Then we don&#39;t have to handle
    buffering and other problems. But we will need to re-enable the serial_console
    interface after this returns
    &#39;&#39;&#39;
    print(&#34;PANDA: entering interactive mode. Type pandaquit to exit&#34;)
    prompt = self.expect_prompt.decode(&#34;utf8&#34;) if self.expect_prompt and isinstance(self.expect_prompt, bytes) else &#34;$ &#34;
    if not prompt.endswith(&#34; &#34;): prompt += &#34; &#34;
    while True:
        cmd = input(prompt) # TODO: Strip all control characters - Ctrl-L breaks things
        if cmd.strip() == &#39;pandaquit&#39;:
            if confirm_quit:
                q = input(&#34;PANDA: Quitting interactive mode. Are you sure? (y/n) &#34;)
                if len(q) and q.lower()[0] == &#39;y&#39;:
                    break
                else:
                    continue
            else: # No confirm - just break
                break
        r = self.run_serial_cmd(cmd) # XXX: may timeout
        print(r)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.is_callback_enabled"><code class="name flex">
<span>def <span class="ident">is_callback_enabled</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_callback_enabled(self, name):
    if name not in self.registered_callbacks.keys():
        raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))
    return self.registered_callbacks[name][&#39;enabled&#39;]</code></pre>
</details>
</dd>
<dt id="pandare.Panda.load_plugin"><code class="name flex">
<span>def <span class="ident">load_plugin</span></span>(<span>self, name, args={})</span>
</code></dt>
<dd>
<div class="desc"><p>Load a C plugin, optionally with arguments</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of plugin</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments matching key to value. e.g. {"key": "value"} sets option <code>key</code> to <code>value</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_plugin(self, name, args={}):
    &#39;&#39;&#39;
    Load a C plugin, optionally with arguments

    Args:
        name (str): Name of plugin
        args (dict): Arguments matching key to value. e.g. {&#34;key&#34;: &#34;value&#34;} sets option `key` to `value`.

    Returns:
        None.
    &#39;&#39;&#39;
    if debug:
        progress (&#34;Loading plugin %s&#34; % name),

    argstrs_ffi = []
    if isinstance(args, dict):
        for k,v in args.items():
            this_arg_s = &#34;{}={}&#34;.format(k,v)
            this_arg = self.ffi.new(&#34;char[]&#34;, bytes(this_arg_s, &#34;utf-8&#34;))
            argstrs_ffi.append(this_arg)

        n = len(args.keys())
    elif isinstance(args, list):
        for arg in args:
            this_arg = self.ffi.new(&#34;char[]&#34;, bytes(arg, &#34;utf-8&#34;))
            argstrs_ffi.append(this_arg)
        n = len(args)

    else:
        raise ValueError(&#34;Arguments to load plugin must be a list or dict of key/value pairs&#34;)

    # First set qemu_path so plugins can load (may be unnecessary after the first time)
    assert(self.panda), &#34;Unknown location of PANDA&#34;
    panda_name_ffi = self.ffi.new(&#34;char[]&#34;, bytes(self.panda,&#34;utf-8&#34;))
    self.libpanda.panda_set_qemu_path(panda_name_ffi)

    if len(argstrs_ffi):
        plugin_args = argstrs_ffi
    else:
        plugin_args = self.ffi.NULL

    charptr = self.ffi.new(&#34;char[]&#34;, bytes(name,&#34;utf-8&#34;))
    self.libpanda.panda_require_from_library(charptr, plugin_args, len(argstrs_ffi))
    self._load_plugin_library(name)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.lookup_gic"><code class="name flex">
<span>def <span class="ident">lookup_gic</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lookup_gic(self,n):
    return self.libpanda.lookup_gic(n)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.make_panda_file_handler"><code class="name flex">
<span>def <span class="ident">make_panda_file_handler</span></span>(<span>self, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Constructs a file and file handler that volatility can't ignore to back by PANDA physical memory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_panda_file_handler(self, debug=False):
    &#39;&#39;&#39;
    Constructs a file and file handler that volatility can&#39;t ignore to back by PANDA physical memory
    &#39;&#39;&#39;
    from urllib.request import BaseHandler
    if &#39;PandaFileHandler&#39; in globals():  # already initialized
        return
    panda = self

    class PandaFile(object):
        def __init__(self, length, panda):
            self.pos = 0
            self.length = length
            self.closed = False
            self.mode = &#34;rb&#34;
            self.name = &#34;/tmp/panda.panda&#34;
            self.panda = panda
            self.classname = type(self).__name__

        def readable(self):
            return self.closed

        def read(self, size=1):
            if self.panda.bits == 32 and self.panda.arch_name == &#34;i386&#34;:
                data = self.panda.physical_memory_read(
                    self.pos &amp; 0xfffffff, size)
            else:
                data = self.panda.physical_memory_read(self.pos, size)
            if debug:
                print(self.classname+&#34;: Reading &#34; +
                      str(size)+&#34; bytes from &#34;+hex(self.pos))
            self.pos += size
            return data

        def peek(self, size=1):
            return self.panda.physical_memory_read(self.pos, size)

        def seek(self, pos, whence=0):
            if whence == 0:
                self.pos = pos
            elif whence == 1:
                self.pos += pos
            else:
                self.pos = self.length - pos
            if self.pos &gt; self.length:
                print(self.classname+&#34;: We&#39;ve gone off the deep end&#34;)
            if debug:
                print(self.classname+&#34; Seeking to address &#34;+hex(self.pos))

        def tell(self):
            return self.pos

        def close(self):
            self.closed = True

    class PandaFileHandler(BaseHandler):
        def default_open(self, req):
            if &#39;panda.panda&#39; in req.full_url:
                length = panda.libpanda.ram_size
                if length &gt; 0xc0000000:
                    length += 0x40000000  # 3GB hole
                if debug:
                    print(type(self).__name__ +
                          &#34;: initializing PandaFile with length=&#34;+hex(length))
                return PandaFile(length=length, panda=panda)
            else:
                return None

        def file_close(self):
            return True

    globals()[&#34;PandaFileHandler&#34;] = PandaFileHandler</code></pre>
</details>
</dd>
<dt id="pandare.Panda.map_memory"><code class="name flex">
<span>def <span class="ident">map_memory</span></span>(<span>self, name, size, address)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a new memory region.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>This is an internal reference name for this region. Must be unique.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>number of bytes the region should be.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>int</code></dt>
<dd>start address of region</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_memory(self, name, size, address):

    &#39;&#39;&#39;
    Make a new memory region.

    Args:
        name (str): This is an internal reference name for this region. Must be unique.
        size (int): number of bytes the region should be.
        address (int): start address of region

    Returns:
        None
    &#39;&#39;&#39;

    name_c = self.ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
    size = ceil(size/1024)*1024 # Must be page-aligned
    return self.libpanda.map_memory(name_c, size, address)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.memory_region_add_subregion"><code class="name flex">
<span>def <span class="ident">memory_region_add_subregion</span></span>(<span>self, mr, offset, sr)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls memory_region_add_subregion from QEMU.
memory_region_add_subregion: Add a subregion to a container.</p>
<p>Adds a subregion at @offset.
The subregion may not overlap with other
subregions (except for those explicitly marked as overlapping).
A region
may only be added once as a subregion (unless removed with
memory_region_del_subregion()); use memory_region_init_alias() if you
want a region to be a subregion in multiple locations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mr</code></strong></dt>
<dd>the region to contain the new subregion; must be a container initialized with memory_region_init().</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>the offset relative to @mr where @subregion is added.</dd>
<dt><strong><code>subregion</code></strong></dt>
<dd>the subregion to be added.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memory_region_add_subregion(self, mr, offset, sr):
    &#39;&#39;&#39;
    Calls memory_region_add_subregion from QEMU.
    memory_region_add_subregion: Add a subregion to a container.

    Adds a subregion at @offset.  The subregion may not overlap with other
    subregions (except for those explicitly marked as overlapping).  A region
    may only be added once as a subregion (unless removed with
    memory_region_del_subregion()); use memory_region_init_alias() if you
    want a region to be a subregion in multiple locations.

    Args:
        mr: the region to contain the new subregion; must be a container initialized with memory_region_init().
        offset: the offset relative to @mr where @subregion is added.
        subregion: the subregion to be added.

    Returns:
        None
    &#39;&#39;&#39;
    return self.libpanda.memory_region_add_subregion(mr,offset,sr)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.memory_region_allocate_system_memory"><code class="name flex">
<span>def <span class="ident">memory_region_allocate_system_memory</span></span>(<span>self, mr, obj, name, ram_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Allocates Memory region by user specificiation.
Calls memory_region_allocation_system_memory QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mr</code></strong></dt>
<dd>MemoryRegion struct</dd>
<dt><strong><code>obj</code></strong></dt>
<dd>Object struct</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Region name</dd>
<dt><strong><code>ram_size</code></strong> :&ensp;<code>int</code></dt>
<dd>RAM size</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memory_region_allocate_system_memory(self, mr, obj, name, ram_size):
    &#39;&#39;&#39;
    Allocates Memory region by user specificiation.
    Calls memory_region_allocation_system_memory QEMU function.

    Args:
        mr: MemoryRegion struct
        obj: Object struct
        name (str): Region name
        ram_size (int): RAM size

    Returns:
        None
    &#39;&#39;&#39;
    return self.libpanda.memory_region_allocate_system_memory(mr, obj, name, ram_size)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.memory_region_init_ram_from_file"><code class="name flex">
<span>def <span class="ident">memory_region_init_ram_from_file</span></span>(<span>self, mr, owner, name, size, share, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls memory_region_init_ram_from_file from QEMU.
memory_region_init_ram_from_file:
Initialize RAM memory region with a mmap-ed backend.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mr</code></strong></dt>
<dd>the #MemoryRegion to be initialized.</dd>
<dt><strong><code>owner</code></strong></dt>
<dd>the object that tracks the region's reference count</dd>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the region.</dd>
<dt><strong><code>size</code></strong></dt>
<dd>size of the region.</dd>
<dt><strong><code>share</code></strong></dt>
<dd>%true if memory must be mmaped with the MAP_SHARED flag</dd>
<dt><strong><code>path</code></strong></dt>
<dd>the path in which to allocate the RAM.</dd>
<dt><strong><code>errp</code></strong></dt>
<dd>pointer to Error*, to store an error if it happens.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memory_region_init_ram_from_file(self, mr, owner, name, size, share, path):
    &#39;&#39;&#39;
    Calls memory_region_init_ram_from_file from QEMU.
    memory_region_init_ram_from_file:  Initialize RAM memory region with a mmap-ed backend.

    Args:
        mr: the #MemoryRegion to be initialized.
        owner: the object that tracks the region&#39;s reference count
        name: the name of the region.
        size: size of the region.
        share: %true if memory must be mmaped with the MAP_SHARED flag
        path: the path in which to allocate the RAM.
        errp: pointer to Error*, to store an error if it happens.

    Returns:
        None
    &#39;&#39;&#39;
    return self.libpanda.memory_region_init_ram_from_file(mr, owner, name, size, share, path, self.libpanda.error_fatal)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.memsavep"><code class="name flex">
<span>def <span class="ident">memsavep</span></span>(<span>self, file_out)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls QEMU memsavep on your specified python file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memsavep(self, file_out):
    &#39;&#39;&#39;
    Calls QEMU memsavep on your specified python file.
    &#39;&#39;&#39;
    # this part was largely copied from https://cffi.readthedocs.io/en/latest/ref.html#support-for-file

    file_out.flush()                 # make sure the file is flushed
    newfd = dup(file_out.fileno())   # make a copy of the file descriptor
    fileptr = self.C.fdopen(newfd, b&#34;w&#34;)
    self.libpanda.panda_memsavep(fileptr)
    self.C.fclose(fileptr)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.object_class_by_name"><code class="name flex">
<span>def <span class="ident">object_class_by_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns class as ObjectClass from name specified.
Calls object_class_by_name QEMU function.</p>
<p>Args
name (str): string defined by user</p>
<h2 id="returns">Returns</h2>
<p>struct as specified by name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_class_by_name(self, name):
    &#39;&#39;&#39;
    Returns class as ObjectClass from name specified.
    Calls object_class_by_name QEMU function.

    Args
        name (str): string defined by user

    Returns:
        struct as specified by name
    &#39;&#39;&#39;
    return self.libpanda.object_class_by_name(name)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.object_class_get_name"><code class="name flex">
<span>def <span class="ident">object_class_get_name</span></span>(<span>self, objclass)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets String QOM typename from object class.
Calls object_class_get_name QEMU function.</p>
<p>Args::
objclass: class to obtain the QOM typename for.</p>
<h2 id="returns">Returns</h2>
<p>String QOM typename for klass.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_class_get_name(self, objclass):
    &#39;&#39;&#39;
    Gets String QOM typename from object class.
    Calls object_class_get_name QEMU function.

    Args::
        objclass: class to obtain the QOM typename for.

    Returns:
        String QOM typename for klass.
    &#39;&#39;&#39;
    return self.libpanda.object_class_get_name(objclass)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.object_new"><code class="name flex">
<span>def <span class="ident">object_new</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new QEMU object from typename.
This function will initialize a new object using heap allocated memory.
The returned object has a reference count of 1, and will be freed when
the last reference is dropped.
Calls object_new QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the type of the object to instantiate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The newly allocated and instantiated object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_new(self, name):
    &#39;&#39;&#39;
    Creates a new QEMU object from typename.
    This function will initialize a new object using heap allocated memory.
    The returned object has a reference count of 1, and will be freed when
    the last reference is dropped.
    Calls object_new QEMU function.

    Args:
        name (str): The name of the type of the object to instantiate.

    Returns:
        The newly allocated and instantiated object.
    &#39;&#39;&#39;
    return self.libpanda.object_new(name)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.object_property_find"><code class="name flex">
<span>def <span class="ident">object_property_find</span></span>(<span>self, obj, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Look up a property for an object and return its #ObjectProperty if found.
Calls object_property_find QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>the object</dd>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the property</dd>
<dt><strong><code>errp</code></strong></dt>
<dd>returns an error if this function fails</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>struct ObjectProperty pointer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_find(self, obj, name):
    &#39;&#39;&#39;
    Look up a property for an object and return its #ObjectProperty if found.
    Calls object_property_find QEMU function.

    Args:
        obj: the object
        name: the name of the property
        errp: returns an error if this function fails

    Returns:
        struct ObjectProperty pointer
    &#39;&#39;&#39;
    return self.libpanda.object_property_find(obj,name, self.ffi.NULL)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.object_property_get_bool"><code class="name flex">
<span>def <span class="ident">object_property_get_bool</span></span>(<span>self, obj, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Pull boolean from object.
Calls object_property_get_bool QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>the object</dd>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the property</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the value of the property, converted to a boolean, or NULL if an error occurs (including when the property value is not a bool).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_get_bool(self, obj, name):
    &#39;&#39;&#39;
    Pull boolean from object.
    Calls object_property_get_bool QEMU function.

    Args:
        obj: the object
        name: the name of the property

    Returns:
        the value of the property, converted to a boolean, or NULL if an error occurs (including when the property value is not a bool).
    &#39;&#39;&#39;
    return self.libpanda.object_property_get_bool(obj,name,self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.object_property_get_int"><code class="name flex">
<span>def <span class="ident">object_property_get_int</span></span>(<span>self, obj, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets integer in QEMU object. Reads an integer value from this property.
Calls object_property_get_int QEMU function.</p>
<pre><code>Paramaters:
    obj: the object
    name: the name of the property

Returns:
    the value of the property, converted to an integer, or negative if an error occurs (including when the property value is not an integer).
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_get_int(self, obj, name):
    &#39;&#39;&#39;
    Gets integer in QEMU object. Reads an integer value from this property.
    Calls object_property_get_int QEMU function.

        Paramaters:
            obj: the object
            name: the name of the property

        Returns:
            the value of the property, converted to an integer, or negative if an error occurs (including when the property value is not an integer).
    &#39;&#39;&#39;
    return self.libpanda.object_property_get_int(obj, name, self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.object_property_get_link"><code class="name flex">
<span>def <span class="ident">object_property_get_link</span></span>(<span>self, obj, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads an object's canonical path to a property.
Calls object_property_get_link QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>the object</dd>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the property</dd>
<dt><strong><code>errp</code></strong></dt>
<dd>returns an error if this function fails</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the value of the property, resolved from a path to an Object, or NULL if an error occurs (including when the property value is not a string or not a valid object path).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_get_link(self, obj, name):
    &#39;&#39;&#39;
    Reads an object&#39;s canonical path to a property.
    Calls object_property_get_link QEMU function.

    Args:
        obj: the object
        name: the name of the property
        errp: returns an error if this function fails

    Returns:
        the value of the property, resolved from a path to an Object, or NULL if an error occurs (including when the property value is not a string or not a valid object path).
    &#39;&#39;&#39;
    return self.libpanda.object_property_get_link(obj,name,self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.object_property_set_bool"><code class="name flex">
<span>def <span class="ident">object_property_set_bool</span></span>(<span>self, obj, value, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a bool value to a property.
Calls object_property_set_bool QEMU function.</p>
<p>Args::
value: the value to be written to the property
name: the name of the property
errp: returns an error if this function fails</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_set_bool(self, obj, value, name):
    &#39;&#39;&#39;
    Writes a bool value to a property.
    Calls object_property_set_bool QEMU function.

    Args::
        value: the value to be written to the property
        name: the name of the property
        errp: returns an error if this function fails

    Returns:
        None
    &#39;&#39;&#39;
    return self.libpanda.object_property_set_bool(obj,value,name,self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.object_property_set_int"><code class="name flex">
<span>def <span class="ident">object_property_set_int</span></span>(<span>self, obj, value, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set integer in QEMU object. Writes an integer value to a property.
Calls object_property_set_int QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>the value to be written to the property</dd>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the property</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_set_int(self,obj, value, name):
    &#39;&#39;&#39;
    Set integer in QEMU object. Writes an integer value to a property.
    Calls object_property_set_int QEMU function.

    Args:
        value: the value to be written to the property
        name: the name of the property

    Returns:
        None
    &#39;&#39;&#39;
    return self.libpanda.object_property_set_int(obj, value, name, self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.object_property_set_link"><code class="name flex">
<span>def <span class="ident">object_property_set_link</span></span>(<span>self, obj, val, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes an object's canonical path to a property.
Calls object_property_set_link QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>the value to be written to the property</dd>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the property</dd>
<dt><strong><code>errp</code></strong></dt>
<dd>returns an error if this function fails</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_set_link(self, obj, val, name):
    &#39;&#39;&#39;
    Writes an object&#39;s canonical path to a property.
    Calls object_property_set_link QEMU function.

    Args:
        value: the value to be written to the property
        name: the name of the property
        errp: returns an error if this function fails

    Returns:
        None
    &#39;&#39;&#39;
    return self.libpanda.object_property_set_link(obj,val,name,self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.panda_finish"><code class="name flex">
<span>def <span class="ident">panda_finish</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Final stage call to underlying panda_finish with initialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def panda_finish(self):
    &#39;&#39;&#39;
    Final stage call to underlying panda_finish with initialization.
    &#39;&#39;&#39;
    return self.libpanda.panda_finish()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.physical_memory_read"><code class="name flex">
<span>def <span class="ident">physical_memory_read</span></span>(<span>self, addr, length, fmt='bytearray')</span>
</code></dt>
<dd>
<div class="desc"><p>Read guest physical memory. In the specified format. Note that the <code>ptrlist</code> format
returns a list of integers, each of the specified architecture's pointer size.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>addr</code></strong> :&ensp;<code>int</code></dt>
<dd>Address</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>length of array you would like returned</dd>
<dt><strong><code>fmt</code></strong> :&ensp;<code>str</code></dt>
<dd>format for returned array. Options: 'bytearray', 'int', 'str', 'ptrlist'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[bytearray, int, str, list[int]]</code></dt>
<dd>memory data</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ValueError if memory access fails or fmt is unsupported</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def physical_memory_read(self, addr, length, fmt=&#39;bytearray&#39;):
    &#39;&#39;&#39;
    Read guest physical memory. In the specified format. Note that the `ptrlist` format
    returns a list of integers, each of the specified architecture&#39;s pointer size.

    Args:
        addr (int): Address
        length (int): length of array you would like returned
        fmt (str): format for returned array. Options: &#39;bytearray&#39;, &#39;int&#39;, &#39;str&#39;, &#39;ptrlist&#39;

    Returns:
        Union[bytearray, int, str, list[int]]: memory data

    Raises:
        ValueError if memory access fails or fmt is unsupported
    &#39;&#39;&#39;
    return self._memory_read(None, addr, length, physical=True, fmt=fmt)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.physical_memory_write"><code class="name flex">
<span>def <span class="ident">physical_memory_write</span></span>(<span>self, addr, buf)</span>
</code></dt>
<dd>
<div class="desc"><p>Write guest physical memory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>addr</code></strong> :&ensp;<code>int</code></dt>
<dd>Address</dd>
<dt><strong><code>buf</code></strong> :&ensp;<code>bytestring</code></dt>
<dd>byte string to write into memory</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>ValueError if the call to panda.physical_memory_write fails (e.g., if you pass a pointer to an invalid memory region)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def physical_memory_write(self, addr, buf):
    &#39;&#39;&#39;
    Write guest physical memory.

    Args:
        addr (int): Address
        buf (bytestring):  byte string to write into memory

    Returns:
        None

    Raises:
        ValueError if the call to panda.physical_memory_write fails (e.g., if you pass a pointer to an invalid memory region)
    &#39;&#39;&#39;
    self._memory_write(None, addr, buf, physical=True)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.ppp"><code class="name flex">
<span>def <span class="ident">ppp</span></span>(<span>self, plugin_name, attr, name=None, autoload=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator for plugin-to-plugin interface. Note this isn't in decorators.py
becuase it uses the panda object.</p>
<p>Example usage to register my_run with syscalls2 as a 'on_sys_open_return'
@ppp("syscalls2", "on_sys_open_return")
def my_fun(cpu, pc, filename, flags, mode):
&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ppp(self, plugin_name, attr, name=None, autoload=True):
    &#39;&#39;&#39;
    Decorator for plugin-to-plugin interface. Note this isn&#39;t in decorators.py
    becuase it uses the panda object.

    Example usage to register my_run with syscalls2 as a &#39;on_sys_open_return&#39;
    @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;)
    def my_fun(cpu, pc, filename, flags, mode):
        ...
    &#39;&#39;&#39;

    if plugin_name not in self.plugins and autoload: # Could automatically load it?
        print(f&#34;PPP automatically loaded plugin {plugin_name}&#34;)

    if not hasattr(self, &#34;ppp_registered_cbs&#34;):
        self.ppp_registered_cbs = {}
        # We use this to traak fn_names-&gt;fn_pointers so we can later disable by name

        # XXX: if  we don&#39;t save the cffi generated callbacks somewhere in Python,
        # they may get garbage collected even though the c-code could still has a
        # reference to them  which will lead to a crash. If we stop using this to track
        # function names, we need to keep it or something similar to ensure the reference
        # count remains &gt;0 in python

    def decorator(fun):
        local_name = name  # We need a new varaible otherwise we have scoping issues, maybe
        if local_name is None:
            local_name = fun.__name__

        def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
            if not hasattr(self, &#34;exit_exception&#34;):
                try:
                    r = fun(*args, **kwargs)
                    #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                    #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                    if return_type is not None:
                        try:
                            return self.ffi.cast(return_type, r)
                        except TypeError:
                            # consider throwing an exception
                            return self.ffi.cast(return_type, 0)
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    if self.catch_exceptions:
                        self.exit_exception = e
                        self.end_analysis()
                    else:
                        raise e
                    # this works in all current callback cases. CFFI auto-converts to void, bool, int, and int32_t
                    if return_type is not None:
                        return self.ffi.cast(return_type, 0)

        cast_rc = self.ffi.callback(attr+&#34;_t&#34;)(_run_and_catch)  # Wrap the python fn in a c-callback.
        return_type = self.ffi.typeof(cast_rc).result
        
        if return_type.cname == &#34;void&#34;:
            return_type = None

        if local_name == &#34;&lt;lambda&gt;&#34;:
            local_name = f&#34;&lt;lambda_{self.lambda_cnt}&gt;&#34;
            self.lambda_cnt += 1

        if local_name in self.ppp_registered_cbs:
            print(f&#34;Warning: replacing existing PPP callback &#39;{local_name}&#39; since it was re-registered&#34;)
            self.disable_ppp(local_name)

        assert (local_name not in self.ppp_registered_cbs), f&#34;Two callbacks with conflicting name: {local_name}&#34;

        # Ensure function isn&#39;t garbage collected, and keep the name-&gt;(fn, plugin_name, attr) map for disabling
        self.ppp_registered_cbs[local_name] = (cast_rc, plugin_name, attr)

        getattr(self.plugins[plugin_name], f&#39;ppp_add_cb_{attr}&#39;)(cast_rc) # All PPP  cbs start with this string.
        return cast_rc
    return decorator</code></pre>
</details>
</dd>
<dt id="pandare.Panda.pyperiph_read_cb"><code class="name flex">
<span>def <span class="ident">pyperiph_read_cb</span></span>(<span>self, cpu, pc, physaddr, size, val_ptr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pyperiph_read_cb(self, cpu, pc, physaddr, size, val_ptr):
    pp = self._addr_to_pyperipheral(physaddr)
    if pp is None:
        return False

    val = pp.read_memory(physaddr, size)
    buf = self.ffi.buffer(val_ptr, size)

    fmt = &#34;{}{}&#34;.format(self._end2fmt[self.endianness], self._num2fmt[size])

    pack_into(fmt, buf, 0, val)

    return True</code></pre>
</details>
</dd>
<dt id="pandare.Panda.pyperiph_write_cb"><code class="name flex">
<span>def <span class="ident">pyperiph_write_cb</span></span>(<span>self, cpu, pc, physaddr, size, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pyperiph_write_cb(self, cpu, pc, physaddr, size, val):
    pp = self._addr_to_pyperipheral(physaddr)
    if pp is None:
        return False

    pp.write_memory(physaddr, size, val)
    return True</code></pre>
</details>
</dd>
<dt id="pandare.Panda.queue_async"><code class="name flex">
<span>def <span class="ident">queue_async</span></span>(<span>self, f, internal=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Explicitly queue work in the asynchronous work queue.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>A python function with no arguments to be called at a later time. The function should</dd>
</dl>
<p>be decorated with <code>@pandare.blocking</code>. You generally want to use <code>panda.queue_blocking</code> over this function.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_async(self, f, internal=False):
    &#39;&#39;&#39;
    Explicitly queue work in the asynchronous work queue.

    Args:
        f: A python function with no arguments to be called at a later time. The function should
        be decorated with `@pandare.blocking`. You generally want to use `panda.queue_blocking` over this function.

    Returns:
        None
    &#39;&#39;&#39;

    # this takes the blocking function and handles errors
    @blocking
    def wrapper():
        try:
            f()
        except Exception as e:
            if self.catch_exceptions:
                self.exit_exception = e
                self.end_analysis()
            else:
                raise e

    # Keep the original function name instead of replacing it with &#39;wrapper&#39;
    wrapper.__name__ = f.__name__
    self.athread.queue(wrapper, internal=internal)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.queue_blocking"><code class="name flex">
<span>def <span class="ident">queue_blocking</span></span>(<span>self, func, queue=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to mark a function as <code>blocking</code>, and (by default) queue it to run asynchronously.
This should be used to mark functions that will drive guest execution. Functions will be run
in the order they are defined. For more precise control, use <code>panda.queue_async</code>.</p>
<pre><code>@panda.queue_blocking
def do_something():
    panda.revert_sync('root')
    print(panda.run_serial_cmd('whoami'))
    panda.end_analysis()
</code></pre>
<p>is equivalent to</p>
<pre><code>@blocking
def run_whoami():
    panda.revert_sync('root')
    print(panda.run_serial_cmd('whoami'))
    panda.end_analysis()

panda.queue_async(run_whoami)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>function</code></dt>
<dd>Function to queue</dd>
<dt><strong><code>queue</code></strong> :&ensp;<code>bool</code></dt>
<dd>Should function automatically be queued</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_blocking(self, func, queue=True):
    &#34;&#34;&#34;
    Decorator to mark a function as `blocking`, and (by default) queue it to run asynchronously.
    This should be used to mark functions that will drive guest execution. Functions will be run
    in the order they are defined. For more precise control, use `panda.queue_async`.


    ```
    @panda.queue_blocking
    def do_something():
        panda.revert_sync(&#39;root&#39;)
        print(panda.run_serial_cmd(&#39;whoami&#39;))
        panda.end_analysis()
    ```

    is equivalent to

    ```
    @blocking
    def run_whoami():
        panda.revert_sync(&#39;root&#39;)
        print(panda.run_serial_cmd(&#39;whoami&#39;))
        panda.end_analysis()

    panda.queue_async(run_whoami)
    ```

    Args:
        func (function): Function to queue
        queue (bool): Should function automatically be queued

    Returns:
        None

    &#34;&#34;&#34;
    f = blocking(func)
    if queue:
        self.queue_async(f)
    return f</code></pre>
</details>
</dd>
<dt id="pandare.Panda.queue_main_loop_wait_fn"><code class="name flex">
<span>def <span class="ident">queue_main_loop_wait_fn</span></span>(<span>self, fn, args=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Queue a function to run at the next main loop
fn is a function we want to run, args are arguments to apss to it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_main_loop_wait_fn(self, fn, args=[]):
    &#39;&#39;&#39;
    Queue a function to run at the next main loop
    fn is a function we want to run, args are arguments to apss to it
    &#39;&#39;&#39;
    self.main_loop_wait_fnargs.append((fn, args))</code></pre>
</details>
</dd>
<dt id="pandare.Panda.read_str"><code class="name flex">
<span>def <span class="ident">read_str</span></span>(<span>self, cpu, ptr, max_length=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper to read a null-terminated string from guest memory given a pointer and CPU state
May return an exception if the call to panda.virtual_memory_read fails (e.g., if you pass a
pointer to an unmapped page)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
<dt><strong><code>ptr</code></strong> :&ensp;<code>int</code></dt>
<dd>Pointer to start of string</dd>
<dt><strong><code>max_length</code></strong> :&ensp;<code>int</code></dt>
<dd>Optional length to stop reading at</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>Data read from memory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_str(self, cpu, ptr, max_length=None):
    &#39;&#39;&#39;
    Helper to read a null-terminated string from guest memory given a pointer and CPU state
    May return an exception if the call to panda.virtual_memory_read fails (e.g., if you pass a
    pointer to an unmapped page)

    Args:
        cpu (CPUState): CPUState structure
        ptr (int): Pointer to start of string
        max_length (int): Optional length to stop reading at

    Returns:
        string: Data read from memory

    &#39;&#39;&#39;
    r = b&#34;&#34;
    idx = 0
    while (max_length is None or idx &lt; max_length):
        next_char = self.virtual_memory_read(cpu, ptr, 1) # If this raises an exn, don&#39;t mask it
        if next_char == b&#34;\x00&#34;:
            break
        r += next_char
        ptr += 1
        idx += 1
    return r.decode(&#34;utf8&#34;, &#34;ignore&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.record"><code class="name flex">
<span>def <span class="ident">record</span></span>(<span>self, recording_name, snapshot_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Begins active recording with name provided.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>recording_name</code></strong> :&ensp;<code>string</code></dt>
<dd>name of recording to save.</dd>
<dt><strong><code>snapshot_name</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Before recording starts restore to this snapshot name. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>raises exception if there was an error starting recording.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def record(self, recording_name, snapshot_name=None):
    &#34;&#34;&#34;Begins active recording with name provided.

    Args:
        recording_name (string): name of recording to save.
        snapshot_name (string, optional): Before recording starts restore to this snapshot name. Defaults to None.

    Raises:
        Exception: raises exception if there was an error starting recording.
    &#34;&#34;&#34;
    if snapshot_name == None:
        snapshot_name_ffi = self.ffi.NULL
    else:
        snapshot_name_ffi = self.ffi.new(&#34;char[]&#34;,snapshot_name.encode())
    recording_name_ffi = self.ffi.new(&#34;char[]&#34;, recording_name.encode())
    result = self.libpanda.panda_record_begin(recording_name_ffi,snapshot_name_ffi)
    res_string_enum = self.ffi.string(self.ffi.cast(&#34;RRCTRL_ret&#34;,result))
    if res_string_enum != &#34;RRCTRL_OK&#34;:
       raise Exception(f&#34;record method failed with RTCTL_ret {res_string_enum} ({result})&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.record_cmd"><code class="name flex">
<span>def <span class="ident">record_cmd</span></span>(<span>self, guest_command, copy_directory=None, iso_name=None, setup_command=None, recording_name='recording', snap_name='root', ignore_errors=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Take a recording as follows:
0) Revert to the specified snapshot name if one is set. By default 'root'. Set to <code>None</code> if you have already set up the guest and are ready to record with no revert
1) Create an ISO of files that need to be copied into the guest if copy_directory is specified. Copy them in
2) Run the setup_command in the guest, if provided
3) Type the command you wish to record but do not press enter to begin execution. This avoids the recording capturing the command being typed
4) Begin the recording (name controlled by recording_name)
5) Press enter in the guest to begin the command. Wait until it finishes.
6) End the recording</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def record_cmd(self, guest_command, copy_directory=None, iso_name=None, setup_command=None, recording_name=&#34;recording&#34;, snap_name=&#34;root&#34;, ignore_errors=False):
    &#39;&#39;&#39;
    Take a recording as follows:
        0) Revert to the specified snapshot name if one is set. By default &#39;root&#39;. Set to `None` if you have already set up the guest and are ready to record with no revert
        1) Create an ISO of files that need to be copied into the guest if copy_directory is specified. Copy them in
        2) Run the setup_command in the guest, if provided
        3) Type the command you wish to record but do not press enter to begin execution. This avoids the recording capturing the command being typed
        4) Begin the recording (name controlled by recording_name)
        5) Press enter in the guest to begin the command. Wait until it finishes.
        6) End the recording
    &#39;&#39;&#39;
    # 0) Revert to the specified snapshot
    if snap_name is not None:
        self.revert_sync(snap_name) # Can&#39;t use self.revert because that would would run async and we&#39;d keep going before the revert happens

    # 1) Make copy_directory into an iso and copy it into the guest - It will end up at the exact same path
    if copy_directory: # If there&#39;s a directory, build an ISO and put it in the cddrive
        # Make iso
        self.copy_to_guest(copy_directory, iso_name)

    # 2) Run setup_command, if provided before we start the recording (good place to CD or install, etc)
    if setup_command:
        print(f&#34;Running setup command {setup_command}&#34;)
        r = self.run_serial_cmd(setup_command)
        print(f&#34;Setup command results: {r}&#34;)

    # 3) type commmand (note we type command, start recording, finish command)
    self.type_serial_cmd(guest_command)

    # 4) start recording
    self.run_monitor_cmd(&#34;begin_record {}&#34;.format(recording_name))

    # 5) finish command
    result = self.finish_serial_cmd()

    if debug:
        progress(&#34;Result of `{}`:&#34;.format(guest_command))
        print(&#34;\t&#34;+&#34;\n\t&#34;.join(result.split(&#34;\n&#34;))+&#34;\n&#34;)

    if &#34;No such file or directory&#34; in result and not ignore_errors:
        print(&#34;Bad output running command: {}&#34;.format(result))
        raise RuntimeError(&#34;Command not found while taking recording&#34;)

    if &#34;cannot execute binary file&#34; in result and not ignore_errors:
        print(&#34;Bad output running command: {}&#34;.format(result))
        raise RuntimeError(&#34;Could not execute binary while taking recording&#34;)

    # 6) End recording
    self.run_monitor_cmd(&#34;end_record&#34;)

    print(&#34;Finished recording&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.recording_exists"><code class="name flex">
<span>def <span class="ident">recording_exists</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a recording file exists on disk.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the recording to check for (e.g., <code>foo</code> which uses <code>foo-rr-snp</code> and <code>foo-rr-nondet.log</code>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>true if file exists, false otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recording_exists(self, name):
    &#39;&#39;&#39;
    Checks if a recording file exists on disk.

    Args:
        name (str): name of the recording to check for (e.g., `foo` which uses `foo-rr-snp` and `foo-rr-nondet.log`)
    
    Returns:
        boolean: true if file exists, false otherwise
    &#39;&#39;&#39;
    if exists(name + &#34;-rr-snp&#34;) or rr2_contains_member(name, &#34;snapshot&#34;):
        return True</code></pre>
</details>
</dd>
<dt id="pandare.Panda.register_callback"><code class="name flex">
<span>def <span class="ident">register_callback</span></span>(<span>self, callback, function, name, enabled=True, procname=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_callback(self, callback, function, name, enabled=True, procname=None):
    # CB   = self.callback.main_loop_wait
    # func = main_loop_wait_cb
    # name = main_loop_wait

    if name in self.registered_callbacks:
        print(f&#34;Warning: replacing existing callback &#39;{name}&#39; since it was re-registered&#34;)
        self.delete_callback(name)

    cb = self.callback_dictionary[callback]

    # Generate a unique handle for each callback type using the number of previously registered CBs of that type added to a constant
    self.plugin_register_count += 1
    handle = self.ffi.cast(&#39;void *&#39;, self.plugin_register_count)

    # XXX: We should have another layer of indirection here so we can catch
    #      exceptions raised during execution of the CB and abort analysis
    pcb = self.ffi.new(&#34;panda_cb *&#34;, {cb.name:function})

    if debug:
        progress(&#34;Registered function &#39;{}&#39; to run on callback {}&#34;.format(name, cb.name))

    self.libpanda.panda_register_callback_helper(handle, cb.number, pcb)
    self.registered_callbacks[name] = {&#34;procname&#34;: procname, &#34;enabled&#34;: True, &#34;callback&#34;: cb,
                       &#34;handle&#34;: handle, &#34;pcb&#34;: pcb, &#34;function&#34;: function} # XXX: if function is not saved here it gets GC&#39;d and everything breaks! Watch out!

    if not enabled: # Note the registered_callbacks dict starts with enabled true and then we update it to false as necessary here
        self.disable_callback(name)

    if &#34;block&#34; in cb.name and &#34;start&#34; not in cb.name and &#34;end&#34; not in cb.name:
        if not self.disabled_tb_chaining:
            print(&#34;Warning: disabling TB chaining to support {} callback&#34;.format(cb.name))
            self.disable_tb_chaining()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.register_cb_decorators"><code class="name flex">
<span>def <span class="ident">register_cb_decorators</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Setup callbacks and generate self.cb_XYZ functions for cb decorators
XXX Don't add any other methods with names starting with 'cb_'
Callbacks can be called as @panda.cb_XYZ in which case they'll take default arguments and be named the same as the decorated function
Or they can be called as @panda.cb_XYZ(name='A', procname='B', enabled=True). Defaults: name is function name, procname=None, enabled=True unless procname set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_cb_decorators(self):
    &#39;&#39;&#39;
    Setup callbacks and generate self.cb_XYZ functions for cb decorators
    XXX Don&#39;t add any other methods with names starting with &#39;cb_&#39;
    Callbacks can be called as @panda.cb_XYZ in which case they&#39;ll take default arguments and be named the same as the decorated function
    Or they can be called as @panda.cb_XYZ(name=&#39;A&#39;, procname=&#39;B&#39;, enabled=True). Defaults: name is function name, procname=None, enabled=True unless procname set
    &#39;&#39;&#39;
    for cb_name, pandatype in zip(self.callback._fields, self.callback):
        def closure(closed_cb_name, closed_pandatype): # Closure on cb_name and pandatype
            def f(*args, **kwargs):
                if len(args): # Called as @panda.cb_XYZ without ()s- no arguments to decorator but we get the function name instead
                    # Call our decorator with only a name argument ON the function itself
                    fun = args[0]
                    return self._generated_callback(closed_pandatype, **{&#34;name&#34;: fun.__name__})(fun)
                else:
                    # Otherwise, we were called as @panda.cb_XYZ() with potential args - Just return the decorator and it&#39;s applied to the function
                    return self._generated_callback(closed_pandatype, *args, **kwargs)
            return f

        setattr(self, &#39;cb_&#39;+cb_name, closure(cb_name, pandatype))</code></pre>
</details>
</dd>
<dt id="pandare.Panda.register_pyperipheral"><code class="name flex">
<span>def <span class="ident">register_pyperipheral</span></span>(<span>self, object)</span>
</code></dt>
<dd>
<div class="desc"><p>Registers a python peripheral, and the necessary attributes to the
panda-object, if not present yet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_pyperipheral(self, object):
    &#34;&#34;&#34;
    Registers a python peripheral, and the necessary attributes to the
    panda-object, if not present yet.
    &#34;&#34;&#34;

    # if we are the first pyperipheral, register the pp-dict
    if not hasattr(self, &#34;pyperipherals&#34;):
        self.pyperipherals = []
        self.pyperipherals_registered_cb = False
        self._num2fmt = {1: &#34;B&#34;, 2: &#34;H&#34;, 4: &#34;I&#34;, 8: &#34;Q&#34;}
        self._end2fmt = {&#34;little&#34;: &#34;&lt;&#34;, &#34;big&#34;: &#34;&gt;&#34;}

    self._validate_object(object)

    if self.pyperipherals_registered_cb is False:
        self.register_callback(
            self.callback.unassigned_io_read,
            self.callback.unassigned_io_read(self.pyperiph_read_cb),
            &#34;pyperipheral_read_callback&#34;,
        )

        self.register_callback(
            self.callback.unassigned_io_write,
            self.callback.unassigned_io_write(self.pyperiph_write_cb),
            &#34;pyperipheral_write_callback&#34;,
        )

        self.pyperipherals_registered_cb = True

    self.pyperipherals.append(object)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.require"><code class="name flex">
<span>def <span class="ident">require</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a C plugin with no arguments. Deprecated. Use load_plugin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def require(self, name):
    &#39;&#39;&#39;
    Load a C plugin with no arguments. Deprecated. Use load_plugin
    &#39;&#39;&#39;
    self.load_plugin(name, args={})</code></pre>
</details>
</dd>
<dt id="pandare.Panda.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>In the next main loop, reset to boot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;In the next main loop, reset to boot&#34;&#34;&#34;
    if debug:
        progress (&#34;Resetting machine to start state&#34;)

    # Stop guest, queue up revert, then continue
    self.vm_stop()
    self.queue_main_loop_wait_fn(self.libpanda.panda_reset)
    self.queue_main_loop_wait_fn(self.libpanda.panda_cont)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.revert_async"><code class="name flex">
<span>def <span class="ident">revert_async</span></span>(<span>self, snapshot_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Request a snapshot revert, eventually. This is fairly dangerous
because you don't know when it finishes. You should be using revert_sync
from a blocking function instead</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def revert_async(self, snapshot_name): # In the next main loop, revert
    &#39;&#39;&#39;
    Request a snapshot revert, eventually. This is fairly dangerous
    because you don&#39;t know when it finishes. You should be using revert_sync
    from a blocking function instead
    &#39;&#39;&#39;
    if not hasattr(self, &#39;warned_async&#39;):
        self.warned_async = True
        print(&#34;WARNING: panda.revert_async may be deprecated in the near future&#34;)
    if debug:
        progress (&#34;Loading snapshot &#34; + snapshot_name)

    # Stop guest, queue up revert, then continue
    timer_start = time()
    self.vm_stop()
    charptr = self.ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
    self.queue_main_loop_wait_fn(self.libpanda.panda_revert, [charptr])
    self.queue_main_loop_wait_fn(self.libpanda.panda_cont)
    if debug:
        self.queue_main_loop_wait_fn(self._finish_timer, [timer_start, &#34;Loaded snapshot&#34;])</code></pre>
</details>
</dd>
<dt id="pandare.Panda.revert_sync"><code class="name flex">
<span>def <span class="ident">revert_sync</span></span>(<span>self, snapshot_name)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>snapshot_name</code></strong></dt>
<dd>name of snapshot in the current qcow to load</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>String</code></dt>
<dd>error message. Empty on success.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def revert_sync(self, snapshot_name):
    &#39;&#39;&#39;
    Args:
        snapshot_name: name of snapshot in the current qcow to load

    Returns:
        String: error message. Empty on success.
    &#39;&#39;&#39;
    result = self.run_monitor_cmd(&#34;loadvm {}&#34;.format(snapshot_name))
    # On success we should get no result

    if result.startswith(&#34;Length mismatch&#34;):
        raise RuntimeError(&#34;QEMU machine&#39;s RAM size doesn&#39;t match snapshot RAM size!&#34;)

    if &#34;does not have the requested snapshot&#34; in result:
        raise ValueError(f&#34;Snapshot &#39;{snapshot_name}&#39; not present in {self.qcow}&#34;)

    result = result.strip()
    if len(result):
        warn(f&#34;snapshot load returned error {result}&#34;)

    return result</code></pre>
</details>
</dd>
<dt id="pandare.Panda.rr_get_guest_instr_count"><code class="name flex">
<span>def <span class="ident">rr_get_guest_instr_count</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns record/replay guest instruction count.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Current instruction count</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rr_get_guest_instr_count(self):
    &#39;&#39;&#39;
    Returns record/replay guest instruction count.

    Returns:
        int: Current instruction count
    &#39;&#39;&#39;
    return self.libpanda.rr_get_guest_instr_count_external()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function starts our running PANDA instance from Python. At termination this function returns and the script continues to run after it.</p>
<p>This function starts execution of the guest. It blocks until guest finishes.
It also initializes panda object, clears main_loop_wait fns, and sets up internal callbacks.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>When emulation has finished due to guest termination, replay conclusion or a call to <code><a title="pandare.Panda.end_analysis" href="#pandare.Panda.end_analysis">Panda.end_analysis()</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#39;&#39;&#39;
    This function starts our running PANDA instance from Python. At termination this function returns and the script continues to run after it.

    This function starts execution of the guest. It blocks until guest finishes.
    It also initializes panda object, clears main_loop_wait fns, and sets up internal callbacks.

    Args:
        None

    Returns:
        None: When emulation has finished due to guest termination, replay conclusion or a call to `Panda.end_analysis`
    &#39;&#39;&#39;

    if len(self.main_loop_wait_fnargs):
        if debug:
            print(&#34;Clearing prior main_loop_wait fns:&#34;, self.main_loop_wait_fnargs)
        self.main_loop_wait_fnargs = [] # [(fn, args), ...]

    self.ending = False

    if debug:
        progress (&#34;Running&#34;)

    self.initializing.set()
    if not self._initialized_panda:
        self._initialize_panda()
    self.initializing.clear()

    if not self.started.is_set():
        self.started.set()

    self.athread.ending = False

    # Ensure our internal CBs are always enabled
    self.enable_internal_callbacks()
    self._setup_internal_signal_handler()
    self.running.set()
    self.libpanda.panda_run() # Give control to panda
    self.running.clear() # Back from panda&#39;s execution (due to shutdown or monitor quit)
    self.unload_plugins() # Unload pyplugins and C plugins
    self.delete_callbacks() # Unload any registered callbacks
    self.plugins = plugin_list(self)
    # Write PANDALOG, if any
    #self.libpanda.panda_cleanup_record()
    if self._in_replay:
        self.reset()
    if hasattr(self, &#34;exit_exception&#34;):
        saved_exception = self.exit_exception
        del self.exit_exception
        raise saved_exception</code></pre>
</details>
</dd>
<dt id="pandare.Panda.run_monitor_cmd"><code class="name flex">
<span>def <span class="ident">run_monitor_cmd</span></span>(<span>self, cmd)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def run_monitor_cmd(self, cmd):
    self.monitor_console.sendline(cmd.encode(&#34;utf8&#34;))
    result = self.monitor_console.expect()
    return result</code></pre>
</details>
</dd>
<dt id="pandare.Panda.run_replay"><code class="name flex">
<span>def <span class="ident">run_replay</span></span>(<span>self, replaypfx)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a replay and run it. Starts PANDA execution and returns after end of VM execution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>replaypfx</code></strong> :&ensp;<code>str</code></dt>
<dd>Replay name/path (e.g., "foo" or "./dir/foo")</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_replay(self, replaypfx):
    &#39;&#39;&#39;
    Load a replay and run it. Starts PANDA execution and returns after end of VM execution.

    Args:
        replaypfx (str): Replay name/path (e.g., &#34;foo&#34; or &#34;./dir/foo&#34;)

    Returns:
        None
    &#39;&#39;&#39;
    if (not isfile(replaypfx+&#34;-rr-snp&#34;) or not isfile(replaypfx+&#34;-rr-nondet.log&#34;)) and not rr2_recording(replaypfx):
        raise ValueError(&#34;Replay files not present to run replay of {}&#34;.format(replaypfx))

    self.ending = False

    if debug:
        progress (&#34;Replaying %s&#34; % replaypfx)

    charptr = self.ffi.new(&#34;char[]&#34;,bytes(replaypfx,&#34;utf-8&#34;))
    self.libpanda.panda_replay_begin(charptr)
    self._in_replay = True
    self.run()
    self._in_replay = False</code></pre>
</details>
</dd>
<dt id="pandare.Panda.run_serial_cmd"><code class="name flex">
<span>def <span class="ident">run_serial_cmd</span></span>(<span>self, cmd, no_timeout=False, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a command inside the guest through a terminal exposed over a serial port. Can only be used if your guest is configured in this way</p>
<p>Guest output will be analyzed until we see the expect_prompt regex printed (i.e., the PS1 prompt)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cmd</code></strong></dt>
<dd>command to run.</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>maximum time to wait for the command to finish</dd>
<dt><strong><code>no_timeout</code></strong></dt>
<dd>if set, don't ever timeout</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>String</code></dt>
<dd>all the output (stdout + stderr) printed after typing your command and pressing enter until the next prompt was printed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def run_serial_cmd(self, cmd, no_timeout=False, timeout=None):
    &#39;&#39;&#39;
    Run a command inside the guest through a terminal exposed over a serial port. Can only be used if your guest is configured in this way

    Guest output will be analyzed until we see the expect_prompt regex printed (i.e., the PS1 prompt)

    Args:
        cmd: command to run.
        timeout: maximum time to wait for the command to finish
        no_timeout: if set, don&#39;t ever timeout

    Returns:
        String: all the output (stdout + stderr) printed after typing your command and pressing enter until the next prompt was printed.
    &#39;&#39;&#39;

    if timeout is None:
        timeout = 30

    if self.serial_console is None:
        raise RuntimeError(&#34;Cannot run serial commands without providing PANDA an expect_prompt&#34;)
    self.running.wait() # Can only run serial when guest is running
    self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
    if no_timeout:
        result = self.serial_console.expect(timeout=9999) # &#34;Don&#39;t ever timeout&#34; above is a bit of an exaggeration
    else:
        result = self.serial_console.expect(timeout=timeout)
    return result</code></pre>
</details>
</dd>
<dt id="pandare.Panda.run_serial_cmd_async"><code class="name flex">
<span>def <span class="ident">run_serial_cmd_async</span></span>(<span>self, cmd, delay=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Type a command and press enter in the guest. Return immediately. No results available
Only use this if you know what you're doing!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def run_serial_cmd_async(self, cmd, delay=1):
    &#39;&#39;&#39;
    Type a command and press enter in the guest. Return immediately. No results available
    Only use this if you know what you&#39;re doing!
    &#39;&#39;&#39;
    self.running.wait() # Can only run serial when guest is running
    self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
    if delay:
        sleep(delay) # Ensure it has a chance to run</code></pre>
</details>
</dd>
<dt id="pandare.Panda.run_volatility"><code class="name flex">
<span>def <span class="ident">run_volatility</span></span>(<span>self, plugin, debug=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_volatility(self, plugin, debug=False):
    try:
        from .volatility_cli_classes import CommandLineRunFullCommand, StringTextRenderer
    except ImportError:
        print(&#34;Warning: Failed to import volatility&#34;)
        return None
    self.make_panda_file_handler(debug=debug)
    cmd = CommandLineRunFullCommand().run(&#34;-q -f panda.panda &#34; + plugin)
    output = StringTextRenderer().render(cmd.run())
    return output</code></pre>
</details>
</dd>
<dt id="pandare.Panda.serial_read_until"><code class="name flex">
<span>def <span class="ident">serial_read_until</span></span>(<span>self, byte_sequence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def serial_read_until(self, byte_sequence):
    if len(self.serial_unconsumed_data) &gt; 0:
        found_idx = self.serial_unconsumed_data.find(byte_sequence)
        if found_idx &gt;= 0:
            match = self.serial_unconsumed_data[ : found_idx]
            self.serial_unconsumed_data = self.serial_unconsumed_data[found_idx + 1 : ]
            return match
    while self.serial_socket != None:
        try:
            readable, _, _ = select.select([self.serial_socket], [], [], 0.5)
            if len(readable) == 0:
                continue
            data = self.serial_socket.recv(65535)
        except Exception as e:
            if &#39;[Errno 11]&#39; in str(e) or &#39;[Errno 35]&#39; in str(e):
                # EAGAIN
                continue
            raise Exception(&#34;Data Read Error: {}&#34;.format(e.message))
        if not data:
            raise Exception(&#39;Connection Closed by Server&#39;)

        self.serial_unconsumed_data += data
        found_idx = self.serial_unconsumed_data.find(byte_sequence)
        if found_idx &gt;= 0:
            match = self.serial_unconsumed_data[ : found_idx]
            self.serial_unconsumed_data = self.serial_unconsumed_data[found_idx + 1 : ]
            return match
    return None</code></pre>
</details>
</dd>
<dt id="pandare.Panda.set_breakpoint"><code class="name flex">
<span>def <span class="ident">set_breakpoint</span></span>(<span>self, cpu, pc)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a GDB breakpoint such that when the guest hits PC, execution is paused and an attached
GDB instance can introspect on guest memory. Requires starting panda with -s, at least for now</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_breakpoint(self, cpu, pc):
    &#39;&#39;&#39;
    Set a GDB breakpoint such that when the guest hits PC, execution is paused and an attached
    GDB instance can introspect on guest memory. Requires starting panda with -s, at least for now
    &#39;&#39;&#39;
    BP_GDB = 0x10
    self.libpanda.cpu_breakpoint_insert(cpu, pc, BP_GDB, self.ffi.NULL)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.set_os_name"><code class="name flex">
<span>def <span class="ident">set_os_name</span></span>(<span>self, os_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set OS target. Equivalent to "-os" flag on the command line. Matches the form of:</p>
<pre><code>"windows[-_]32[-_]xpsp[23]",
"windows[-_]32[-_]2000",
"windows[-_]32[-_]7sp[01]",
"windows[-_]64[-_]7sp[01]",
"linux[-_]32[-_].+",
"linux[-_]64[-_].+",
"freebsd[-_]32[-_].+",
"freebsd[-_]64[-_].+",

Args:
    os_name (str): Name that matches the format for the os flag.

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_os_name(self, os_name):
    &#34;&#34;&#34;
    Set OS target. Equivalent to &#34;-os&#34; flag on the command line. Matches the form of:

        &#34;windows[-_]32[-_]xpsp[23]&#34;,
        &#34;windows[-_]32[-_]2000&#34;,
        &#34;windows[-_]32[-_]7sp[01]&#34;,
        &#34;windows[-_]64[-_]7sp[01]&#34;,
        &#34;linux[-_]32[-_].+&#34;,
        &#34;linux[-_]64[-_].+&#34;,
        &#34;freebsd[-_]32[-_].+&#34;,
        &#34;freebsd[-_]64[-_].+&#34;,

        Args:
            os_name (str): Name that matches the format for the os flag.

        Returns:
            None
    &#34;&#34;&#34;
    print (&#34;os_name=[%s]&#34; % os_name)
    os_name_new = self.ffi.new(&#34;char[]&#34;, bytes(os_name, &#34;utf-8&#34;))
    self.libpanda.panda_set_os_name(os_name_new)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.set_pandalog"><code class="name flex">
<span>def <span class="ident">set_pandalog</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable recording to a pandalog (plog) named <code>name</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>filename to output data to</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pandalog(self, name):
    &#39;&#39;&#39;
    Enable recording to a pandalog (plog) named `name`

    Args:
        name (str): filename to output data to

    Returns:
        None
    &#39;&#39;&#39;
    charptr = self.ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
    self.libpanda.panda_start_pandalog(charptr)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.snap"><code class="name flex">
<span>def <span class="ident">snap</span></span>(<span>self, snapshot_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Create snapshot with specified name</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>snapshot_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the snapshot</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def snap(self, snapshot_name):
    &#39;&#39;&#39;
    Create snapshot with specified name

    Args:
        snapshot_name (str): name of the snapshot

    Returns:
        None
    &#39;&#39;&#39;
    if debug:
        progress (&#34;Creating snapshot &#34; + snapshot_name)

    # Stop guest execution, queue up a snapshot, then continue
    timer_start = time()
    self.vm_stop()
    charptr = self.ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
    self.queue_main_loop_wait_fn(self.libpanda.panda_snap, [charptr])
    self.queue_main_loop_wait_fn(self.libpanda.panda_cont)
    if debug:
        self.queue_main_loop_wait_fn(self._finish_timer, [timer_start, &#34;Saved snapshot&#34;])</code></pre>
</details>
</dd>
<dt id="pandare.Panda.stop_run"><code class="name flex">
<span>def <span class="ident">stop_run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>From a blocking thread, request vl.c loop to break. Returns control flow in main thread.
In other words, once this is called, panda.run() will finish and your main thread will continue.
If you also want to unload plugins, use end_analysis instead</p>
<p>XXX: This doesn't work in replay mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def stop_run(self):
    &#39;&#39;&#39;
    From a blocking thread, request vl.c loop to break. Returns control flow in main thread.
    In other words, once this is called, panda.run() will finish and your main thread will continue.
    If you also want to unload plugins, use end_analysis instead

    XXX: This doesn&#39;t work in replay mode
    &#39;&#39;&#39;
    self.libpanda.panda_break_vl_loop_req = True</code></pre>
</details>
</dd>
<dt id="pandare.Panda.string_to_condition"><code class="name flex">
<span>def <span class="ident">string_to_condition</span></span>(<span>self, string: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def string_to_condition(self, string: str):
    s = self.string_to_solver(string)
    asrts = s.assertions()
    if len(asrts) == 0:
        return None 
    return asrts[0]</code></pre>
</details>
</dd>
<dt id="pandare.Panda.string_to_expr"><code class="name flex">
<span>def <span class="ident">string_to_expr</span></span>(<span>self, string: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def string_to_expr(self, string: str):
    eq = self.string_to_condition(string)
    if eq and len(eq.children()) &gt; 0:
        return eq.children()[0]
    return None</code></pre>
</details>
</dd>
<dt id="pandare.Panda.string_to_solver"><code class="name flex">
<span>def <span class="ident">string_to_solver</span></span>(<span>self, string: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def string_to_solver(self, string: str):
    from z3 import Solver
    s = Solver()
    s.from_string(string)
    return s</code></pre>
</details>
</dd>
<dt id="pandare.Panda.sysbus_create_varargs"><code class="name flex">
<span>def <span class="ident">sysbus_create_varargs</span></span>(<span>self, name, addr)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns DeviceState struct from user specified information
Calls sysbus_create_varargs QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt>name (str):</dt>
<dt><strong><code>addr</code></strong> :&ensp;<code>int</code></dt>
<dd>hwaddr</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DeviceState struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sysbus_create_varargs(self, name, addr):
    &#39;&#39;&#39;
    Returns DeviceState struct from user specified information
    Calls sysbus_create_varargs QEMU function.

    Args:
        name (str):
        addr (int): hwaddr

    Returns:
        DeviceState struct
    &#39;&#39;&#39;
    return self.libpanda.sysbus_create_varargs(name,addr, self.ffi.NULL)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_check_laddr"><code class="name flex">
<span>def <span class="ident">taint_check_laddr</span></span>(<span>self, addr, off)</span>
</code></dt>
<dd>
<div class="desc"><p>returns boolean result checking if this laddr is tainted</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_check_laddr(self, addr, off):
    &#39;&#39;&#39;
    returns boolean result checking if this laddr is tainted
    &#39;&#39;&#39;
    self._assert_taint_enabled()
    return self.plugins[&#39;taint2&#39;].taint2_query_laddr(addr, off) &gt; 0</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_check_ram"><code class="name flex">
<span>def <span class="ident">taint_check_ram</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<div class="desc"><p>returns boolean representing if physical address is tainted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_check_ram(self, addr):
    &#39;&#39;&#39;
    returns boolean representing if physical address is tainted.
    &#39;&#39;&#39;
    self._assert_taint_enabled()
    return self.plugins[&#39;taint2&#39;].taint2_query_ram(addr) &gt; 0</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_check_reg"><code class="name flex">
<span>def <span class="ident">taint_check_reg</span></span>(<span>self, reg_num)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if register reg_num is tainted. Returns boolean.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_check_reg(self, reg_num):
    &#39;&#39;&#39;
    Checks if register reg_num is tainted. Returns boolean.
    &#39;&#39;&#39;
    self._assert_taint_enabled()
    for offset in range(self.register_size):
        if self.plugins[&#39;taint2&#39;].taint2_query_reg(reg_num, offset) &gt; 0:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_enable"><code class="name flex">
<span>def <span class="ident">taint_enable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable taint.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_enable(self):
    &#39;&#39;&#39;
    Enable taint.
    &#39;&#39;&#39;
    self.plugins[&#34;taint2&#34;].taint2_enable_taint()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_enabled"><code class="name flex">
<span>def <span class="ident">taint_enabled</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks to see if taint2 plugin has been loaded</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_enabled(self):
    &#39;&#39;&#39;
    Checks to see if taint2 plugin has been loaded
    &#39;&#39;&#39;
    return self._plugin_loaded(&#34;taint2&#34;) and self.plugins[&#34;taint2&#34;].taint2_enabled()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_get_laddr"><code class="name flex">
<span>def <span class="ident">taint_get_laddr</span></span>(<span>self, addr, offset)</span>
</code></dt>
<dd>
<div class="desc"><p>returns array of results, one for each byte in this laddr
None if no taint.
QueryResult struct otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_get_laddr(self, addr, offset):
    &#39;&#39;&#39;
    returns array of results, one for each byte in this laddr
    None if no taint.  QueryResult struct otherwise
    &#39;&#39;&#39;
    self._assert_taint_enabled()
    if self.plugins[&#39;taint2&#39;].taint2_query_laddr(addr, offset) &gt; 0:
        query_res = self.ffi.new(&#34;QueryResult *&#34;)
        self.plugins[&#39;taint2&#39;].taint2_query_laddr_full(addr, offset, query_res)
        tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;], self.ffi)
        return tq
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_get_ram"><code class="name flex">
<span>def <span class="ident">taint_get_ram</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<div class="desc"><p>returns array of results, one for each byte in this register
None if no taint.
QueryResult struct otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_get_ram(self, addr):
    &#39;&#39;&#39;
    returns array of results, one for each byte in this register
    None if no taint.  QueryResult struct otherwise
    &#39;&#39;&#39;
    self._assert_taint_enabled()
    if self.plugins[&#39;taint2&#39;].taint2_query_ram(addr) &gt; 0:
        query_res = self.ffi.new(&#34;QueryResult *&#34;)
        self.plugins[&#39;taint2&#39;].taint2_query_ram_full(addr, query_res)
        tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;], self.ffi)
        return tq
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_get_reg"><code class="name flex">
<span>def <span class="ident">taint_get_reg</span></span>(<span>self, reg_num)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns array of results, one for each byte in this register
None if no taint.
QueryResult struct otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_get_reg(self, reg_num):
    &#39;&#39;&#39;
    Returns array of results, one for each byte in this register
    None if no taint.  QueryResult struct otherwise
    &#39;&#39;&#39;
    self._assert_taint_enabled()
    res = []
    for offset in range(self.register_size):
        if self.plugins[&#39;taint2&#39;].taint2_query_reg(reg_num, offset) &gt; 0:
            query_res = self.ffi.new(&#34;QueryResult *&#34;)
            self.plugins[&#39;taint2&#39;].taint2_query_reg_full(reg_num, offset, query_res)
            tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;], self.ffi)
            res.append(tq)
        else:
            res.append(None)
    return res</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_label_ram"><code class="name flex">
<span>def <span class="ident">taint_label_ram</span></span>(<span>self, addr, label)</span>
</code></dt>
<dd>
<div class="desc"><p>Labels ram at address with label.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_label_ram(self, addr, label):
    &#39;&#39;&#39;
    Labels ram at address with label.
    &#39;&#39;&#39;
    self._assert_taint_enabled()
    self.plugins[&#34;taint2&#34;].taint2_label_ram(addr, label)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_label_reg"><code class="name flex">
<span>def <span class="ident">taint_label_reg</span></span>(<span>self, reg_num, label)</span>
</code></dt>
<dd>
<div class="desc"><p>Labels taint register reg_num with label.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_label_reg(self, reg_num, label):
    &#39;&#39;&#39;
    Labels taint register reg_num with label.
    &#39;&#39;&#39;
    self._assert_taint_enabled()
    for i in range(self.register_size):
        self.plugins[&#34;taint2&#34;].taint2_label_reg(reg_num, i, label)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_sym_branch_meta"><code class="name flex">
<span>def <span class="ident">taint_sym_branch_meta</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_sym_branch_meta(self):
    branch_meta_ptr_ffi = self.ffi.new(&#39;SymbolicBranchMeta **&#39;)
    n_ptr_ffi = self.ffi.new(&#39;uint32_t *&#39;, 0)

    self.plugins[&#39;taint2&#39;].taint2_sym_branch_meta(n_ptr_ffi, branch_meta_ptr_ffi)
    # Unpack size
    n = self.ffi.unpack(n_ptr_ffi, 1)[0]
    if n == 0:
        return []
    meta_ptr = self.ffi.unpack(branch_meta_ptr_ffi, 1)[0]
    metas_ffi = self.ffi.unpack(meta_ptr, n)
    # Meta only has a pc field now
    metas = [
        meta_ffi.pc
        for meta_ffi in metas_ffi
    ]
    return metas</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_sym_enable"><code class="name flex">
<span>def <span class="ident">taint_sym_enable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Inform python that taint is enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_sym_enable(self):
    &#34;&#34;&#34;
    Inform python that taint is enabled.
    &#34;&#34;&#34;
    if not self.taint_enabled():
        self.taint_enable()
        progress(&#34;taint symbolic not enabled -- enabling&#34;)
    self.plugins[&#34;taint2&#34;].taint2_enable_sym()</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_sym_label_ram"><code class="name flex">
<span>def <span class="ident">taint_sym_label_ram</span></span>(<span>self, addr, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_sym_label_ram(self, addr, label):
    self._assert_taint_sym_enabled()
    self.plugins[&#39;taint2&#39;].taint2_sym_label_ram(addr,label)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_sym_label_reg"><code class="name flex">
<span>def <span class="ident">taint_sym_label_reg</span></span>(<span>self, reg_num, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_sym_label_reg(self, reg_num, label):
    # label all bytes in this register.
    # or at least four of them
    # XXX label must increment by panda.register_size after the call
    self._assert_taint_sym_enabled()
    self.taint_sym_enable()
    for i in range(self.register_size):
        self.plugins[&#39;taint2&#39;].taint2_sym_label_reg(reg_num, i, label+i)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_sym_path_constraints"><code class="name flex">
<span>def <span class="ident">taint_sym_path_constraints</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_sym_path_constraints(self):
    # Prepare ptr for returned string
    str_ptr_ffi = self.ffi.new(&#39;char**&#39;)
    # Prepare ptr for string size
    n_ptr_ffi = self.ffi.new(&#39;uint32_t *&#39;, 0)

    self.plugins[&#39;taint2&#39;].taint2_sym_path_constraints(n_ptr_ffi, str_ptr_ffi)
    # Unpack size
    n = self.ffi.unpack(n_ptr_ffi, 1)[0]
    if n == 0:
        return []
    # Unpack cstr
    str_ptr = self.ffi.unpack(str_ptr_ffi, 1)[0]
    str_bs = self.ffi.unpack(str_ptr, n)
    expr_str = str(str_bs, &#39;utf-8&#39;)
    solver = self.string_to_solver(expr_str)
    return solver.assertions() if solver != None else []</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_sym_query_ram"><code class="name flex">
<span>def <span class="ident">taint_sym_query_ram</span></span>(<span>self, addr, size=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_sym_query_ram(self, addr, size=1):
    # Prepare ptr for returned string
    str_ptr_ffi = self.ffi.new(&#39;char**&#39;)
    # Prepare ptr for string size
    n_ptr_ffi = self.ffi.new(&#39;uint32_t *&#39;, 0)

    self.plugins[&#39;taint2&#39;].taint2_sym_query_ram(addr, size, n_ptr_ffi, str_ptr_ffi)
    # Unpack size
    n = self.ffi.unpack(n_ptr_ffi, 1)[0]
    if n == 0:
        return None
    # Unpack cstr
    str_ptr = self.ffi.unpack(str_ptr_ffi, 1)[0]
    str_bs = self.ffi.unpack(str_ptr, n)
    expr_str = str(str_bs, &#39;utf-8&#39;)
    return self.string_to_expr(expr_str)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.taint_sym_query_reg"><code class="name flex">
<span>def <span class="ident">taint_sym_query_reg</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_sym_query_reg(self, addr):
    # Prepare ptr for returned string
    str_ptr_ffi = self.ffi.new(&#39;char**&#39;)
    # Prepare ptr for string size
    n_ptr_ffi = self.ffi.new(&#39;uint32_t *&#39;, 0)

    self.plugins[&#39;taint2&#39;].taint2_sym_query_reg(addr, n_ptr_ffi, str_ptr_ffi)
    # Unpack size
    n = self.ffi.unpack(n_ptr_ffi, 1)[0]
    if n == 0:
        return None
    # Unpack cstr
    str_ptr = self.ffi.unpack(str_ptr_ffi, 1)[0]
    str_bs = self.ffi.unpack(str_ptr, n)
    expr_str = str(str_bs, &#39;utf-8&#39;)
    return self.string_to_expr(expr_str)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.to_unsigned_guest"><code class="name flex">
<span>def <span class="ident">to_unsigned_guest</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a singed python int to an unsigned int32/unsigned int64
depending on guest bit-size</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>Python integer</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Python integer representing x as an unsigned value in the guest's pointer-size.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_unsigned_guest(self, x):
    &#39;&#39;&#39;
    Convert a singed python int to an unsigned int32/unsigned int64
    depending on guest bit-size

    Args:
        x (int): Python integer

    Returns:
        int: Python integer representing x as an unsigned value in the guest&#39;s pointer-size.
    &#39;&#39;&#39;
    import ctypes
    if self.bits == 32:
        return ctypes.c_uint32(x).value
    elif self.bits == 64:
        return ctypes.c_uint64(x).value
    else:
        raise ValueError(&#34;Unsupported number of bits&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.type_serial_cmd"><code class="name flex">
<span>def <span class="ident">type_serial_cmd</span></span>(<span>self, cmd)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def type_serial_cmd(self, cmd):
    #Can send message into socket without guest running (no self.running.wait())
    if isinstance(cmd, str):
        cmd = cmd.encode(&#39;utf8&#39;)
    self.serial_console.send(cmd) # send, not sendline</code></pre>
</details>
</dd>
<dt id="pandare.Panda.unload_plugin"><code class="name flex">
<span>def <span class="ident">unload_plugin</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Unload plugin with given name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of plug</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unload_plugin(self, name):
    &#39;&#39;&#39;
    Unload plugin with given name.

    Args:
        name (str): Name of plug

    Returns:
        None
    &#39;&#39;&#39;
    if debug:
        progress (&#34;Unloading plugin %s&#34; % name),
    name_ffi = self.ffi.new(&#34;char[]&#34;, bytes(name,&#34;utf-8&#34;))
    self.libpanda.panda_unload_plugin_by_name(name_ffi)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.unload_plugins"><code class="name flex">
<span>def <span class="ident">unload_plugins</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable all python plugins and request to unload all c plugins
at the next main_loop_wait.</p>
<p>XXX: If called during shutdown/exit, c plugins won't be unloaded
because the next main_loop_wait will never happen. Instead, call
panda.panda_finish directly (which is done at the end of panda.run())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unload_plugins(self):
    &#39;&#39;&#39;
    Disable all python plugins and request to unload all c plugins
    at the next main_loop_wait.

    XXX: If called during shutdown/exit, c plugins won&#39;t be unloaded
    because the next main_loop_wait will never happen. Instead, call
    panda.panda_finish directly (which is done at the end of panda.run())
    &#39;&#39;&#39;
    if debug:
        progress (&#34;Disabling all python plugins, unloading all C plugins&#34;)

    # In next main loop wait, unload all python plugin
    self.queue_main_loop_wait_fn(self._unload_pyplugins)

    # Then unload C plugins. May be unsafe to do except from the top of the main loop (taint segfaults otherwise)
    self.queue_main_loop_wait_fn(self.libpanda.panda_unload_plugins)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.unregister_pyperipheral"><code class="name flex">
<span>def <span class="ident">unregister_pyperipheral</span></span>(<span>self, pyperiph)</span>
</code></dt>
<dd>
<div class="desc"><p>deregisters a python peripheral.
The pyperiph parameter can be either an object, or an address
Returns true if the pyperipheral was successfully removed, else false.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister_pyperipheral(self, pyperiph):
    &#34;&#34;&#34;
    deregisters a python peripheral.
    The pyperiph parameter can be either an object, or an address
    Returns true if the pyperipheral was successfully removed, else false.
    &#34;&#34;&#34;

    if isinstance(pyperiph, int) is True:
        pp = self._addr_to_pyperipheral(pyperiph)
        if pp is None:
            return False
    else:
        if pyperiph not in self.pyperipherals:
            return False
        pp = pyperiph

    self.pyperipherals.remove(pp)

    # If we dont have any pyperipherals left, unregister callbacks
    if len(self.pyperipherals) == 0:
        self.disable_callback(&#34;pyperipheral_read_callback&#34;, forever=True)
        self.disable_callback(&#34;pyperipheral_write_callback&#34;, forever=True)
        self.pyperipherals_registered_cb = False
    return True</code></pre>
</details>
</dd>
<dt id="pandare.Panda.virt_to_phys"><code class="name flex">
<span>def <span class="ident">virt_to_phys</span></span>(<span>self, cpu, addr)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert virtual address to physical address.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState struct</dd>
<dt><strong><code>addr</code></strong> :&ensp;<code>int</code></dt>
<dd>virtual address to convert</dd>
</dl>
<h2 id="return">Return</h2>
<p>int: physical address</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def virt_to_phys(self, cpu, addr):
    &#39;&#39;&#39;
    Convert virtual address to physical address.

    Args:
        cpu (CPUState): CPUState struct
        addr (int): virtual address to convert

    Return:
        int: physical address
    &#39;&#39;&#39;
    if &#34;osi_linux&#34; in self.plugins.keys() or self._plugin_loaded(&#34;osi_linux&#34;):
        return self.plugins[&#34;osi_linux&#34;].osi_linux_virt_to_phys(cpu, addr)
    else:
        return self.libpanda.panda_virt_to_phys_external(cpu, addr)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.virtual_memory_read"><code class="name flex">
<span>def <span class="ident">virtual_memory_read</span></span>(<span>self, cpu, addr, length, fmt='bytearray')</span>
</code></dt>
<dd>
<div class="desc"><p>Read guest virtual memory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
<dt><strong><code>addr</code></strong> :&ensp;<code>int</code></dt>
<dd>Address</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>length of data you would like returned</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>format for returned array. See <code>physical_memory_read</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[bytearray, int, str, list[int]]</code></dt>
<dd>memory data</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ValueError if memory access fails or fmt is unsupported</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def virtual_memory_read(self, cpu, addr, length, fmt=&#39;bytearray&#39;):
    &#39;&#39;&#39;
    Read guest virtual memory.

    Args:
        cpu (CPUState): CPUState structure
        addr (int): Address
        length (int): length of data you would like returned
        fmt: format for returned array. See `physical_memory_read`.

    Returns:
        Union[bytearray, int, str, list[int]]: memory data

    Raises:
        ValueError if memory access fails or fmt is unsupported
    &#39;&#39;&#39;

    return self._memory_read(cpu, addr, length, physical=False, fmt=fmt)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.virtual_memory_write"><code class="name flex">
<span>def <span class="ident">virtual_memory_write</span></span>(<span>self, cpu, addr, buf)</span>
</code></dt>
<dd>
<div class="desc"><p>Write guest virtual memory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>int</code></dt>
<dd>Address</dd>
<dt><strong><code>buf</code></strong> :&ensp;<code>bytestr</code></dt>
<dd>byte string to write into memory</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>ValueError if the call to panda.virtual_memory_write fails (e.g., if you pass a pointer to an unmapped page)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def virtual_memory_write(self, cpu, addr, buf):
    &#39;&#39;&#39;
    Write guest virtual memory.

    Args:
        cpu (CPUState): CPUState structure
        address (int): Address
        buf (bytestr): byte string to write into memory

    Returns:
        None

    Raises:
        ValueError if the call to panda.virtual_memory_write fails (e.g., if you pass a pointer to an unmapped page)
    &#39;&#39;&#39;
    self._memory_write(cpu, addr, buf, physical=False)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.vm_stop"><code class="name flex">
<span>def <span class="ident">vm_stop</span></span>(<span>self, code=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop execution, default code means RUN_STATE_PAUSED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vm_stop(self, code=4):
    &#39;&#39;&#39; Stop execution, default code means RUN_STATE_PAUSED &#39;&#39;&#39;
    self.libpanda.panda_stop(code)</code></pre>
</details>
</dd>
<dt id="pandare.Panda.was_aborted"><code class="name flex">
<span>def <span class="ident">was_aborted</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if panda was aborted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def was_aborted(self):
    &#39;&#39;&#39;
    Returns true if panda was aborted.
    &#39;&#39;&#39;
    return self.libpanda.panda_was_aborted()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandare.PyPlugin"><code class="flex name class">
<span>class <span class="ident">PyPlugin</span></span>
<span>(</span><span>panda)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class which PyPANDA plugins should inherit. Subclasses may
register callbacks using the provided panda object and use the
PyPlugin APIs:</p>
<ul>
<li>self.get_args or self.get_arg_bool to check argument values</li>
<li>self.ppp to interact with other PyPlugins via PPP interfaces</li>
<li>self.ppp_cb_boilerplate('cb_name') to register a ppp-style callback</li>
<li>self.ppp_run_cb('cb_name') to run a previously-registered ppp-style callback</li>
<li>@PyPlugin.ppp_export to mark a class method as ppp-exported</li>
</ul>
<p>For more information, check out the pyplugin documentation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PyPlugin:
    def __init__(self, panda):
        &#39;&#39;&#39;
        Base class which PyPANDA plugins should inherit. Subclasses may
        register callbacks using the provided panda object and use the
        PyPlugin APIs:

        * self.get_args or self.get_arg_bool to check argument values
        * self.ppp to interact with other PyPlugins via PPP interfaces
        * self.ppp_cb_boilerplate(&#39;cb_name&#39;) to register a ppp-style callback
        * self.ppp_run_cb(&#39;cb_name&#39;) to run a previously-registered ppp-style callback
        * @PyPlugin.ppp_export to mark a class method as ppp-exported

        For more information, check out the pyplugin documentation.
        &#39;&#39;&#39;

    # Parent init method which will be called prior to child __init__
    def __preinit__(self, pypluginmgr, args):
        self.ppp_cbs = {} # ppp callback name =&gt; _PPP instance which tracks registered cbs and runs them

        self.args = args
        self.pypluginmgr = pypluginmgr

    @property
    def ppp(self):
        # Why is this a property you ask? Because it makes it easier to set a docstring
        &#39;&#39;&#39;
        The .ppp property of the PyPlugin class is used for accessing PPP methods and callbacks
        exposed by other PyPlugins. (Under the hood, this is a refernece to the PyPluginManager.ppp
        property).

        Through self.ppp, you can reference another PyPlugin by name, e.g., if a previously-loaded plugin
        is named `Server`, from your plugin you can do `self.ppp.Server` to access PPP-exported methods.

        From there, you can run PPP-exported functions by name: `self.ppp.Server.some_exported_fn(*args)`.
        Or you can register a local class method a PPP-style callback provided by the other plugin:
            `self.ppp.server.ppp_reg_cb(&#39;some_provided_callback&#39;, self.some_local_method)`
        &#39;&#39;&#39;
        return self.pypluginmgr.ppp


    @staticmethod
    def ppp_export(method):
        &#39;&#39;&#39;
        Decorator to apply to a class method in a PyPlugin to indicate that other plugins should
        be allowed to call this function. Example:

            from pandare import PyPlugin
            Class Server(PyPlugin):
                def __init__(self, panda):
                    pass

                @PyPlugin.ppp_export
                def do_add(self, x):
                    return x+1

            Class Client(PyPlugin):
                def __init__(self, panda):
                    print(self.ppp.Server.do_add(1))
        &#39;&#39;&#39;
        @wraps(method)
        def f(*args, **kwargs):
            return method(*args, **kwargs)
        f.__is_pyplugin_ppp = True
        f.__original_method = method
        return f

    # Argument loading
    def get_arg(self, arg_name):
        &#39;&#39;&#39;
        Returns either the argument as a string or None if the argument
        wasn&#39;t passed (arguments passed in bool form (i.e., set but with no value)
        instead of key/value form will also return None).
        &#39;&#39;&#39;
        if arg_name in self.args:
            return self.args[arg_name]

        return None

    def get_arg_bool(self, arg_name):
        &#39;&#39;&#39;
        Returns True if the argument is set and has a truthy value
        &#39;&#39;&#39;

        if arg_name not in self.args:
            # Argument name unset - it&#39;s false
            return False

        arg_val = self.args[arg_name]
        if isinstance(arg_val, bool):
            # If it&#39;s a python bol already, just return it
            return arg_val

        if isinstance(arg_val, str):
            # string of true/y/1  is True
            return arg_val.lower() in [&#39;true&#39;, &#39;y&#39;, &#39;1&#39;]

        if isinstance(arg_val, int):
            # Nonzero is True
            return arg_val != 0

        # If it&#39;s not a string, int, or bool something is weird
        raise ValueError(f&#34;Unsupported arg type: {type(arg_val)}&#34;)

    # Callback definition / registration / use. Note these functions mirror the behavior of the macros used
    # in C plugin, check out docs/readme.md for additional details.

    def ppp_cb_boilerplate(self, cb_name):
        &#39;&#39;&#39;
        &#34;Define&#34; a PPP-style function in this plugin. Note that there is no type
        information because this is Python. Run via .ppp[cb_name].run(...)
        &#39;&#39;&#39;
        plugin_name = self.__class__.__name__

        if cb_name in self.ppp_cbs:
            raise ValueError(f&#34;PPP function {cb_name} is being redefined in {plugin_name}&#34;)

        # Add two callbacks into our PPP namesapce: fn_add and fn_run
        this_ppp_cb = _PPP_CB()
        self.ppp.add(self.__class__.__name__, &#34;ppp_reg_cb_&#34; + cb_name, this_ppp_cb.add_callback)
        self.ppp.add(self.__class__.__name__, &#34;ppp_run_cb_&#34; + cb_name, this_ppp_cb.run)

        # Make sure we have a helper self.ppp[class].ppp_reg_cb which just calls
        # the ppp_reg_[cb_name] we just saved
        try:
            getattr(getattr(self.ppp, self.__class__.__name__), &#34;ppp_reg_cb&#34;)
        except AttributeError:
            def _reg_cb(target_ppp, func):
                getattr(getattr(self.ppp,
                    self.__class__.__name__), &#34;ppp_reg_cb_&#34; + target_ppp)(func)
            self.ppp.add(self.__class__.__name__, &#34;ppp_reg_cb&#34;, _reg_cb)

    def ppp_run_cb(self, target_ppp, *args):
        &#39;&#39;&#39;
        Trigger a previously defind PPP-style callback named `target_ppp` in this plugin with `args`
        Any other pyplugins which have registered a function to run on this callback will be called with `args`.
        &#39;&#39;&#39;
        getattr(getattr(self.ppp, self.__class__.__name__), &#34;ppp_run_cb_&#34; + target_ppp)(*args)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pandare.extras.procTrace.ProcGraph" href="extras/procTrace.html#pandare.extras.procTrace.ProcGraph">ProcGraph</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pandare.PyPlugin.ppp_export"><code class="name flex">
<span>def <span class="ident">ppp_export</span></span>(<span>method)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to apply to a class method in a PyPlugin to indicate that other plugins should
be allowed to call this function. Example:</p>
<pre><code>from pandare import PyPlugin
Class Server(PyPlugin):
    def __init__(self, panda):
        pass

    @PyPlugin.ppp_export
    def do_add(self, x):
        return x+1

Class Client(PyPlugin):
    def __init__(self, panda):
        print(self.ppp.Server.do_add(1))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ppp_export(method):
    &#39;&#39;&#39;
    Decorator to apply to a class method in a PyPlugin to indicate that other plugins should
    be allowed to call this function. Example:

        from pandare import PyPlugin
        Class Server(PyPlugin):
            def __init__(self, panda):
                pass

            @PyPlugin.ppp_export
            def do_add(self, x):
                return x+1

        Class Client(PyPlugin):
            def __init__(self, panda):
                print(self.ppp.Server.do_add(1))
    &#39;&#39;&#39;
    @wraps(method)
    def f(*args, **kwargs):
        return method(*args, **kwargs)
    f.__is_pyplugin_ppp = True
    f.__original_method = method
    return f</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pandare.PyPlugin.ppp"><code class="name">var <span class="ident">ppp</span></code></dt>
<dd>
<div class="desc"><p>The .ppp property of the PyPlugin class is used for accessing PPP methods and callbacks
exposed by other PyPlugins. (Under the hood, this is a refernece to the PyPluginManager.ppp
property).</p>
<p>Through self.ppp, you can reference another PyPlugin by name, e.g., if a previously-loaded plugin
is named <code>Server</code>, from your plugin you can do <code>self.ppp.Server</code> to access PPP-exported methods.</p>
<p>From there, you can run PPP-exported functions by name: <code>self.ppp.Server.some_exported_fn(*args)</code>.
Or you can register a local class method a PPP-style callback provided by the other plugin:
<code>self.ppp.server.ppp_reg_cb('some_provided_callback', self.some_local_method)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ppp(self):
    # Why is this a property you ask? Because it makes it easier to set a docstring
    &#39;&#39;&#39;
    The .ppp property of the PyPlugin class is used for accessing PPP methods and callbacks
    exposed by other PyPlugins. (Under the hood, this is a refernece to the PyPluginManager.ppp
    property).

    Through self.ppp, you can reference another PyPlugin by name, e.g., if a previously-loaded plugin
    is named `Server`, from your plugin you can do `self.ppp.Server` to access PPP-exported methods.

    From there, you can run PPP-exported functions by name: `self.ppp.Server.some_exported_fn(*args)`.
    Or you can register a local class method a PPP-style callback provided by the other plugin:
        `self.ppp.server.ppp_reg_cb(&#39;some_provided_callback&#39;, self.some_local_method)`
    &#39;&#39;&#39;
    return self.pypluginmgr.ppp</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pandare.PyPlugin.get_arg"><code class="name flex">
<span>def <span class="ident">get_arg</span></span>(<span>self, arg_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns either the argument as a string or None if the argument
wasn't passed (arguments passed in bool form (i.e., set but with no value)
instead of key/value form will also return None).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_arg(self, arg_name):
    &#39;&#39;&#39;
    Returns either the argument as a string or None if the argument
    wasn&#39;t passed (arguments passed in bool form (i.e., set but with no value)
    instead of key/value form will also return None).
    &#39;&#39;&#39;
    if arg_name in self.args:
        return self.args[arg_name]

    return None</code></pre>
</details>
</dd>
<dt id="pandare.PyPlugin.get_arg_bool"><code class="name flex">
<span>def <span class="ident">get_arg_bool</span></span>(<span>self, arg_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the argument is set and has a truthy value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_arg_bool(self, arg_name):
    &#39;&#39;&#39;
    Returns True if the argument is set and has a truthy value
    &#39;&#39;&#39;

    if arg_name not in self.args:
        # Argument name unset - it&#39;s false
        return False

    arg_val = self.args[arg_name]
    if isinstance(arg_val, bool):
        # If it&#39;s a python bol already, just return it
        return arg_val

    if isinstance(arg_val, str):
        # string of true/y/1  is True
        return arg_val.lower() in [&#39;true&#39;, &#39;y&#39;, &#39;1&#39;]

    if isinstance(arg_val, int):
        # Nonzero is True
        return arg_val != 0

    # If it&#39;s not a string, int, or bool something is weird
    raise ValueError(f&#34;Unsupported arg type: {type(arg_val)}&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.PyPlugin.ppp_cb_boilerplate"><code class="name flex">
<span>def <span class="ident">ppp_cb_boilerplate</span></span>(<span>self, cb_name)</span>
</code></dt>
<dd>
<div class="desc"><p>"Define" a PPP-style function in this plugin. Note that there is no type
information because this is Python. Run via .ppp[cb_name].run(&hellip;)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ppp_cb_boilerplate(self, cb_name):
    &#39;&#39;&#39;
    &#34;Define&#34; a PPP-style function in this plugin. Note that there is no type
    information because this is Python. Run via .ppp[cb_name].run(...)
    &#39;&#39;&#39;
    plugin_name = self.__class__.__name__

    if cb_name in self.ppp_cbs:
        raise ValueError(f&#34;PPP function {cb_name} is being redefined in {plugin_name}&#34;)

    # Add two callbacks into our PPP namesapce: fn_add and fn_run
    this_ppp_cb = _PPP_CB()
    self.ppp.add(self.__class__.__name__, &#34;ppp_reg_cb_&#34; + cb_name, this_ppp_cb.add_callback)
    self.ppp.add(self.__class__.__name__, &#34;ppp_run_cb_&#34; + cb_name, this_ppp_cb.run)

    # Make sure we have a helper self.ppp[class].ppp_reg_cb which just calls
    # the ppp_reg_[cb_name] we just saved
    try:
        getattr(getattr(self.ppp, self.__class__.__name__), &#34;ppp_reg_cb&#34;)
    except AttributeError:
        def _reg_cb(target_ppp, func):
            getattr(getattr(self.ppp,
                self.__class__.__name__), &#34;ppp_reg_cb_&#34; + target_ppp)(func)
        self.ppp.add(self.__class__.__name__, &#34;ppp_reg_cb&#34;, _reg_cb)</code></pre>
</details>
</dd>
<dt id="pandare.PyPlugin.ppp_run_cb"><code class="name flex">
<span>def <span class="ident">ppp_run_cb</span></span>(<span>self, target_ppp, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Trigger a previously defind PPP-style callback named <code>target_ppp</code> in this plugin with <code>args</code>
Any other pyplugins which have registered a function to run on this callback will be called with <code>args</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ppp_run_cb(self, target_ppp, *args):
    &#39;&#39;&#39;
    Trigger a previously defind PPP-style callback named `target_ppp` in this plugin with `args`
    Any other pyplugins which have registered a function to run on this callback will be called with `args`.
    &#39;&#39;&#39;
    getattr(getattr(self.ppp, self.__class__.__name__), &#34;ppp_run_cb_&#34; + target_ppp)(*args)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="panda.re Docs" href="/">
<img src="//panda.re/img/logo.png" alt="logo"> PANDA.re Docs
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#pypanda">PyPANDA</a><ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#example-program">Example program</a></li>
</ul>
</li>
<li><a href="#usage">Usage</a><ul>
<li><a href="#create-an-instance-of-panda">Create an instance of Panda</a></li>
<li><a href="#register-a-callback">Register a callback</a></li>
<li><a href="#enable-and-disable-callbacks">Enable and disable callbacks</a></li>
<li><a href="#replaying-recordings">Replaying Recordings</a></li>
<li><a href="#load-and-unload-a-c-plugin">Load and unload a C plugin</a></li>
<li><a href="#asynchronous-activity">Asynchronous Activity</a></li>
<li><a href="#recordings">Recordings</a></li>
</ul>
</li>
<li><a href="#typical-use-patterns">Typical Use Patterns</a><ul>
<li><a href="#live-system">Live system</a></li>
<li><a href="#recordreplay">Record/Replay</a></li>
</ul>
</li>
<li><a href="#additional-information">Additional Information</a><ul>
<li><a href="#here-be-dragons">Here be dragons</a></li>
<li><a href="#extending-pypanda">Extending PyPANDA</a></li>
<li><a href="#learn-more">Learn more</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pandare.arch" href="arch.html">pandare.arch</a></code></li>
<li><code><a title="pandare.cosi" href="cosi.html">pandare.cosi</a></code></li>
<li><code><a title="pandare.extras" href="extras/index.html">pandare.extras</a></code></li>
<li><code><a title="pandare.panda" href="panda.html">pandare.panda</a></code></li>
<li><code><a title="pandare.panda_expect" href="panda_expect.html">pandare.panda_expect</a></code></li>
<li><code><a title="pandare.plog_reader" href="plog_reader.html">pandare.plog_reader</a></code></li>
<li><code><a title="pandare.pyplugin" href="pyplugin.html">pandare.pyplugin</a></code></li>
<li><code><a title="pandare.pypluginmanager" href="pypluginmanager.html">pandare.pypluginmanager</a></code></li>
<li><code><a title="pandare.qcows" href="qcows.html">pandare.qcows</a></code></li>
<li><code><a title="pandare.qcows_internal" href="qcows_internal.html">pandare.qcows_internal</a></code></li>
<li><code><a title="pandare.qemu_logging" href="qemu_logging.html">pandare.qemu_logging</a></code></li>
<li><code><a title="pandare.taint" href="taint/index.html">pandare.taint</a></code></li>
<li><code><a title="pandare.utils" href="utils.html">pandare.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pandare.Callbacks" href="#pandare.Callbacks">Callbacks</a></code></h4>
<ul class="">
<li><code><a title="pandare.Callbacks.@panda.cb_after_block_exec" href="#pandare.Callbacks.@panda.cb_after_block_exec">@panda.cb_after_block_exec</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_after_block_translate" href="#pandare.Callbacks.@panda.cb_after_block_translate">@panda.cb_after_block_translate</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_after_cpu_exec_enter" href="#pandare.Callbacks.@panda.cb_after_cpu_exec_enter">@panda.cb_after_cpu_exec_enter</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_after_insn_exec" href="#pandare.Callbacks.@panda.cb_after_insn_exec">@panda.cb_after_insn_exec</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_after_insn_translate" href="#pandare.Callbacks.@panda.cb_after_insn_translate">@panda.cb_after_insn_translate</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_after_loadvm" href="#pandare.Callbacks.@panda.cb_after_loadvm">@panda.cb_after_loadvm</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_after_machine_init" href="#pandare.Callbacks.@panda.cb_after_machine_init">@panda.cb_after_machine_init</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_asid_changed" href="#pandare.Callbacks.@panda.cb_asid_changed">@panda.cb_asid_changed</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_before_block_exec" href="#pandare.Callbacks.@panda.cb_before_block_exec">@panda.cb_before_block_exec</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_before_block_exec_invalidate_opt" href="#pandare.Callbacks.@panda.cb_before_block_exec_invalidate_opt">@panda.cb_before_block_exec_invalidate_opt</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_before_block_translate" href="#pandare.Callbacks.@panda.cb_before_block_translate">@panda.cb_before_block_translate</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_before_cpu_exec_exit" href="#pandare.Callbacks.@panda.cb_before_cpu_exec_exit">@panda.cb_before_cpu_exec_exit</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_before_handle_exception" href="#pandare.Callbacks.@panda.cb_before_handle_exception">@panda.cb_before_handle_exception</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_before_handle_interrupt" href="#pandare.Callbacks.@panda.cb_before_handle_interrupt">@panda.cb_before_handle_interrupt</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_before_loadvm" href="#pandare.Callbacks.@panda.cb_before_loadvm">@panda.cb_before_loadvm</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_before_tcg_codegen" href="#pandare.Callbacks.@panda.cb_before_tcg_codegen">@panda.cb_before_tcg_codegen</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_cpu_restore_state" href="#pandare.Callbacks.@panda.cb_cpu_restore_state">@panda.cb_cpu_restore_state</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_during_machine_init" href="#pandare.Callbacks.@panda.cb_during_machine_init">@panda.cb_during_machine_init</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_end_block_exec" href="#pandare.Callbacks.@panda.cb_end_block_exec">@panda.cb_end_block_exec</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_guest_hypercall" href="#pandare.Callbacks.@panda.cb_guest_hypercall">@panda.cb_guest_hypercall</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_hd_read" href="#pandare.Callbacks.@panda.cb_hd_read">@panda.cb_hd_read</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_hd_write" href="#pandare.Callbacks.@panda.cb_hd_write">@panda.cb_hd_write</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_insn_exec" href="#pandare.Callbacks.@panda.cb_insn_exec">@panda.cb_insn_exec</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_insn_translate" href="#pandare.Callbacks.@panda.cb_insn_translate">@panda.cb_insn_translate</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_main_loop_wait" href="#pandare.Callbacks.@panda.cb_main_loop_wait">@panda.cb_main_loop_wait</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_mmio_after_read" href="#pandare.Callbacks.@panda.cb_mmio_after_read">@panda.cb_mmio_after_read</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_mmio_before_write" href="#pandare.Callbacks.@panda.cb_mmio_before_write">@panda.cb_mmio_before_write</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_monitor" href="#pandare.Callbacks.@panda.cb_monitor">@panda.cb_monitor</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_phys_mem_after_read" href="#pandare.Callbacks.@panda.cb_phys_mem_after_read">@panda.cb_phys_mem_after_read</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_phys_mem_after_write" href="#pandare.Callbacks.@panda.cb_phys_mem_after_write">@panda.cb_phys_mem_after_write</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_phys_mem_before_read" href="#pandare.Callbacks.@panda.cb_phys_mem_before_read">@panda.cb_phys_mem_before_read</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_phys_mem_before_write" href="#pandare.Callbacks.@panda.cb_phys_mem_before_write">@panda.cb_phys_mem_before_write</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_pre_shutdown" href="#pandare.Callbacks.@panda.cb_pre_shutdown">@panda.cb_pre_shutdown</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_qmp" href="#pandare.Callbacks.@panda.cb_qmp">@panda.cb_qmp</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_after_dma" href="#pandare.Callbacks.@panda.cb_replay_after_dma">@panda.cb_replay_after_dma</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_before_dma" href="#pandare.Callbacks.@panda.cb_replay_before_dma">@panda.cb_replay_before_dma</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_handle_packet" href="#pandare.Callbacks.@panda.cb_replay_handle_packet">@panda.cb_replay_handle_packet</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_hd_transfer" href="#pandare.Callbacks.@panda.cb_replay_hd_transfer">@panda.cb_replay_hd_transfer</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_net_transfer" href="#pandare.Callbacks.@panda.cb_replay_net_transfer">@panda.cb_replay_net_transfer</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_serial_read" href="#pandare.Callbacks.@panda.cb_replay_serial_read">@panda.cb_replay_serial_read</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_serial_receive" href="#pandare.Callbacks.@panda.cb_replay_serial_receive">@panda.cb_replay_serial_receive</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_serial_send" href="#pandare.Callbacks.@panda.cb_replay_serial_send">@panda.cb_replay_serial_send</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_serial_write" href="#pandare.Callbacks.@panda.cb_replay_serial_write">@panda.cb_replay_serial_write</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_start_block_exec" href="#pandare.Callbacks.@panda.cb_start_block_exec">@panda.cb_start_block_exec</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_top_loop" href="#pandare.Callbacks.@panda.cb_top_loop">@panda.cb_top_loop</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_unassigned_io_read" href="#pandare.Callbacks.@panda.cb_unassigned_io_read">@panda.cb_unassigned_io_read</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_unassigned_io_write" href="#pandare.Callbacks.@panda.cb_unassigned_io_write">@panda.cb_unassigned_io_write</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_virt_mem_after_read" href="#pandare.Callbacks.@panda.cb_virt_mem_after_read">@panda.cb_virt_mem_after_read</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_virt_mem_after_write" href="#pandare.Callbacks.@panda.cb_virt_mem_after_write">@panda.cb_virt_mem_after_write</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_virt_mem_before_read" href="#pandare.Callbacks.@panda.cb_virt_mem_before_read">@panda.cb_virt_mem_before_read</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_virt_mem_before_write" href="#pandare.Callbacks.@panda.cb_virt_mem_before_write">@panda.cb_virt_mem_before_write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.PLogReader" href="#pandare.PLogReader">PLogReader</a></code></h4>
</li>
<li>
<h4><code><a title="pandare.Panda" href="#pandare.Panda">Panda</a></code></h4>
<ul class="">
<li><code><a title="pandare.Panda.address_to_ram_offset" href="#pandare.Panda.address_to_ram_offset">address_to_ram_offset</a></code></li>
<li><code><a title="pandare.Panda.arch" href="#pandare.Panda.arch">arch</a></code></li>
<li><code><a title="pandare.Panda.arm_load_kernel" href="#pandare.Panda.arm_load_kernel">arm_load_kernel</a></code></li>
<li><code><a title="pandare.Panda.break_exec" href="#pandare.Panda.break_exec">break_exec</a></code></li>
<li><code><a title="pandare.Panda.callstack_callers" href="#pandare.Panda.callstack_callers">callstack_callers</a></code></li>
<li><code><a title="pandare.Panda.cleanup" href="#pandare.Panda.cleanup">cleanup</a></code></li>
<li><code><a title="pandare.Panda.clear_breakpoint" href="#pandare.Panda.clear_breakpoint">clear_breakpoint</a></code></li>
<li><code><a title="pandare.Panda.cont" href="#pandare.Panda.cont">cont</a></code></li>
<li><code><a title="pandare.Panda.copy_to_guest" href="#pandare.Panda.copy_to_guest">copy_to_guest</a></code></li>
<li><code><a title="pandare.Panda.cpu_class_by_name" href="#pandare.Panda.cpu_class_by_name">cpu_class_by_name</a></code></li>
<li><code><a title="pandare.Panda.create_external_gic" href="#pandare.Panda.create_external_gic">create_external_gic</a></code></li>
<li><code><a title="pandare.Panda.create_internal_gic" href="#pandare.Panda.create_internal_gic">create_internal_gic</a></code></li>
<li><code><a title="pandare.Panda.create_one_flash" href="#pandare.Panda.create_one_flash">create_one_flash</a></code></li>
<li><code><a title="pandare.Panda.create_virtio_devices" href="#pandare.Panda.create_virtio_devices">create_virtio_devices</a></code></li>
<li><code><a title="pandare.Panda.current_asid" href="#pandare.Panda.current_asid">current_asid</a></code></li>
<li><code><a title="pandare.Panda.current_pc" href="#pandare.Panda.current_pc">current_pc</a></code></li>
<li><code><a title="pandare.Panda.current_sp" href="#pandare.Panda.current_sp">current_sp</a></code></li>
<li><code><a title="pandare.Panda.delete_callback" href="#pandare.Panda.delete_callback">delete_callback</a></code></li>
<li><code><a title="pandare.Panda.delete_callbacks" href="#pandare.Panda.delete_callbacks">delete_callbacks</a></code></li>
<li><code><a title="pandare.Panda.delvm" href="#pandare.Panda.delvm">delvm</a></code></li>
<li><code><a title="pandare.Panda.delvm_sync" href="#pandare.Panda.delvm_sync">delvm_sync</a></code></li>
<li><code><a title="pandare.Panda.disable_callback" href="#pandare.Panda.disable_callback">disable_callback</a></code></li>
<li><code><a title="pandare.Panda.disable_hook2" href="#pandare.Panda.disable_hook2">disable_hook2</a></code></li>
<li><code><a title="pandare.Panda.disable_hypercall" href="#pandare.Panda.disable_hypercall">disable_hypercall</a></code></li>
<li><code><a title="pandare.Panda.disable_llvm" href="#pandare.Panda.disable_llvm">disable_llvm</a></code></li>
<li><code><a title="pandare.Panda.disable_llvm_helpers" href="#pandare.Panda.disable_llvm_helpers">disable_llvm_helpers</a></code></li>
<li><code><a title="pandare.Panda.disable_memcb" href="#pandare.Panda.disable_memcb">disable_memcb</a></code></li>
<li><code><a title="pandare.Panda.disable_plugin" href="#pandare.Panda.disable_plugin">disable_plugin</a></code></li>
<li><code><a title="pandare.Panda.disable_ppp" href="#pandare.Panda.disable_ppp">disable_ppp</a></code></li>
<li><code><a title="pandare.Panda.disable_precise_pc" href="#pandare.Panda.disable_precise_pc">disable_precise_pc</a></code></li>
<li><code><a title="pandare.Panda.disable_tb_chaining" href="#pandare.Panda.disable_tb_chaining">disable_tb_chaining</a></code></li>
<li><code><a title="pandare.Panda.disas2" href="#pandare.Panda.disas2">disas2</a></code></li>
<li><code><a title="pandare.Panda.do_panda_finish" href="#pandare.Panda.do_panda_finish">do_panda_finish</a></code></li>
<li><code><a title="pandare.Panda.drive_get" href="#pandare.Panda.drive_get">drive_get</a></code></li>
<li><code><a title="pandare.Panda.enable_all_callbacks" href="#pandare.Panda.enable_all_callbacks">enable_all_callbacks</a></code></li>
<li><code><a title="pandare.Panda.enable_callback" href="#pandare.Panda.enable_callback">enable_callback</a></code></li>
<li><code><a title="pandare.Panda.enable_hook2" href="#pandare.Panda.enable_hook2">enable_hook2</a></code></li>
<li><code><a title="pandare.Panda.enable_internal_callbacks" href="#pandare.Panda.enable_internal_callbacks">enable_internal_callbacks</a></code></li>
<li><code><a title="pandare.Panda.enable_llvm" href="#pandare.Panda.enable_llvm">enable_llvm</a></code></li>
<li><code><a title="pandare.Panda.enable_llvm_helpers" href="#pandare.Panda.enable_llvm_helpers">enable_llvm_helpers</a></code></li>
<li><code><a title="pandare.Panda.enable_memcb" href="#pandare.Panda.enable_memcb">enable_memcb</a></code></li>
<li><code><a title="pandare.Panda.enable_plugin" href="#pandare.Panda.enable_plugin">enable_plugin</a></code></li>
<li><code><a title="pandare.Panda.enable_precise_pc" href="#pandare.Panda.enable_precise_pc">enable_precise_pc</a></code></li>
<li><code><a title="pandare.Panda.enable_tb_chaining" href="#pandare.Panda.enable_tb_chaining">enable_tb_chaining</a></code></li>
<li><code><a title="pandare.Panda.end_analysis" href="#pandare.Panda.end_analysis">end_analysis</a></code></li>
<li><code><a title="pandare.Panda.end_record" href="#pandare.Panda.end_record">end_record</a></code></li>
<li><code><a title="pandare.Panda.end_replay" href="#pandare.Panda.end_replay">end_replay</a></code></li>
<li><code><a title="pandare.Panda.error_report" href="#pandare.Panda.error_report">error_report</a></code></li>
<li><code><a title="pandare.Panda.exit_cpu_loop" href="#pandare.Panda.exit_cpu_loop">exit_cpu_loop</a></code></li>
<li><code><a title="pandare.Panda.finish_serial_cmd" href="#pandare.Panda.finish_serial_cmd">finish_serial_cmd</a></code></li>
<li><code><a title="pandare.Panda.flush_tb" href="#pandare.Panda.flush_tb">flush_tb</a></code></li>
<li><code><a title="pandare.Panda.from_unsigned_guest" href="#pandare.Panda.from_unsigned_guest">from_unsigned_guest</a></code></li>
<li><code><a title="pandare.Panda.g_malloc0" href="#pandare.Panda.g_malloc0">g_malloc0</a></code></li>
<li><code><a title="pandare.Panda.garray_len" href="#pandare.Panda.garray_len">garray_len</a></code></li>
<li><code><a title="pandare.Panda.get_best_matching_symbol" href="#pandare.Panda.get_best_matching_symbol">get_best_matching_symbol</a></code></li>
<li><code><a title="pandare.Panda.get_build_dir" href="#pandare.Panda.get_build_dir">get_build_dir</a></code></li>
<li><code><a title="pandare.Panda.get_cpu" href="#pandare.Panda.get_cpu">get_cpu</a></code></li>
<li><code><a title="pandare.Panda.get_current_process" href="#pandare.Panda.get_current_process">get_current_process</a></code></li>
<li><code><a title="pandare.Panda.get_file_name" href="#pandare.Panda.get_file_name">get_file_name</a></code></li>
<li><code><a title="pandare.Panda.get_id" href="#pandare.Panda.get_id">get_id</a></code></li>
<li><code><a title="pandare.Panda.get_mapping_by_addr" href="#pandare.Panda.get_mapping_by_addr">get_mapping_by_addr</a></code></li>
<li><code><a title="pandare.Panda.get_mappings" href="#pandare.Panda.get_mappings">get_mappings</a></code></li>
<li><code><a title="pandare.Panda.get_os_family" href="#pandare.Panda.get_os_family">get_os_family</a></code></li>
<li><code><a title="pandare.Panda.get_plugin_path" href="#pandare.Panda.get_plugin_path">get_plugin_path</a></code></li>
<li><code><a title="pandare.Panda.get_process_name" href="#pandare.Panda.get_process_name">get_process_name</a></code></li>
<li><code><a title="pandare.Panda.get_processes" href="#pandare.Panda.get_processes">get_processes</a></code></li>
<li><code><a title="pandare.Panda.get_processes_dict" href="#pandare.Panda.get_processes_dict">get_processes_dict</a></code></li>
<li><code><a title="pandare.Panda.get_system_memory" href="#pandare.Panda.get_system_memory">get_system_memory</a></code></li>
<li><code><a title="pandare.Panda.get_volatility_symbols" href="#pandare.Panda.get_volatility_symbols">get_volatility_symbols</a></code></li>
<li><code><a title="pandare.Panda.hook" href="#pandare.Panda.hook">hook</a></code></li>
<li><code><a title="pandare.Panda.hook2" href="#pandare.Panda.hook2">hook2</a></code></li>
<li><code><a title="pandare.Panda.hook2_single_insn" href="#pandare.Panda.hook2_single_insn">hook2_single_insn</a></code></li>
<li><code><a title="pandare.Panda.hook_mem" href="#pandare.Panda.hook_mem">hook_mem</a></code></li>
<li><code><a title="pandare.Panda.hook_phys_mem_read" href="#pandare.Panda.hook_phys_mem_read">hook_phys_mem_read</a></code></li>
<li><code><a title="pandare.Panda.hook_phys_mem_write" href="#pandare.Panda.hook_phys_mem_write">hook_phys_mem_write</a></code></li>
<li><code><a title="pandare.Panda.hook_symbol" href="#pandare.Panda.hook_symbol">hook_symbol</a></code></li>
<li><code><a title="pandare.Panda.hook_symbol_resolution" href="#pandare.Panda.hook_symbol_resolution">hook_symbol_resolution</a></code></li>
<li><code><a title="pandare.Panda.hook_virt_mem_read" href="#pandare.Panda.hook_virt_mem_read">hook_virt_mem_read</a></code></li>
<li><code><a title="pandare.Panda.hook_virt_mem_write" href="#pandare.Panda.hook_virt_mem_write">hook_virt_mem_write</a></code></li>
<li><code><a title="pandare.Panda.hypercall" href="#pandare.Panda.hypercall">hypercall</a></code></li>
<li><code><a title="pandare.Panda.in_kernel" href="#pandare.Panda.in_kernel">in_kernel</a></code></li>
<li><code><a title="pandare.Panda.in_kernel_code_linux" href="#pandare.Panda.in_kernel_code_linux">in_kernel_code_linux</a></code></li>
<li><code><a title="pandare.Panda.in_kernel_mode" href="#pandare.Panda.in_kernel_mode">in_kernel_mode</a></code></li>
<li><code><a title="pandare.Panda.interact" href="#pandare.Panda.interact">interact</a></code></li>
<li><code><a title="pandare.Panda.is_callback_enabled" href="#pandare.Panda.is_callback_enabled">is_callback_enabled</a></code></li>
<li><code><a title="pandare.Panda.load_plugin" href="#pandare.Panda.load_plugin">load_plugin</a></code></li>
<li><code><a title="pandare.Panda.lookup_gic" href="#pandare.Panda.lookup_gic">lookup_gic</a></code></li>
<li><code><a title="pandare.Panda.make_panda_file_handler" href="#pandare.Panda.make_panda_file_handler">make_panda_file_handler</a></code></li>
<li><code><a title="pandare.Panda.map_memory" href="#pandare.Panda.map_memory">map_memory</a></code></li>
<li><code><a title="pandare.Panda.memory_region_add_subregion" href="#pandare.Panda.memory_region_add_subregion">memory_region_add_subregion</a></code></li>
<li><code><a title="pandare.Panda.memory_region_allocate_system_memory" href="#pandare.Panda.memory_region_allocate_system_memory">memory_region_allocate_system_memory</a></code></li>
<li><code><a title="pandare.Panda.memory_region_init_ram_from_file" href="#pandare.Panda.memory_region_init_ram_from_file">memory_region_init_ram_from_file</a></code></li>
<li><code><a title="pandare.Panda.memsavep" href="#pandare.Panda.memsavep">memsavep</a></code></li>
<li><code><a title="pandare.Panda.object_class_by_name" href="#pandare.Panda.object_class_by_name">object_class_by_name</a></code></li>
<li><code><a title="pandare.Panda.object_class_get_name" href="#pandare.Panda.object_class_get_name">object_class_get_name</a></code></li>
<li><code><a title="pandare.Panda.object_new" href="#pandare.Panda.object_new">object_new</a></code></li>
<li><code><a title="pandare.Panda.object_property_find" href="#pandare.Panda.object_property_find">object_property_find</a></code></li>
<li><code><a title="pandare.Panda.object_property_get_bool" href="#pandare.Panda.object_property_get_bool">object_property_get_bool</a></code></li>
<li><code><a title="pandare.Panda.object_property_get_int" href="#pandare.Panda.object_property_get_int">object_property_get_int</a></code></li>
<li><code><a title="pandare.Panda.object_property_get_link" href="#pandare.Panda.object_property_get_link">object_property_get_link</a></code></li>
<li><code><a title="pandare.Panda.object_property_set_bool" href="#pandare.Panda.object_property_set_bool">object_property_set_bool</a></code></li>
<li><code><a title="pandare.Panda.object_property_set_int" href="#pandare.Panda.object_property_set_int">object_property_set_int</a></code></li>
<li><code><a title="pandare.Panda.object_property_set_link" href="#pandare.Panda.object_property_set_link">object_property_set_link</a></code></li>
<li><code><a title="pandare.Panda.panda_finish" href="#pandare.Panda.panda_finish">panda_finish</a></code></li>
<li><code><a title="pandare.Panda.physical_memory_read" href="#pandare.Panda.physical_memory_read">physical_memory_read</a></code></li>
<li><code><a title="pandare.Panda.physical_memory_write" href="#pandare.Panda.physical_memory_write">physical_memory_write</a></code></li>
<li><code><a title="pandare.Panda.ppp" href="#pandare.Panda.ppp">ppp</a></code></li>
<li><code><a title="pandare.Panda.pyperiph_read_cb" href="#pandare.Panda.pyperiph_read_cb">pyperiph_read_cb</a></code></li>
<li><code><a title="pandare.Panda.pyperiph_write_cb" href="#pandare.Panda.pyperiph_write_cb">pyperiph_write_cb</a></code></li>
<li><code><a title="pandare.Panda.pyplugins" href="#pandare.Panda.pyplugins">pyplugins</a></code></li>
<li><code><a title="pandare.Panda.queue_async" href="#pandare.Panda.queue_async">queue_async</a></code></li>
<li><code><a title="pandare.Panda.queue_blocking" href="#pandare.Panda.queue_blocking">queue_blocking</a></code></li>
<li><code><a title="pandare.Panda.queue_main_loop_wait_fn" href="#pandare.Panda.queue_main_loop_wait_fn">queue_main_loop_wait_fn</a></code></li>
<li><code><a title="pandare.Panda.read_str" href="#pandare.Panda.read_str">read_str</a></code></li>
<li><code><a title="pandare.Panda.record" href="#pandare.Panda.record">record</a></code></li>
<li><code><a title="pandare.Panda.record_cmd" href="#pandare.Panda.record_cmd">record_cmd</a></code></li>
<li><code><a title="pandare.Panda.recording_exists" href="#pandare.Panda.recording_exists">recording_exists</a></code></li>
<li><code><a title="pandare.Panda.register_callback" href="#pandare.Panda.register_callback">register_callback</a></code></li>
<li><code><a title="pandare.Panda.register_cb_decorators" href="#pandare.Panda.register_cb_decorators">register_cb_decorators</a></code></li>
<li><code><a title="pandare.Panda.register_pyperipheral" href="#pandare.Panda.register_pyperipheral">register_pyperipheral</a></code></li>
<li><code><a title="pandare.Panda.require" href="#pandare.Panda.require">require</a></code></li>
<li><code><a title="pandare.Panda.reset" href="#pandare.Panda.reset">reset</a></code></li>
<li><code><a title="pandare.Panda.revert_async" href="#pandare.Panda.revert_async">revert_async</a></code></li>
<li><code><a title="pandare.Panda.revert_sync" href="#pandare.Panda.revert_sync">revert_sync</a></code></li>
<li><code><a title="pandare.Panda.rr_get_guest_instr_count" href="#pandare.Panda.rr_get_guest_instr_count">rr_get_guest_instr_count</a></code></li>
<li><code><a title="pandare.Panda.run" href="#pandare.Panda.run">run</a></code></li>
<li><code><a title="pandare.Panda.run_monitor_cmd" href="#pandare.Panda.run_monitor_cmd">run_monitor_cmd</a></code></li>
<li><code><a title="pandare.Panda.run_replay" href="#pandare.Panda.run_replay">run_replay</a></code></li>
<li><code><a title="pandare.Panda.run_serial_cmd" href="#pandare.Panda.run_serial_cmd">run_serial_cmd</a></code></li>
<li><code><a title="pandare.Panda.run_serial_cmd_async" href="#pandare.Panda.run_serial_cmd_async">run_serial_cmd_async</a></code></li>
<li><code><a title="pandare.Panda.run_volatility" href="#pandare.Panda.run_volatility">run_volatility</a></code></li>
<li><code><a title="pandare.Panda.serial_read_until" href="#pandare.Panda.serial_read_until">serial_read_until</a></code></li>
<li><code><a title="pandare.Panda.set_breakpoint" href="#pandare.Panda.set_breakpoint">set_breakpoint</a></code></li>
<li><code><a title="pandare.Panda.set_os_name" href="#pandare.Panda.set_os_name">set_os_name</a></code></li>
<li><code><a title="pandare.Panda.set_pandalog" href="#pandare.Panda.set_pandalog">set_pandalog</a></code></li>
<li><code><a title="pandare.Panda.snap" href="#pandare.Panda.snap">snap</a></code></li>
<li><code><a title="pandare.Panda.stop_run" href="#pandare.Panda.stop_run">stop_run</a></code></li>
<li><code><a title="pandare.Panda.string_to_condition" href="#pandare.Panda.string_to_condition">string_to_condition</a></code></li>
<li><code><a title="pandare.Panda.string_to_expr" href="#pandare.Panda.string_to_expr">string_to_expr</a></code></li>
<li><code><a title="pandare.Panda.string_to_solver" href="#pandare.Panda.string_to_solver">string_to_solver</a></code></li>
<li><code><a title="pandare.Panda.sysbus_create_varargs" href="#pandare.Panda.sysbus_create_varargs">sysbus_create_varargs</a></code></li>
<li><code><a title="pandare.Panda.taint_check_laddr" href="#pandare.Panda.taint_check_laddr">taint_check_laddr</a></code></li>
<li><code><a title="pandare.Panda.taint_check_ram" href="#pandare.Panda.taint_check_ram">taint_check_ram</a></code></li>
<li><code><a title="pandare.Panda.taint_check_reg" href="#pandare.Panda.taint_check_reg">taint_check_reg</a></code></li>
<li><code><a title="pandare.Panda.taint_enable" href="#pandare.Panda.taint_enable">taint_enable</a></code></li>
<li><code><a title="pandare.Panda.taint_enabled" href="#pandare.Panda.taint_enabled">taint_enabled</a></code></li>
<li><code><a title="pandare.Panda.taint_get_laddr" href="#pandare.Panda.taint_get_laddr">taint_get_laddr</a></code></li>
<li><code><a title="pandare.Panda.taint_get_ram" href="#pandare.Panda.taint_get_ram">taint_get_ram</a></code></li>
<li><code><a title="pandare.Panda.taint_get_reg" href="#pandare.Panda.taint_get_reg">taint_get_reg</a></code></li>
<li><code><a title="pandare.Panda.taint_label_ram" href="#pandare.Panda.taint_label_ram">taint_label_ram</a></code></li>
<li><code><a title="pandare.Panda.taint_label_reg" href="#pandare.Panda.taint_label_reg">taint_label_reg</a></code></li>
<li><code><a title="pandare.Panda.taint_sym_branch_meta" href="#pandare.Panda.taint_sym_branch_meta">taint_sym_branch_meta</a></code></li>
<li><code><a title="pandare.Panda.taint_sym_enable" href="#pandare.Panda.taint_sym_enable">taint_sym_enable</a></code></li>
<li><code><a title="pandare.Panda.taint_sym_label_ram" href="#pandare.Panda.taint_sym_label_ram">taint_sym_label_ram</a></code></li>
<li><code><a title="pandare.Panda.taint_sym_label_reg" href="#pandare.Panda.taint_sym_label_reg">taint_sym_label_reg</a></code></li>
<li><code><a title="pandare.Panda.taint_sym_path_constraints" href="#pandare.Panda.taint_sym_path_constraints">taint_sym_path_constraints</a></code></li>
<li><code><a title="pandare.Panda.taint_sym_query_ram" href="#pandare.Panda.taint_sym_query_ram">taint_sym_query_ram</a></code></li>
<li><code><a title="pandare.Panda.taint_sym_query_reg" href="#pandare.Panda.taint_sym_query_reg">taint_sym_query_reg</a></code></li>
<li><code><a title="pandare.Panda.to_unsigned_guest" href="#pandare.Panda.to_unsigned_guest">to_unsigned_guest</a></code></li>
<li><code><a title="pandare.Panda.type_serial_cmd" href="#pandare.Panda.type_serial_cmd">type_serial_cmd</a></code></li>
<li><code><a title="pandare.Panda.unload_plugin" href="#pandare.Panda.unload_plugin">unload_plugin</a></code></li>
<li><code><a title="pandare.Panda.unload_plugins" href="#pandare.Panda.unload_plugins">unload_plugins</a></code></li>
<li><code><a title="pandare.Panda.unregister_pyperipheral" href="#pandare.Panda.unregister_pyperipheral">unregister_pyperipheral</a></code></li>
<li><code><a title="pandare.Panda.virt_to_phys" href="#pandare.Panda.virt_to_phys">virt_to_phys</a></code></li>
<li><code><a title="pandare.Panda.virtual_memory_read" href="#pandare.Panda.virtual_memory_read">virtual_memory_read</a></code></li>
<li><code><a title="pandare.Panda.virtual_memory_write" href="#pandare.Panda.virtual_memory_write">virtual_memory_write</a></code></li>
<li><code><a title="pandare.Panda.vm_stop" href="#pandare.Panda.vm_stop">vm_stop</a></code></li>
<li><code><a title="pandare.Panda.was_aborted" href="#pandare.Panda.was_aborted">was_aborted</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandare.PyPlugin" href="#pandare.PyPlugin">PyPlugin</a></code></h4>
<ul class="two-column">
<li><code><a title="pandare.PyPlugin.get_arg" href="#pandare.PyPlugin.get_arg">get_arg</a></code></li>
<li><code><a title="pandare.PyPlugin.get_arg_bool" href="#pandare.PyPlugin.get_arg_bool">get_arg_bool</a></code></li>
<li><code><a title="pandare.PyPlugin.ppp" href="#pandare.PyPlugin.ppp">ppp</a></code></li>
<li><code><a title="pandare.PyPlugin.ppp_cb_boilerplate" href="#pandare.PyPlugin.ppp_cb_boilerplate">ppp_cb_boilerplate</a></code></li>
<li><code><a title="pandare.PyPlugin.ppp_export" href="#pandare.PyPlugin.ppp_export">ppp_export</a></code></li>
<li><code><a title="pandare.PyPlugin.ppp_run_cb" href="#pandare.PyPlugin.ppp_run_cb">ppp_run_cb</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>