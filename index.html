<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pandare API documentation</title>
<meta name="description" content="`pandare` (also called PyPANDA) is a Python 3 module built for interacting with the PANDA project.
The module enables driving an execution of a â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<!-- Bootstrap core CSS -->
<!--
<link href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css" rel="stylesheet">
-->
<!-- hand-crafted bootstrap navbar -->
<style>
.bg-light {
background-color: #f8f9fa!important;
}
.navbar {
position: relative;
display: -ms-flexbox;
display: flex;
-ms-flex-wrap: wrap;
flex-wrap: wrap;
-ms-flex-align: center;
align-items: center;
-ms-flex-pack: justify;
justify-content: space-between;
padding: .5rem 1rem;
}
.navbar-expand-lg {
-ms-flex-direction: row;
flex-direction: row;
-ms-flex-wrap: nowrap;
flex-wrap: nowrap;
-ms-flex-pack: start;
justify-content: flex-start;
}
navbar-light .navbar-brand {
color: rgba(0,0,0,.9);
}
.navbar-brand {
display: inline-block;
padding-top: .3125rem;
padding-bottom: .3125rem;
margin-right: 1rem;
font-size: 1.25rem;
line-height: inherit;
white-space: nowrap;
}
.navbar-nav {
display: -ms-flexbox;
display: flex;
-ms-flex-direction: column;
flex-direction: column;
padding-left: 0;
margin-bottom: 0;
list-style: none;
}
.navbar-expand-lg .navbar-nav {
-ms-flex-direction: row;
flex-direction: row;
}
.mr-auto {
margin-right: auto!important;
}
.navbar-expand-lg .navbar-collapse {
display: -ms-flexbox!important;
display: flex!important;
}
.navbar-collapse {
-ms-flex-preferred-size: 100%;
flex-basis: 100%;
-ms-flex-align: center;
align-items: center;
}
.navbar-light .navbar-brand {
color: rgba(0,0,0,.9);
}
.navbar a {
color: #007bff;
text-decoration: none;
background-color: transparent;
-webkit-text-decoration-skip: objects;
}
.navbar-expand-lg .navbar-nav .nav-link {
padding-right: .5rem;
padding-left: .5rem;
}
.navbar .navbar-nav {
margin: 0;
font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
font-size: 1rem;
font-weight: 400;
line-height: 1.5;
color: #212529;
}
.navbar-light .navbar-nav .active>.nav-link, .navbar-light .navbar-nav .nav-link.active, .navbar-light .navbar-nav .nav-link.show, .navbar-light .navbar-nav .show>.nav-link {
color: rgba(0,0,0,.9);
}
.navbar-light .navbar-nav .nav-link {
color: rgba(0,0,0,.5);
}
.nav-link {
display: block;
padding: .5rem 1rem;
}
</style>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-light">
<a class="navbar-brand" href="/">PANDA.re</a>
<div class="collapse navbar-collapse" id="navbarSupportedContent">
<ul class="navbar-nav mr-auto">
<li class="nav-item">
<a class="nav-link" href="//panda.re/">Home</a>
</li>
<li class="nav-item">
<a class="nav-link" target="_new" href="https://github.com/panda-re/panda">Github</a>
</li>
<li class="nav-item ">
<a class="nav-link" href="//panda.re/blog/">Blog</a>
</li>
<li class="nav-item ">
<a class="nav-link active" href="//docs.panda.re">Python Docs</a>
</li>
<li class="nav-item ">
<a class="nav-link" href="//panda.re/invite.php">Slack</a>
</li>
<!-- No resources tab here because we don't have real bootstrap -->
</div>
</nav>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>pandare</code></h1>
</header>
<section id="section-intro">
<p><code><a title="pandare" href="#pandare">pandare</a></code> (also called PyPANDA) is a Python 3 module built for interacting with the PANDA project.
The module enables driving an execution of a virtual machine while also introspecting on its execution using PANDA's callback
and plugin systems.</p>
<p>Most of the commonly used APIs are in <code><a title="pandare.panda" href="panda.html">pandare.panda</a></code>.</p>
<p>Example plugins are available in the <a href="https://github.com/panda-re/panda/tree/master/panda/python/examples">examples directory</a>.</p>
<h1 id="pypanda">PyPANDA</h1>
<p>PyPANDA is a python interface to PANDA. With PyPANDA, you can quickly develop plugins
to analyze behavior of a running system, record a system and analyze replays, or do
nearly anything you can do using PANDA's C/C++ APIs.</p>
<h2 id="installation">Installation</h2>
<p>Follow PANDA's build instructions. The <code><a title="pandare.panda" href="panda.html">pandare.panda</a></code> docker container includes the <code><a title="pandare" href="#pandare">pandare</a></code> package. If you setup panda with the <code>install_ubuntu.sh</code> script, it will install PyPANDA for you. Otherwise, when your install instructions tell you to run <code>build.sh</code> be sure to include the <code>--python</code> flag.</p>
<h2 id="example-program">Example program</h2>
<p>This program counts the number of basic blocks executed while running <code>uname -a</code> inside a 32-bit guest.</p>
<pre><code class="language-py">from pandare import Panda
panda = Panda(generic='i386') # Create an instance of panda

# Counter of the number of basic blocks
blocks = 0

# Register a callback to run before_block_exec and increment blocks
@panda.cb_before_block_exec
def before_block_execute(cpustate, transblock):
    global blocks
    blocks += 1

# This 'blocking' function is queued to run in a seperate thread from the main CPU loop
# which allows for it to wait for the guest to complete commands
@panda.queue_blocking
def run_cmd():
    # First revert to the qcow's root snapshot (synchronously)
    panda.revert_sync(&quot;root&quot;)
    # Then type a command via the serial port and print its results
    print(panda.run_serial_cmd(&quot;uname -a&quot;))
    # When the command finishes, terminate the panda.run() call
    panda.end_analysis()

# Start the guest
panda.run()
print(&quot;Finished. Saw a total of {} basic blocks during execution&quot;.format(blocks))
</code></pre>
<h1 id="usage">Usage</h1>
<h2 id="create-an-instance-of-panda">Create an instance of Panda</h2>
<p>The <code>Panda</code> class takes many arguments, but the only crucial argument is a
specificed qcow image. If you wish to get started quickly you may use the <code><a title="pandare.qcows.Qcows" href="qcows.html#pandare.qcows.Qcows">Qcows</a></code> module
to automatically download a pre-configured virtual machine for you to use.</p>
<p>For example: <code>panda = Panda(generic='i386')</code></p>
<h2 id="register-a-callback">Register a callback</h2>
<pre><code class="language-py">@panda.cb_before_block_exec
def my_before_block_fn(cpustate, translation_block):
  pc = panda.current_pc(cpustate)
  print(&quot;About to run the block at 0x{:x}&quot;.format(pc))
</code></pre>
<p>The panda object creates decorators named <code>cb_[CALLBACK_NAME]</code> for each PANDA callback.
The decorated functions must take the same number of arguments, and return the same type
as expected by the original C callback. The <strong><a href="#pandare.Callbacks">list of callbacks</a></strong> is available below.
The decorated functions are called at the appropriate times, similarly to how a PANDA plugin written
in C behaves.</p>
<h2 id="enable-and-disable-callbacks">Enable and disable callbacks</h2>
<p>Python callbacks can be enabled and disabled using their names.
By default, a callback is named after the function that is decorated. For example, the callback describe in</p>
<pre><code class="language-py">@panda.cb_before_block_exec
def my_before_block_fn(cpustate, translation_block):
  ...
</code></pre>
<p>is named <code>my_before_block_fn</code> and can be disabled with <code>panda.disable_callback('my_before_block_fn')</code> and later
enabled with <code>panda.enable_callback('my_before_block_fn')</code>.</p>
<p>Callbacks can be given custom names and disabled at initialization by passing arguments to their decorators:</p>
<pre><code class="language-py">@panda.cb_before_block_exec(name='my_callback', enabled=False)
def my_before_block_fn(cpustate, translation_block):
  ...
panda.enable_callback('my_callback')
</code></pre>
<p>If a callback is decorated with a <code>procname</code> argument, it will only be enabled when that process is running.
To permanently disable such a callback, you can use <code>panda.disable_callback('name', forever=True)</code>.</p>
<p>Note that if you wish to define a function multiple times (e.g., inside a loop), you'll need to give it multiple names
or it will be overwritten.</p>
<pre><code class="language-py">for x in range(10):
  @panda.cb_before_block_exec(name=f&quot;bbe_{x}&quot;)
  def bbe_loop(cpu, tb):
     print(f&quot;Before block exec function #{x}&quot;)
</code></pre>
<h2 id="replaying-recordings">Replaying Recordings</h2>
<pre><code class="language-py">panda = Panda(...)
# Register functions to run on callbacks here
panda.run_replay(&quot;/file/path/here&quot;) # Runs the replay
</code></pre>
<h2 id="load-and-unload-a-c-plugin">Load and unload a C plugin</h2>
<p>A C plugin can be loaded from pypanda easily: <code>panda.load_plugin("stringsearch")</code></p>
<p>C plugins can be passed named arguments using a dictionary: <code>panda.load_plugin("stringsearch", {"name": "jpeg"})</code></p>
<p>Or unnamed arguments using a list: <code>panda.load_plugin("my_plugin", ["arg1", "arg2"])</code></p>
<h2 id="asynchronous-activity">Asynchronous Activity</h2>
<p>When a callback is executing, the guest is suspended until the callback finishes. However, we often want to interact
with guests during our analyses. In these situations, we run code asynchronously to send data into and wait for results
from the guest.</p>
<p>PyPANDA is designed to easily support such analyses with the <code>@panda.queue_blocking</code> decorator.</p>
<p>Consider if you with to run the commands <code>uname -a</code>, then <code>whoami</code> in a guest. If your guest exposes a console over a serial port
(as all the 'generic' qcows we use do), you could run these commands by simply typing them and waiting for a response. But if you were
to do this in a callback, the guest would have no chance to respond to your commands and you'd end up in a deadlock where your callback
code never terminates until the guest executes your command, and the guest will never execute commands until your callback terminates.</p>
<p>Instead, you can queue up blocking functions to run asynchronously as follows:</p>
<pre><code class="language-py">panda = ...

@panda.queue_blocking
def first_cmd():
    print(panda.run_serial_cmd(&quot;uname -a&quot;))

@panda.queue_blocking
def second_cmd():
    print(panda.run_serial_cmd(&quot;whoami&quot;))
    panda.end_analysis()

panda.run()
</code></pre>
<p>Note that the <code>panda.queue_blocking</code> decorator both marks a function as being a blocking function (which allows it to use functions such as <code>panda.run_serial_cmd</code>) and queues it up to run after the call to <code>panda.run()</code></p>
<h2 id="recordings">Recordings</h2>
<p>See <a href="https://github.com/panda-re/panda/tree/master/panda/python/examples/take_recording.py">take_recording.py</a></p>
<p>A replay can be taken with the function <code>panda.record_cmd('cmd_to_run', recording_name='replay_name')</code> which will revert the guest to a <code>root</code> snapshot, type a command, begin a recording, press enter, wait for the command to finish, and then end the replay.
Once a replay is created on disk, it can be analyzed by using <code>panda.run_replay('replay_name')</code>.</p>
<p>Alternatively, you can begin/end the recording through the monitor with <code>panda.run_monitor_cmd('begin_record myname')</code>
and <code>panda.run_monitor_cmd('end_record')</code> and drive the guest using <code>panda.run_serial_cmd</code> in the middle.</p>
<h1 id="typical-use-patterns">Typical Use Patterns</h1>
<h2 id="live-system">Live system</h2>
<p>Example: <a href="https://github.com/panda-re/panda/tree/master/panda/python/examples/asid.py">asid.py</a>.</p>
<ol>
<li>Initialize a panda object based off a generic machine or a qcow you have.</li>
<li>Register functions to run at various PANDA callbacks.</li>
<li>Register and queue up a blocking function to revert the guest to a snapshot, run commands with <code>panda.run_serial_cmd()</code>, and stop the execution with <code>panda.end_analysis()</code></li>
<li>Start the execution with <code>panda.run()</code></li>
</ol>
<h2 id="recordreplay">Record/Replay</h2>
<p>Example: <a href="https://github.com/panda-re/panda/tree/master/panda/python/tests/record_then_replay.py">tests/record_then_replay.py</a>.</p>
<ol>
<li>Initialize a panda object based off a generic machine or a qcow you have.</li>
<li>Register and queue up a blocking function to drive guest execution while recording or with <code>panda.record_cmd</code> then call <code>panda.end_analysis()</code></li>
<li>Register functions to run at various PANDA callbacks.</li>
<li>Analyze the replay with <code>panda.run_replay(filename)</code></li>
</ol>
<h1 id="additional-information">Additional Information</h1>
<h2 id="here-be-dragons">Here be dragons</h2>
<ul>
<li>You can't have multiple instances of panda running at the same time. Once you've created a panda object for a given architecture, you can never create another. Hoewver, you can modify the machine after it's created to run a new analysis as long as you don't change the machine type.</li>
<li>PyPANDA is slower than traditional PANDA. Well-engineered plugins typically have a runtime overhead of ~10% compared to regular PANDA plugins (for up to 10M instructions). To improve performance try disabling callbacks when possible and only enabling them when they are needed.</li>
</ul>
<h2 id="extending-pypanda">Extending PyPANDA</h2>
<p>PyPANDA currently supports interactions (e.g., ppp callbacks) with many PANDA plugins such as <code>taint2</code> and <code>osi</code>. If you wish to extend PyPANDA to support an new plugin, its header file
must be cleaned up such that it can be parsed by CFFI. See <a href="https://github.com/panda-re/panda/tree/master/panda/python/utils/create_panda_datatypes.py">create_panda_datatypes.py</a>
and the magic <code>BEGIN_PYPANDA_NEEDS_THIS</code> strings it searches for.</p>
<h2 id="learn-more">Learn more</h2>
<p>The <a href="https://moyix.net/~moyix/papers/pypanda.pdf">PyPANDA paper</a> was published at the NDSS Binary Analysis Research Workshop in 2021 and includes details on the project's design goals as well as an evaluation of it's usability and performance.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
`pandare` (also called PyPANDA) is a Python 3 module built for interacting with the PANDA project.
The module enables driving an execution of a virtual machine while also introspecting on its execution using PANDA&#39;s callback
and plugin systems.

Most of the commonly used APIs are in `pandare.panda`.

Example plugins are available in the [examples directory](https://github.com/panda-re/panda/tree/master/panda/python/examples).

.. include:: ../../docs/USAGE.md
&#34;&#34;&#34;

from .panda import Panda, blocking
from .plog_reader import PLogReader

__pdoc__ = {}

__pdoc__[&#39;asyncthread&#39;] = False
__pdoc__[&#39;autogen&#39;] = False
__pdoc__[&#39;ffi_importer&#39;] = False
__pdoc__[&#39;plog_pb2&#39;] = False
__pdoc__[&#39;volatility_cli_classes&#39;] = False

# The following code is soley here to allow pdoc to document callbacks
from .autogen.panda_datatypes import get_cb_docs
class Callbacks:
    &#39;&#39;&#39;
    The core callbacks provided by PANDA. Note this is a pseudo class just for documentation.
    Note **the arguments listed are the arguments your callback function will receive** and
    **the return value is what your callback must return**.

    These decorators should be accessed through a handle to a panda object, for example:

        panda = Panda(generic=&#39;x86_64&#39;)

        @panda.cb_before_block_exec
        def my_bbe_callback(cpu, tb):
            print(&#34;Before block exec!&#34;)
        ...
    &#39;&#39;&#39;

cb_docs = get_cb_docs()
for cb_name, (rv, args, docstring) in cb_docs._asdict().items():
    # Add fake functions to our callbacks class with dynamic docstrings

    if cb_name == &#34;init&#34;:
        continue
    fakename = &#34;@panda.cb_&#34; + cb_name

    # Add no-op function to the class
    setattr(Callbacks, fakename, lambda Your_Function: None)

    # Build argument list and reformat for pdoc from function signature
    args = args.replace(&#34; *&#34;, &#34;* &#34;) # CPUState *env -&gt; CPUState* env
    arglist = []
    for arg in args.split(&#34;,&#34;):
        arg = arg.strip()
        if &#34; &#34; in arg:
            typ = arg.split(&#34; &#34;)[0]
            name = arg[len(typ)+1:]
            arglist.append((typ, name))
        else:
            arglist.append((arg, &#34;&#34;))

    # Try to build argument descriptions too from text by finding lines like &#34;argname: something\n&#34;
    arg_desc = {}
    rv_desc = &#34;&#34;
    next_rv = False

    type_signature = f&#34;{rv} (*&#34; # To identify when we&#39;re done with useful docs

    for line in docstring.split(&#34;\n&#34;):
        # Get arg descriptions
        for (arg_type, arg_name) in arglist:
            if f&#34;{arg_name}:&#34; in line:
                arg_desc[arg_name] = line.split(f&#34;{arg_name}:&#34;)[1].strip()

        # Get return value description
        if line.startswith(&#34;Return value:&#34;):
            next_rv = True
        elif next_rv and &#34;:&#34; in line or type_signature in line:
            # End when we hit something like &#34;Notes: &#34; or &#34;void (*this_callback)...&#34;
            next_rv = False
        elif next_rv:
            rv_desc += line.strip() + &#34; &#34;

    argnames = &#34;\n        &#34;.join(f&#34;{argtype}: {argname}: {arg_desc[argname] if argname in arg_desc else &#39;&#39;}&#34; for (argtype, argname) in arglist)

    # Build docstring
    full_ds = &#34;&#34;

    # Now we want to add the comments from the C header, but we have to avoid
    # including &#34;Arguments:&#34; or pdoc will stop special-formatting our above
    # arguments we worked so hard to get.
    # For now let&#39;s just grab from [name]: up until a line ending with Arguments
    # and also Notes:

    record = False
    for line in docstring.split(&#34;\n&#34;):
        if line.strip().replace(&#34;:&#34;, &#34;&#34;).endswith(&#34;Arguments&#34;):
            record = False

        if &#39;Notes:&#39; in line: # Include Notes: in our ouptut
            record = True
            #full_ds += &#34;\n\n&#34;

        if cb_name+&#34;:&#34; in line:
            start = line.split(cb_name+&#34;:&#34;)[1]
            if len(start):
                start+= &#34; &#34;
            full_ds += start
            record = True
            continue

        if type_signature in line:
            record = False

        if record:
            full_ds += line + &#34; &#34;

    # Now add args and retval
    full_ds += f&#34;&#34;&#34;
    Args:
        {argnames}

    Returns:
        {rv}: {rv_desc if len(rv_desc) else &#39;the type your callback must return&#39;}

    &#34;&#34;&#34;

    __pdoc__[f&#34;Callbacks.{fakename}&#34;] = full_ds</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pandare.arch" href="arch.html">pandare.arch</a></code></dt>
<dd>
<div class="desc"><p>This module contains architecture-specific code â€¦</p></div>
</dd>
<dt><code class="name"><a title="pandare.extras" href="extras/index.html">pandare.extras</a></code></dt>
<dd>
<div class="desc"><p>Extras are PyPANDA plugins which you can import into other python analyses. Typically
this is done by passing a handle from your script's PANDA object â€¦</p></div>
</dd>
<dt><code class="name"><a title="pandare.panda" href="panda.html">pandare.panda</a></code></dt>
<dd>
<div class="desc"><p>This module simply contains the Panda class</p></div>
</dd>
<dt><code class="name"><a title="pandare.panda_expect" href="panda_expect.html">pandare.panda_expect</a></code></dt>
<dd>
<div class="desc"><p>Custom library for interacting/expecting data via serial-like FDs</p></div>
</dd>
<dt><code class="name"><a title="pandare.plog_reader" href="plog_reader.html">pandare.plog_reader</a></code></dt>
<dd>
<div class="desc"><p>Module for reading and writing PANDAlog (plog) files from Python.</p></div>
</dd>
<dt><code class="name"><a title="pandare.qcows" href="qcows.html">pandare.qcows</a></code></dt>
<dd>
<div class="desc"><p>Module for fetching generic PANDA images and managing their metadata.</p></div>
</dd>
<dt><code class="name"><a title="pandare.taint" href="taint/index.html">pandare.taint</a></code></dt>
<dd>
<div class="desc"><p>Structures to support the taint subsystem.</p></div>
</dd>
<dt><code class="name"><a title="pandare.utils" href="utils.html">pandare.utils</a></code></dt>
<dd>
<div class="desc"><p>Misc helper functions</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pandare.Callbacks"><code class="flex name class">
<span>class <span class="ident">Callbacks</span></span>
</code></dt>
<dd>
<div class="desc"><p>The core callbacks provided by PANDA. Note this is a pseudo class just for documentation.
Note <strong>the arguments listed are the arguments your callback function will receive</strong> and
<strong>the return value is what your callback must return</strong>.</p>
<p>These decorators should be accessed through a handle to a panda object, for example:</p>
<pre><code>panda = Panda(generic='x86_64')

@panda.cb_before_block_exec
def my_bbe_callback(cpu, tb):
    print("Before block exec!")
...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Callbacks:
    &#39;&#39;&#39;
    The core callbacks provided by PANDA. Note this is a pseudo class just for documentation.
    Note **the arguments listed are the arguments your callback function will receive** and
    **the return value is what your callback must return**.

    These decorators should be accessed through a handle to a panda object, for example:

        panda = Panda(generic=&#39;x86_64&#39;)

        @panda.cb_before_block_exec
        def my_bbe_callback(cpu, tb):
            print(&#34;Before block exec!&#34;)
        ...
    &#39;&#39;&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pandare.Callbacks.@panda.cb_after_block_exec"><code class="name flex">
<span>def <span class="ident">@panda.cb_after_block_exec</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after execution of every basic block. If exitCode &gt; TB_EXIT_IDX1, then the block exited early.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>TranslationBlock*</code></strong></dt>
<dd>tb: the TB we just executed</dd>
<dt><strong><code>uint8_t</code></strong></dt>
<dd>exitCode: why the block execution exited</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_after_block_translate"><code class="name flex">
<span>def <span class="ident">@panda.cb_after_block_translate</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after the translation of each basic block.
Notes: This is a good place to perform extra passes over the generated code (particularly by manipulating the LLVM code). FIXME: How would this actually work? By this point the out ASM has already been generated. Modify the IR and then regenerate?
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>TranslationBlock*</code></strong></dt>
<dd>tb: the TB we just translated</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_after_cpu_exec_enter"><code class="name flex">
<span>def <span class="ident">@panda.cb_after_cpu_exec_enter</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after cpu_exec calls cpu_exec_enter function.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_after_insn_exec"><code class="name flex">
<span>def <span class="ident">@panda.cb_after_insn_exec</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after execution of an instruction identified by the PANDA_CB_AFTER_INSN_TRANSLATE callback
Notes: See <code>insn_exec</code>. Enabled via the PANDA_CB_AFTER_INSN_TRANSLATE callback.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the next guest PC already executed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>unused
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_after_insn_translate"><code class="name flex">
<span>def <span class="ident">@panda.cb_after_insn_translate</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after the translation of each instruction.
Notes: See <code>insn_translate</code>, callbacks are registered via PANDA_CB_AFTER_INSN_EXEC
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the next guest PC we've translated</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true if PANDA should insert instrumentation into the generated code, false otherwise
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_after_loadvm"><code class="name flex">
<span>def <span class="ident">@panda.cb_after_loadvm</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called right after a snapshot has been loaded (either with loadvm or replay initialization), but before any guest code runs.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_after_machine_init"><code class="name flex">
<span>def <span class="ident">@panda.cb_after_machine_init</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called right after the machine has been initialized, but before any guest code runs.
Notes: This callback allows initialization of components that need access to the RAM, CPU object, etc. E.g. for the taint2 plugin, this is the appropriate place to call taint2_enable_taint().
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_asid_changed"><code class="name flex">
<span>def <span class="ident">@panda.cb_asid_changed</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when asid changes.
Notes: The callback is only invoked implemented for x86 and ARM. This should break plugins which rely on it to detect context switches in any other architecture.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>oldval: old asid value</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>newval: new asid value</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true if the asid should be prevented from being changed false otherwise
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_before_block_exec"><code class="name flex">
<span>def <span class="ident">@panda.cb_before_block_exec</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before execution of every basic block.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>TranslationBlock*</code></strong></dt>
<dd>tb: the TB we are about to execute</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_before_block_exec_invalidate_opt"><code class="name flex">
<span>def <span class="ident">@panda.cb_before_block_exec_invalidate_opt</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before execution of every basic block, with the option to invalidate the TB.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>TranslationBlock*</code></strong></dt>
<dd>tb: the TB we are about to execute</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true if we should invalidate the current translation block and retranslate, false otherwise.
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_before_block_translate"><code class="name flex">
<span>def <span class="ident">@panda.cb_before_block_translate</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before translation of each basic block.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC we are about to translate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_before_cpu_exec_exit"><code class="name flex">
<span>def <span class="ident">@panda.cb_before_cpu_exec_exit</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before cpu_exec calls cpu_exec_exit function.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>bool</code></strong></dt>
<dd>ranBlock: true if ran a block since previous cpu_exec_enter</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_before_handle_exception"><code class="name flex">
<span>def <span class="ident">@panda.cb_before_handle_exception</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called just before we are about to handle an exception.
Note: only called for cpu-&gt;exception_index &gt; 0
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>cpu: </dd>
<dt><strong><code>int32_t</code></strong></dt>
<dd>exception_index: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int32_t</code></dt>
<dd>a new exception_index.
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_before_handle_interrupt"><code class="name flex">
<span>def <span class="ident">@panda.cb_before_handle_interrupt</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called just before we are about to handle an interrupt.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>cpu: </dd>
<dt><strong><code>int32_t</code></strong></dt>
<dd>interrupt_request: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int32_t</code></dt>
<dd>new interrupt_rquest
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_before_loadvm"><code class="name flex">
<span>def <span class="ident">@panda.cb_before_loadvm</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called at start of replay, before loadvm is called. This allows us to hook devices' loadvm handlers. Remember to unregister the existing handler for the device first. See the example in the sample plugin.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>void</code></strong></dt>
<dd>: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>unused
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_before_tcg_codegen"><code class="name flex">
<span>def <span class="ident">@panda.cb_before_tcg_codegen</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before host code generation for every basic block. Enables inspection and modification of the TCG block after lifting from guest code.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>TranslationBlock*</code></strong></dt>
<dd>tb: the TB about to be compiled</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>None
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_cpu_restore_state"><code class="name flex">
<span>def <span class="ident">@panda.cb_cpu_restore_state</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called inside of cpu_restore_state(), when there is a CPU fault/exception.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>TranslationBlock*</code></strong></dt>
<dd>tb: the current translation block</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_during_machine_init"><code class="name flex">
<span>def <span class="ident">@panda.cb_during_machine_init</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called in the middle of machine initialization
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>MachineState*</code></strong></dt>
<dd>machine: pointer to the machine state</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>None
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_end_block_exec"><code class="name flex">
<span>def <span class="ident">@panda.cb_end_block_exec</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>This is like after_block_exec except its part of the TCG stream.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>cpu: </dd>
<dt><strong><code>TranslationBlock*</code></strong></dt>
<dd>tb: the TB we are executing</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_guest_hypercall"><code class="name flex">
<span>def <span class="ident">@panda.cb_guest_hypercall</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when a program inside the guest makes a hypercall to pass information from inside the guest to a plugin
Notes: On x86, this is called whenever CPUID is executed. On ARM, the MCR instructions is used. Plugins should check for magic values in the registers to determine if it really is a guest hypercall. Parameters can be passed in other registers. If the plugin processes the hypercall, it should return true so the execution of the normal instruction is skipped.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true if the callback has processed the hypercall, false if the hypercall has been ignored.
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_hd_read"><code class="name flex">
<span>def <span class="ident">@panda.cb_hd_read</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>the type your callback must return</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_hd_write"><code class="name flex">
<span>def <span class="ident">@panda.cb_hd_write</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>the type your callback must return</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_insn_exec"><code class="name flex">
<span>def <span class="ident">@panda.cb_insn_exec</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before execution of any instruction identified by the PANDA_CB_INSN_TRANSLATE callback.
Notes: This instrumentation is implemented by generating a call to a helper function just before the instruction itself is generated. This is fairly expensive, which is why it's only enabled via the PANDA_CB_INSN_TRANSLATE callback.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC we are about to execute</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>unused
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_insn_translate"><code class="name flex">
<span>def <span class="ident">@panda.cb_insn_translate</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before the translation of each instruction.
Notes: This allows a plugin writer to instrument only a small number of instructions, avoiding the performance hit of instrumenting everything. If you do want to instrument every single instruction, just return true. See the documentation for PANDA_CB_INSN_EXEC for more detail.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC we are about to translate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true if PANDA should insert instrumentation into the generated code, false otherwise
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_main_loop_wait"><code class="name flex">
<span>def <span class="ident">@panda.cb_main_loop_wait</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called in IO thread in place where monitor cmds are processed
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>void</code></strong></dt>
<dd>: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>None
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_mmio_after_read"><code class="name flex">
<span>def <span class="ident">@panda.cb_mmio_after_read</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after MMIO memory is read.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>physaddr: the physical address being read from</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>vaddr: the virtual address being read from</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the read</dd>
<dt><strong><code>uint64_t*</code></strong></dt>
<dd>val: the value being read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_mmio_before_write"><code class="name flex">
<span>def <span class="ident">@panda.cb_mmio_before_write</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after MMIO memory is written to.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>physaddr: the physical address being written to</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>vaddr: the virtual address being written to</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the write</dd>
<dt><strong><code>uint64_t*</code></strong></dt>
<dd>val: the value being written</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_monitor"><code class="name flex">
<span>def <span class="ident">@panda.cb_monitor</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when someone uses the plugin_cmd monitor command.
Notes: The command is passed as a single string. No parsing is performed on the string before it is passed to the plugin, so each plugin must parse the string as it deems appropriate (e.g. by using strtok and getopt) to do more complex option processing. It is recommended that each plugin implementing this callback respond to the "help" message by listing the commands supported by the plugin. Note that every loaded plugin will have the opportunity to respond to each plugin_cmd; thus it is a good idea to ensure that your plugin's monitor commands are uniquely named, e.g. by using the plugin name as a prefix ("sample_do_foo" rather than "do_foo").
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>Monitor*</code></strong></dt>
<dd>mon: a pointer to the Monitor</dd>
<dt><strong><code>const</code></strong></dt>
<dd>char* cmd: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>unused
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_phys_mem_after_read"><code class="name flex">
<span>def <span class="ident">@panda.cb_phys_mem_after_read</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after memory is read.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC doing the read</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>addr: the (physical) address being read</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the read</dd>
<dt><strong><code>uint8_t*</code></strong></dt>
<dd>buf: pointer to data just read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_phys_mem_after_write"><code class="name flex">
<span>def <span class="ident">@panda.cb_phys_mem_after_write</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC doing the write</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>addr: the (physical) address being written</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the write</dd>
<dt><strong><code>uint8_t*</code></strong></dt>
<dd>buf: pointer to the data that was written</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_phys_mem_before_read"><code class="name flex">
<span>def <span class="ident">@panda.cb_phys_mem_before_read</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after memory is read.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC doing the read</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>addr: the (physical) address being read</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_phys_mem_before_write"><code class="name flex">
<span>def <span class="ident">@panda.cb_phys_mem_before_write</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC doing the write</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>addr: the (physical) address being written</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the write</dd>
<dt><strong><code>uint8_t*</code></strong></dt>
<dd>buf: pointer to the data that is to be written</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_pre_shutdown"><code class="name flex">
<span>def <span class="ident">@panda.cb_pre_shutdown</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called just before qemu shuts down
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>void</code></strong></dt>
<dd>: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>None
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_after_dma"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_after_dma</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>const</code></strong></dt>
<dd>uint8_t* buf: </dd>
<dt><strong><code>hwaddr</code></strong></dt>
<dd>addr: address written to in the guest RAM</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: size of transfer</dd>
<dt><strong><code>bool</code></strong></dt>
<dd>is_write: indicates whether the DMA transfer writes to memory</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_before_dma"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_before_dma</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>In replay only. We are about to dma between qemu buffer and guest memory.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>const</code></strong></dt>
<dd>uint8_t* buf: </dd>
<dt><strong><code>hwaddr</code></strong></dt>
<dd>addr: address written to in the guest RAM</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: size of transfer</dd>
<dt><strong><code>bool</code></strong></dt>
<dd>is_write: indicates whether the DMA transfer writes to memory</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_handle_packet"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_handle_packet</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Notes: <code>buf_addr_rec</code> corresponds to the address of the device buffer of the emulated NIC. I.e. it is the address of a VM-host-side buffer. It is useful for implementing network tainting in an OS-agnostic way, in conjunction with taint2_label_io().
FIXME: The <code>buf_addr_rec</code> maps to the <code>uint8_t *buf</code> field of the internal <code>RR_handle_packet_args</code> struct. The field is dumped/loaded to/from the trace without proper serialization/deserialization. As a result, a 64bit build of PANDA will not be able to process traces produced by a 32bit of PANDA, and vice-versa. There are more internal structs that suffer from the same issue. This is an oversight that will eventually be fixed. But as the real impact is minimal (virtually nobody uses 32bit builds), the fix has a very low priority in the bugfix list.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>uint8_t*</code></strong></dt>
<dd>buf: buffer containing packet data</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: num bytes in buffer</dd>
<dt><strong><code>uint8_t</code></strong></dt>
<dd>direction: either <code>PANDA_NET_RX</code> or <code>PANDA_NET_TX</code></dd>
<dt><strong><code>uint64_t</code></strong></dt>
<dd>buf_addr_rec: the address of <code>buf</code> at the time of recording</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_hd_transfer"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_hd_transfer</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>In replay only. Some kind of data transfer involving hard drive.
Notes: Unlike most callbacks, this is neither a "before" or "after" callback. In replay the transfer doesn't really happen. We are <em>at</em> the point at which it happened, really.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>uint32_t</code></strong></dt>
<dd>type: type of transfer
(Hd_transfer_type)</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>src_addr: address for src</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>dest_addr: address for dest</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>num_bytes: size of transfer in bytes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_net_transfer"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_net_transfer</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>In replay only, some kind of data transfer within the network card (currently, only the E1000 is supported).
Notes: Unlike most callbacks, this is neither a "before" or "after" callback. In replay the transfer doesn't really happen. We are <em>at</em> the point at which it happened, really. Also, the src_addr and dest_addr may be for either host (ie. a location in the emulated network device) or guest, depending upon the type.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>uint32_t</code></strong></dt>
<dd>type: type of transfer
(Net_transfer_type)</dd>
<dt><strong><code>uint64_t</code></strong></dt>
<dd>src_addr: address for src</dd>
<dt><strong><code>uint64_t</code></strong></dt>
<dd>dest_addr: address for dest</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>num_bytes: size of transfer in bytes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_serial_read"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_serial_read</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>In replay only, called when a byte read from the serial RX FIFO
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>fifo_addr: address of the data within the fifo (source)</dd>
<dt><strong><code>uint32_t</code></strong></dt>
<dd>port_addr: address of the IO port where data is being read (destination)</dd>
<dt><strong><code>uint8_t</code></strong></dt>
<dd>value: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_serial_receive"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_serial_receive</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>In replay only, called when a byte is received on the serial port.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>fifo_addr: address of the data within the fifo</dd>
<dt><strong><code>uint8_t</code></strong></dt>
<dd>value: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>unused
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_serial_send"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_serial_send</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>In replay only, called when a byte is sent on the serial port.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>fifo_addr: address of the data within the fifo</dd>
<dt><strong><code>uint8_t</code></strong></dt>
<dd>value: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_replay_serial_write"><code class="name flex">
<span>def <span class="ident">@panda.cb_replay_serial_write</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>fifo_addr: address of the data within the fifo (source)</dd>
<dt><strong><code>uint32_t</code></strong></dt>
<dd>port_addr: address of the IO port where data is being read (destination)</dd>
<dt><strong><code>uint8_t</code></strong></dt>
<dd>value: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_start_block_exec"><code class="name flex">
<span>def <span class="ident">@panda.cb_start_block_exec</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>This is like before_block_exec except its part of the TCG stream.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>cpu: </dd>
<dt><strong><code>TranslationBlock*</code></strong></dt>
<dd>tb: the TB we are executing</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_top_loop"><code class="name flex">
<span>def <span class="ident">@panda.cb_top_loop</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called at the top of the loop that manages emulation.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: pointer to CPUState</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>unused
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_unassigned_io_read"><code class="name flex">
<span>def <span class="ident">@panda.cb_unassigned_io_read</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the guest attempts to read from an unmapped peripheral via MMIO
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: </dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: Guest program counter at time of write</dd>
<dt><strong><code>hwaddr</code></strong></dt>
<dd>addr: Physical address written to</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: Size of write</dd>
<dt><strong><code>uint64_t*</code></strong></dt>
<dd>val: Pointer to a buffer that will be passed to the guest as the result of the read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if value read was changed by a PANDA plugin and should be returned False if error-logic (invalid write) should be run
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_unassigned_io_write"><code class="name flex">
<span>def <span class="ident">@panda.cb_unassigned_io_write</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the guest attempts to write to an unmapped peripheral via MMIO
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: </dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: Guest program counter at time of write</dd>
<dt><strong><code>hwaddr</code></strong></dt>
<dd>addr: Physical address written to</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: Size of write</dd>
<dt><strong><code>uint64_t</code></strong></dt>
<dd>val: Data being written, up to 8 bytes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the write should be allowed without error False if normal behavior should be used (error-logic)
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_virt_mem_after_read"><code class="name flex">
<span>def <span class="ident">@panda.cb_virt_mem_after_read</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after memory is read.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC doing the read</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>addr: the (virtual) address being read</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the read</dd>
<dt><strong><code>uint8_t*</code></strong></dt>
<dd>buf: pointer to data just read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_virt_mem_after_write"><code class="name flex">
<span>def <span class="ident">@panda.cb_virt_mem_after_write</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after memory is written.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC doing the write</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>addr: the (virtual) address being written</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the write</dd>
<dt><strong><code>uint8_t*</code></strong></dt>
<dd>buf: pointer to the data that was written</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_virt_mem_before_read"><code class="name flex">
<span>def <span class="ident">@panda.cb_virt_mem_before_read</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before memory is read.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC doing the read</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>addr: the (virtual) address being read</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
<dt id="pandare.Callbacks.@panda.cb_virt_mem_before_write"><code class="name flex">
<span>def <span class="ident">@panda.cb_virt_mem_before_write</span></span>(<span>Your_Function)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before memory is written.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CPUState*</code></strong></dt>
<dd>env: the current CPU state</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>pc: the guest PC doing the write</dd>
<dt><strong><code>target_ptr_t</code></strong></dt>
<dd>addr: the (virtual) address being written</dd>
<dt><strong><code>size_t</code></strong></dt>
<dd>size: the size of the write</dd>
<dt><strong><code>uint8_t*</code></strong></dt>
<dd>buf: pointer to the data that is to be written</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>none
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setattr(Callbacks, fakename, lambda Your_Function: None)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="panda.re Docs" href="/">
<img src="//panda.re/img/logo.png" alt="logo"> PANDA.re Docs
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#pypanda">PyPANDA</a><ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#example-program">Example program</a></li>
</ul>
</li>
<li><a href="#usage">Usage</a><ul>
<li><a href="#create-an-instance-of-panda">Create an instance of Panda</a></li>
<li><a href="#register-a-callback">Register a callback</a></li>
<li><a href="#enable-and-disable-callbacks">Enable and disable callbacks</a></li>
<li><a href="#replaying-recordings">Replaying Recordings</a></li>
<li><a href="#load-and-unload-a-c-plugin">Load and unload a C plugin</a></li>
<li><a href="#asynchronous-activity">Asynchronous Activity</a></li>
<li><a href="#recordings">Recordings</a></li>
</ul>
</li>
<li><a href="#typical-use-patterns">Typical Use Patterns</a><ul>
<li><a href="#live-system">Live system</a></li>
<li><a href="#recordreplay">Record/Replay</a></li>
</ul>
</li>
<li><a href="#additional-information">Additional Information</a><ul>
<li><a href="#here-be-dragons">Here be dragons</a></li>
<li><a href="#extending-pypanda">Extending PyPANDA</a></li>
<li><a href="#learn-more">Learn more</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pandare.arch" href="arch.html">pandare.arch</a></code></li>
<li><code><a title="pandare.extras" href="extras/index.html">pandare.extras</a></code></li>
<li><code><a title="pandare.panda" href="panda.html">pandare.panda</a></code></li>
<li><code><a title="pandare.panda_expect" href="panda_expect.html">pandare.panda_expect</a></code></li>
<li><code><a title="pandare.plog_reader" href="plog_reader.html">pandare.plog_reader</a></code></li>
<li><code><a title="pandare.qcows" href="qcows.html">pandare.qcows</a></code></li>
<li><code><a title="pandare.taint" href="taint/index.html">pandare.taint</a></code></li>
<li><code><a title="pandare.utils" href="utils.html">pandare.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pandare.Callbacks" href="#pandare.Callbacks">Callbacks</a></code></h4>
<ul class="">
<li><code><a title="pandare.Callbacks.@panda.cb_after_block_exec" href="#pandare.Callbacks.@panda.cb_after_block_exec">@panda.cb_after_block_exec</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_after_block_translate" href="#pandare.Callbacks.@panda.cb_after_block_translate">@panda.cb_after_block_translate</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_after_cpu_exec_enter" href="#pandare.Callbacks.@panda.cb_after_cpu_exec_enter">@panda.cb_after_cpu_exec_enter</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_after_insn_exec" href="#pandare.Callbacks.@panda.cb_after_insn_exec">@panda.cb_after_insn_exec</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_after_insn_translate" href="#pandare.Callbacks.@panda.cb_after_insn_translate">@panda.cb_after_insn_translate</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_after_loadvm" href="#pandare.Callbacks.@panda.cb_after_loadvm">@panda.cb_after_loadvm</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_after_machine_init" href="#pandare.Callbacks.@panda.cb_after_machine_init">@panda.cb_after_machine_init</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_asid_changed" href="#pandare.Callbacks.@panda.cb_asid_changed">@panda.cb_asid_changed</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_before_block_exec" href="#pandare.Callbacks.@panda.cb_before_block_exec">@panda.cb_before_block_exec</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_before_block_exec_invalidate_opt" href="#pandare.Callbacks.@panda.cb_before_block_exec_invalidate_opt">@panda.cb_before_block_exec_invalidate_opt</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_before_block_translate" href="#pandare.Callbacks.@panda.cb_before_block_translate">@panda.cb_before_block_translate</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_before_cpu_exec_exit" href="#pandare.Callbacks.@panda.cb_before_cpu_exec_exit">@panda.cb_before_cpu_exec_exit</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_before_handle_exception" href="#pandare.Callbacks.@panda.cb_before_handle_exception">@panda.cb_before_handle_exception</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_before_handle_interrupt" href="#pandare.Callbacks.@panda.cb_before_handle_interrupt">@panda.cb_before_handle_interrupt</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_before_loadvm" href="#pandare.Callbacks.@panda.cb_before_loadvm">@panda.cb_before_loadvm</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_before_tcg_codegen" href="#pandare.Callbacks.@panda.cb_before_tcg_codegen">@panda.cb_before_tcg_codegen</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_cpu_restore_state" href="#pandare.Callbacks.@panda.cb_cpu_restore_state">@panda.cb_cpu_restore_state</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_during_machine_init" href="#pandare.Callbacks.@panda.cb_during_machine_init">@panda.cb_during_machine_init</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_end_block_exec" href="#pandare.Callbacks.@panda.cb_end_block_exec">@panda.cb_end_block_exec</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_guest_hypercall" href="#pandare.Callbacks.@panda.cb_guest_hypercall">@panda.cb_guest_hypercall</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_hd_read" href="#pandare.Callbacks.@panda.cb_hd_read">@panda.cb_hd_read</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_hd_write" href="#pandare.Callbacks.@panda.cb_hd_write">@panda.cb_hd_write</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_insn_exec" href="#pandare.Callbacks.@panda.cb_insn_exec">@panda.cb_insn_exec</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_insn_translate" href="#pandare.Callbacks.@panda.cb_insn_translate">@panda.cb_insn_translate</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_main_loop_wait" href="#pandare.Callbacks.@panda.cb_main_loop_wait">@panda.cb_main_loop_wait</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_mmio_after_read" href="#pandare.Callbacks.@panda.cb_mmio_after_read">@panda.cb_mmio_after_read</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_mmio_before_write" href="#pandare.Callbacks.@panda.cb_mmio_before_write">@panda.cb_mmio_before_write</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_monitor" href="#pandare.Callbacks.@panda.cb_monitor">@panda.cb_monitor</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_phys_mem_after_read" href="#pandare.Callbacks.@panda.cb_phys_mem_after_read">@panda.cb_phys_mem_after_read</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_phys_mem_after_write" href="#pandare.Callbacks.@panda.cb_phys_mem_after_write">@panda.cb_phys_mem_after_write</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_phys_mem_before_read" href="#pandare.Callbacks.@panda.cb_phys_mem_before_read">@panda.cb_phys_mem_before_read</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_phys_mem_before_write" href="#pandare.Callbacks.@panda.cb_phys_mem_before_write">@panda.cb_phys_mem_before_write</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_pre_shutdown" href="#pandare.Callbacks.@panda.cb_pre_shutdown">@panda.cb_pre_shutdown</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_after_dma" href="#pandare.Callbacks.@panda.cb_replay_after_dma">@panda.cb_replay_after_dma</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_before_dma" href="#pandare.Callbacks.@panda.cb_replay_before_dma">@panda.cb_replay_before_dma</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_handle_packet" href="#pandare.Callbacks.@panda.cb_replay_handle_packet">@panda.cb_replay_handle_packet</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_hd_transfer" href="#pandare.Callbacks.@panda.cb_replay_hd_transfer">@panda.cb_replay_hd_transfer</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_net_transfer" href="#pandare.Callbacks.@panda.cb_replay_net_transfer">@panda.cb_replay_net_transfer</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_serial_read" href="#pandare.Callbacks.@panda.cb_replay_serial_read">@panda.cb_replay_serial_read</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_serial_receive" href="#pandare.Callbacks.@panda.cb_replay_serial_receive">@panda.cb_replay_serial_receive</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_serial_send" href="#pandare.Callbacks.@panda.cb_replay_serial_send">@panda.cb_replay_serial_send</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_replay_serial_write" href="#pandare.Callbacks.@panda.cb_replay_serial_write">@panda.cb_replay_serial_write</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_start_block_exec" href="#pandare.Callbacks.@panda.cb_start_block_exec">@panda.cb_start_block_exec</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_top_loop" href="#pandare.Callbacks.@panda.cb_top_loop">@panda.cb_top_loop</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_unassigned_io_read" href="#pandare.Callbacks.@panda.cb_unassigned_io_read">@panda.cb_unassigned_io_read</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_unassigned_io_write" href="#pandare.Callbacks.@panda.cb_unassigned_io_write">@panda.cb_unassigned_io_write</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_virt_mem_after_read" href="#pandare.Callbacks.@panda.cb_virt_mem_after_read">@panda.cb_virt_mem_after_read</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_virt_mem_after_write" href="#pandare.Callbacks.@panda.cb_virt_mem_after_write">@panda.cb_virt_mem_after_write</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_virt_mem_before_read" href="#pandare.Callbacks.@panda.cb_virt_mem_before_read">@panda.cb_virt_mem_before_read</a></code></li>
<li><code><a title="pandare.Callbacks.@panda.cb_virt_mem_before_write" href="#pandare.Callbacks.@panda.cb_virt_mem_before_write">@panda.cb_virt_mem_before_write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>