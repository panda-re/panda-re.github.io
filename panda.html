<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pandare.panda API documentation</title>
<meta name="description" content="This module simply contains the Panda class" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<!-- Bootstrap core CSS -->
<!--
<link href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css" rel="stylesheet">
-->
<!-- hand-crafted bootstrap navbar -->
<style>
.bg-light {
background-color: #f8f9fa!important;
}
.navbar {
position: relative;
display: -ms-flexbox;
display: flex;
-ms-flex-wrap: wrap;
flex-wrap: wrap;
-ms-flex-align: center;
align-items: center;
-ms-flex-pack: justify;
justify-content: space-between;
padding: .5rem 1rem;
}
.navbar-expand-lg {
-ms-flex-direction: row;
flex-direction: row;
-ms-flex-wrap: nowrap;
flex-wrap: nowrap;
-ms-flex-pack: start;
justify-content: flex-start;
}
navbar-light .navbar-brand {
color: rgba(0,0,0,.9);
}
.navbar-brand {
display: inline-block;
padding-top: .3125rem;
padding-bottom: .3125rem;
margin-right: 1rem;
font-size: 1.25rem;
line-height: inherit;
white-space: nowrap;
}
.navbar-nav {
display: -ms-flexbox;
display: flex;
-ms-flex-direction: column;
flex-direction: column;
padding-left: 0;
margin-bottom: 0;
list-style: none;
}
.navbar-expand-lg .navbar-nav {
-ms-flex-direction: row;
flex-direction: row;
}
.mr-auto {
margin-right: auto!important;
}
.navbar-expand-lg .navbar-collapse {
display: -ms-flexbox!important;
display: flex!important;
}
.navbar-collapse {
-ms-flex-preferred-size: 100%;
flex-basis: 100%;
-ms-flex-align: center;
align-items: center;
}
.navbar-light .navbar-brand {
color: rgba(0,0,0,.9);
}
.navbar a {
color: #007bff;
text-decoration: none;
background-color: transparent;
-webkit-text-decoration-skip: objects;
}
.navbar-expand-lg .navbar-nav .nav-link {
padding-right: .5rem;
padding-left: .5rem;
}
.navbar .navbar-nav {
margin: 0;
font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
font-size: 1rem;
font-weight: 400;
line-height: 1.5;
color: #212529;
}
.navbar-light .navbar-nav .active>.nav-link, .navbar-light .navbar-nav .nav-link.active, .navbar-light .navbar-nav .nav-link.show, .navbar-light .navbar-nav .show>.nav-link {
color: rgba(0,0,0,.9);
}
.navbar-light .navbar-nav .nav-link {
color: rgba(0,0,0,.5);
}
.nav-link {
display: block;
padding: .5rem 1rem;
}
</style>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-light">
<a class="navbar-brand" href="/">PANDA.re</a>
<div class="collapse navbar-collapse" id="navbarSupportedContent">
<ul class="navbar-nav mr-auto">
<li class="nav-item">
<a class="nav-link" href="//panda.re/">Home</a>
</li>
<li class="nav-item">
<a class="nav-link" target="_new" href="https://github.com/panda-re/panda">Github</a>
</li>
<li class="nav-item ">
<a class="nav-link" href="//panda.re/blog/">Blog</a>
</li>
<li class="nav-item ">
<a class="nav-link active" href="//docs.panda.re">Python Docs</a>
</li>
<li class="nav-item ">
<a class="nav-link" href="//panda.re/invite.php">Slack</a>
</li>
<!-- No resources tab here because we don't have real bootstrap -->
</div>
</nav>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pandare.panda</code></h1>
</header>
<section id="section-intro">
<p>This module simply contains the Panda class</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module simply contains the Panda class
&#34;&#34;&#34;

from sys import version_info, exit

if version_info[0] &lt; 3:
    print(&#34;Please run with Python 3!&#34;)
    exit(0)

import socket
import threading


import readline
# XXX: readline is unused but necessary. We need to load python
# readline, to preempt PANDA loading another version. PANDA
# seems to work with python&#39;s but not vice-versa. This allows for
# stdio interactions later (e.g., pdb, input())  without segfaults

from os.path import realpath, exists, abspath, isfile, dirname, join as pjoin
from os import dup, getenv, environ, path
from random import randint
from inspect import signature
from tempfile import NamedTemporaryFile
from time import time
from math import ceil
from inspect import signature
from struct import pack_into
from shlex import quote as shlex_quote
from time import sleep
from cffi import FFI

from .utils import progress, warn, make_iso, debug, blocking, GArrayIterator, plugin_list
from .taint import TaintQuery
from .panda_expect import Expect
from .asyncthread import AsyncThread
from .qcows import Qcows
from .arch import ArmArch, Aarch64Arch, MipsArch, X86Arch, X86_64Arch

# Might be worth importing and auto-initilizing a PLogReader
# object within Panda for the current architecture?
#from .plog import PLogReader


class Panda():
    &#39;&#39;&#39;
    This is the object used to interact with PANDA. Initializing it creates a virtual machine to interact with.
    &#39;&#39;&#39;

    def __init__(self, arch=&#34;i386&#34;, mem=&#34;128M&#34;,
            expect_prompt=None, # Regular expression describing the prompt exposed by the guest on a serial console. Used so we know when a running command has finished with its output
            serial_kwargs=None,
            os_version=None,
            qcow=None, # Qcow file to load
            os=&#34;linux&#34;,
            generic=None, # Helper: specify a generic qcow to use and set other arguments. Supported values: arm/ppc/x86_64/i386. Will download qcow automatically
            raw_monitor=False, # When set, don&#39;t specify a -monitor. arg Allows for use of -nographic in args with ctrl-A+C for interactive qemu prompt.
            extra_args=None):
        &#39;&#39;&#39;
        Construct a new `Panda` object.  Note that multiple Panda objects cannot coexist in the same Python instance.
        Args:
            arch: architecture string (e.g. &#34;i386&#34;, &#34;x86_64&#34;, &#34;arm&#34;, &#34;mips&#34;, &#34;mipsel&#34;)
            generic: specify a generic qcow to use from `pandare.qcows.SUPPORTED_IMAGES` and set all subsequent arguments. Will automatically download qcow if necessary.
            mem: size of memory for machine (e.g. &#34;128M&#34;, &#34;1G&#34;)
            expect_prompt: Regular expression describing the prompt exposed by the guest
                    on a serial console. Used so we know when a running command has finished
                    with its output.
            serial_kwargs: dict of additional arguments to pass to pandare.Expect (see signature of its constructor).
                    Note that `expect_prompt` is already passed to Expect as &#34;expectation&#34;.
                    If not explicitly given, &#34;unansi&#34; is set to True (simulates a subset of ANSI codes and attempts to
                    remove command strings repeated by the shell from the shell output).
            os_version: analagous to PANDA&#39;s -os argument (e.g, linux-32-debian:3.2.0-4-686-pae&#34;)
            os: type of OS (e.g. &#34;linux&#34;)
            qcow: path to a qcow file to load
            raw_monitor: When set, don&#39;t specify a -monitor. arg Allows for use of
                    -nographic in args with ctrl-A+C for interactive qemu prompt. Experts only!
            extra_args: extra arguments to pass to PANDA as either a string or an
                    array. (e.g. &#34;-nographic&#34; or [&#34;-nographic&#34;, &#34;-net&#34;, &#34;none&#34;])
        Returns:
            Panda: the created panda object
        &#39;&#39;&#39;
        self.arch_name = arch
        self.mem = mem
        self.os = os_version
        self.os_type = os
        self.qcow = qcow
        self.plugins = plugin_list(self)
        self.expect_prompt = expect_prompt
        self.lambda_cnt = 0
        self.__sighandler = None
        self.ending = False # True during end_analysis


        if isinstance(extra_args, str): # Extra args can be a string or array
            extra_args = extra_args.split()
        elif extra_args is None:
            extra_args = []

        # If specified, use a generic (x86_64, i386, arm, etc) qcow from MIT and ignore
        if generic:                                 # other args. See details in qcows.py
            print(&#34;using generic &#34; +str(generic))
            q = Qcows.get_qcow_info(generic)
            self.arch_name     = q.arch
            self.os       = q.os
            self.mem      = q.default_mem # Might clobber a specified argument, but required if you want snapshots
            self.qcow     = Qcows.get_qcow(generic)
            self.expect_prompt = q.prompt
            if q.extra_args:
                extra_args.extend(q.extra_args.split(&#34; &#34;))

        if self.qcow: # Otherwise we shuld be able to do a replay with no qcow but this is probably broken
            if not (exists(self.qcow)):
                print(&#34;Missing qcow &#39;{}&#39; Please go create that qcow and give it to the PANDA maintainers&#34;.format(self.qcow))

        # panda.arch is a subclass with architecture-specific functions

        self.arch = None # Keep this with the following docstring such that pydoc generats good docs for it; this is a useful variable!
        &#34;&#34;&#34;
        A reference to an auto-instantiated `pandare.arch.PandaArch` subclass (e.g., `pandare.arch.X86Arch`)
        &#34;&#34;&#34;

        if self.arch_name == &#34;i386&#34;:
            self.arch = X86Arch(self)
        elif self.arch_name == &#34;x86_64&#34;:
            self.arch = X86_64Arch(self)
        elif self.arch_name in [&#34;arm&#34;]:
            self.arch = ArmArch(self)
        elif self.arch_name in [&#34;aarch64&#34;]:
            self.arch = Aarch64Arch(self)
        elif self.arch_name in [&#34;mips&#34;, &#34;mipsel&#34;]:
            self.arch = MipsArch(self)
        else:
            raise ValueError(f&#34;Unsupported architecture {self.arch_name}&#34;)
        self.bits, self.endianness, self.register_size = self.arch._determine_bits()

        self.build_dir  = self._find_build_dir()
        environ[&#34;PANDA_DIR&#34;] = self.build_dir
        self.libpanda_path = pjoin(self.build_dir, &#34;{0}-softmmu/libpanda-{0}.so&#34;.format(self.arch_name))
        self.panda = self.libpanda_path # Necessary for realpath to work inside core-panda, may cause issues?

        self.ffi = self._do_types_import()

        self.libpanda = self.ffi.dlopen(self.libpanda_path)
        self.C = self.ffi.dlopen(None)

        # set OS name if we have one
        if self.os:
            self.set_os_name(self.os)

        # Setup argv for panda
        self.panda_args = [self.panda]
        biospath = realpath(pjoin(self.build_dir, &#34;pc-bios&#34;)) # XXX: necessary for network drivers for arm, so &#39;pc-bios&#39; is a misleading name
        self.panda_args.append(&#34;-L&#34;)
        self.panda_args.append(biospath)

        if self.qcow:
            self.panda_args.append(self.qcow)

        self.panda_args += extra_args

        # Configure memory options
        self.panda_args.extend([&#39;-m&#39;, self.mem])

        # Configure serial - if we have an expect_prompt set. Otherwise how can we know what guest cmds are outputting?
        if self.expect_prompt or self.expect_kwargs.get(&#39;expectation&#39;):
            self.serial_file = NamedTemporaryFile(prefix=&#34;pypanda_s&#34;).name
            self.serial_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            expect_kwargs = {&#39;expectation&#39;: self.expect_prompt, &#39;consume_first&#39;: False, &#39;unansi&#39;: True}
            if serial_kwargs:
                expect_kwargs.update(serial_kwargs)
            self.serial_console = Expect(&#39;serial&#39;, **expect_kwargs)
            self.panda_args.extend([&#39;-serial&#39;, &#39;unix:{},server,nowait&#39;.format(self.serial_file)])
        else:
            self.serial_file = None
            self.serial_socket = None
            self.serial_console = None

        # Configure monitor - Always enabled for now
        self.monitor_file = NamedTemporaryFile(prefix=&#34;pypanda_m&#34;).name
        self.monitor_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.raw_monitor = raw_monitor
        if not self.raw_monitor:
            # XXX don&#39;t forget to escape expectation regex parens!
            self.monitor_console = Expect(&#39;monitor&#39;, expectation=rb&#34;\(qemu\) &#34;, consume_first=True)
            self.panda_args.extend([&#39;-monitor&#39;, &#39;unix:{},server,nowait&#39;.format(self.monitor_file)])

        self.running = threading.Event()
        self.started = threading.Event()
        self.initializing = threading.Event()
        self.athread = AsyncThread(self.started) # athread manages actions that need to occur outside qemu&#39;s CPU loop

        # Callbacks
        self.register_cb_decorators()
        self.registered_callbacks = {} # name -&gt; {procname: &#34;bash&#34;, enabled: False, callback: None}

        # Register asid_changed CB if and only if a callback requires procname
        self._registered_asid_changed_internal_cb = False
        self._registered_mmap_cb = False

        self._initialized_panda = False
        self.disabled_tb_chaining = False
        self.taint_enabled = False
        self.taint_sym_enabled = False
        self.named_hooks = {}
        self.hook_list = []
        self.hook_list2 = {}
        self.mem_hooks = {}

        # Asid stuff
        self.current_asid_name = None
        self.asid_mapping = {}

        # Shutdown stuff
        self.exception = None # When set to an exn, we&#39;ll raise and exit
        self._in_replay = False

        # main_loop_wait functions and callbacks
        self.main_loop_wait_fnargs = [] # [(fn, args), ...]
        progress (&#34;Panda args: [&#34; + (&#34; &#34;.join(self.panda_args)) + &#34;]&#34;)
    # /__init__

    def _do_types_import(self):
        &#39;&#39;&#39;
        Import objects from panda_datatypes which are configured by the environment variables(?)
        Store these objects in self.callback and self.callback_dictionary

        Returns a handle to the FFI object for the libpanda object
        &#39;&#39;&#39;
        from importlib import import_module
        from .autogen.panda_datatypes import get_cbs
        panda_arch_support = import_module(f&#34;.autogen.panda_{self.arch_name}_{self.bits}&#34;,package=&#39;pandare&#39;)

        ffi = panda_arch_support.ffi
        self.callback, self.callback_dictionary = get_cbs(ffi)

        return ffi

    def _initialize_panda(self):
        &#39;&#39;&#39;
        After initializing the class, the user has a chance to do something
        (TODO: what? register callbacks? It&#39;s something important...) before we finish initializing
        &#39;&#39;&#39;
        self.libpanda._panda_set_library_mode(True)

        cenvp = self.ffi.new(&#34;char**&#34;, self.ffi.new(&#34;char[]&#34;, b&#34;&#34;))
        len_cargs = self.ffi.cast(&#34;int&#34;, len(self.panda_args))
        panda_args_ffi = [self.ffi.new(&#34;char[]&#34;, bytes(str(i),&#34;utf-8&#34;)) for i in self.panda_args]
        self.libpanda.panda_init(len_cargs, panda_args_ffi, cenvp)

        # Now we&#39;ve run qemu init so we can connect to the sockets for the monitor and serial
        if self.serial_console and not self.serial_console.is_connected():
            self.serial_socket.connect(self.serial_file)
            self.serial_console.connect(self.serial_socket)
        if not self.raw_monitor and not self.monitor_console.is_connected():
            self.monitor_socket.connect(self.monitor_file)
            self.monitor_console.connect(self.monitor_socket)

        # Register __main_loop_wait_callback
        self.register_callback(self.callback.main_loop_wait,
                self.callback.main_loop_wait(self.__main_loop_wait_cb), &#39;__main_loop_wait&#39;)

        self._initialized_panda = True


    def __main_loop_wait_cb(self):
        &#39;&#39;&#39;
        __main_loop_wait_cb is called at the start of the main cpu loop in qemu.
        This is a fairly safe place to call into qemu internals but watch out for deadlocks caused
        by your request blocking on the guest&#39;s execution. Here any functions in main_loop_wait_fnargs will be called
        &#39;&#39;&#39;
        try:
            # Then run any and all requested commands
            if len(self.main_loop_wait_fnargs) == 0: return
            #progress(&#34;Entering main_loop_wait_cb&#34;)
            for fnargs in self.main_loop_wait_fnargs:
                (fn, args) = fnargs
                ret = fn(*args)
            self.main_loop_wait_fnargs = []
        except KeyboardInterrupt:
            self.end_analysis()

    def _find_build_dir(self):
        &#39;&#39;&#39;
        Find build directory containing ARCH-softmmu/libpanda-ARCH.so and ARCH-softmmu/panda/plugins/
        1) check relative to file (in the case of installed packages)
        2) Check in../ ../../../build/
        3) raise RuntimeError
        &#39;&#39;&#39;
        archs = [&#39;i386&#39;, &#39;x86_64&#39;, &#39;arm&#39;, &#39;ppc&#39;]
        python_package = pjoin(*[dirname(__file__), &#34;data&#34;])
        local_build = realpath(pjoin(dirname(__file__), &#34;../../../../build&#34;))
        path_end = &#34;{0}-softmmu/libpanda-{0}.so&#34;.format(self.arch_name)

        pot_paths = [python_package, local_build]
        for potential_path in pot_paths:
            if isfile(pjoin(potential_path, path_end)):
                print(&#34;Loading libpanda from {}&#34;.format(potential_path))
                return potential_path

        searched_paths = &#34;\n&#34;.join([&#34;\t&#34;+p for p in  pot_paths])
        raise RuntimeError((&#34;Couldn&#39;t find libpanda-{}.so.\n&#34;
                            &#34;Did you built PANDA for this architecture?\n&#34;
                            &#34;Searched paths:\n{}&#34;
                           ).format(self.arch_name, searched_paths))


    def queue_main_loop_wait_fn(self, fn, args=[]):
        &#39;&#39;&#39;
        Queue a function to run at the next main loop
        fn is a function we want to run, args are arguments to apss to it
        &#39;&#39;&#39;
        self.main_loop_wait_fnargs.append((fn, args))

    def exit_cpu_loop(self):
        &#39;&#39;&#39;
        Stop cpu execution at nearest juncture.
        &#39;&#39;&#39;
        self.libpanda.panda_exit_loop = True

    def revert_async(self, snapshot_name): # In the next main loop, revert
        &#39;&#39;&#39;
        Request a snapshot revert, eventually. This is fairly dangerous
        because you don&#39;t know when it finishes. You should be using revert_sync
        from a blocking function instead
        &#39;&#39;&#39;
        print(&#34;WARNING: panda.revert_async may be deprecated in the near future&#34;)
        if debug:
            progress (&#34;Loading snapshot &#34; + snapshot_name)

        # Stop guest, queue up revert, then continue
        timer_start = time()
        self.vm_stop()
        charptr = self.ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
        self.queue_main_loop_wait_fn(self.libpanda.panda_revert, [charptr])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont)
        if debug:
            self.queue_main_loop_wait_fn(self._finish_timer, [timer_start, &#34;Loaded snapshot&#34;])

    def reset(self):
        &#34;&#34;&#34;In the next main loop, reset to boot&#34;&#34;&#34;
        if debug:
            progress (&#34;Resetting machine to start state&#34;)

        # Stop guest, queue up revert, then continue
        self.vm_stop()
        self.queue_main_loop_wait_fn(self.libpanda.panda_reset)
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont)

    def cont(self):
        &#39;&#39;&#39; Continue execution (run after vm_stop) &#39;&#39;&#39;
        self.libpanda.panda_cont()
        self.running.set()

    def vm_stop(self, code=4):
        &#39;&#39;&#39; Stop execution, default code means RUN_STATE_PAUSED &#39;&#39;&#39;
        self.libpanda.panda_stop(code)

    def snap(self, snapshot_name):
        &#39;&#39;&#39;
        Create snapshot with specified name

        Args:
            snapshot_name (str): name of the snapshot

        Returns:
            None
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Creating snapshot &#34; + snapshot_name)

        # Stop guest execution, queue up a snapshot, then continue
        timer_start = time()
        self.vm_stop()
        charptr = self.ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
        self.queue_main_loop_wait_fn(self.libpanda.panda_snap, [charptr])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont)
        if debug:
            self.queue_main_loop_wait_fn(self._finish_timer, [timer_start, &#34;Saved snapshot&#34;])

    def delvm(self, snapshot_name):
        &#39;&#39;&#39;
        Delete snapshot with specified name
        Args:
            snapshot_name (str): name of the snapshot

        Returns:
            None
        &#39;&#39;&#39;

        if debug:
            progress (&#34;Deleting snapshot &#34; + snapshot_name)

        # Stop guest, queue up delete, then continue
        self.vm_stop()
        charptr = self.ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
        self.queue_main_loop_wait_fn(self.libpanda.panda_delvm, [charptr])

    def _finish_timer(self, start, msg):
        &#39;&#39;&#39; Print how long some (main_loop_wait) task took &#39;&#39;&#39;
        t = time() - start
        print(&#34;{} in {1:.08f} seconds&#34;.format(msg, t))


    def enable_tb_chaining(self):
        &#39;&#39;&#39;
        This function enables translation block chaining in QEMU
        &#39;&#39;&#39;
        if debug:
            progress(&#34;Enabling TB chaining&#34;)
        self.disabled_tb_chaining = False
        self.libpanda.panda_enable_tb_chaining()

    def disable_tb_chaining(self):
        &#39;&#39;&#39;
        This function disables translation block chaining in QEMU
        &#39;&#39;&#39;
        if not self.disabled_tb_chaining:
            if debug:
                progress(&#34;Disabling TB chaining&#34;)
            self.disabled_tb_chaining = True
            self.libpanda.panda_disable_tb_chaining()

    def _setup_internal_signal_handler(self, signal_handler=None):
        def SigHandler(SIG,a,b):
            from signal import SIGINT, SIGHUP, SIGTERM
            if SIG == SIGINT:
                self.end_run_raise_signal = KeyboardInterrupt
                self.end_analysis()
            elif SIG == SIGHUP:
                self.end_run_raise_signal = KeyboardInterrupt
                self.end_analysis()
            elif SIG == SIGTERM:
                self.end_run_raise_signal = KeyboardInterrupt
                self.end_analysis()
            else:
                print(f&#34;PyPanda Signal handler received unhandled signal {SIG}&#34;)


        if signal_handler is not None:
            # store custom signal handler if requested1
            self.__sighandler = signal_handler

        if self._initialized_panda:
            # initialize and register signal handler only if panda is initialized
            self.__sighandler = (self.ffi.callback(&#34;void(int,void*,void*)&#34;, SigHandler)
                       if signal_handler is None and self.__sighandler is None
                       else self.ffi.callback(&#34;void(int,void*,void*)&#34;, self.__sighandler))

            self.libpanda.panda_setup_signal_handling(self.__sighandler)


    def run(self):
        &#39;&#39;&#39;
        This function starts our running PANDA instance from Python. At termination this function returns and the script continues to run after it.

        This function starts execution of the guest. It blocks until guest finishes.
        It also initializes panda object, clears main_loop_wait fns, and sets up internal callbacks.

        Args:
            None

        Returns:
            None: When emulation has finished due to guest termination, replay conclusion or a call to `Panda.end_analysis`
        &#39;&#39;&#39;

        if len(self.main_loop_wait_fnargs):
            if debug:
                print(&#34;Clearing prior main_loop_wait fns:&#34;, self.main_loop_wait_fnargs)
            self.main_loop_wait_fnargs = [] # [(fn, args), ...]

        self.ending = False

        if debug:
            progress (&#34;Running&#34;)

        self.initializing.set()
        if not self._initialized_panda:
            self._initialize_panda()
        self.initializing.clear()

        if not self.started.is_set():
            self.started.set()

        self.athread.ending = False

        # Ensure our internal CBs are always enabled
        self.enable_internal_callbacks()
        self._setup_internal_signal_handler()
        self.running.set()
        self.libpanda.panda_run() # Give control to panda
        self.running.clear() # Back from panda&#39;s execution (due to shutdown or monitor quit)
        self.delete_callbacks()
        self.libpanda.panda_unload_plugins() # Unload c plugins - should be safe now since exec has stopped
        self.plugins = plugin_list(self)
        # Write PANDALOG, if any
        #self.libpanda.panda_cleanup_record()
        if self._in_replay:
            self.reset()
        if hasattr(self, &#34;end_run_raise_signal&#34;):
            saved_exception = self.end_run_raise_signal
            del self.end_run_raise_signal
            raise saved_exception
        if hasattr(self, &#34;callback_exit_exception&#34;):
            saved_exception = self.callback_exit_exception
            del self.callback_exit_exception
            raise saved_exception
        if hasattr(self, &#34;blocking_queue_error&#34;):
            saved_exception = self.blocking_queue_error
            del self.blocking_queue_error
            raise saved_exception
        if hasattr(self, &#34;hook_exit_exception&#34;):
            saved_exception = self.hook_exit_exception
            del self.hook_exit_exception
            raise saved_exception


    def end_analysis(self):
        &#39;&#39;&#39;
        Stop running machine.

        Call from any thread to unload all plugins and stop all queued functions.
        If called from async thread or a callback, it will also unblock panda.run()

        Note here we use the async class&#39;s internal thread to process these
        without needing to wait for tasks in the main async thread
        &#39;&#39;&#39;
        self.athread.ending = True
        self.ending = True
        self.unload_plugins()
        if self.running.is_set() or self.initializing.is_set():

            # If we were running, stop the execution and check if we crashed
            self.queue_async(self.stop_run, internal=True)

    def record(self, recording_name, snapshot_name=None):
        &#34;&#34;&#34;Begins active recording with name provided.

        Args:
            recording_name (string): name of recording to save.
            snapshot_name (string, optional): Before recording starts restore to this snapshot name. Defaults to None.

        Raises:
            Exception: raises exception if there was an error starting recording.
        &#34;&#34;&#34;
        if snapshot_name == None:
            snapshot_name_ffi = self.ffi.NULL
        else:
            snapshot_name_ffi = self.ffi.new(&#34;char[]&#34;,snapshot_name.encode())
        recording_name_ffi = self.ffi.new(&#34;char[]&#34;, recording_name.encode())
        result = self.libpanda.panda_record_begin(recording_name_ffi,snapshot_name_ffi)
        res_string_enum = self.ffi.string(self.ffi.cast(&#34;RRCTRL_ret&#34;,result))
        if res_string_enum != &#34;RRCTRL_OK&#34;:
           raise Exception(f&#34;record method failed with RTCTL_ret {res_string_enum} ({result})&#34;)

    def end_record(self):
        &#34;&#34;&#34;Stop active recording.

        Raises:
            Exception: raises exception if there was an error stopping recording.
        &#34;&#34;&#34;
        result = self.libpanda.panda_record_end()
        res_string_enum = self.ffi.string(self.ffi.cast(&#34;RRCTRL_ret&#34;,result))
        if res_string_enum != &#34;RRCTRL_OK&#34;:
           raise Exception(f&#34;record method failed with RTCTL_ret {res_string_enum} ({result})&#34;)
    
    def recording_exists(self, name):
        &#39;&#39;&#39;
        Checks if a recording file exists on disk.

        Args:
            name (str): name of the recording to check for (e.g., `foo` which uses `foo-rr-snp` and `foo-rr-nondet.log`)
        
        Returns:
            boolean: true if file exists, false otherwise
        &#39;&#39;&#39;
        if exists(name + &#34;-rr-snp&#34;):
            return True

    def run_replay(self, replaypfx):
        &#39;&#39;&#39;
        Load a replay and run it. Starts PANDA execution and returns after end of VM execution.

        Args:
            replaypfx (str): Replay name/path (e.g., &#34;foo&#34; or &#34;./dir/foo&#34;)

        Returns:
            None
        &#39;&#39;&#39;
        if not isfile(replaypfx+&#34;-rr-snp&#34;) or not isfile(replaypfx+&#34;-rr-nondet.log&#34;):
            raise ValueError(&#34;Replay files not present to run replay of {}&#34;.format(replaypfx))

        self.ending = False

        if debug:
            progress (&#34;Replaying %s&#34; % replaypfx)

        charptr = self.ffi.new(&#34;char[]&#34;,bytes(replaypfx,&#34;utf-8&#34;))
        self.libpanda.panda_replay_begin(charptr)
        self._in_replay = True
        self.run()
        self._in_replay = False


    def end_replay(self):
        &#39;&#39;&#39;
        Terminates a currently running replay

            Returns:
                None

            Raises:
                Exception: raises exception if no replay is active or termination failed.
        &#39;&#39;&#39;

        if self._in_replay is False:
            raise Exception(&#34;Tried to terminate replay while not in replay mode!&#34;)

        result = self.libpanda.panda_replay_end()

        res_string_enum = self.ffi.string(self.ffi.cast(&#34;RRCTRL_ret&#34;,result))
        if res_string_enum != &#34;RRCTRL_OK&#34;:
           raise Exception(f&#34;ending record method failed with RTCTL_ret {res_string_enum} ({result})&#34;)


    def require(self, name):
        &#39;&#39;&#39;
        Load a C plugin with no arguments. Deprecated. Use load_plugin
        &#39;&#39;&#39;
        self.load_plugin(name, args={})

    def load_plugin(self, name, args={}):
        &#39;&#39;&#39;
        Load a C plugin, optionally with arguments

        Args:
            name (str): Name of plugin
            args (dict): Arguments matching key to value. e.g. {&#34;key&#34;: &#34;value&#34;} sets option `key` to `value`.

        Returns:
            None.
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Loading plugin %s&#34; % name),

        argstrs_ffi = []
        if isinstance(args, dict):
            for k,v in args.items():
                this_arg_s = &#34;{}={}&#34;.format(k,v)
                this_arg = self.ffi.new(&#34;char[]&#34;, bytes(this_arg_s, &#34;utf-8&#34;))
                argstrs_ffi.append(this_arg)

            n = len(args.keys())
        elif isinstance(args, list):
            for arg in args:
                this_arg = self.ffi.new(&#34;char[]&#34;, bytes(arg, &#34;utf-8&#34;))
                argstrs_ffi.append(this_arg)
            n = len(args)

        else:
            raise ValueError(&#34;Arguments to load plugin must be a list or dict of key/value pairs&#34;)

        # First set qemu_path so plugins can load (may be unnecessary after the first time)
        assert(self.panda), &#34;Unknown location of PANDA&#34;
        panda_name_ffi = self.ffi.new(&#34;char[]&#34;, bytes(self.panda,&#34;utf-8&#34;))
        self.libpanda.panda_set_qemu_path(panda_name_ffi)

        if len(argstrs_ffi):
            plugin_args = argstrs_ffi
        else:
            plugin_args = self.ffi.NULL

        charptr = self.ffi.new(&#34;char[]&#34;, bytes(name,&#34;utf-8&#34;))
        self.libpanda.panda_require_from_library(charptr, plugin_args, len(argstrs_ffi))
        self._load_plugin_library(name)

    def _procname_changed(self, cpu, name):
        for cb_name, cb in self.registered_callbacks.items():
            if not cb[&#34;procname&#34;]:
                continue
            if name == cb[&#34;procname&#34;] and not cb[&#39;enabled&#39;]:
                self.enable_callback(cb_name)
            if name != cb[&#34;procname&#34;] and cb[&#39;enabled&#39;]:
                self.disable_callback(cb_name)

    def unload_plugin(self, name):
        &#39;&#39;&#39;
        Unload plugin with given name.

        Args:
            name (str): Name of plug

        Returns:
            None
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Unloading plugin %s&#34; % name),
        name_ffi = self.ffi.new(&#34;char[]&#34;, bytes(name,&#34;utf-8&#34;))
        self.libpanda.panda_unload_plugin_by_name(name_ffi)

    def unload_plugins(self):
        &#39;&#39;&#39;
        Disable all python plugins and request to unload all c plugins
        at the next main_loop_wait.

        XXX: If called during shutdown/exit, c plugins won&#39;t be unloaded
        because the next main_loop_wait will never happen. Instead, call
        panda.panda_finish directly (which is done at the end of panda.run())
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Disabling all python plugins, unloading all C plugins&#34;)

        # First unload python plugins, should be safe to do anytime
        #for name in self.registered_callbacks.keys():
        while len(list(self.registered_callbacks)) &gt; 0:
            try:
                self.delete_callback(list(self.registered_callbacks.keys())[0])
            except IndexError:
                continue
            #self.disable_callback(name)

        # Then unload C plugins. May be unsafe to do except from the top of the main loop (taint segfaults otherwise)
        self.queue_main_loop_wait_fn(self.libpanda.panda_unload_plugins)

    def memsavep(self, file_out):
        &#39;&#39;&#39;
        Calls QEMU memsavep on your specified python file.
        &#39;&#39;&#39;
        # this part was largely copied from https://cffi.readthedocs.io/en/latest/ref.html#support-for-file

        file_out.flush()                 # make sure the file is flushed
        newfd = dup(file_out.fileno())   # make a copy of the file descriptor
        fileptr = self.C.fdopen(newfd, b&#34;w&#34;)
        self.libpanda.panda_memsavep(fileptr)
        self.C.fclose(fileptr)

    def physical_memory_read(self, addr, length, fmt=&#39;bytearray&#39;):
        &#39;&#39;&#39;
        Read guest physical memory. In the specified format. Note that the `ptrlist` format
        returns a list of integers, each of the specified architecture&#39;s pointer size.

        Args:
            addr (int): Address
            length (int): length of array you would like returned
            fmt (str): format for returned array. Options: &#39;bytearray&#39;, &#39;int&#39;, &#39;str&#39;, &#39;ptrlist&#39;

        Returns:
            Union[bytearray, int, str, list[int]]: memory data

        Raises:
            ValueError if memory access fails or fmt is unsupported
        &#39;&#39;&#39;
        return self._memory_read(None, addr, length, physical=True, fmt=fmt)

    def virtual_memory_read(self, cpu, addr, length, fmt=&#39;bytearray&#39;):
        &#39;&#39;&#39;
        Read guest virtual memory.

        Args:
            cpu (CPUState): CPUState structure
            addr (int): Address
            length (int): length of data you would like returned
            fmt: format for returned array. See `physical_memory_read`.

        Returns:
            Union[bytearray, int, str, list[int]]: memory data

        Raises:
            ValueError if memory access fails or fmt is unsupported
        &#39;&#39;&#39;

        return self._memory_read(cpu, addr, length, physical=False, fmt=fmt)

    def _memory_read(self, env, addr, length, physical=False, fmt=&#39;bytearray&#39;):
        &#39;&#39;&#39;
        Read but with an autogen&#39;d buffer
        Supports physical or virtual addresses
        Raises ValueError if read fails
        &#39;&#39;&#39;
        if not isinstance(addr, int):
            raise ValueError(f&#34;Unsupported read from address {repr(addr)}&#34;)

        buf = self.ffi.new(&#34;char[]&#34;, length)

        # Force CFFI to parse addr as an unsigned value. Otherwise we get OverflowErrors
        # when it decides that it&#39;s negative
        ptr_typ = f&#39;uint{self.bits}_t&#39;
        addr_u = int(self.ffi.cast(ptr_typ, addr))

        buf_a = self.ffi.cast(&#34;char*&#34;, buf)
        length_a = self.ffi.cast(&#34;int&#34;, length)
        if physical:
            err = self.libpanda.panda_physical_memory_read_external(addr_u, buf_a, length_a)
        else:
            err = self.libpanda.panda_virtual_memory_read_external(env, addr_u, buf_a, length_a)

        if err &lt; 0:
            raise ValueError(f&#34;Memory access failed with err={err}&#34;) # TODO: make a PANDA Exn class

        r = self.ffi.unpack(buf, length)
        if fmt == &#39;bytearray&#39;:
            return r
        elif fmt==&#39;int&#39;:
            return int.from_bytes(r, byteorder=self.endianness)  # XXX size better be small enough to pack into an int!
        elif fmt==&#39;str&#39;:
            return self.ffi.string(buf, length)
        elif fmt==&#39;ptrlist&#39;:
            # This one is weird. Chunmk the memory into byte-sequences of (self.bits/8) bytes and flip endianness as approperiate
            # return a list
            bytelen = int(self.bits/8)
            if (length % bytelen != 0):
                raise ValueError(f&#34;Memory of size {length} does not evenly divide into {bytelen} byte chunks&#34;)
            chunks = []
            for start in range(0, length, bytelen):
                data = r[start:start+bytelen]
                int_data = int.from_bytes(data, byteorder=self.endianness)
                chunks.append(int_data)
            return chunks

        else:
            raise ValueError(&#34;fmt={} unsupported&#34;.format(fmt))

    def physical_memory_write(self, addr, buf):
        &#39;&#39;&#39;
        Write guest physical memory.

        Args:
            addr (int): Address
            buf (bytestring):  byte string to write into memory

        Returns:
            bool: error
        &#39;&#39;&#39;
        return self._memory_write(None, addr, buf, physical=True)

    def virtual_memory_write(self, cpu, addr, buf):
        &#39;&#39;&#39;
        Write guest virtual memory.

        Args:
            cpu (CPUState): CPUState structure
            address (int): Address
            buf (bytestr): byte string to write into memory

        Returns:
            bool: error

        &#39;&#39;&#39;
        return self._memory_write(cpu, addr, buf, physical=False)

    def _memory_write(self, cpu, addr, buf, physical=False):
        &#39;&#39;&#39;
        Write a bytearray into memory at the specified physical/virtual address
        &#39;&#39;&#39;
        length = len(buf)
        c_buf = self.ffi.new(&#34;char[]&#34;,buf)
        buf_a = self.ffi.cast(&#34;char*&#34;, c_buf)
        length_a = self.ffi.cast(&#34;int&#34;, length)

        if not hasattr(self, &#34;_memcb&#34;): # XXX: Why do we enable memcbs for memory writes?
            self.enable_memcb()

        if physical:
            return self.libpanda.panda_physical_memory_write_external(addr, buf_a, length_a)
        else:
            return self.libpanda.panda_virtual_memory_write_external(cpu, addr, buf_a, length_a)

    def callstack_callers(self, lim, cpu): # XXX move into new directory, &#39;callstack&#39; ?
        &#39;&#39;&#39;
        Helper function for callstack_instr plugin
        Handle conversion and return get_callers from callstack_instr.
        &#39;&#39;&#39;
        if not &#34;callstack_instr&#34; in self.plugins:
            progress(&#34;enabling callstack_instr plugin&#34;)
            self.load_plugin(&#34;callstack_instr&#34;)

        callers = self.ffi.new(&#34;uint%d_t[%d]&#34; % (self.bits, lim))
        n = self.plugins[&#39;callstack_instr&#39;].get_callers(callers, lim, cpu)
        c = []
        for pc in callers:
            c.append(pc)
        return c

    def _load_plugin_library(self, name):
        if hasattr(self,&#34;__did_load_libpanda&#34;):
            libpanda_path_chr = self.ffi.new(&#34;char[]&#34;,bytes(self.libpanda_path, &#34;UTF-8&#34;))
            self.__did_load_libpanda = self.libpanda.panda_load_libpanda(libpanda_path_chr)
        if not name in self.plugins.keys():
            assert(isfile(pjoin(*[self.build_dir, self.arch_name+&#34;-softmmu&#34;, &#34;panda/plugins/panda_{}.so&#34;.format(name)])))
            library = self.ffi.dlopen(pjoin(*[self.build_dir, self.arch_name+&#34;-softmmu&#34;, &#34;panda/plugins/panda_{}.so&#34;.format(name)]))
            self.plugins[name] = library

    def queue_async(self, f, internal=False):
        &#39;&#39;&#39;
        Explicitly queue work in the asynchronous work queue.

        Args:
            f: A python function with no arguments to be called at a later time. The function should
            be decorated with `@pandare.blocking`. You generally want to use `panda.queue_blocking` over this function.

        Returns:
            None
        &#39;&#39;&#39;

        # this takes the blocking function and handles errors
        @blocking
        def wrapper():
            try:
                f()
            except Exception as e:
                self.blocking_queue_error = e
                self.end_analysis()


        # Keep the original function name instead of replacing it with &#39;wrapper&#39;
        wrapper.__name__ = f.__name__
        self.athread.queue(wrapper, internal=internal)

    def map_memory(self, name, size, address):

        &#39;&#39;&#39;
        Make a new memory region.

        Args:
            name (str): This is an internal reference name for this region. Must be unique.
            size (int): number of bytes the region should be.
            address (int): start address of region

        Returns:
            None
        &#39;&#39;&#39;

        name_c = self.ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
        size = ceil(size/1024)*1024 # Must be page-aligned
        return self.libpanda.map_memory(name_c, size, address)

    def read_str(self, cpu, ptr, max_length=None):
        &#39;&#39;&#39;
        Helper to read a null-terminated string from guest memory given a pointer and CPU state
        May return an exception if the call to panda.virtual_memory_read fails (e.g., if you pass a
        pointer to an unmapped page)

        Args:
            cpu (CPUState): CPUState structure
            ptr (int): Pointer to start of string
            max_length (int): Optional length to stop reading at

        Returns:
            string: Data read from memory

        &#39;&#39;&#39;
        r = b&#34;&#34;
        idx = 0
        while (max_length is None or idx &lt; max_length):
            next_char = self.virtual_memory_read(cpu, ptr, 1) # If this raises an exn, don&#39;t mask it
            if next_char == b&#34;\x00&#34;:
                break
            r += next_char
            ptr += 1
            idx += 1
        return r.decode(&#34;utf8&#34;, &#34;ignore&#34;)

    def to_unsigned_guest(self, x):
        &#39;&#39;&#39;
        Convert a singed python int to an unsigned int32/unsigned int64
        depending on guest bit-size

        Args:
            x (int): Python integer

        Returns:
            int: Python integer representing x as an unsigned value in the guest&#39;s pointer-size.
        &#39;&#39;&#39;
        import ctypes
        if self.bits == 32:
            return ctypes.c_uint32(x).value
        elif self.bits == 64:
            return ctypes.c_uint64(x).value
        else:
            raise ValueError(&#34;Unsupported number of bits&#34;)

    def from_unsigned_guest(self, x):
        &#39;&#39;&#39;
        Convert an unsigned int32/unsigned int64 from the guest
        (depending on guest bit-size) to a (signed) python int

        Args:
            x (int): Python integer representing an unsigned value in the guest&#39;s pointer-size

        Returns:
            int: Python integer representing x as a signed value
        &#39;&#39;&#39;
        if x &gt;= 2**(self.bits-1): # If highest bit is set, it&#39;s negative
            return (x - 2**self.bits)
        else: # Else it&#39;s positive
            return x

    def queue_blocking(self, func, queue=True):
        &#34;&#34;&#34;
        Decorator to mark a function as `blocking`, and (by default) queue it to run asynchronously.
        This should be used to mark functions that will drive guest execution. Functions will be run
        in the order they are defined. For more precise control, use `panda.queue_async`.


        ```
        @panda.queue_blocking
        def do_something():
            panda.revert_sync(&#39;root&#39;)
            print(panda.run_serial_cmd(&#39;whoami&#39;))
            panda.end_analysis()
        ```

        is equivalent to

        ```
        @blocking
        def run_whoami():
            panda.revert_sync(&#39;root&#39;)
            print(panda.run_serial_cmd(&#39;whoami&#39;))
            panda.end_analysis()

        panda.queue_async(run_whoami)
        ```

        Args:
            func (function): Function to queue
            queue (bool): Should function automatically be queued

        Returns:
            None

        &#34;&#34;&#34;
        f = blocking(func)
        if queue:
            self.queue_async(f)
        return f


    ########################## LIBPANDA FUNCTIONS ########################
    # Methods that directly pass data to/from PANDA with no extra logic beyond argument reformatting.
    def set_pandalog(self, name):
        &#39;&#39;&#39;
        Enable recording to a pandalog (plog) named `name`

        Args:
            name (str): filename to output data to

        Returns:
            None
        &#39;&#39;&#39;
        charptr = self.ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
        self.libpanda.panda_start_pandalog(charptr)

    def enable_memcb(self):
        &#39;&#39;&#39;
        Enable memory callbacks. Must be called for memory callbacks to work.
        pypanda enables this automatically with some callbacks.
        &#39;&#39;&#39;
        self._memcb = True
        self.libpanda.panda_enable_memcb()

    def disable_memcb(self):
        &#39;&#39;&#39;
        Disable memory callbacks. Must be enabled for memory callbacks to work.
        pypanda enables this automatically with some callbacks.
        &#39;&#39;&#39;
        self._memcb = False
        self.libpanda.panda_disable_memcb()

    def virt_to_phys(self, cpu, addr):
        &#39;&#39;&#39;
        Convert virtual address to physical address.

        Args:
            cpu (CPUState): CPUState struct
            addr (int): virtual address to convert

        Return:
            int: physical address
        &#39;&#39;&#39;
        return self.libpanda.panda_virt_to_phys_external(cpu, addr)

    def enable_plugin(self, handle):
        &#39;&#39;&#39;
        Enable plugin.

        Args:
            handle (int): pointer to handle returned by plugin

        Return:
            None
        &#39;&#39;&#39;
        self.libpanda.panda_enable_plugin(handle)

    def disable_plugin(self, handle):
        &#39;&#39;&#39;
        Disable plugin.

        Args:
            handle (int): pointer to handle returned by plugin

        Return:
            None
        &#39;&#39;&#39;
        self.libpanda.panda_disable_plugin(handle)

    def enable_llvm(self):
        &#39;&#39;&#39;
        Enables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
        &#39;&#39;&#39;
        self.libpanda.panda_enable_llvm()

    def disable_llvm(self):
        &#39;&#39;&#39;
        Disables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
        &#39;&#39;&#39;
        self.libpanda.panda_disable_llvm()

    def enable_llvm_helpers(self):
        &#39;&#39;&#39;
        Enables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
        &#39;&#39;&#39;
        self.libpanda.panda_enable_llvm_helpers()

    def disable_llvm_helpers(self):
        &#39;&#39;&#39;
        Disables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
        &#39;&#39;&#39;
        self.libpanda.panda_disable_llvm_helpers()

    def flush_tb(self):
        &#39;&#39;&#39;
        This function requests that the translation block cache be flushed as soon as possible. If running with translation block chaining turned off (e.g. when in LLVM mode or replay mode), this will happen when the current translation block is done executing.
        Flushing the translation block cache is additionally necessary if the plugin makes changes to the way code is translated. For example, by using panda_enable_precise_pc.
        &#39;&#39;&#39;
        return self.libpanda.panda_do_flush_tb()

    def enable_precise_pc(self):
        &#39;&#39;&#39;
        By default, QEMU does not update the program counter after every instruction.
        This function enables precise tracking of the program counter. After enabling precise PC tracking, the program counter will be available in env-&gt;panda_guest_pc and can be assumed to accurately reflect the guest state.
        &#39;&#39;&#39;
        self.libpanda.panda_enable_precise_pc()

    def disable_precise_pc(self):
        &#39;&#39;&#39;
        By default, QEMU does not update the program counter after every instruction.
        This function disables precise tracking of the program counter.
        &#39;&#39;&#39;
        self.libpanda.panda_disable_precise_pc()

    def in_kernel(self, cpustate):
        &#39;&#39;&#39;
        Returns true if the processor is in the privilege level corresponding to kernel mode for any of the PANDA supported architectures.
        Legacy alias for in_kernel_mode().
        &#39;&#39;&#39;
        return self.libpanda.panda_in_kernel_external(cpustate)

    def in_kernel_mode(self, cpustate):
        &#39;&#39;&#39;
        Check if the processor is running in priviliged mode.

        Args:
            cpu (CPUState): CPUState structure

        Returns:
            Bool: If the processor is in the privilege level corresponding to kernel mode
                  for the given architecture
        &#39;&#39;&#39;
        return self.libpanda.panda_in_kernel_mode_external(cpustate)

    def in_kernel_code_linux(self, cpustate):
        &#39;&#39;&#39;
        Check if the processor is running in linux kernelspace.

        Args:
            cpu (CPUState): CPUState structure

        Returns:
            Bool: If the processor is running in Linux kernel space code.
        &#39;&#39;&#39;
        return self.libpanda.panda_in_kernel_code_linux_external(cpustate)

    def g_malloc0(self, size):
        &#39;&#39;&#39;
        Helper function to call glib malloc

        Args:
            size (int): size to call with malloc

        Returns:
            buffer of the requested size from g_malloc
        &#39;&#39;&#39;
        return self.libpanda.g_malloc0(size)

    def current_sp(self, cpu):
        &#39;&#39;&#39;
        Get current stack pointer

        Args:
            cpu (CPUState): CPUState structure

        Return:
            int: Value of stack pointer
        &#39;&#39;&#39;
        return self.libpanda.panda_current_sp_external(cpu)

    def current_pc(self, cpu):
        &#39;&#39;&#39;
        Get current program counter

        Args:
            cpu (CPUState): CPUState structure

        Return:
            integer value of current program counter

        .. Deprecated:: Use panda.arch.get_pc(cpu) instead
        &#39;&#39;&#39;
        return self.libpanda.panda_current_pc(cpu)

    def current_asid(self, cpu):
        &#39;&#39;&#39;
        Get current Application Specific ID

        Args:
            cpu (CPUState): CPUState structure

        Returns:
            integer: value of current ASID
        &#39;&#39;&#39;
        return self.libpanda.panda_current_asid(cpu)

    def disas2(self, code, size):
        &#39;&#39;&#39;
        Call panda_disas to diasassemble an amount of code at a pointer.
        FIXME: seem to not match up to PANDA definition
        &#39;&#39;&#39;
        self.libpanda.panda_disas(code, size)

    def cleanup(self):
        &#39;&#39;&#39;
        Unload all plugins and close pandalog.

        Returns:
            None
        &#39;&#39;&#39;
        self.libpanda.panda_cleanup()

    def was_aborted(self):
        &#39;&#39;&#39;
        Returns true if panda was aborted.
        &#39;&#39;&#39;
        return self.libpanda.panda_was_aborted()

    def get_cpu(self):
        &#39;&#39;&#39;
        This function returns first_cpu CPUState object from QEMU.
        XXX: You rarely want this

        Returns:
            CPUState: cpu
        &#39;&#39;&#39;
        return self.libpanda.get_cpu()

    def garray_len(self, garray):
        &#39;&#39;&#39;
        Convenience function to get array length of glibc array.

        Args:
            g (garray): Pointer to a glibc array
                
        Returns:
            int: length of the array
        &#39;&#39;&#39;
        return self.libpanda.garray_len(garray)

    def panda_finish(self):
        &#39;&#39;&#39;
        Final stage call to underlying panda_finish with initialization.
        &#39;&#39;&#39;
        return self.libpanda.panda_finish()

    def rr_get_guest_instr_count(self):
        &#39;&#39;&#39;
        Returns record/replay guest instruction count.

        Returns:
            int: Current instruction count
        &#39;&#39;&#39;
        return self.libpanda.rr_get_guest_instr_count_external()

    ################### LIBQEMU Functions ############
    #Methods that directly pass data to/from QEMU with no extra logic beyond argument reformatting.
    #All QEMU function can be directly accessed by Python. These are here for convenience.
    # It&#39;s usally better to find a function name and look at the QEMU source for these functions.

    def drive_get(self, blocktype, bus, unit):
        &#39;&#39;&#39;
        Gets DriveInfo struct from user specified information.

        Args:
            blocktype: BlockInterfaceType structure
            bus: integer bus
            unit: integer unit

        Returns:
            DriveInfo struct
        &#39;&#39;&#39;
        return self.libpanda.drive_get(blocktype,bus,unit)

    def sysbus_create_varargs(self, name, addr):
        &#39;&#39;&#39;
        Returns DeviceState struct from user specified information
        Calls sysbus_create_varargs QEMU function.

        Args:
            name (str):
            addr (int): hwaddr

        Returns:
            DeviceState struct
        &#39;&#39;&#39;
        return self.libpanda.sysbus_create_varargs(name,addr,ffi.NULL)

    def cpu_class_by_name(self, name, cpu_model):
        &#39;&#39;&#39;
        Gets cpu class from name.
        Calls cpu_class_by_name QEMU function.

        Args:
            name: typename from python string
            cpu_model: string specified cpu model

        Returns:
            ObjectClass struct
        &#39;&#39;&#39;
        return self.libpanda.cpu_class_by_name(name, cpu_model)

    def object_class_by_name(self, name):
        &#39;&#39;&#39;
        Returns class as ObjectClass from name specified.
        Calls object_class_by_name QEMU function.

        Args
            name (str): string defined by user

        Returns:
            struct as specified by name
        &#39;&#39;&#39;
        return self.libpanda.object_class_by_name(name)

    def object_property_set_bool(self, obj, value, name):
        &#39;&#39;&#39;
        Writes a bool value to a property.
        Calls object_property_set_bool QEMU function.

        Args::
            value: the value to be written to the property
            name: the name of the property
            errp: returns an error if this function fails

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.object_property_set_bool(obj,value,name,self.libpanda.error_abort)

    def object_class_get_name(self, objclass):
        &#39;&#39;&#39;
        Gets String QOM typename from object class.
        Calls object_class_get_name QEMU function.

        Args::
            objclass: class to obtain the QOM typename for.

        Returns:
            String QOM typename for klass.
        &#39;&#39;&#39;
        return self.libpanda.object_class_get_name(objclass)

    def object_new(self, name):
        &#39;&#39;&#39;
        Creates a new QEMU object from typename.
        This function will initialize a new object using heap allocated memory.
        The returned object has a reference count of 1, and will be freed when
        the last reference is dropped.
        Calls object_new QEMU function.

        Args:
            name (str): The name of the type of the object to instantiate.

        Returns:
            The newly allocated and instantiated object.
        &#39;&#39;&#39;
        return self.libpanda.object_new(name)

    def object_property_get_bool(self, obj, name):
        &#39;&#39;&#39;
        Pull boolean from object.
        Calls object_property_get_bool QEMU function.

        Args:
            obj: the object
            name: the name of the property

        Returns:
            the value of the property, converted to a boolean, or NULL if an error occurs (including when the property value is not a bool).
        &#39;&#39;&#39;
        return self.libpanda.object_property_get_bool(obj,name,self.libpanda.error_abort)

    def object_property_set_int(self,obj, value, name):
        &#39;&#39;&#39;
        Set integer in QEMU object. Writes an integer value to a property.
        Calls object_property_set_int QEMU function.

        Args:
            value: the value to be written to the property
            name: the name of the property

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.object_property_set_int(obj, value, name, self.libpanda.error_abort)

    def object_property_get_int(self, obj, name):
        &#39;&#39;&#39;
        Gets integer in QEMU object. Reads an integer value from this property.
        Calls object_property_get_int QEMU function.

            Paramaters:
                obj: the object
                name: the name of the property

            Returns:
                the value of the property, converted to an integer, or negative if an error occurs (including when the property value is not an integer).
        &#39;&#39;&#39;
        return self.libpanda.object_property_get_int(obj, name, self.libpanda.error_abort)

    def object_property_set_link(self, obj, val, name):
        &#39;&#39;&#39;
        Writes an object&#39;s canonical path to a property.
        Calls object_property_set_link QEMU function.

        Args:
            value: the value to be written to the property
            name: the name of the property
            errp: returns an error if this function fails

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.object_property_set_link(obj,val,name,self.libpanda.error_abort)

    def object_property_get_link(self, obj, name):
        &#39;&#39;&#39;
        Reads an object&#39;s canonical path to a property.
        Calls object_property_get_link QEMU function.

        Args:
            obj: the object
            name: the name of the property
            errp: returns an error if this function fails

        Returns:
            the value of the property, resolved from a path to an Object, or NULL if an error occurs (including when the property value is not a string or not a valid object path).
        &#39;&#39;&#39;
        return self.libpanda.object_property_get_link(obj,name,self.libpanda.error_abort)

    def object_property_find(self, obj, name):
        &#39;&#39;&#39;
        Look up a property for an object and return its #ObjectProperty if found.
        Calls object_property_find QEMU function.

        Args:
            obj: the object
            name: the name of the property
            errp: returns an error if this function fails

        Returns:
            struct ObjectProperty pointer
        &#39;&#39;&#39;
        return self.libpanda.object_property_find(obj,name,ffi.NULL)

    def memory_region_allocate_system_memory(self, mr, obj, name, ram_size):
        &#39;&#39;&#39;
        Allocates Memory region by user specificiation.
        Calls memory_region_allocation_system_memory QEMU function.

        Args:
            mr: MemoryRegion struct
            obj: Object struct
            name (str): Region name
            ram_size (int): RAM size

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.memory_region_allocate_system_memory(mr, obj, name, ram_size)

    def memory_region_add_subregion(self, mr, offset, sr):
        &#39;&#39;&#39;
        Calls memory_region_add_subregion from QEMU.
        memory_region_add_subregion: Add a subregion to a container.

        Adds a subregion at @offset.  The subregion may not overlap with other
        subregions (except for those explicitly marked as overlapping).  A region
        may only be added once as a subregion (unless removed with
        memory_region_del_subregion()); use memory_region_init_alias() if you
        want a region to be a subregion in multiple locations.

        Args:
            mr: the region to contain the new subregion; must be a container initialized with memory_region_init().
            offset: the offset relative to @mr where @subregion is added.
            subregion: the subregion to be added.

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.memory_region_add_subregion(mr,offset,sr)

    def memory_region_init_ram_from_file(self, mr, owner, name, size, share, path):
        &#39;&#39;&#39;
        Calls memory_region_init_ram_from_file from QEMU.
        memory_region_init_ram_from_file:  Initialize RAM memory region with a mmap-ed backend.

        Args:
            mr: the #MemoryRegion to be initialized.
            owner: the object that tracks the region&#39;s reference count
            name: the name of the region.
            size: size of the region.
            share: %true if memory must be mmaped with the MAP_SHARED flag
            path: the path in which to allocate the RAM.
            errp: pointer to Error*, to store an error if it happens.

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.memory_region_init_ram_from_file(mr, owner, name, size, share, path, self.libpanda.error_fatal)

    def create_internal_gic(self, vbi, irqs, gic_vers):
        return self.libpanda.create_internal_gic(vbi, irqs, gic_vers)

    def create_one_flash(self, name, flashbase, flashsize, filename, mr):
        return self.libpanda.create_one_flash(name, flashbase, flashsize, filename, mr)

    def create_external_gic(self, vbi, irqs, gic_vers, secure):
        return self.libpanda.create_external_gic(vbi, irqs, gic_vers, secure)

    def create_virtio_devices(self, vbi, pic):
        return self.libpanda.create_virtio_devices(vbi, pic)

    def arm_load_kernel(self, cpu, bootinfo):
        return self.libpanda.arm_load_kernel(cpu, bootinfo)

    def error_report(self, s):
        return self.libpanda.error_report(s)

    def get_system_memory(self):
        return self.libpanda.get_system_memory()

    def lookup_gic(self,n):
        return self.libpanda.lookup_gic(n)

    ##################### OSI FUNCTIONS ###########
    #Convenience functions to interact with the Operating System Instrospection (OSI) class of plugins.

    def set_os_name(self, os_name):
        &#34;&#34;&#34;
        Set OS target. Equivalent to &#34;-os&#34; flag on the command line. Matches the form of:

            &#34;windows[-_]32[-_]xpsp[23]&#34;,
            &#34;windows[-_]32[-_]7&#34;,
            &#34;windows[-_]32[-_]2000&#34;,
            &#34;linux[-_]32[-_].+&#34;,
            &#34;linux[-_]64[-_].+&#34;,

            Args:
                os_name (str): Name that matches the format for the os flag.

            Returns:
                None
        &#34;&#34;&#34;
        os_name_new = self.ffi.new(&#34;char[]&#34;, bytes(os_name, &#34;utf-8&#34;))
        self.libpanda.panda_set_os_name(os_name_new)


    def get_mappings(self, cpu):
        &#39;&#39;&#39;
        Get all active memory mappings in the system.

        Requires: OSI

        Args:
            cpu: CPUState struct

        Returns:
            pandare.utils.GArrayIterator: iterator of OsiModule structures
        &#39;&#39;&#39;
        current = self.plugins[&#39;osi&#39;].get_current_process(cpu)
        maps = self.plugins[&#39;osi&#39;].get_mappings(cpu, current)
        map_len = self.garray_len(maps)
        return GArrayIterator(self.plugins[&#39;osi&#39;].get_one_module, maps, map_len, self.plugins[&#39;osi&#39;].cleanup_garray)

    def get_processes(self, cpu):
        &#39;&#39;&#39;
        Get all running processes in the system. Includes kernel modules on Linux.

        Requires: OSI

        Args:
            cpu: CPUState struct

        Returns:
            pandare.utils.GArrayIterator: iterator of OsiProc structures
        &#39;&#39;&#39;
        processes = self.plugins[&#39;osi&#39;].get_processes(cpu)
        processes_len = self.garray_len(processes)
        return GArrayIterator(self.plugins[&#39;osi&#39;].get_one_proc, processes, processes_len, self.plugins[&#39;osi&#39;].cleanup_garray)

    def get_processes_dict(self, cpu):
        &#39;&#39;&#39;
        Get all running processes for the system at this moment in time as a dictionary.

        The dictionary maps proceses by their PID. Each mapping returns a dictionary containing the process name, its pid,
        and its parent pid (ppid).

        Requires: OSI

        Args:
            cpu: CPUState struct

        Returns:
            Dict: processes as described above
        &#39;&#39;&#39;

        procs = {} #pid: {name: X, pid: Y, parent_pid: Z})

        for proc in self.get_processes(cpu):
            assert(proc != self.ffi.NULL)
            assert(proc.pid not in procs)
            procs[proc.pid] = {&#34;name&#34;: self.ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;), &#39;pid&#39;: proc.pid, &#39;parent_pid&#39;: proc.ppid}
            assert(not (proc.pid != 0 and proc.pid == proc.ppid)) # No cycles allowed other than at 0
        return procs

    def get_process_name(self, cpu):
        &#39;&#39;&#39;
        Get the name of the current process. May return None if OSI cannot identify the current process
        &#39;&#39;&#39;
        proc = self.plugins[&#39;osi&#39;].get_current_process(cpu)
        if proc == self.ffi.NULL or proc.name == self.ffi.NULL:
            return None

        procname = self.ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;)
        return self.ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;)


    ################## PYPERIPHERAL FUNCTIONS #####################
    # Pyperipherals are objects which handle mmio read/writes using the PANDA callback infrastructure.
    # Under the hood, they use the cb_unassigned_io_read/cb_unassigned_io_write callbacks.
    # A python peripheral itself is an object which exposes the following functions:
    #     write_memory(self, address, size, value)
    #     read_memory(self, address, size)
    # And has at least the following attributes:
    #     address
    #     size

    # One example for such a python object are avatar2&#39;s AvatarPeripheral.
    def _addr_to_pyperipheral(self, address):
        &#34;&#34;&#34;
        Returns the python peripheral for a given address, or None if no
        peripheral is registered for that address
        &#34;&#34;&#34;

        for pp in self.pyperipherals:
            if pp.address &lt;= address &lt; pp.address + pp.size:
                return pp
        return None

    def _validate_object(self, object):
        # This function makes sure that the object exposes the right interfaces

        if not hasattr(object, &#34;address&#34;) or not isinstance(object.address, int):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing or non-int `address` attribute&#34;
                ).format(str(object.__repr__()))
            )

        if not hasattr(object, &#34;size&#34;) or not isinstance(object.size, int):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing or non-int `address` attribute&#34;
                ).format(object.__repr__())
            )

        if not hasattr(object, &#34;read_memory&#34;):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing read_memory function&#34;
                ).format(object.__repr__())
            )

        params = list(signature(object.read_memory).parameters)
        if params[0] != &#34;address&#34; or params[1] != &#34;size&#34;:
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Invalid function signature for read_memory&#34;
                ).format(object.__repr__())
            )

        if not hasattr(object, &#34;write_memory&#34;):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing write_memory function&#34;
                ).format(object.__repr__())
            )

        params = list(signature(object.write_memory).parameters)
        if params[0] != &#34;address&#34; or params[1] != &#34;size&#34; or params[2] != &#34;value&#34;:
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Invalid function signature for write_memory&#34;
                ).format(object.__repr__())
            )

        # Ensure object is not overlapping with any other pyperipheral
        if (
            self._addr_to_pyperipheral(object.address) is not None
            or self._addr_to_pyperipheral(object.address + object.size) is not None
        ):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34; &#34;Overlapping memories!&#34;
                ).format(object.__repr__())
            )

        return True

    def pyperiph_read_cb(self, cpu, pc, physaddr, size, val_ptr):
        pp = self._addr_to_pyperipheral(physaddr)
        if pp is None:
            return False

        val = pp.read_memory(physaddr, size)
        buf = self.ffi.buffer(val_ptr, size)

        fmt = &#34;{}{}&#34;.format(self._end2fmt[self.endianness], self._num2fmt[size])

        pack_into(fmt, buf, 0, val)

        return True

    def pyperiph_write_cb(self, cpu, pc, physaddr, size, val):
        pp = self._addr_to_pyperipheral(physaddr)
        if pp is None:
            return False

        pp.write_memory(physaddr, size, val)
        return True

    def register_pyperipheral(self, object):
        &#34;&#34;&#34;
        Registers a python peripheral, and the necessary attributes to the
        panda-object, if not present yet.
        &#34;&#34;&#34;

        # if we are the first pyperipheral, register the pp-dict
        if not hasattr(self, &#34;pyperipherals&#34;):
            self.pyperipherals = []
            self.pyperipherals_registered_cb = False
            self._num2fmt = {1: &#34;B&#34;, 2: &#34;H&#34;, 4: &#34;I&#34;, 8: &#34;Q&#34;}
            self._end2fmt = {&#34;little&#34;: &#34;&lt;&#34;, &#34;big&#34;: &#34;&gt;&#34;}

        self._validate_object(object)

        if self.pyperipherals_registered_cb is False:
            self.register_callback(
                self.callback.unassigned_io_read,
                self.callback.unassigned_io_read(self.pyperiph_read_cb),
                &#34;pyperipheral_read_callback&#34;,
            )

            self.register_callback(
                self.callback.unassigned_io_write,
                self.callback.unassigned_io_write(self.pyperiph_write_cb),
                &#34;pyperipheral_write_callback&#34;,
            )

            self.pyperipherals_registered_cb = True

        self.pyperipherals.append(object)

    def unregister_pyperipheral(self, pyperiph):
        &#34;&#34;&#34;
        deregisters a python peripheral.
        The pyperiph parameter can be either an object, or an address
        Returns true if the pyperipheral was successfully removed, else false.
        &#34;&#34;&#34;

        if isinstance(pyperiph, int) is True:
            pp = self._addr_to_pyperipheral(pyperiph)
            if pp is None:
                return False
        else:
            if pyperiph not in self.pyperipherals:
                return False
            pp = pyperiph

        self.pyperipherals.remove(pp)

        # If we dont have any pyperipherals left, unregister callbacks
        if len(self.pyperipherals) == 0:
            self.disable_callback(&#34;pyperipheral_read_callback&#34;, forever=True)
            self.disable_callback(&#34;pyperipheral_write_callback&#34;, forever=True)
            self.pyperipherals_registered_cb = False
        return True

    ############## TAINT FUNCTIONS ###############
    # Convenience methods for interacting with the taint subsystem.
    def taint_enable(self, cont=True):
        &#34;&#34;&#34;
        Inform python that taint is enabled.
        &#34;&#34;&#34;
        if not self.taint_enabled:
            progress(&#34;taint not enabled -- enabling&#34;)
            self.vm_stop()
            self.load_plugin(&#34;taint2&#34;)
#            self.queue_main_loop_wait_fn(self.load_plugin, [&#34;taint2&#34;])
            self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_enable_taint, [])
            if cont:
                self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])
            self.taint_enabled = True

    # label all bytes in this register.
    # or at least four of them
    def taint_label_reg(self, reg_num, label):
        self.taint_enable(cont=False)
        #if debug:
        #    progress(&#34;taint_reg reg=%d label=%d&#34; % (reg_num, label))

        # XXX must ensure labeling is done in a before_block_invalidate that rets 1
        #     or some other safe way where the main_loop_wait code will always be run
        #self.stop()
        for i in range(self.register_size):
            self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_label_reg, [reg_num, i, label])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])

    def taint_label_ram(self, addr, label):
        self.taint_enable(cont=False)
        #if debug:
            #progress(&#34;taint_ram addr=0x%x label=%d&#34; % (addr, label))

        # XXX must ensure labeling is done in a before_block_invalidate that rets 1
        #     or some other safe way where the main_loop_wait code will always be run
        #self.stop()
        self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_label_ram, [addr, label])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])

    # returns true if any bytes in this register have any taint labels
    def taint_check_reg(self, reg_num):
        if not self.taint_enabled: return False
#        if debug:
#            progress(&#34;taint_check_reg %d&#34; % (reg_num))
        for offset in range(self.register_size):
            if self.plugins[&#39;taint2&#39;].taint2_query_reg(reg_num, offset) &gt; 0:
                return True

    # returns true if this physical address is tainted
    def taint_check_ram(self, addr):
        if not self.taint_enabled: return False
        if self.plugins[&#39;taint2&#39;].taint2_query_ram(addr) &gt; 0:
            return True

    def taint_get_reg(self, reg_num):
        &#39;&#39;&#39;
        Returns array of results, one for each byte in this register
        None if no taint.  QueryResult struct otherwise
        &#39;&#39;&#39;
        if not self.taint_enabled: return None
        if debug:
            progress(&#34;taint_get_reg %d&#34; % (reg_num))
        res = []
        for offset in range(self.register_size):
            if self.plugins[&#39;taint2&#39;].taint2_query_reg(reg_num, offset) &gt; 0:
                query_res = self.ffi.new(&#34;QueryResult *&#34;)
                self.plugins[&#39;taint2&#39;].taint2_query_reg_full(reg_num, offset, query_res)
                tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;], self.ffi)
                res.append(tq)
            else:
                res.append(None)
        return res

    # returns array of results, one for each byte in this register
    # None if no taint.  QueryResult struct otherwise
    def taint_get_ram(self, addr):
        if not self.taint_enabled: return None
        if self.plugins[&#39;taint2&#39;].taint2_query_ram(addr) &gt; 0:
            query_res = self.ffi.new(&#34;QueryResult *&#34;)
            self.plugins[&#39;taint2&#39;].taint2_query_ram_full(addr, query_res)
            tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;], self.ffi)
            return tq
        else:
            return None

    # returns true if this laddr is tainted
    def taint_check_laddr(self, addr, off):
        if not self.taint_enabled: return False
        if self.plugins[&#39;taint2&#39;].taint2_query_laddr(addr, off) &gt; 0:
            return True

    # returns array of results, one for each byte in this laddr
    # None if no taint.  QueryResult struct otherwise
    def taint_get_laddr(self, addr, offset):
        if not self.taint_enabled: return None
        if self.plugins[&#39;taint2&#39;].taint2_query_laddr(addr, offset) &gt; 0:
            query_res = self.ffi.new(&#34;QueryResult *&#34;)
            self.plugins[&#39;taint2&#39;].taint2_query_laddr_full(addr, offset, query_res)
            tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;], self.ffi)
            return tq
        else:
            return None

    def taint_sym_enable(self, cont=True):
        &#34;&#34;&#34;
        Inform python that taint is enabled.
        &#34;&#34;&#34;
        if not self.taint_enabled:
            progress(&#34;taint symbolic not enabled -- enabling&#34;)
            self.vm_stop()
            self.load_plugin(&#34;taint2&#34;)
#            self.queue_main_loop_wait_fn(self.load_plugin, [&#34;taint2&#34;])
        if not self.taint_sym_enabled:
            self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_enable_sym, [])
            if cont:
                self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])
            self.taint_enabled = True

    def taint_sym_label_ram(self, addr, label):
        self.taint_sym_enable(cont=False)
        #if debug:
            #progress(&#34;taint_ram addr=0x%x label=%d&#34; % (addr, label))

        # XXX must ensure labeling is done in a before_block_invalidate that rets 1
        #     or some other safe way where the main_loop_wait code will always be run
        #self.stop()
        self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_sym_label_ram, [addr, label])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])

    # label all bytes in this register.
    # or at least four of them
    def taint_sym_label_reg(self, reg_num, label):
        self.taint_sym_enable(cont=False)
        #if debug:
        #    progress(&#34;taint_reg reg=%d label=%d&#34; % (reg_num, label))

        # XXX must ensure labeling is done in a before_block_invalidate that rets 1
        #     or some other safe way where the main_loop_wait code will always be run
        #self.stop()
        for i in range(self.register_size):
            self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_sym_label_reg, [reg_num, i, label])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])


    ############ Volatility mixins
    &#34;&#34;&#34;
    Utilities to integrate Volatility with PANDA. Highly experimental.
    &#34;&#34;&#34;

    def make_panda_file_handler(self, debug=False):
        &#39;&#39;&#39;
        Constructs a file and file handler that volatility can&#39;t ignore to back by PANDA physical memory
        &#39;&#39;&#39;
        from urllib.request import BaseHandler
        if &#39;PandaFileHandler&#39; in globals():  # already initialized
            return
        panda = self

        class PandaFile(object):
            def __init__(self, length, panda):
                self.pos = 0
                self.length = length
                self.closed = False
                self.mode = &#34;rb&#34;
                self.name = &#34;/tmp/panda.panda&#34;
                self.panda = panda
                self.classname = type(self).__name__

            def readable(self):
                return self.closed

            def read(self, size=1):
                if self.panda.bits == 32 and self.panda.arch_name == &#34;i386&#34;:
                    data = self.panda.physical_memory_read(
                        self.pos &amp; 0xfffffff, size)
                else:
                    data = self.panda.physical_memory_read(self.pos, size)
                if debug:
                    print(self.classname+&#34;: Reading &#34; +
                          str(size)+&#34; bytes from &#34;+hex(self.pos))
                self.pos += size
                return data

            def peek(self, size=1):
                return self.panda.physical_memory_read(self.pos, size)

            def seek(self, pos, whence=0):
                if whence == 0:
                    self.pos = pos
                elif whence == 1:
                    self.pos += pos
                else:
                    self.pos = self.length - pos
                if self.pos &gt; self.length:
                    print(self.classname+&#34;: We&#39;ve gone off the deep end&#34;)
                if debug:
                    print(self.classname+&#34; Seeking to address &#34;+hex(self.pos))

            def tell(self):
                return self.pos

            def close(self):
                self.closed = True

        class PandaFileHandler(BaseHandler):
            def default_open(self, req):
                if &#39;panda.panda&#39; in req.full_url:
                    length = panda.libpanda.ram_size
                    if length &gt; 0xc0000000:
                        length += 0x40000000  # 3GB hole
                    if debug:
                        print(type(self).__name__ +
                              &#34;: initializing PandaFile with length=&#34;+hex(length))
                    return PandaFile(length=length, panda=panda)
                else:
                    return None

            def file_close(self):
                return True

        globals()[&#34;PandaFileHandler&#34;] = PandaFileHandler

    def get_volatility_symbols(self, debug=False):
        try:
            from .volatility_cli_classes import CommandLineMoreEfficient
            from volatility.framework import contexts
            from volatility.framework.layers.linear import LinearlyMappedLayer
            from volatility.framework.automagic import linux
        except ImportError:
            print(&#34;Warning: Failed to import volatility&#34;)
            return None
        if &#34;linux&#34; in self.os_type:
            if not hasattr(self, &#34;_vmlinux&#34;):
                self.make_panda_file_handler(debug=debug)
                constructed_original = CommandLineMoreEfficient().run()
                linux.LinuxUtilities.aslr_mask_symbol_table(
                    constructed_original.context, constructed_original.config[&#39;vmlinux&#39;], constructed_original.config[&#39;primary&#39;])
                self._vmlinux = contexts.Module(
                    constructed_original.context, constructed_original.config[&#39;vmlinux&#39;], constructed_original.config[&#39;primary&#39;], 0)
            else:
                LinearlyMappedLayer.read.cache_clear()  # smearing technique
            return self._vmlinux
        else:
            print(&#34;Unsupported.&#34;)
            return None

    def run_volatility(self, plugin, debug=False):
        try:
            from .volatility_cli_classes import CommandLineRunFullCommand, StringTextRenderer
        except ImportError:
            print(&#34;Warning: Failed to import volatility&#34;)
            return None
        self.make_panda_file_handler(debug=debug)
        cmd = CommandLineRunFullCommand().run(&#34;-q -f panda.panda &#34; + plugin)
        output = StringTextRenderer().render(cmd.run())
        return output

    ########## BLOCKING MIXINS ############
    &#39;&#39;&#39;
    Utilities to provide blocking interactions with PANDA. This includes serial and monitor interactions as well as file copy to the guest.
    XXX: Do not call any of the following from the main thread- they depend on the CPU loop running
    &#39;&#39;&#39;
    @blocking
    def stop_run(self):
        &#39;&#39;&#39;
        From a blocking thread, request vl.c loop to break. Returns control flow in main thread.
        In other words, once this is called, panda.run() will finish and your main thread will continue.
        If you also want to unload plugins, use end_analysis instead

        XXX: This doesn&#39;t work in replay mode
        &#39;&#39;&#39;
        self.libpanda.panda_break_vl_loop_req = True

    @blocking
    def run_serial_cmd(self, cmd, no_timeout=False, timeout=None):
        &#39;&#39;&#39;
        Run a command inside the guest through a terminal exposed over a serial port. Can only be used if your guest is configured in this way

        Guest output will be analyzed until we see the expect_prompt regex printed (i.e., the PS1 prompt)

        Args:
            cmd: command to run.
            timeout: maximum time to wait for the command to finish
            no_timeout: if set, don&#39;t ever timeout

        Returns:
            String: all the output (stdout + stderr) printed after typing your command and pressing enter until the next prompt was printed.
        &#39;&#39;&#39;

        if timeout is None:
            timeout = 30

        if self.serial_console is None:
            raise RuntimeError(&#34;Cannot run serial commands without providing PANDA an expect_prompt&#34;)
        self.running.wait() # Can only run serial when guest is running
        self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
        if no_timeout:
            result = self.serial_console.expect(timeout=9999) # &#34;Don&#39;t ever timeout&#34; above is a bit of an exaggeration
        else:
            result = self.serial_console.expect(timeout=timeout)
        return result

    @blocking
    def run_serial_cmd_async(self, cmd, delay=1):
        &#39;&#39;&#39;
        Type a command and press enter in the guest. Return immediately. No results available
        Only use this if you know what you&#39;re doing!
        &#39;&#39;&#39;
        self.running.wait() # Can only run serial when guest is running
        self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
        if delay:
            sleep(delay) # Ensure it has a chance to run

    @blocking
    def type_serial_cmd(self, cmd):
        #Can send message into socket without guest running (no self.running.wait())
        self.serial_console.send(cmd.encode(&#34;utf8&#34;)) # send, not sendline

    def finish_serial_cmd(self):
        result = self.serial_console.send_eol()
        result = self.serial_console.expect()
        return result

    @blocking
    def run_monitor_cmd(self, cmd):
        self.monitor_console.sendline(cmd.encode(&#34;utf8&#34;))
        result = self.monitor_console.expect()
        return result

    @blocking
    def revert_sync(self, snapshot_name):
        &#39;&#39;&#39;
        Args:
            snapshot_name: name of snapshot in the current qcow to load

        Returns:
            String: error message. Empty on success.
        &#39;&#39;&#39;
        result = self.run_monitor_cmd(&#34;loadvm {}&#34;.format(snapshot_name))
        # On success we should get no result

        if result.startswith(&#34;Length mismatch&#34;):
            raise RuntimeError(&#34;QEMU machine&#39;s RAM size doesn&#39;t match snapshot RAM size!&#34;)

        if &#34;does not have the requested snapshot&#34; in result:
            raise ValueError(f&#34;Snapshot &#39;{snapshot_name}&#39; not present in {self.qcow}&#34;)

        result = result.strip()
        if len(result):
            warn(f&#34;snapshot load returned error {result}&#34;)

        return result

    @blocking
    def delvm_sync(self, snapshot_name):
        self.run_monitor_cmd(&#34;delvm {}&#34;.format(snapshot_name))

    @blocking
    def copy_to_guest(self, copy_directory, iso_name=None, absolute_paths=False, setup_script=&#34;setup.sh&#34;, timeout=None):
        &#39;&#39;&#39;

        Copy a directory from the host into the guest by
        1) Creating an .iso image of the directory on the host
        2) Run a bash command to mount it at the exact same path + .ro and then copy the files to the provided path
        3) If the directory contains setup.sh, run it

        Args:
            copy_directory: Local directory to copy into guest
            iso_name: Name of iso file that will be generated. Defaults to [copy_directory].iso
            absolute_paths: is copy_directory an absolute or relative path
            seutp_script: name of a script which, if present inside copy_directory, will be automatically run after the copy
            timeout: maximum time each copy command will be allowed to run for, will use the `run_serial_cmd` default value unless another is provided

        Returns:
            None
        &#39;&#39;&#39;

        if not iso_name:
            iso_name = copy_directory + &#39;.iso&#39;
        make_iso(copy_directory, iso_name)

        if not absolute_paths:
            copy_directory = path.split(copy_directory)[-1] # Copy directory relative, not absolutely


        # Drive the guest to mount the drive
        # setup_sh:
        #   Make sure cdrom didn&#39;t automount
        #   Make sure guest path mirrors host path
        #   if there is a setup.sh script in the directory,
        #   then run that setup.sh script first (good for scripts that need to
        #   prep guest environment before script runs)
        mount_dir = shlex_quote(copy_directory)

        mkdir_result = self.run_serial_cmd(f&#34;mkdir -p {mount_dir} {mount_dir}.ro &amp;&amp; echo \&#34;mkdir_ok\&#34;; echo \&#34;exit code $?\&#34;&#34;, timeout=timeout)

        if &#39;mkdir_ok&#39; not in mkdir_result:
            raise RuntimeError(f&#34;Failed to create mount directories inside guest: {mkdir_result}&#34;)

        # Tell panda to we insert the CD drive
        # TODO: the cd-drive name should be a config option, see the values in qcow.py
        errs = self.run_monitor_cmd(&#34;change ide1-cd0 \&#34;{}\&#34;&#34;.format(iso_name))
        if len(errs):
            warn(f&#34;Warning encountered when connecting media to guest: {errs}&#34;)

        try:
            mount_status = &#34;bad&#34;
            for _ in range(10):
                if &#39;mount_ok&#39; in mount_status:
                    break
                mount_status = self.run_serial_cmd(f&#34;mount /dev/cdrom {mount_dir}.ro &amp;&amp; echo &#39;mount_ok&#39; || (umount /dev/cdrom; echo &#39;bad&#39;)&#34;, timeout=timeout)
                sleep(1)
            else:
                # Didn&#39;t ever break
                raise RuntimeError(f&#34;Failed to mount media inside guest: {mount_status}&#34;)

            # Note the . after our src/. directory - that&#39;s special syntax for cp -a
            copy_result = self.run_serial_cmd(f&#34;cp -a {mount_dir}.ro/. {mount_dir} &amp;&amp; echo &#39;ok&#39;&#34;, timeout=timeout)
            if copy_result != &#39;ok&#39;:
                raise RuntimeError(f&#34;Copy to rw directory failed: {copy_result}&#34;)

        finally:
            # Ensure we disconnect the CD drive after the mount + copy, even if it fails
            self.run_serial_cmd(&#34;umount /dev/cdrom&#34;) # This can fail and that&#39;s okay, we&#39;ll forece eject
            sleep(1)
            errs = self.run_monitor_cmd(&#34;eject -f ide1-cd0&#34;)
            if len(errs):
                warn(f&#34;Warning encountered when disconnecting media from guest: {errs}&#34;)

        if isfile(pjoin(copy_directory, setup_script)):
            setup_result = self.run_serial_cmd(f&#34;{mount_dir}/{setup_script}&#34;, timeout=timeout)
            progress(&#34;[Setup command]: {setup_result}&#34;)

    @blocking
    def record_cmd(self, guest_command, copy_directory=None, iso_name=None, setup_command=None, recording_name=&#34;recording&#34;, snap_name=&#34;root&#34;, ignore_errors=False):
        &#39;&#39;&#39;
        Take a recording as follows:
            0) Revert to the specified snapshot name if one is set. By default &#39;root&#39;. Set to `None` if you have already set up the guest and are ready to record with no revert
            1) Create an ISO of files that need to be copied into the guest if copy_directory is specified. Copy them in
            2) Run the setup_command in the guest, if provided
            3) Type the command you wish to record but do not press enter to begin execution. This avoids the recording capturing the command being typed
            4) Begin the recording (name controlled by recording_name)
            5) Press enter in the guest to begin the command. Wait until it finishes.
            6) End the recording
        &#39;&#39;&#39;
        # 0) Revert to the specified snapshot
        if snap_name is not None:
            self.revert_sync(snap_name) # Can&#39;t use self.revert because that would would run async and we&#39;d keep going before the revert happens

        # 1) Make copy_directory into an iso and copy it into the guest - It will end up at the exact same path
        if copy_directory: # If there&#39;s a directory, build an ISO and put it in the cddrive
            # Make iso
            self.copy_to_guest(copy_directory, iso_name)

        # 2) Run setup_command, if provided before we start the recording (good place to CD or install, etc)
        if setup_command:
            print(f&#34;Running setup command {setup_command}&#34;)
            r = self.run_serial_cmd(setup_command)
            print(f&#34;Setup command results: {r}&#34;)

        # 3) type commmand (note we type command, start recording, finish command)
        self.type_serial_cmd(guest_command)

        # 4) start recording
        self.run_monitor_cmd(&#34;begin_record {}&#34;.format(recording_name))

        # 5) finish command
        result = self.finish_serial_cmd()

        if debug:
            progress(&#34;Result of `{}`:&#34;.format(guest_command))
            print(&#34;\t&#34;+&#34;\n\t&#34;.join(result.split(&#34;\n&#34;))+&#34;\n&#34;)

        if &#34;No such file or directory&#34; in result and not ignore_errors:
            print(&#34;Bad output running command: {}&#34;.format(result))
            raise RuntimeError(&#34;Command not found while taking recording&#34;)

        if &#34;cannot execute binary file&#34; in result and not ignore_errors:
            print(&#34;Bad output running command: {}&#34;.format(result))
            raise RuntimeError(&#34;Could not execute binary while taking recording&#34;)

        # 6) End recording
        self.run_monitor_cmd(&#34;end_record&#34;)

        print(&#34;Finished recording&#34;)

    @blocking
    def interact(self, confirm_quit=True):
        &#39;&#39;&#39;
        Expose console interactively until user types pandaquit
        Must be run in blocking thread.

        TODO: This should probably repace self.serial_console with something
        that directly renders output to the user. Then we don&#39;t have to handle
        buffering and other problems. But we will need to re-enable the serial_console
        interface after this returns
        &#39;&#39;&#39;
        print(&#34;PANDA: entering interactive mode. Type pandaquit to exit&#34;)
        prompt = self.expect_prompt.decode(&#34;utf8&#34;) if self.expect_prompt  else &#34;$ &#34;
        if not prompt.endswith(&#34; &#34;): prompt += &#34; &#34;
        while True:
            cmd = input(prompt) # TODO: Strip all control characters - Ctrl-L breaks things
            if cmd.strip() == &#39;pandaquit&#39;:
                if confirm_quit:
                    q = input(&#34;PANDA: Quitting interactive mode. Are you sure? (y/n) &#34;)
                    if len(q) and q.lower()[0] == &#39;y&#39;:
                        break
                    else:
                        continue
                else: # No confirm - just break
                    break
            r = self.run_serial_cmd(cmd) # XXX: may timeout
            print(r)

    @blocking
    def do_panda_finish(self):
        &#39;&#39;&#39;
        Call panda_finish. Note this isn&#39;t really blocking - the
        guest should have exited by now, but queue this after
        (blocking) shutdown commands in our internal async queue
        so it must also be labeled as blocking.
        &#39;&#39;&#39;
#        assert (not self.running.is_set()), &#34;Can&#39;t finish while still running&#34;
        self.panda_finish()

    ################## CALLBACK FUNCTIONS ################
    # Mixin for handling callbacks and generation of decorators that allow users to register their own callbacks
    # such as panda.cb_before_block_exec()
    def register_cb_decorators(self):
        &#39;&#39;&#39;
        Setup callbacks and generate self.cb_XYZ functions for cb decorators
        XXX Don&#39;t add any other methods with names starting with &#39;cb_&#39;
        Callbacks can be called as @panda.cb_XYZ in which case they&#39;ll take default arguments and be named the same as the decorated function
        Or they can be called as @panda.cb_XYZ(name=&#39;A&#39;, procname=&#39;B&#39;, enabled=True). Defaults: name is function name, procname=None, enabled=True unless procname set
        &#39;&#39;&#39;
        for cb_name, pandatype in zip(self.callback._fields, self.callback):
            def closure(closed_cb_name, closed_pandatype): # Closure on cb_name and pandatype
                def f(*args, **kwargs):
                    if len(args): # Called as @panda.cb_XYZ without ()s- no arguments to decorator but we get the function name instead
                        # Call our decorator with only a name argument ON the function itself
                        fun = args[0]
                        return self._generated_callback(closed_pandatype, **{&#34;name&#34;: fun.__name__})(fun)
                    else:
                        # Otherwise, we were called as @panda.cb_XYZ() with potential args - Just return the decorator and it&#39;s applied to the function
                        return self._generated_callback(closed_pandatype, *args, **kwargs)
                return f

            setattr(self, &#39;cb_&#39;+cb_name, closure(cb_name, pandatype))

    def _generated_callback(self, pandatype, name=None, procname=None, enabled=True):
        &#39;&#39;&#39;
        Actual implementation of self.cb_XYZ. pandatype is pcb.XYZ
        name must uniquely describe a callback
        if procname is specified, callback will only be enabled when that asid is running (requires OSI support)
        &#39;&#39;&#39;

        if procname:
            enabled = False # Process won&#39;t be running at time 0 (probably)
            self._register_internal_asid_changed_cb()

        def decorator(fun):
            local_name = name  # We need a new varaible otherwise we have scoping issues with _generated_callback&#39;s name
            if name is None:
                local_name = fun.__name__

            # 0 works for all callbacks except void. We check later on
            # to see if we need to return None otherwise we return 0
            return_from_exception = 0

            def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
                try:
                    r = fun(*args, **kwargs)
                    #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                    #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                    #print(fun, r) # Stuck with TypeError in _run_and_catch? Enable this to find where the bug is.
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    self.callback_exit_exception = e
                    self.end_analysis()
                    return return_from_exception

            cast_rc = pandatype(_run_and_catch)
            cast_rc_string = str(self.ffi.typeof(cast_rc))
            return_from_exception = 0
            if &#34;void(*)(&#34; in cast_rc_string:
                return_from_exception = None

            self.register_callback(pandatype, cast_rc, local_name, enabled=enabled, procname=procname)
            def wrapper(*args, **kw):
                return _run_and_catch(*args, **kw)
            return wrapper
        return decorator

    def _register_internal_asid_changed_cb(self):
        &#39;&#39;&#39;
        Call this function if you need procname filtering for callbacks. It enables
        an internal callback on asid_changed (and sometimes an after_block_exec cb)
        which will deteremine when the process name changes and enable/disable other callbacks
        that filter on process name.
        &#39;&#39;&#39;
        if self._registered_asid_changed_internal_cb: # Already registered these callbacks
            return

        @self.ppp(&#34;syscalls2&#34;, &#34;on_sys_brk_enter&#34;)
        def on_sys_brk_enter(cpu, pc, brk):
            name = self.get_process_name(cpu)
            asid = self.libpanda.panda_current_asid(cpu)
            if self.asid_mapping.get(asid, None) != name:
                self.asid_mapping[asid] = name
                self._procname_changed(cpu, name)

        @self.callback.after_block_exec
        def __get_pending_procname_change(cpu, tb, exit_code):
            if exit_code: # Didn&#39;t actually execute block
                return None
            if not self.in_kernel(cpu): # Once we&#39;re out of kernel code, grab procname
                process = self.plugins[&#39;osi&#39;].get_current_process(cpu)
                if process != self.ffi.NULL:
                    name = self.ffi.string(process.name).decode(&#34;utf8&#34;, &#34;ignore&#34;)
                else:
                    return None # Couldn&#39;t figure out the process
                asid = self.libpanda.panda_current_asid(cpu)
                self.asid_mapping[asid] = name
                self._procname_changed(cpu, name)
                self.disable_callback(&#39;__get_pending_procname_change&#39;) # Disabled to begin


        # Local function def
        @self.callback.asid_changed
        def __asid_changed(cpustate, old_asid, new_asid):
            &#39;&#39;&#39;
            When the ASID changes, check if we know its procname (in self.asid_mapping),
            if so, call panda._procname_changed(cpu, name). Otherwise, we enable __get_pending_procname_change CB, which
            waits until the procname changes. Then we grab the new procname, update self.asid_mapping and call
            panda._procname_changed(cpu, name)
            &#39;&#39;&#39;
            if old_asid == new_asid:
                return 0

            if new_asid not in self.asid_mapping: # We don&#39;t know this ASID-&gt;procname - turn on __get_pending_procname_change
                if not self.is_callback_enabled(&#39;__get_pending_procname_change&#39;):
                    self.enable_callback(&#39;__get_pending_procname_change&#39;)
            else: # We do know this ASID-&gt;procname, just call procname_changed
                self._procname_changed(cpustate, self.asid_mapping[new_asid])

            return 0

        self.register_callback(self.callback.asid_changed, __asid_changed, &#34;__asid_changed&#34;) # Always call on ASID change

        # This internal callback is only enabled on-demand (later) when we need to figure out ASID-&gt;procname mappings
        self.register_callback(self.callback.after_block_exec, __get_pending_procname_change, &#34;__get_pending_procname_change&#34;, enabled=False)

        self._registered_asid_changed_internal_cb = True

    def register_callback(self, callback, function, name, enabled=True, procname=None):
        # CB   = self.callback.main_loop_wait
        # func = main_loop_wait_cb
        # name = main_loop_wait

        if name in self.registered_callbacks:
            print(f&#34;Warning: replacing existing callback &#39;{name}&#39; since it was re-registered&#34;)
            self.delete_callback(name)

        cb = self.callback_dictionary[callback]

        # Generate a unique handle for each callback type using the number of previously registered CBs of that type added to a constant
        handle = self.ffi.cast(&#39;void *&#39;, 0x8888 + 100*len([x for x in self.registered_callbacks.values() if x[&#39;callback&#39;] == cb]))

        # XXX: We should have another layer of indirection here so we can catch
        #      exceptions raised during execution of the CB and abort analysis
        pcb = self.ffi.new(&#34;panda_cb *&#34;, {cb.name:function})

        if debug:
            progress(&#34;Registered function &#39;{}&#39; to run on callback {}&#34;.format(name, cb.name))

        self.libpanda.panda_register_callback_helper(handle, cb.number, pcb)
        self.registered_callbacks[name] = {&#34;procname&#34;: procname, &#34;enabled&#34;: True, &#34;callback&#34;: cb,
                           &#34;handle&#34;: handle, &#34;pcb&#34;: pcb, &#34;function&#34;: function} # XXX: if function is not saved here it gets GC&#39;d and everything breaks! Watch out!

        if not enabled: # Note the registered_callbacks dict starts with enabled true and then we update it to false as necessary here
            self.disable_callback(name)

        if &#34;block&#34; in cb.name and &#34;start&#34; not in cb.name and &#34;end&#34; not in cb.name:
            if not self.disabled_tb_chaining:
                print(&#34;Warning: disabling TB chaining to support {} callback&#34;.format(cb.name))
                self.disable_tb_chaining()


    def is_callback_enabled(self, name):
        if name not in self.registered_callbacks.keys():
            raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))
        return self.registered_callbacks[name][&#39;enabled&#39;]

    def enable_internal_callbacks(self):
        &#39;&#39;&#39;
        Enable all our internal callbacks that start with __ such as __main_loop_wait
        and __asid_changed. Important in case user has done a panda.end_analysis()
        and then (re)called run
        &#39;&#39;&#39;
        for name in self.registered_callbacks.keys():
            if name.startswith(&#34;__&#34;) and not self.registered_callbacks[name][&#39;enabled&#39;]:
                self.enable_callback(name)

    def enable_all_callbacks(self):
        &#39;&#39;&#39;
        Enable all python callbacks that have been disabled
        &#39;&#39;&#39;
        for name in self.registered_callbacks.keys():
            self.enable_callback(name)

    def enable_callback(self, name):
        &#39;&#39;&#39;
        Enable a panda plugin using its handle and cb.number as a unique ID
        &#39;&#39;&#39;

        # During shutdown callback may be deleted before a request to enable comes through
        if self.ending:
            return

        if name not in self.registered_callbacks.keys():
            raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))

        self.registered_callbacks[name][&#39;enabled&#39;] = True
        handle = self.registered_callbacks[name][&#39;handle&#39;]
        cb = self.registered_callbacks[name][&#39;callback&#39;]
        pcb = self.registered_callbacks[name][&#39;pcb&#39;]
        #progress(&#34;Enabling callback &#39;{}&#39; on &#39;{}&#39; handle = {}&#34;.format(name, cb.name, handle))
        self.libpanda.panda_enable_callback_helper(handle, cb.number, pcb)

    def disable_callback(self, name, forever=False):
        &#39;&#39;&#39;
        Disable a panda plugin using its handle and cb.number as a unique ID
        If forever is specified, we&#39;ll never reenable the call- useful when
        you want to really turn off something with a procname filter.
        &#39;&#39;&#39;
        # During shutdown callback may be deleted before a request to enable comes through
        if self.ending:
            return

        if name not in self.registered_callbacks.keys():
            raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))
        self.registered_callbacks[name][&#39;enabled&#39;] = False
        handle = self.registered_callbacks[name][&#39;handle&#39;]
        cb = self.registered_callbacks[name][&#39;callback&#39;]
        pcb = self.registered_callbacks[name][&#39;pcb&#39;]
        #progress(&#34;Disabling callback &#39;{}&#39; on &#39;{}&#39; handle={}&#34;.format(name, cb.name, handle))
        self.libpanda.panda_disable_callback_helper(handle, cb.number, pcb)

        if forever:
            del self.registered_callbacks[name]

    def delete_callback(self, name):
        &#39;&#39;&#39;
        Completely delete a registered panda callback by name
        &#39;&#39;&#39;
        if name not in self.registered_callbacks.keys():
            raise ValueError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))

        handle = self.registered_callbacks[name][&#39;handle&#39;]
        self.libpanda.panda_unregister_callbacks(handle)
        if not hasattr(self,&#34;old_cb_list&#34;):
            self.old_cb_list = []
        self.old_cb_list.append(self.registered_callbacks[name])
        del self.registered_callbacks[name][&#39;handle&#39;]
        del self.registered_callbacks[name]

    def delete_callbacks(self):
        #for name in self.registered_callbacks.keys():
        while len(self.registered_callbacks.keys()) &gt; 0:
            self.delete_callback(list(self.registered_callbacks.keys())[0])

    ###########################
    ### PPP-style callbacks ###
    ###########################

    def ppp(self, plugin_name, attr, name=None, autoload=True):
        &#39;&#39;&#39;
        Decorator for plugin-to-plugin interface. Note this isn&#39;t in decorators.py
        becuase it uses the panda object.

        Example usage to register my_run with syscalls2 as a &#39;on_sys_open_return&#39;
        @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;)
        def my_fun(cpu, pc, filename, flags, mode):
            ...
        &#39;&#39;&#39;

        if plugin_name not in self.plugins and autoload: # Could automatically load it?
            print(f&#34;PPP automatically loaded plugin {plugin_name}&#34;)

        if not hasattr(self, &#34;ppp_registered_cbs&#34;):
            self.ppp_registered_cbs = {}
            # We use this to traak fn_names-&gt;fn_pointers so we can later disable by name

            # XXX: if  we don&#39;t save the cffi generated callbacks somewhere in Python,
            # they may get garbage collected even though the c-code could still has a
            # reference to them  which will lead to a crash. If we stop using this to track
            # function names, we need to keep it or something similar to ensure the reference
            # count remains &gt;0 in python

        def decorator(fun):
            local_name = name  # We need a new varaible otherwise we have scoping issues, maybe
            if local_name is None:
                local_name = fun.__name__

            def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
                try:
                    r = fun(*args, **kwargs)
                    #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                    #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    self.callback_exit_exception = e
                    self.end_analysis()
                    # this works in all current callback cases. CFFI auto-converts to void, bool, int, and int32_t

            f = self.ffi.callback(attr+&#34;_t&#34;)(_run_and_catch)  # Wrap the python fn in a c-callback.
            if local_name == &#34;&lt;lambda&gt;&#34;:
                local_name = f&#34;&lt;lambda_{self.lambda_cnt}&gt;&#34;
                self.lambda_cnt += 1

            if local_name in self.ppp_registered_cbs:
                print(f&#34;Warning: replacing existing PPP callback &#39;{local_name}&#39; since it was re-registered&#34;)
                self.disable_ppp(local_name)

            assert (local_name not in self.ppp_registered_cbs), f&#34;Two callbacks with conflicting name: {local_name}&#34;

            # Ensure function isn&#39;t garbage collected, and keep the name-&gt;(fn, plugin_name, attr) map for disabling
            self.ppp_registered_cbs[local_name] = (f, plugin_name, attr)

            eval(f&#34;self.plugins[&#39;{plugin_name}&#39;].ppp_add_cb_{attr}&#34;)(f) # All PPP  cbs start with this string. XXX insecure eval
            return f
        return decorator


    def disable_ppp(self, name):
        &#39;&#39;&#39;
        Disable a ppp-style callback by name.
        Unlike regular panda callbacks which can be enabled/disabled/deleted, PPP callbacks are only enabled/deleted (which we call disabled)

        Example usage to register my_run with syscalls2 as a &#39;on_sys_open_return&#39; and then disable:
        ```
        @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;)
        def my_fun(cpu, pc, filename, flags, mode):
            ...

        panda.disable_ppp(&#34;my_fun&#34;)
        ```

        -- OR --

        ```
        @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;, name=&#34;custom&#34;)
        def my_fun(cpu, pc, filename, flags, mode):
            ...
        ```

        panda.disable_ppp(&#34;custom&#34;)
        &#39;&#39;&#39;

        (f, plugin_name, attr) = self.ppp_registered_cbs[name]
        eval(f&#34;self.plugins[&#39;{plugin_name}&#39;].ppp_remove_cb_{attr}&#34;)(f) # All PPP cbs start with this string. XXX insecure eval
        del self.ppp_registered_cbs[name] # It&#39;s now safe to be garbage collected

    ########## GDB MIXINS ##############
    &#34;&#34;&#34;
    Provides the ability to interact with a QEMU attached gdb session by setting and clearing breakpoints. Experimental.
    &#34;&#34;&#34;

    def set_breakpoint(self, cpu, pc):
        &#39;&#39;&#39;
        Set a GDB breakpoint such that when the guest hits PC, execution is paused and an attached
        GDB instance can introspect on guest memory. Requires starting panda with -s, at least for now
        &#39;&#39;&#39;
        BP_GDB = 0x10
        self.libpanda.cpu_breakpoint_insert(cpu, pc, BP_GDB, self.ffi.NULL)

    def clear_breakpoint(self, cpu, pc):
        &#39;&#39;&#39;
        Remove a breakpoint
        &#39;&#39;&#39;
        BP_GDB = 0x10
        self.libpanda.cpu_breakpoint_remove(cpu, pc, BP_GDB)

    ############# HOOKING MIXINS ###############

    def hook(self, addr, enabled=True, kernel=None, asid=None, cb_type=&#34;start_block_exec&#34;):
        &#39;&#39;&#39;
        Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
        the function will be called with args (CPUState, TranslationBlock)
        &#39;&#39;&#39;

        def decorator(fun):
            if cb_type == &#34;before_tcg_codegen&#34; or cb_type == &#34;after_block_translate&#34; or cb_type == &#34;before_block_exec&#34; or cb_type == &#34;start_block_exec&#34; or cb_type == &#34;end_block_exec&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , struct hook *)&#34;)
            elif cb_type == &#34;after_block_exec&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , uint8_t, struct hook *)&#34;)
            elif cb_type == &#34;before_block_translate&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState* env, target_ptr_t pc, struct hook*)&#34;)
            elif cb_type == &#34;before_block_exec_invalidate_opt&#34;:
                hook_cb_type = self.ffi.callback(&#34;bool(CPUState* env, TranslationBlock*, struct hook*)&#34;)
            else:
                print(&#34;function type not supported&#34;)
                return
            type_num = getattr(self.libpanda, &#34;PANDA_CB_&#34;+cb_type.upper())

            if debug:
                print(&#34;Registering breakpoint at 0x{:x} -&gt; {} == {}&#34;.format(addr, fun, &#39;cdata_cb&#39;))

            # Inform the plugin that it has a new breakpoint at addr
            hook_cb_passed = hook_cb_type(fun)
            new_hook = self.ffi.new(&#34;struct hook*&#34;)
            new_hook.type = type_num
            new_hook.addr = addr
            if kernel or asid is None:
                new_hook.asid = 0
            else:
                new_hook.asid = asid

            setattr(new_hook.cb,cb_type, hook_cb_passed)
            if kernel:
                new_hook.km = self.libpanda.MODE_KERNEL_ONLY
            elif kernel == False:
                new_hook.km = self.libpanda.MODE_USER_ONLY
            else:
                new_hook.km = self.libpanda.MODE_ANY
            new_hook.enabled = enabled

            self.plugins[&#39;hooks&#39;].add_hook(new_hook)
            self.hook_list.append((new_hook, hook_cb_passed))

            @hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
            def wrapper(*args, **kw):
                try:
                    r = fun(*args, **kw)
                    #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    self.hook_exit_exception = e
                    self.end_analysis()
                    # this works in all current callback cases. CFFI auto-converts to void, bool, int, and int32_t
                    return 0

            return wrapper
        return decorator


    def hook_symbol(self, libraryname, symbol, kernel=False, name=None, cb_type=&#34;start_block_exec&#34;):
        &#39;&#39;&#39;
        Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
        the function will be called with args (CPUState, TranslationBlock)

        Args:
            libraryname (string): Name of library containing symbol to be hooked. May be None to match any.
            symbol (string, int): Name of symbol or offset into library to hook
            kernel (bool): if hook should be applied exclusively in kernel mode
            name (string): name of hook, defaults to function name
            cb_type (string): callback-type, defaults to start_block_exec

        Returns:
            None: Decorated function is called when (before/after is determined by cb_type) guest goes to call
                  the specified symbol in the specified library.
        &#39;&#39;&#39;

        def decorator(fun):
            if cb_type == &#34;before_tcg_codegen&#34; or cb_type == &#34;after_block_translate&#34; or cb_type == &#34;before_block_exec&#34; or cb_type == &#34;start_block_exec&#34; or cb_type == &#34;end_block_exec&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , struct hook *)&#34;)
            elif cb_type == &#34;after_block_exec&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , uint8_t, struct hook *)&#34;)
            elif cb_type == &#34;before_block_translate&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState* env, target_ptr_t pc, struct hook*)&#34;)
            elif cb_type == &#34;before_block_exec_invalidate_opt&#34;:
                hook_cb_type = self.ffi.callback(&#34;bool(CPUState* env, TranslationBlock*, struct hook*)&#34;)
            else:
                print(&#34;function type not supported&#34;)
                return

            # Inform the plugin that it has a new breakpoint at addr
            hook_cb_passed = hook_cb_type(fun)
            new_hook = self.ffi.new(&#34;struct symbol_hook*&#34;)
            type_num = getattr(self.libpanda, &#34;PANDA_CB_&#34;+cb_type.upper())
            new_hook.type = type_num
            if libraryname is not None:
                libname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(libraryname,&#34;utf-8&#34;))
            else:
                libname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
            self.ffi.memmove(new_hook.section,libname_ffi,len(libname_ffi))

            new_hook.hook_offset = False
            if symbol is not None:
                if isinstance(symbol, int):
                    new_hook.offset = symbol
                    new_hook.hook_offset = True
                    symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
                else:
                    symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(symbol,&#34;utf-8&#34;))
                    new_hook.hook_offset = False
            else:
                symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
            self.ffi.memmove(new_hook.name,symbolname_ffi,len(symbolname_ffi))
            setattr(new_hook.cb,cb_type, hook_cb_passed)
            hook_ptr = self.plugins[&#39;hooks&#39;].add_symbol_hook(new_hook)
            if name is not None:
                self.named_hooks[name] = hook_ptr
            self.hook_list.append((fun, new_hook,hook_cb_passed, hook_ptr))

            @hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
            def wrapper(*args, **kw):
                try:
                    r = fun(*args, **kw)
                    #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    self.hook_exit_exception = e
                    self.end_analysis()
                    # this works in all current callback cases. CFFI auto-converts to void, bool, int, and int32_t
                    return 0

            return wrapper
        return decorator

    def get_best_matching_symbol(self, cpu, pc=None, asid=None):
        &#39;&#39;&#39;
        Use the dynamic symbols plugin to get the best matching symbol for a given program counter.

        Args:
            cpu (CPUState): CPUState structure
            pc (int): program counter, defaults to current
            asid (int): ASID, defaults to current
        &#39;&#39;&#39;
        if asid is None:
            asid = self.current_asid(cpu)
        if pc is None:
            pc = self.current_pc(cpu)
        return self.plugins[&#39;dynamic_symbols&#39;].get_best_matching_symbol(cpu, pc, asid)


    ################### Hooks2 Functions ############
    # Provides the ability to interact with the hooks2 plugin and receive callbacks based on user-provided criteria.

    def enable_hook2(self,hook_name):
        &#39;&#39;&#39;
        Set a hook2-plugin hook&#39;s status to active.

        .. Deprecated:: Use the hooks plugin instead.
        &#39;&#39;&#39;
        if hook_name in self.hook_list2:
            self.plugins[&#39;hooks2&#39;].enable_hooks2(self.hook_list2[hook_name])
        else:
            print(&#34;ERROR: Your hook name was not in the hook list&#34;)

    def disable_hook2(self,hook_name):
        &#39;&#39;&#39;
        Set a hook2-plugin hook&#39;s status to inactive.

        .. Deprecated:: Use the hooks plugin instead.
        &#39;&#39;&#39;
        if hook_name in self.hook_list2:
            self.plugins[&#39;hooks2&#39;].disable_hooks2(self.hook_list2[hook_name])
        else:
            print(&#34;ERROR: Your hook name was not in the hook list&#34;)

    def hook2(self,name, kernel=True, procname=None, libname=None, trace_start=0, trace_stop=0, range_begin=0, range_end=0):
        &#39;&#39;&#39;
        Decorator to create a hook with the hooks2 plugin.

        .. Deprecated:: Use the hooks plugin instead.
        &#39;&#39;&#39;

        if procname == None:
            procname = self.ffi.NULL
        if libname == None:
            libname = self.ffi.NULL


        if procname != self.ffi.NULL:
            procname = self.ffi.new(&#34;char[]&#34;,bytes(procname,&#34;utf-8&#34;))
        if libname != self.ffi.NULL:
            libname = self.ffi.new(&#34;char[]&#34;,bytes(libname,&#34;utf-8&#34;))
        &#39;&#39;&#39;
        Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
        the function will be called with args (CPUState, TranslationBlock)
        &#39;&#39;&#39;
        def decorator(fun):
            # Ultimately, our hook resolves as a before_block_exec_invalidate_opt callback so we must match its args
            hook_cb_type = self.ffi.callback(&#34;bool (CPUState*, TranslationBlock*, void*)&#34;)
            # Inform the plugin that it has a new breakpoint at addr

            hook_cb_passed = hook_cb_type(fun)
            if not hasattr(self, &#34;hook_gc_list&#34;):
                self.hook_gc_list = [hook_cb_passed]
            else:
                self.hook_gc_list.append(hook_cb_passed)

            # I don&#39;t know what this is/does
            cb_data =self.ffi.NULL
            hook_number = self.plugins[&#39;hooks2&#39;].add_hooks2(hook_cb_passed, cb_data, kernel, \
                procname, libname, trace_start, trace_stop, range_begin,range_end)

            self.hook_list2[name] = hook_number

            @hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
            def wrapper(*args, **kw):
                return fun(*args, **kw)

            return wrapper
        return decorator

    def hook2_single_insn(self, name, pc, kernel=False, procname=None, libname=None):
        &#39;&#39;&#39;
        Helper function to hook a single instruction with the hooks2 plugin.

        .. Deprecated:: Use the hooks plugin instead.
        &#39;&#39;&#39;
        if procname == None:
            procname = self.ffi.NULL
        if libname == None:
            libname = self.ffi.NULL
        return self.hook2(name, kernel=kernel, procname=procname,libname=libname,range_begin=pc, range_end=pc)

    # MEM HOOKS
    def _hook_mem(self, start_address, end_address, before, after, read, write, virtual, physical, enabled):
        def decorator(fun):
            mem_hook_cb_type = self.ffi.callback(&#34;mem_hook_func_t&#34;)
            # Inform the plugin that it has a new breakpoint at addr

            hook_cb_passed = mem_hook_cb_type(fun)
            mem_reg = self.ffi.new(&#34;struct memory_hooks_region*&#34;)
            mem_reg.start_address = start_address
            mem_reg.stop_address = end_address
            mem_reg.on_before = before
            mem_reg.on_after = after
            mem_reg.on_read = read
            mem_reg.on_write = write
            mem_reg.on_virtual = virtual
            mem_reg.on_physical = physical
            mem_reg.enabled = enabled
            mem_reg.cb = hook_cb_passed

            hook = self.plugins[&#39;mem_hooks&#39;].add_mem_hook(mem_reg)

            self.mem_hooks[hook] = [mem_reg, hook_cb_passed]

            @mem_hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
            def wrapper(*args, **kw):
                return fun(*args, **kw)

            return wrapper
        return decorator

    def hook_mem(self, start_address, end_address, on_before, on_after, on_read, on_write, on_virtual, on_physical, enabled):
        &#39;&#39;&#39;
        Decorator to hook a memory range with the mem_hooks plugin

        .. todo:: Fully document mem-hook decorators
        &#39;&#39;&#39;
        return self._hook_mem(start_address,end_address,on_before,on_after,on_read, on_write, on_virtual, on_physical, enabled)

    def hook_phys_mem_read(self, start_address, end_address, on_before=True, on_after=False, enabled=True):
        &#39;&#39;&#39;
        Decorator to hook physical memory reads with the mem_hooks plugin
        &#39;&#39;&#39;
        return self._hook_mem(start_address,end_address,on_before,on_after, True, False, False, True, True)

    def hook_phys_mem_write(self, start_address, end_address, on_before=True, on_after=False):
        &#39;&#39;&#39;
        Decorator to hook physical memory writes with the mem_hooks plugin
        &#39;&#39;&#39;
        return self._hook_mem(start_address,end_address,on_before,on_after, False, True, False, True, True)

    def hook_virt_mem_read(self, start_address, end_address, on_before=True, on_after=False):
        &#39;&#39;&#39;
        Decorator to hook virtual memory reads with the mem_hooks plugin
        &#39;&#39;&#39;
        return self._hook_mem(start_address,end_address,on_before,on_after, True, False, True, False, True)

    def hook_virt_mem_write(self, start_address, end_address, on_before=True, on_after=False):
        &#39;&#39;&#39;
        Decorator to hook virtual memory writes with the mem_hooks plugin
        &#39;&#39;&#39;
        return self._hook_mem(start_address,end_address,on_before,on_after, False, True, True, False, True)

# vim: expandtab:tabstop=4:</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pandare.panda.Panda"><code class="flex name class">
<span>class <span class="ident">Panda</span></span>
<span>(</span><span>arch='i386', mem='128M', expect_prompt=None, serial_kwargs=None, os_version=None, qcow=None, os='linux', generic=None, raw_monitor=False, extra_args=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the object used to interact with PANDA. Initializing it creates a virtual machine to interact with.</p>
<p>Construct a new <code><a title="pandare.panda.Panda" href="#pandare.panda.Panda">Panda</a></code> object.
Note that multiple Panda objects cannot coexist in the same Python instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arch</code></strong></dt>
<dd>architecture string (e.g. "i386", "x86_64", "arm", "mips", "mipsel")</dd>
<dt><strong><code>generic</code></strong></dt>
<dd>specify a generic qcow to use from <code><a title="pandare.qcows.SUPPORTED_IMAGES" href="qcows.html#pandare.qcows.SUPPORTED_IMAGES">SUPPORTED_IMAGES</a></code> and set all subsequent arguments. Will automatically download qcow if necessary.</dd>
<dt><strong><code>mem</code></strong></dt>
<dd>size of memory for machine (e.g. "128M", "1G")</dd>
<dt><strong><code>expect_prompt</code></strong></dt>
<dd>Regular expression describing the prompt exposed by the guest
on a serial console. Used so we know when a running command has finished
with its output.</dd>
<dt><strong><code>serial_kwargs</code></strong></dt>
<dd>dict of additional arguments to pass to pandare.Expect (see signature of its constructor).
Note that <code>expect_prompt</code> is already passed to Expect as "expectation".
If not explicitly given, "unansi" is set to True (simulates a subset of ANSI codes and attempts to
remove command strings repeated by the shell from the shell output).</dd>
<dt><strong><code>os_version</code></strong></dt>
<dd>analagous to PANDA's -os argument (e.g, linux-32-debian:3.2.0-4-686-pae")</dd>
<dt><strong><code>os</code></strong></dt>
<dd>type of OS (e.g. "linux")</dd>
<dt><strong><code>qcow</code></strong></dt>
<dd>path to a qcow file to load</dd>
<dt><strong><code>raw_monitor</code></strong></dt>
<dd>When set, don't specify a -monitor. arg Allows for use of
-nographic in args with ctrl-A+C for interactive qemu prompt. Experts only!</dd>
<dt><strong><code>extra_args</code></strong></dt>
<dd>extra arguments to pass to PANDA as either a string or an
array. (e.g. "-nographic" or ["-nographic", "-net", "none"])</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pandare.panda.Panda" href="#pandare.panda.Panda">Panda</a></code></dt>
<dd>the created panda object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Panda():
    &#39;&#39;&#39;
    This is the object used to interact with PANDA. Initializing it creates a virtual machine to interact with.
    &#39;&#39;&#39;

    def __init__(self, arch=&#34;i386&#34;, mem=&#34;128M&#34;,
            expect_prompt=None, # Regular expression describing the prompt exposed by the guest on a serial console. Used so we know when a running command has finished with its output
            serial_kwargs=None,
            os_version=None,
            qcow=None, # Qcow file to load
            os=&#34;linux&#34;,
            generic=None, # Helper: specify a generic qcow to use and set other arguments. Supported values: arm/ppc/x86_64/i386. Will download qcow automatically
            raw_monitor=False, # When set, don&#39;t specify a -monitor. arg Allows for use of -nographic in args with ctrl-A+C for interactive qemu prompt.
            extra_args=None):
        &#39;&#39;&#39;
        Construct a new `Panda` object.  Note that multiple Panda objects cannot coexist in the same Python instance.
        Args:
            arch: architecture string (e.g. &#34;i386&#34;, &#34;x86_64&#34;, &#34;arm&#34;, &#34;mips&#34;, &#34;mipsel&#34;)
            generic: specify a generic qcow to use from `pandare.qcows.SUPPORTED_IMAGES` and set all subsequent arguments. Will automatically download qcow if necessary.
            mem: size of memory for machine (e.g. &#34;128M&#34;, &#34;1G&#34;)
            expect_prompt: Regular expression describing the prompt exposed by the guest
                    on a serial console. Used so we know when a running command has finished
                    with its output.
            serial_kwargs: dict of additional arguments to pass to pandare.Expect (see signature of its constructor).
                    Note that `expect_prompt` is already passed to Expect as &#34;expectation&#34;.
                    If not explicitly given, &#34;unansi&#34; is set to True (simulates a subset of ANSI codes and attempts to
                    remove command strings repeated by the shell from the shell output).
            os_version: analagous to PANDA&#39;s -os argument (e.g, linux-32-debian:3.2.0-4-686-pae&#34;)
            os: type of OS (e.g. &#34;linux&#34;)
            qcow: path to a qcow file to load
            raw_monitor: When set, don&#39;t specify a -monitor. arg Allows for use of
                    -nographic in args with ctrl-A+C for interactive qemu prompt. Experts only!
            extra_args: extra arguments to pass to PANDA as either a string or an
                    array. (e.g. &#34;-nographic&#34; or [&#34;-nographic&#34;, &#34;-net&#34;, &#34;none&#34;])
        Returns:
            Panda: the created panda object
        &#39;&#39;&#39;
        self.arch_name = arch
        self.mem = mem
        self.os = os_version
        self.os_type = os
        self.qcow = qcow
        self.plugins = plugin_list(self)
        self.expect_prompt = expect_prompt
        self.lambda_cnt = 0
        self.__sighandler = None
        self.ending = False # True during end_analysis


        if isinstance(extra_args, str): # Extra args can be a string or array
            extra_args = extra_args.split()
        elif extra_args is None:
            extra_args = []

        # If specified, use a generic (x86_64, i386, arm, etc) qcow from MIT and ignore
        if generic:                                 # other args. See details in qcows.py
            print(&#34;using generic &#34; +str(generic))
            q = Qcows.get_qcow_info(generic)
            self.arch_name     = q.arch
            self.os       = q.os
            self.mem      = q.default_mem # Might clobber a specified argument, but required if you want snapshots
            self.qcow     = Qcows.get_qcow(generic)
            self.expect_prompt = q.prompt
            if q.extra_args:
                extra_args.extend(q.extra_args.split(&#34; &#34;))

        if self.qcow: # Otherwise we shuld be able to do a replay with no qcow but this is probably broken
            if not (exists(self.qcow)):
                print(&#34;Missing qcow &#39;{}&#39; Please go create that qcow and give it to the PANDA maintainers&#34;.format(self.qcow))

        # panda.arch is a subclass with architecture-specific functions

        self.arch = None # Keep this with the following docstring such that pydoc generats good docs for it; this is a useful variable!
        &#34;&#34;&#34;
        A reference to an auto-instantiated `pandare.arch.PandaArch` subclass (e.g., `pandare.arch.X86Arch`)
        &#34;&#34;&#34;

        if self.arch_name == &#34;i386&#34;:
            self.arch = X86Arch(self)
        elif self.arch_name == &#34;x86_64&#34;:
            self.arch = X86_64Arch(self)
        elif self.arch_name in [&#34;arm&#34;]:
            self.arch = ArmArch(self)
        elif self.arch_name in [&#34;aarch64&#34;]:
            self.arch = Aarch64Arch(self)
        elif self.arch_name in [&#34;mips&#34;, &#34;mipsel&#34;]:
            self.arch = MipsArch(self)
        else:
            raise ValueError(f&#34;Unsupported architecture {self.arch_name}&#34;)
        self.bits, self.endianness, self.register_size = self.arch._determine_bits()

        self.build_dir  = self._find_build_dir()
        environ[&#34;PANDA_DIR&#34;] = self.build_dir
        self.libpanda_path = pjoin(self.build_dir, &#34;{0}-softmmu/libpanda-{0}.so&#34;.format(self.arch_name))
        self.panda = self.libpanda_path # Necessary for realpath to work inside core-panda, may cause issues?

        self.ffi = self._do_types_import()

        self.libpanda = self.ffi.dlopen(self.libpanda_path)
        self.C = self.ffi.dlopen(None)

        # set OS name if we have one
        if self.os:
            self.set_os_name(self.os)

        # Setup argv for panda
        self.panda_args = [self.panda]
        biospath = realpath(pjoin(self.build_dir, &#34;pc-bios&#34;)) # XXX: necessary for network drivers for arm, so &#39;pc-bios&#39; is a misleading name
        self.panda_args.append(&#34;-L&#34;)
        self.panda_args.append(biospath)

        if self.qcow:
            self.panda_args.append(self.qcow)

        self.panda_args += extra_args

        # Configure memory options
        self.panda_args.extend([&#39;-m&#39;, self.mem])

        # Configure serial - if we have an expect_prompt set. Otherwise how can we know what guest cmds are outputting?
        if self.expect_prompt or self.expect_kwargs.get(&#39;expectation&#39;):
            self.serial_file = NamedTemporaryFile(prefix=&#34;pypanda_s&#34;).name
            self.serial_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            expect_kwargs = {&#39;expectation&#39;: self.expect_prompt, &#39;consume_first&#39;: False, &#39;unansi&#39;: True}
            if serial_kwargs:
                expect_kwargs.update(serial_kwargs)
            self.serial_console = Expect(&#39;serial&#39;, **expect_kwargs)
            self.panda_args.extend([&#39;-serial&#39;, &#39;unix:{},server,nowait&#39;.format(self.serial_file)])
        else:
            self.serial_file = None
            self.serial_socket = None
            self.serial_console = None

        # Configure monitor - Always enabled for now
        self.monitor_file = NamedTemporaryFile(prefix=&#34;pypanda_m&#34;).name
        self.monitor_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.raw_monitor = raw_monitor
        if not self.raw_monitor:
            # XXX don&#39;t forget to escape expectation regex parens!
            self.monitor_console = Expect(&#39;monitor&#39;, expectation=rb&#34;\(qemu\) &#34;, consume_first=True)
            self.panda_args.extend([&#39;-monitor&#39;, &#39;unix:{},server,nowait&#39;.format(self.monitor_file)])

        self.running = threading.Event()
        self.started = threading.Event()
        self.initializing = threading.Event()
        self.athread = AsyncThread(self.started) # athread manages actions that need to occur outside qemu&#39;s CPU loop

        # Callbacks
        self.register_cb_decorators()
        self.registered_callbacks = {} # name -&gt; {procname: &#34;bash&#34;, enabled: False, callback: None}

        # Register asid_changed CB if and only if a callback requires procname
        self._registered_asid_changed_internal_cb = False
        self._registered_mmap_cb = False

        self._initialized_panda = False
        self.disabled_tb_chaining = False
        self.taint_enabled = False
        self.taint_sym_enabled = False
        self.named_hooks = {}
        self.hook_list = []
        self.hook_list2 = {}
        self.mem_hooks = {}

        # Asid stuff
        self.current_asid_name = None
        self.asid_mapping = {}

        # Shutdown stuff
        self.exception = None # When set to an exn, we&#39;ll raise and exit
        self._in_replay = False

        # main_loop_wait functions and callbacks
        self.main_loop_wait_fnargs = [] # [(fn, args), ...]
        progress (&#34;Panda args: [&#34; + (&#34; &#34;.join(self.panda_args)) + &#34;]&#34;)
    # /__init__

    def _do_types_import(self):
        &#39;&#39;&#39;
        Import objects from panda_datatypes which are configured by the environment variables(?)
        Store these objects in self.callback and self.callback_dictionary

        Returns a handle to the FFI object for the libpanda object
        &#39;&#39;&#39;
        from importlib import import_module
        from .autogen.panda_datatypes import get_cbs
        panda_arch_support = import_module(f&#34;.autogen.panda_{self.arch_name}_{self.bits}&#34;,package=&#39;pandare&#39;)

        ffi = panda_arch_support.ffi
        self.callback, self.callback_dictionary = get_cbs(ffi)

        return ffi

    def _initialize_panda(self):
        &#39;&#39;&#39;
        After initializing the class, the user has a chance to do something
        (TODO: what? register callbacks? It&#39;s something important...) before we finish initializing
        &#39;&#39;&#39;
        self.libpanda._panda_set_library_mode(True)

        cenvp = self.ffi.new(&#34;char**&#34;, self.ffi.new(&#34;char[]&#34;, b&#34;&#34;))
        len_cargs = self.ffi.cast(&#34;int&#34;, len(self.panda_args))
        panda_args_ffi = [self.ffi.new(&#34;char[]&#34;, bytes(str(i),&#34;utf-8&#34;)) for i in self.panda_args]
        self.libpanda.panda_init(len_cargs, panda_args_ffi, cenvp)

        # Now we&#39;ve run qemu init so we can connect to the sockets for the monitor and serial
        if self.serial_console and not self.serial_console.is_connected():
            self.serial_socket.connect(self.serial_file)
            self.serial_console.connect(self.serial_socket)
        if not self.raw_monitor and not self.monitor_console.is_connected():
            self.monitor_socket.connect(self.monitor_file)
            self.monitor_console.connect(self.monitor_socket)

        # Register __main_loop_wait_callback
        self.register_callback(self.callback.main_loop_wait,
                self.callback.main_loop_wait(self.__main_loop_wait_cb), &#39;__main_loop_wait&#39;)

        self._initialized_panda = True


    def __main_loop_wait_cb(self):
        &#39;&#39;&#39;
        __main_loop_wait_cb is called at the start of the main cpu loop in qemu.
        This is a fairly safe place to call into qemu internals but watch out for deadlocks caused
        by your request blocking on the guest&#39;s execution. Here any functions in main_loop_wait_fnargs will be called
        &#39;&#39;&#39;
        try:
            # Then run any and all requested commands
            if len(self.main_loop_wait_fnargs) == 0: return
            #progress(&#34;Entering main_loop_wait_cb&#34;)
            for fnargs in self.main_loop_wait_fnargs:
                (fn, args) = fnargs
                ret = fn(*args)
            self.main_loop_wait_fnargs = []
        except KeyboardInterrupt:
            self.end_analysis()

    def _find_build_dir(self):
        &#39;&#39;&#39;
        Find build directory containing ARCH-softmmu/libpanda-ARCH.so and ARCH-softmmu/panda/plugins/
        1) check relative to file (in the case of installed packages)
        2) Check in../ ../../../build/
        3) raise RuntimeError
        &#39;&#39;&#39;
        archs = [&#39;i386&#39;, &#39;x86_64&#39;, &#39;arm&#39;, &#39;ppc&#39;]
        python_package = pjoin(*[dirname(__file__), &#34;data&#34;])
        local_build = realpath(pjoin(dirname(__file__), &#34;../../../../build&#34;))
        path_end = &#34;{0}-softmmu/libpanda-{0}.so&#34;.format(self.arch_name)

        pot_paths = [python_package, local_build]
        for potential_path in pot_paths:
            if isfile(pjoin(potential_path, path_end)):
                print(&#34;Loading libpanda from {}&#34;.format(potential_path))
                return potential_path

        searched_paths = &#34;\n&#34;.join([&#34;\t&#34;+p for p in  pot_paths])
        raise RuntimeError((&#34;Couldn&#39;t find libpanda-{}.so.\n&#34;
                            &#34;Did you built PANDA for this architecture?\n&#34;
                            &#34;Searched paths:\n{}&#34;
                           ).format(self.arch_name, searched_paths))


    def queue_main_loop_wait_fn(self, fn, args=[]):
        &#39;&#39;&#39;
        Queue a function to run at the next main loop
        fn is a function we want to run, args are arguments to apss to it
        &#39;&#39;&#39;
        self.main_loop_wait_fnargs.append((fn, args))

    def exit_cpu_loop(self):
        &#39;&#39;&#39;
        Stop cpu execution at nearest juncture.
        &#39;&#39;&#39;
        self.libpanda.panda_exit_loop = True

    def revert_async(self, snapshot_name): # In the next main loop, revert
        &#39;&#39;&#39;
        Request a snapshot revert, eventually. This is fairly dangerous
        because you don&#39;t know when it finishes. You should be using revert_sync
        from a blocking function instead
        &#39;&#39;&#39;
        print(&#34;WARNING: panda.revert_async may be deprecated in the near future&#34;)
        if debug:
            progress (&#34;Loading snapshot &#34; + snapshot_name)

        # Stop guest, queue up revert, then continue
        timer_start = time()
        self.vm_stop()
        charptr = self.ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
        self.queue_main_loop_wait_fn(self.libpanda.panda_revert, [charptr])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont)
        if debug:
            self.queue_main_loop_wait_fn(self._finish_timer, [timer_start, &#34;Loaded snapshot&#34;])

    def reset(self):
        &#34;&#34;&#34;In the next main loop, reset to boot&#34;&#34;&#34;
        if debug:
            progress (&#34;Resetting machine to start state&#34;)

        # Stop guest, queue up revert, then continue
        self.vm_stop()
        self.queue_main_loop_wait_fn(self.libpanda.panda_reset)
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont)

    def cont(self):
        &#39;&#39;&#39; Continue execution (run after vm_stop) &#39;&#39;&#39;
        self.libpanda.panda_cont()
        self.running.set()

    def vm_stop(self, code=4):
        &#39;&#39;&#39; Stop execution, default code means RUN_STATE_PAUSED &#39;&#39;&#39;
        self.libpanda.panda_stop(code)

    def snap(self, snapshot_name):
        &#39;&#39;&#39;
        Create snapshot with specified name

        Args:
            snapshot_name (str): name of the snapshot

        Returns:
            None
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Creating snapshot &#34; + snapshot_name)

        # Stop guest execution, queue up a snapshot, then continue
        timer_start = time()
        self.vm_stop()
        charptr = self.ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
        self.queue_main_loop_wait_fn(self.libpanda.panda_snap, [charptr])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont)
        if debug:
            self.queue_main_loop_wait_fn(self._finish_timer, [timer_start, &#34;Saved snapshot&#34;])

    def delvm(self, snapshot_name):
        &#39;&#39;&#39;
        Delete snapshot with specified name
        Args:
            snapshot_name (str): name of the snapshot

        Returns:
            None
        &#39;&#39;&#39;

        if debug:
            progress (&#34;Deleting snapshot &#34; + snapshot_name)

        # Stop guest, queue up delete, then continue
        self.vm_stop()
        charptr = self.ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
        self.queue_main_loop_wait_fn(self.libpanda.panda_delvm, [charptr])

    def _finish_timer(self, start, msg):
        &#39;&#39;&#39; Print how long some (main_loop_wait) task took &#39;&#39;&#39;
        t = time() - start
        print(&#34;{} in {1:.08f} seconds&#34;.format(msg, t))


    def enable_tb_chaining(self):
        &#39;&#39;&#39;
        This function enables translation block chaining in QEMU
        &#39;&#39;&#39;
        if debug:
            progress(&#34;Enabling TB chaining&#34;)
        self.disabled_tb_chaining = False
        self.libpanda.panda_enable_tb_chaining()

    def disable_tb_chaining(self):
        &#39;&#39;&#39;
        This function disables translation block chaining in QEMU
        &#39;&#39;&#39;
        if not self.disabled_tb_chaining:
            if debug:
                progress(&#34;Disabling TB chaining&#34;)
            self.disabled_tb_chaining = True
            self.libpanda.panda_disable_tb_chaining()

    def _setup_internal_signal_handler(self, signal_handler=None):
        def SigHandler(SIG,a,b):
            from signal import SIGINT, SIGHUP, SIGTERM
            if SIG == SIGINT:
                self.end_run_raise_signal = KeyboardInterrupt
                self.end_analysis()
            elif SIG == SIGHUP:
                self.end_run_raise_signal = KeyboardInterrupt
                self.end_analysis()
            elif SIG == SIGTERM:
                self.end_run_raise_signal = KeyboardInterrupt
                self.end_analysis()
            else:
                print(f&#34;PyPanda Signal handler received unhandled signal {SIG}&#34;)


        if signal_handler is not None:
            # store custom signal handler if requested1
            self.__sighandler = signal_handler

        if self._initialized_panda:
            # initialize and register signal handler only if panda is initialized
            self.__sighandler = (self.ffi.callback(&#34;void(int,void*,void*)&#34;, SigHandler)
                       if signal_handler is None and self.__sighandler is None
                       else self.ffi.callback(&#34;void(int,void*,void*)&#34;, self.__sighandler))

            self.libpanda.panda_setup_signal_handling(self.__sighandler)


    def run(self):
        &#39;&#39;&#39;
        This function starts our running PANDA instance from Python. At termination this function returns and the script continues to run after it.

        This function starts execution of the guest. It blocks until guest finishes.
        It also initializes panda object, clears main_loop_wait fns, and sets up internal callbacks.

        Args:
            None

        Returns:
            None: When emulation has finished due to guest termination, replay conclusion or a call to `Panda.end_analysis`
        &#39;&#39;&#39;

        if len(self.main_loop_wait_fnargs):
            if debug:
                print(&#34;Clearing prior main_loop_wait fns:&#34;, self.main_loop_wait_fnargs)
            self.main_loop_wait_fnargs = [] # [(fn, args), ...]

        self.ending = False

        if debug:
            progress (&#34;Running&#34;)

        self.initializing.set()
        if not self._initialized_panda:
            self._initialize_panda()
        self.initializing.clear()

        if not self.started.is_set():
            self.started.set()

        self.athread.ending = False

        # Ensure our internal CBs are always enabled
        self.enable_internal_callbacks()
        self._setup_internal_signal_handler()
        self.running.set()
        self.libpanda.panda_run() # Give control to panda
        self.running.clear() # Back from panda&#39;s execution (due to shutdown or monitor quit)
        self.delete_callbacks()
        self.libpanda.panda_unload_plugins() # Unload c plugins - should be safe now since exec has stopped
        self.plugins = plugin_list(self)
        # Write PANDALOG, if any
        #self.libpanda.panda_cleanup_record()
        if self._in_replay:
            self.reset()
        if hasattr(self, &#34;end_run_raise_signal&#34;):
            saved_exception = self.end_run_raise_signal
            del self.end_run_raise_signal
            raise saved_exception
        if hasattr(self, &#34;callback_exit_exception&#34;):
            saved_exception = self.callback_exit_exception
            del self.callback_exit_exception
            raise saved_exception
        if hasattr(self, &#34;blocking_queue_error&#34;):
            saved_exception = self.blocking_queue_error
            del self.blocking_queue_error
            raise saved_exception
        if hasattr(self, &#34;hook_exit_exception&#34;):
            saved_exception = self.hook_exit_exception
            del self.hook_exit_exception
            raise saved_exception


    def end_analysis(self):
        &#39;&#39;&#39;
        Stop running machine.

        Call from any thread to unload all plugins and stop all queued functions.
        If called from async thread or a callback, it will also unblock panda.run()

        Note here we use the async class&#39;s internal thread to process these
        without needing to wait for tasks in the main async thread
        &#39;&#39;&#39;
        self.athread.ending = True
        self.ending = True
        self.unload_plugins()
        if self.running.is_set() or self.initializing.is_set():

            # If we were running, stop the execution and check if we crashed
            self.queue_async(self.stop_run, internal=True)

    def record(self, recording_name, snapshot_name=None):
        &#34;&#34;&#34;Begins active recording with name provided.

        Args:
            recording_name (string): name of recording to save.
            snapshot_name (string, optional): Before recording starts restore to this snapshot name. Defaults to None.

        Raises:
            Exception: raises exception if there was an error starting recording.
        &#34;&#34;&#34;
        if snapshot_name == None:
            snapshot_name_ffi = self.ffi.NULL
        else:
            snapshot_name_ffi = self.ffi.new(&#34;char[]&#34;,snapshot_name.encode())
        recording_name_ffi = self.ffi.new(&#34;char[]&#34;, recording_name.encode())
        result = self.libpanda.panda_record_begin(recording_name_ffi,snapshot_name_ffi)
        res_string_enum = self.ffi.string(self.ffi.cast(&#34;RRCTRL_ret&#34;,result))
        if res_string_enum != &#34;RRCTRL_OK&#34;:
           raise Exception(f&#34;record method failed with RTCTL_ret {res_string_enum} ({result})&#34;)

    def end_record(self):
        &#34;&#34;&#34;Stop active recording.

        Raises:
            Exception: raises exception if there was an error stopping recording.
        &#34;&#34;&#34;
        result = self.libpanda.panda_record_end()
        res_string_enum = self.ffi.string(self.ffi.cast(&#34;RRCTRL_ret&#34;,result))
        if res_string_enum != &#34;RRCTRL_OK&#34;:
           raise Exception(f&#34;record method failed with RTCTL_ret {res_string_enum} ({result})&#34;)
    
    def recording_exists(self, name):
        &#39;&#39;&#39;
        Checks if a recording file exists on disk.

        Args:
            name (str): name of the recording to check for (e.g., `foo` which uses `foo-rr-snp` and `foo-rr-nondet.log`)
        
        Returns:
            boolean: true if file exists, false otherwise
        &#39;&#39;&#39;
        if exists(name + &#34;-rr-snp&#34;):
            return True

    def run_replay(self, replaypfx):
        &#39;&#39;&#39;
        Load a replay and run it. Starts PANDA execution and returns after end of VM execution.

        Args:
            replaypfx (str): Replay name/path (e.g., &#34;foo&#34; or &#34;./dir/foo&#34;)

        Returns:
            None
        &#39;&#39;&#39;
        if not isfile(replaypfx+&#34;-rr-snp&#34;) or not isfile(replaypfx+&#34;-rr-nondet.log&#34;):
            raise ValueError(&#34;Replay files not present to run replay of {}&#34;.format(replaypfx))

        self.ending = False

        if debug:
            progress (&#34;Replaying %s&#34; % replaypfx)

        charptr = self.ffi.new(&#34;char[]&#34;,bytes(replaypfx,&#34;utf-8&#34;))
        self.libpanda.panda_replay_begin(charptr)
        self._in_replay = True
        self.run()
        self._in_replay = False


    def end_replay(self):
        &#39;&#39;&#39;
        Terminates a currently running replay

            Returns:
                None

            Raises:
                Exception: raises exception if no replay is active or termination failed.
        &#39;&#39;&#39;

        if self._in_replay is False:
            raise Exception(&#34;Tried to terminate replay while not in replay mode!&#34;)

        result = self.libpanda.panda_replay_end()

        res_string_enum = self.ffi.string(self.ffi.cast(&#34;RRCTRL_ret&#34;,result))
        if res_string_enum != &#34;RRCTRL_OK&#34;:
           raise Exception(f&#34;ending record method failed with RTCTL_ret {res_string_enum} ({result})&#34;)


    def require(self, name):
        &#39;&#39;&#39;
        Load a C plugin with no arguments. Deprecated. Use load_plugin
        &#39;&#39;&#39;
        self.load_plugin(name, args={})

    def load_plugin(self, name, args={}):
        &#39;&#39;&#39;
        Load a C plugin, optionally with arguments

        Args:
            name (str): Name of plugin
            args (dict): Arguments matching key to value. e.g. {&#34;key&#34;: &#34;value&#34;} sets option `key` to `value`.

        Returns:
            None.
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Loading plugin %s&#34; % name),

        argstrs_ffi = []
        if isinstance(args, dict):
            for k,v in args.items():
                this_arg_s = &#34;{}={}&#34;.format(k,v)
                this_arg = self.ffi.new(&#34;char[]&#34;, bytes(this_arg_s, &#34;utf-8&#34;))
                argstrs_ffi.append(this_arg)

            n = len(args.keys())
        elif isinstance(args, list):
            for arg in args:
                this_arg = self.ffi.new(&#34;char[]&#34;, bytes(arg, &#34;utf-8&#34;))
                argstrs_ffi.append(this_arg)
            n = len(args)

        else:
            raise ValueError(&#34;Arguments to load plugin must be a list or dict of key/value pairs&#34;)

        # First set qemu_path so plugins can load (may be unnecessary after the first time)
        assert(self.panda), &#34;Unknown location of PANDA&#34;
        panda_name_ffi = self.ffi.new(&#34;char[]&#34;, bytes(self.panda,&#34;utf-8&#34;))
        self.libpanda.panda_set_qemu_path(panda_name_ffi)

        if len(argstrs_ffi):
            plugin_args = argstrs_ffi
        else:
            plugin_args = self.ffi.NULL

        charptr = self.ffi.new(&#34;char[]&#34;, bytes(name,&#34;utf-8&#34;))
        self.libpanda.panda_require_from_library(charptr, plugin_args, len(argstrs_ffi))
        self._load_plugin_library(name)

    def _procname_changed(self, cpu, name):
        for cb_name, cb in self.registered_callbacks.items():
            if not cb[&#34;procname&#34;]:
                continue
            if name == cb[&#34;procname&#34;] and not cb[&#39;enabled&#39;]:
                self.enable_callback(cb_name)
            if name != cb[&#34;procname&#34;] and cb[&#39;enabled&#39;]:
                self.disable_callback(cb_name)

    def unload_plugin(self, name):
        &#39;&#39;&#39;
        Unload plugin with given name.

        Args:
            name (str): Name of plug

        Returns:
            None
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Unloading plugin %s&#34; % name),
        name_ffi = self.ffi.new(&#34;char[]&#34;, bytes(name,&#34;utf-8&#34;))
        self.libpanda.panda_unload_plugin_by_name(name_ffi)

    def unload_plugins(self):
        &#39;&#39;&#39;
        Disable all python plugins and request to unload all c plugins
        at the next main_loop_wait.

        XXX: If called during shutdown/exit, c plugins won&#39;t be unloaded
        because the next main_loop_wait will never happen. Instead, call
        panda.panda_finish directly (which is done at the end of panda.run())
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Disabling all python plugins, unloading all C plugins&#34;)

        # First unload python plugins, should be safe to do anytime
        #for name in self.registered_callbacks.keys():
        while len(list(self.registered_callbacks)) &gt; 0:
            try:
                self.delete_callback(list(self.registered_callbacks.keys())[0])
            except IndexError:
                continue
            #self.disable_callback(name)

        # Then unload C plugins. May be unsafe to do except from the top of the main loop (taint segfaults otherwise)
        self.queue_main_loop_wait_fn(self.libpanda.panda_unload_plugins)

    def memsavep(self, file_out):
        &#39;&#39;&#39;
        Calls QEMU memsavep on your specified python file.
        &#39;&#39;&#39;
        # this part was largely copied from https://cffi.readthedocs.io/en/latest/ref.html#support-for-file

        file_out.flush()                 # make sure the file is flushed
        newfd = dup(file_out.fileno())   # make a copy of the file descriptor
        fileptr = self.C.fdopen(newfd, b&#34;w&#34;)
        self.libpanda.panda_memsavep(fileptr)
        self.C.fclose(fileptr)

    def physical_memory_read(self, addr, length, fmt=&#39;bytearray&#39;):
        &#39;&#39;&#39;
        Read guest physical memory. In the specified format. Note that the `ptrlist` format
        returns a list of integers, each of the specified architecture&#39;s pointer size.

        Args:
            addr (int): Address
            length (int): length of array you would like returned
            fmt (str): format for returned array. Options: &#39;bytearray&#39;, &#39;int&#39;, &#39;str&#39;, &#39;ptrlist&#39;

        Returns:
            Union[bytearray, int, str, list[int]]: memory data

        Raises:
            ValueError if memory access fails or fmt is unsupported
        &#39;&#39;&#39;
        return self._memory_read(None, addr, length, physical=True, fmt=fmt)

    def virtual_memory_read(self, cpu, addr, length, fmt=&#39;bytearray&#39;):
        &#39;&#39;&#39;
        Read guest virtual memory.

        Args:
            cpu (CPUState): CPUState structure
            addr (int): Address
            length (int): length of data you would like returned
            fmt: format for returned array. See `physical_memory_read`.

        Returns:
            Union[bytearray, int, str, list[int]]: memory data

        Raises:
            ValueError if memory access fails or fmt is unsupported
        &#39;&#39;&#39;

        return self._memory_read(cpu, addr, length, physical=False, fmt=fmt)

    def _memory_read(self, env, addr, length, physical=False, fmt=&#39;bytearray&#39;):
        &#39;&#39;&#39;
        Read but with an autogen&#39;d buffer
        Supports physical or virtual addresses
        Raises ValueError if read fails
        &#39;&#39;&#39;
        if not isinstance(addr, int):
            raise ValueError(f&#34;Unsupported read from address {repr(addr)}&#34;)

        buf = self.ffi.new(&#34;char[]&#34;, length)

        # Force CFFI to parse addr as an unsigned value. Otherwise we get OverflowErrors
        # when it decides that it&#39;s negative
        ptr_typ = f&#39;uint{self.bits}_t&#39;
        addr_u = int(self.ffi.cast(ptr_typ, addr))

        buf_a = self.ffi.cast(&#34;char*&#34;, buf)
        length_a = self.ffi.cast(&#34;int&#34;, length)
        if physical:
            err = self.libpanda.panda_physical_memory_read_external(addr_u, buf_a, length_a)
        else:
            err = self.libpanda.panda_virtual_memory_read_external(env, addr_u, buf_a, length_a)

        if err &lt; 0:
            raise ValueError(f&#34;Memory access failed with err={err}&#34;) # TODO: make a PANDA Exn class

        r = self.ffi.unpack(buf, length)
        if fmt == &#39;bytearray&#39;:
            return r
        elif fmt==&#39;int&#39;:
            return int.from_bytes(r, byteorder=self.endianness)  # XXX size better be small enough to pack into an int!
        elif fmt==&#39;str&#39;:
            return self.ffi.string(buf, length)
        elif fmt==&#39;ptrlist&#39;:
            # This one is weird. Chunmk the memory into byte-sequences of (self.bits/8) bytes and flip endianness as approperiate
            # return a list
            bytelen = int(self.bits/8)
            if (length % bytelen != 0):
                raise ValueError(f&#34;Memory of size {length} does not evenly divide into {bytelen} byte chunks&#34;)
            chunks = []
            for start in range(0, length, bytelen):
                data = r[start:start+bytelen]
                int_data = int.from_bytes(data, byteorder=self.endianness)
                chunks.append(int_data)
            return chunks

        else:
            raise ValueError(&#34;fmt={} unsupported&#34;.format(fmt))

    def physical_memory_write(self, addr, buf):
        &#39;&#39;&#39;
        Write guest physical memory.

        Args:
            addr (int): Address
            buf (bytestring):  byte string to write into memory

        Returns:
            bool: error
        &#39;&#39;&#39;
        return self._memory_write(None, addr, buf, physical=True)

    def virtual_memory_write(self, cpu, addr, buf):
        &#39;&#39;&#39;
        Write guest virtual memory.

        Args:
            cpu (CPUState): CPUState structure
            address (int): Address
            buf (bytestr): byte string to write into memory

        Returns:
            bool: error

        &#39;&#39;&#39;
        return self._memory_write(cpu, addr, buf, physical=False)

    def _memory_write(self, cpu, addr, buf, physical=False):
        &#39;&#39;&#39;
        Write a bytearray into memory at the specified physical/virtual address
        &#39;&#39;&#39;
        length = len(buf)
        c_buf = self.ffi.new(&#34;char[]&#34;,buf)
        buf_a = self.ffi.cast(&#34;char*&#34;, c_buf)
        length_a = self.ffi.cast(&#34;int&#34;, length)

        if not hasattr(self, &#34;_memcb&#34;): # XXX: Why do we enable memcbs for memory writes?
            self.enable_memcb()

        if physical:
            return self.libpanda.panda_physical_memory_write_external(addr, buf_a, length_a)
        else:
            return self.libpanda.panda_virtual_memory_write_external(cpu, addr, buf_a, length_a)

    def callstack_callers(self, lim, cpu): # XXX move into new directory, &#39;callstack&#39; ?
        &#39;&#39;&#39;
        Helper function for callstack_instr plugin
        Handle conversion and return get_callers from callstack_instr.
        &#39;&#39;&#39;
        if not &#34;callstack_instr&#34; in self.plugins:
            progress(&#34;enabling callstack_instr plugin&#34;)
            self.load_plugin(&#34;callstack_instr&#34;)

        callers = self.ffi.new(&#34;uint%d_t[%d]&#34; % (self.bits, lim))
        n = self.plugins[&#39;callstack_instr&#39;].get_callers(callers, lim, cpu)
        c = []
        for pc in callers:
            c.append(pc)
        return c

    def _load_plugin_library(self, name):
        if hasattr(self,&#34;__did_load_libpanda&#34;):
            libpanda_path_chr = self.ffi.new(&#34;char[]&#34;,bytes(self.libpanda_path, &#34;UTF-8&#34;))
            self.__did_load_libpanda = self.libpanda.panda_load_libpanda(libpanda_path_chr)
        if not name in self.plugins.keys():
            assert(isfile(pjoin(*[self.build_dir, self.arch_name+&#34;-softmmu&#34;, &#34;panda/plugins/panda_{}.so&#34;.format(name)])))
            library = self.ffi.dlopen(pjoin(*[self.build_dir, self.arch_name+&#34;-softmmu&#34;, &#34;panda/plugins/panda_{}.so&#34;.format(name)]))
            self.plugins[name] = library

    def queue_async(self, f, internal=False):
        &#39;&#39;&#39;
        Explicitly queue work in the asynchronous work queue.

        Args:
            f: A python function with no arguments to be called at a later time. The function should
            be decorated with `@pandare.blocking`. You generally want to use `panda.queue_blocking` over this function.

        Returns:
            None
        &#39;&#39;&#39;

        # this takes the blocking function and handles errors
        @blocking
        def wrapper():
            try:
                f()
            except Exception as e:
                self.blocking_queue_error = e
                self.end_analysis()


        # Keep the original function name instead of replacing it with &#39;wrapper&#39;
        wrapper.__name__ = f.__name__
        self.athread.queue(wrapper, internal=internal)

    def map_memory(self, name, size, address):

        &#39;&#39;&#39;
        Make a new memory region.

        Args:
            name (str): This is an internal reference name for this region. Must be unique.
            size (int): number of bytes the region should be.
            address (int): start address of region

        Returns:
            None
        &#39;&#39;&#39;

        name_c = self.ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
        size = ceil(size/1024)*1024 # Must be page-aligned
        return self.libpanda.map_memory(name_c, size, address)

    def read_str(self, cpu, ptr, max_length=None):
        &#39;&#39;&#39;
        Helper to read a null-terminated string from guest memory given a pointer and CPU state
        May return an exception if the call to panda.virtual_memory_read fails (e.g., if you pass a
        pointer to an unmapped page)

        Args:
            cpu (CPUState): CPUState structure
            ptr (int): Pointer to start of string
            max_length (int): Optional length to stop reading at

        Returns:
            string: Data read from memory

        &#39;&#39;&#39;
        r = b&#34;&#34;
        idx = 0
        while (max_length is None or idx &lt; max_length):
            next_char = self.virtual_memory_read(cpu, ptr, 1) # If this raises an exn, don&#39;t mask it
            if next_char == b&#34;\x00&#34;:
                break
            r += next_char
            ptr += 1
            idx += 1
        return r.decode(&#34;utf8&#34;, &#34;ignore&#34;)

    def to_unsigned_guest(self, x):
        &#39;&#39;&#39;
        Convert a singed python int to an unsigned int32/unsigned int64
        depending on guest bit-size

        Args:
            x (int): Python integer

        Returns:
            int: Python integer representing x as an unsigned value in the guest&#39;s pointer-size.
        &#39;&#39;&#39;
        import ctypes
        if self.bits == 32:
            return ctypes.c_uint32(x).value
        elif self.bits == 64:
            return ctypes.c_uint64(x).value
        else:
            raise ValueError(&#34;Unsupported number of bits&#34;)

    def from_unsigned_guest(self, x):
        &#39;&#39;&#39;
        Convert an unsigned int32/unsigned int64 from the guest
        (depending on guest bit-size) to a (signed) python int

        Args:
            x (int): Python integer representing an unsigned value in the guest&#39;s pointer-size

        Returns:
            int: Python integer representing x as a signed value
        &#39;&#39;&#39;
        if x &gt;= 2**(self.bits-1): # If highest bit is set, it&#39;s negative
            return (x - 2**self.bits)
        else: # Else it&#39;s positive
            return x

    def queue_blocking(self, func, queue=True):
        &#34;&#34;&#34;
        Decorator to mark a function as `blocking`, and (by default) queue it to run asynchronously.
        This should be used to mark functions that will drive guest execution. Functions will be run
        in the order they are defined. For more precise control, use `panda.queue_async`.


        ```
        @panda.queue_blocking
        def do_something():
            panda.revert_sync(&#39;root&#39;)
            print(panda.run_serial_cmd(&#39;whoami&#39;))
            panda.end_analysis()
        ```

        is equivalent to

        ```
        @blocking
        def run_whoami():
            panda.revert_sync(&#39;root&#39;)
            print(panda.run_serial_cmd(&#39;whoami&#39;))
            panda.end_analysis()

        panda.queue_async(run_whoami)
        ```

        Args:
            func (function): Function to queue
            queue (bool): Should function automatically be queued

        Returns:
            None

        &#34;&#34;&#34;
        f = blocking(func)
        if queue:
            self.queue_async(f)
        return f


    ########################## LIBPANDA FUNCTIONS ########################
    # Methods that directly pass data to/from PANDA with no extra logic beyond argument reformatting.
    def set_pandalog(self, name):
        &#39;&#39;&#39;
        Enable recording to a pandalog (plog) named `name`

        Args:
            name (str): filename to output data to

        Returns:
            None
        &#39;&#39;&#39;
        charptr = self.ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
        self.libpanda.panda_start_pandalog(charptr)

    def enable_memcb(self):
        &#39;&#39;&#39;
        Enable memory callbacks. Must be called for memory callbacks to work.
        pypanda enables this automatically with some callbacks.
        &#39;&#39;&#39;
        self._memcb = True
        self.libpanda.panda_enable_memcb()

    def disable_memcb(self):
        &#39;&#39;&#39;
        Disable memory callbacks. Must be enabled for memory callbacks to work.
        pypanda enables this automatically with some callbacks.
        &#39;&#39;&#39;
        self._memcb = False
        self.libpanda.panda_disable_memcb()

    def virt_to_phys(self, cpu, addr):
        &#39;&#39;&#39;
        Convert virtual address to physical address.

        Args:
            cpu (CPUState): CPUState struct
            addr (int): virtual address to convert

        Return:
            int: physical address
        &#39;&#39;&#39;
        return self.libpanda.panda_virt_to_phys_external(cpu, addr)

    def enable_plugin(self, handle):
        &#39;&#39;&#39;
        Enable plugin.

        Args:
            handle (int): pointer to handle returned by plugin

        Return:
            None
        &#39;&#39;&#39;
        self.libpanda.panda_enable_plugin(handle)

    def disable_plugin(self, handle):
        &#39;&#39;&#39;
        Disable plugin.

        Args:
            handle (int): pointer to handle returned by plugin

        Return:
            None
        &#39;&#39;&#39;
        self.libpanda.panda_disable_plugin(handle)

    def enable_llvm(self):
        &#39;&#39;&#39;
        Enables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
        &#39;&#39;&#39;
        self.libpanda.panda_enable_llvm()

    def disable_llvm(self):
        &#39;&#39;&#39;
        Disables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
        &#39;&#39;&#39;
        self.libpanda.panda_disable_llvm()

    def enable_llvm_helpers(self):
        &#39;&#39;&#39;
        Enables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
        &#39;&#39;&#39;
        self.libpanda.panda_enable_llvm_helpers()

    def disable_llvm_helpers(self):
        &#39;&#39;&#39;
        Disables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
        &#39;&#39;&#39;
        self.libpanda.panda_disable_llvm_helpers()

    def flush_tb(self):
        &#39;&#39;&#39;
        This function requests that the translation block cache be flushed as soon as possible. If running with translation block chaining turned off (e.g. when in LLVM mode or replay mode), this will happen when the current translation block is done executing.
        Flushing the translation block cache is additionally necessary if the plugin makes changes to the way code is translated. For example, by using panda_enable_precise_pc.
        &#39;&#39;&#39;
        return self.libpanda.panda_do_flush_tb()

    def enable_precise_pc(self):
        &#39;&#39;&#39;
        By default, QEMU does not update the program counter after every instruction.
        This function enables precise tracking of the program counter. After enabling precise PC tracking, the program counter will be available in env-&gt;panda_guest_pc and can be assumed to accurately reflect the guest state.
        &#39;&#39;&#39;
        self.libpanda.panda_enable_precise_pc()

    def disable_precise_pc(self):
        &#39;&#39;&#39;
        By default, QEMU does not update the program counter after every instruction.
        This function disables precise tracking of the program counter.
        &#39;&#39;&#39;
        self.libpanda.panda_disable_precise_pc()

    def in_kernel(self, cpustate):
        &#39;&#39;&#39;
        Returns true if the processor is in the privilege level corresponding to kernel mode for any of the PANDA supported architectures.
        Legacy alias for in_kernel_mode().
        &#39;&#39;&#39;
        return self.libpanda.panda_in_kernel_external(cpustate)

    def in_kernel_mode(self, cpustate):
        &#39;&#39;&#39;
        Check if the processor is running in priviliged mode.

        Args:
            cpu (CPUState): CPUState structure

        Returns:
            Bool: If the processor is in the privilege level corresponding to kernel mode
                  for the given architecture
        &#39;&#39;&#39;
        return self.libpanda.panda_in_kernel_mode_external(cpustate)

    def in_kernel_code_linux(self, cpustate):
        &#39;&#39;&#39;
        Check if the processor is running in linux kernelspace.

        Args:
            cpu (CPUState): CPUState structure

        Returns:
            Bool: If the processor is running in Linux kernel space code.
        &#39;&#39;&#39;
        return self.libpanda.panda_in_kernel_code_linux_external(cpustate)

    def g_malloc0(self, size):
        &#39;&#39;&#39;
        Helper function to call glib malloc

        Args:
            size (int): size to call with malloc

        Returns:
            buffer of the requested size from g_malloc
        &#39;&#39;&#39;
        return self.libpanda.g_malloc0(size)

    def current_sp(self, cpu):
        &#39;&#39;&#39;
        Get current stack pointer

        Args:
            cpu (CPUState): CPUState structure

        Return:
            int: Value of stack pointer
        &#39;&#39;&#39;
        return self.libpanda.panda_current_sp_external(cpu)

    def current_pc(self, cpu):
        &#39;&#39;&#39;
        Get current program counter

        Args:
            cpu (CPUState): CPUState structure

        Return:
            integer value of current program counter

        .. Deprecated:: Use panda.arch.get_pc(cpu) instead
        &#39;&#39;&#39;
        return self.libpanda.panda_current_pc(cpu)

    def current_asid(self, cpu):
        &#39;&#39;&#39;
        Get current Application Specific ID

        Args:
            cpu (CPUState): CPUState structure

        Returns:
            integer: value of current ASID
        &#39;&#39;&#39;
        return self.libpanda.panda_current_asid(cpu)

    def disas2(self, code, size):
        &#39;&#39;&#39;
        Call panda_disas to diasassemble an amount of code at a pointer.
        FIXME: seem to not match up to PANDA definition
        &#39;&#39;&#39;
        self.libpanda.panda_disas(code, size)

    def cleanup(self):
        &#39;&#39;&#39;
        Unload all plugins and close pandalog.

        Returns:
            None
        &#39;&#39;&#39;
        self.libpanda.panda_cleanup()

    def was_aborted(self):
        &#39;&#39;&#39;
        Returns true if panda was aborted.
        &#39;&#39;&#39;
        return self.libpanda.panda_was_aborted()

    def get_cpu(self):
        &#39;&#39;&#39;
        This function returns first_cpu CPUState object from QEMU.
        XXX: You rarely want this

        Returns:
            CPUState: cpu
        &#39;&#39;&#39;
        return self.libpanda.get_cpu()

    def garray_len(self, garray):
        &#39;&#39;&#39;
        Convenience function to get array length of glibc array.

        Args:
            g (garray): Pointer to a glibc array
                
        Returns:
            int: length of the array
        &#39;&#39;&#39;
        return self.libpanda.garray_len(garray)

    def panda_finish(self):
        &#39;&#39;&#39;
        Final stage call to underlying panda_finish with initialization.
        &#39;&#39;&#39;
        return self.libpanda.panda_finish()

    def rr_get_guest_instr_count(self):
        &#39;&#39;&#39;
        Returns record/replay guest instruction count.

        Returns:
            int: Current instruction count
        &#39;&#39;&#39;
        return self.libpanda.rr_get_guest_instr_count_external()

    ################### LIBQEMU Functions ############
    #Methods that directly pass data to/from QEMU with no extra logic beyond argument reformatting.
    #All QEMU function can be directly accessed by Python. These are here for convenience.
    # It&#39;s usally better to find a function name and look at the QEMU source for these functions.

    def drive_get(self, blocktype, bus, unit):
        &#39;&#39;&#39;
        Gets DriveInfo struct from user specified information.

        Args:
            blocktype: BlockInterfaceType structure
            bus: integer bus
            unit: integer unit

        Returns:
            DriveInfo struct
        &#39;&#39;&#39;
        return self.libpanda.drive_get(blocktype,bus,unit)

    def sysbus_create_varargs(self, name, addr):
        &#39;&#39;&#39;
        Returns DeviceState struct from user specified information
        Calls sysbus_create_varargs QEMU function.

        Args:
            name (str):
            addr (int): hwaddr

        Returns:
            DeviceState struct
        &#39;&#39;&#39;
        return self.libpanda.sysbus_create_varargs(name,addr,ffi.NULL)

    def cpu_class_by_name(self, name, cpu_model):
        &#39;&#39;&#39;
        Gets cpu class from name.
        Calls cpu_class_by_name QEMU function.

        Args:
            name: typename from python string
            cpu_model: string specified cpu model

        Returns:
            ObjectClass struct
        &#39;&#39;&#39;
        return self.libpanda.cpu_class_by_name(name, cpu_model)

    def object_class_by_name(self, name):
        &#39;&#39;&#39;
        Returns class as ObjectClass from name specified.
        Calls object_class_by_name QEMU function.

        Args
            name (str): string defined by user

        Returns:
            struct as specified by name
        &#39;&#39;&#39;
        return self.libpanda.object_class_by_name(name)

    def object_property_set_bool(self, obj, value, name):
        &#39;&#39;&#39;
        Writes a bool value to a property.
        Calls object_property_set_bool QEMU function.

        Args::
            value: the value to be written to the property
            name: the name of the property
            errp: returns an error if this function fails

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.object_property_set_bool(obj,value,name,self.libpanda.error_abort)

    def object_class_get_name(self, objclass):
        &#39;&#39;&#39;
        Gets String QOM typename from object class.
        Calls object_class_get_name QEMU function.

        Args::
            objclass: class to obtain the QOM typename for.

        Returns:
            String QOM typename for klass.
        &#39;&#39;&#39;
        return self.libpanda.object_class_get_name(objclass)

    def object_new(self, name):
        &#39;&#39;&#39;
        Creates a new QEMU object from typename.
        This function will initialize a new object using heap allocated memory.
        The returned object has a reference count of 1, and will be freed when
        the last reference is dropped.
        Calls object_new QEMU function.

        Args:
            name (str): The name of the type of the object to instantiate.

        Returns:
            The newly allocated and instantiated object.
        &#39;&#39;&#39;
        return self.libpanda.object_new(name)

    def object_property_get_bool(self, obj, name):
        &#39;&#39;&#39;
        Pull boolean from object.
        Calls object_property_get_bool QEMU function.

        Args:
            obj: the object
            name: the name of the property

        Returns:
            the value of the property, converted to a boolean, or NULL if an error occurs (including when the property value is not a bool).
        &#39;&#39;&#39;
        return self.libpanda.object_property_get_bool(obj,name,self.libpanda.error_abort)

    def object_property_set_int(self,obj, value, name):
        &#39;&#39;&#39;
        Set integer in QEMU object. Writes an integer value to a property.
        Calls object_property_set_int QEMU function.

        Args:
            value: the value to be written to the property
            name: the name of the property

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.object_property_set_int(obj, value, name, self.libpanda.error_abort)

    def object_property_get_int(self, obj, name):
        &#39;&#39;&#39;
        Gets integer in QEMU object. Reads an integer value from this property.
        Calls object_property_get_int QEMU function.

            Paramaters:
                obj: the object
                name: the name of the property

            Returns:
                the value of the property, converted to an integer, or negative if an error occurs (including when the property value is not an integer).
        &#39;&#39;&#39;
        return self.libpanda.object_property_get_int(obj, name, self.libpanda.error_abort)

    def object_property_set_link(self, obj, val, name):
        &#39;&#39;&#39;
        Writes an object&#39;s canonical path to a property.
        Calls object_property_set_link QEMU function.

        Args:
            value: the value to be written to the property
            name: the name of the property
            errp: returns an error if this function fails

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.object_property_set_link(obj,val,name,self.libpanda.error_abort)

    def object_property_get_link(self, obj, name):
        &#39;&#39;&#39;
        Reads an object&#39;s canonical path to a property.
        Calls object_property_get_link QEMU function.

        Args:
            obj: the object
            name: the name of the property
            errp: returns an error if this function fails

        Returns:
            the value of the property, resolved from a path to an Object, or NULL if an error occurs (including when the property value is not a string or not a valid object path).
        &#39;&#39;&#39;
        return self.libpanda.object_property_get_link(obj,name,self.libpanda.error_abort)

    def object_property_find(self, obj, name):
        &#39;&#39;&#39;
        Look up a property for an object and return its #ObjectProperty if found.
        Calls object_property_find QEMU function.

        Args:
            obj: the object
            name: the name of the property
            errp: returns an error if this function fails

        Returns:
            struct ObjectProperty pointer
        &#39;&#39;&#39;
        return self.libpanda.object_property_find(obj,name,ffi.NULL)

    def memory_region_allocate_system_memory(self, mr, obj, name, ram_size):
        &#39;&#39;&#39;
        Allocates Memory region by user specificiation.
        Calls memory_region_allocation_system_memory QEMU function.

        Args:
            mr: MemoryRegion struct
            obj: Object struct
            name (str): Region name
            ram_size (int): RAM size

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.memory_region_allocate_system_memory(mr, obj, name, ram_size)

    def memory_region_add_subregion(self, mr, offset, sr):
        &#39;&#39;&#39;
        Calls memory_region_add_subregion from QEMU.
        memory_region_add_subregion: Add a subregion to a container.

        Adds a subregion at @offset.  The subregion may not overlap with other
        subregions (except for those explicitly marked as overlapping).  A region
        may only be added once as a subregion (unless removed with
        memory_region_del_subregion()); use memory_region_init_alias() if you
        want a region to be a subregion in multiple locations.

        Args:
            mr: the region to contain the new subregion; must be a container initialized with memory_region_init().
            offset: the offset relative to @mr where @subregion is added.
            subregion: the subregion to be added.

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.memory_region_add_subregion(mr,offset,sr)

    def memory_region_init_ram_from_file(self, mr, owner, name, size, share, path):
        &#39;&#39;&#39;
        Calls memory_region_init_ram_from_file from QEMU.
        memory_region_init_ram_from_file:  Initialize RAM memory region with a mmap-ed backend.

        Args:
            mr: the #MemoryRegion to be initialized.
            owner: the object that tracks the region&#39;s reference count
            name: the name of the region.
            size: size of the region.
            share: %true if memory must be mmaped with the MAP_SHARED flag
            path: the path in which to allocate the RAM.
            errp: pointer to Error*, to store an error if it happens.

        Returns:
            None
        &#39;&#39;&#39;
        return self.libpanda.memory_region_init_ram_from_file(mr, owner, name, size, share, path, self.libpanda.error_fatal)

    def create_internal_gic(self, vbi, irqs, gic_vers):
        return self.libpanda.create_internal_gic(vbi, irqs, gic_vers)

    def create_one_flash(self, name, flashbase, flashsize, filename, mr):
        return self.libpanda.create_one_flash(name, flashbase, flashsize, filename, mr)

    def create_external_gic(self, vbi, irqs, gic_vers, secure):
        return self.libpanda.create_external_gic(vbi, irqs, gic_vers, secure)

    def create_virtio_devices(self, vbi, pic):
        return self.libpanda.create_virtio_devices(vbi, pic)

    def arm_load_kernel(self, cpu, bootinfo):
        return self.libpanda.arm_load_kernel(cpu, bootinfo)

    def error_report(self, s):
        return self.libpanda.error_report(s)

    def get_system_memory(self):
        return self.libpanda.get_system_memory()

    def lookup_gic(self,n):
        return self.libpanda.lookup_gic(n)

    ##################### OSI FUNCTIONS ###########
    #Convenience functions to interact with the Operating System Instrospection (OSI) class of plugins.

    def set_os_name(self, os_name):
        &#34;&#34;&#34;
        Set OS target. Equivalent to &#34;-os&#34; flag on the command line. Matches the form of:

            &#34;windows[-_]32[-_]xpsp[23]&#34;,
            &#34;windows[-_]32[-_]7&#34;,
            &#34;windows[-_]32[-_]2000&#34;,
            &#34;linux[-_]32[-_].+&#34;,
            &#34;linux[-_]64[-_].+&#34;,

            Args:
                os_name (str): Name that matches the format for the os flag.

            Returns:
                None
        &#34;&#34;&#34;
        os_name_new = self.ffi.new(&#34;char[]&#34;, bytes(os_name, &#34;utf-8&#34;))
        self.libpanda.panda_set_os_name(os_name_new)


    def get_mappings(self, cpu):
        &#39;&#39;&#39;
        Get all active memory mappings in the system.

        Requires: OSI

        Args:
            cpu: CPUState struct

        Returns:
            pandare.utils.GArrayIterator: iterator of OsiModule structures
        &#39;&#39;&#39;
        current = self.plugins[&#39;osi&#39;].get_current_process(cpu)
        maps = self.plugins[&#39;osi&#39;].get_mappings(cpu, current)
        map_len = self.garray_len(maps)
        return GArrayIterator(self.plugins[&#39;osi&#39;].get_one_module, maps, map_len, self.plugins[&#39;osi&#39;].cleanup_garray)

    def get_processes(self, cpu):
        &#39;&#39;&#39;
        Get all running processes in the system. Includes kernel modules on Linux.

        Requires: OSI

        Args:
            cpu: CPUState struct

        Returns:
            pandare.utils.GArrayIterator: iterator of OsiProc structures
        &#39;&#39;&#39;
        processes = self.plugins[&#39;osi&#39;].get_processes(cpu)
        processes_len = self.garray_len(processes)
        return GArrayIterator(self.plugins[&#39;osi&#39;].get_one_proc, processes, processes_len, self.plugins[&#39;osi&#39;].cleanup_garray)

    def get_processes_dict(self, cpu):
        &#39;&#39;&#39;
        Get all running processes for the system at this moment in time as a dictionary.

        The dictionary maps proceses by their PID. Each mapping returns a dictionary containing the process name, its pid,
        and its parent pid (ppid).

        Requires: OSI

        Args:
            cpu: CPUState struct

        Returns:
            Dict: processes as described above
        &#39;&#39;&#39;

        procs = {} #pid: {name: X, pid: Y, parent_pid: Z})

        for proc in self.get_processes(cpu):
            assert(proc != self.ffi.NULL)
            assert(proc.pid not in procs)
            procs[proc.pid] = {&#34;name&#34;: self.ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;), &#39;pid&#39;: proc.pid, &#39;parent_pid&#39;: proc.ppid}
            assert(not (proc.pid != 0 and proc.pid == proc.ppid)) # No cycles allowed other than at 0
        return procs

    def get_process_name(self, cpu):
        &#39;&#39;&#39;
        Get the name of the current process. May return None if OSI cannot identify the current process
        &#39;&#39;&#39;
        proc = self.plugins[&#39;osi&#39;].get_current_process(cpu)
        if proc == self.ffi.NULL or proc.name == self.ffi.NULL:
            return None

        procname = self.ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;)
        return self.ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;)


    ################## PYPERIPHERAL FUNCTIONS #####################
    # Pyperipherals are objects which handle mmio read/writes using the PANDA callback infrastructure.
    # Under the hood, they use the cb_unassigned_io_read/cb_unassigned_io_write callbacks.
    # A python peripheral itself is an object which exposes the following functions:
    #     write_memory(self, address, size, value)
    #     read_memory(self, address, size)
    # And has at least the following attributes:
    #     address
    #     size

    # One example for such a python object are avatar2&#39;s AvatarPeripheral.
    def _addr_to_pyperipheral(self, address):
        &#34;&#34;&#34;
        Returns the python peripheral for a given address, or None if no
        peripheral is registered for that address
        &#34;&#34;&#34;

        for pp in self.pyperipherals:
            if pp.address &lt;= address &lt; pp.address + pp.size:
                return pp
        return None

    def _validate_object(self, object):
        # This function makes sure that the object exposes the right interfaces

        if not hasattr(object, &#34;address&#34;) or not isinstance(object.address, int):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing or non-int `address` attribute&#34;
                ).format(str(object.__repr__()))
            )

        if not hasattr(object, &#34;size&#34;) or not isinstance(object.size, int):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing or non-int `address` attribute&#34;
                ).format(object.__repr__())
            )

        if not hasattr(object, &#34;read_memory&#34;):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing read_memory function&#34;
                ).format(object.__repr__())
            )

        params = list(signature(object.read_memory).parameters)
        if params[0] != &#34;address&#34; or params[1] != &#34;size&#34;:
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Invalid function signature for read_memory&#34;
                ).format(object.__repr__())
            )

        if not hasattr(object, &#34;write_memory&#34;):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing write_memory function&#34;
                ).format(object.__repr__())
            )

        params = list(signature(object.write_memory).parameters)
        if params[0] != &#34;address&#34; or params[1] != &#34;size&#34; or params[2] != &#34;value&#34;:
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Invalid function signature for write_memory&#34;
                ).format(object.__repr__())
            )

        # Ensure object is not overlapping with any other pyperipheral
        if (
            self._addr_to_pyperipheral(object.address) is not None
            or self._addr_to_pyperipheral(object.address + object.size) is not None
        ):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34; &#34;Overlapping memories!&#34;
                ).format(object.__repr__())
            )

        return True

    def pyperiph_read_cb(self, cpu, pc, physaddr, size, val_ptr):
        pp = self._addr_to_pyperipheral(physaddr)
        if pp is None:
            return False

        val = pp.read_memory(physaddr, size)
        buf = self.ffi.buffer(val_ptr, size)

        fmt = &#34;{}{}&#34;.format(self._end2fmt[self.endianness], self._num2fmt[size])

        pack_into(fmt, buf, 0, val)

        return True

    def pyperiph_write_cb(self, cpu, pc, physaddr, size, val):
        pp = self._addr_to_pyperipheral(physaddr)
        if pp is None:
            return False

        pp.write_memory(physaddr, size, val)
        return True

    def register_pyperipheral(self, object):
        &#34;&#34;&#34;
        Registers a python peripheral, and the necessary attributes to the
        panda-object, if not present yet.
        &#34;&#34;&#34;

        # if we are the first pyperipheral, register the pp-dict
        if not hasattr(self, &#34;pyperipherals&#34;):
            self.pyperipherals = []
            self.pyperipherals_registered_cb = False
            self._num2fmt = {1: &#34;B&#34;, 2: &#34;H&#34;, 4: &#34;I&#34;, 8: &#34;Q&#34;}
            self._end2fmt = {&#34;little&#34;: &#34;&lt;&#34;, &#34;big&#34;: &#34;&gt;&#34;}

        self._validate_object(object)

        if self.pyperipherals_registered_cb is False:
            self.register_callback(
                self.callback.unassigned_io_read,
                self.callback.unassigned_io_read(self.pyperiph_read_cb),
                &#34;pyperipheral_read_callback&#34;,
            )

            self.register_callback(
                self.callback.unassigned_io_write,
                self.callback.unassigned_io_write(self.pyperiph_write_cb),
                &#34;pyperipheral_write_callback&#34;,
            )

            self.pyperipherals_registered_cb = True

        self.pyperipherals.append(object)

    def unregister_pyperipheral(self, pyperiph):
        &#34;&#34;&#34;
        deregisters a python peripheral.
        The pyperiph parameter can be either an object, or an address
        Returns true if the pyperipheral was successfully removed, else false.
        &#34;&#34;&#34;

        if isinstance(pyperiph, int) is True:
            pp = self._addr_to_pyperipheral(pyperiph)
            if pp is None:
                return False
        else:
            if pyperiph not in self.pyperipherals:
                return False
            pp = pyperiph

        self.pyperipherals.remove(pp)

        # If we dont have any pyperipherals left, unregister callbacks
        if len(self.pyperipherals) == 0:
            self.disable_callback(&#34;pyperipheral_read_callback&#34;, forever=True)
            self.disable_callback(&#34;pyperipheral_write_callback&#34;, forever=True)
            self.pyperipherals_registered_cb = False
        return True

    ############## TAINT FUNCTIONS ###############
    # Convenience methods for interacting with the taint subsystem.
    def taint_enable(self, cont=True):
        &#34;&#34;&#34;
        Inform python that taint is enabled.
        &#34;&#34;&#34;
        if not self.taint_enabled:
            progress(&#34;taint not enabled -- enabling&#34;)
            self.vm_stop()
            self.load_plugin(&#34;taint2&#34;)
#            self.queue_main_loop_wait_fn(self.load_plugin, [&#34;taint2&#34;])
            self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_enable_taint, [])
            if cont:
                self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])
            self.taint_enabled = True

    # label all bytes in this register.
    # or at least four of them
    def taint_label_reg(self, reg_num, label):
        self.taint_enable(cont=False)
        #if debug:
        #    progress(&#34;taint_reg reg=%d label=%d&#34; % (reg_num, label))

        # XXX must ensure labeling is done in a before_block_invalidate that rets 1
        #     or some other safe way where the main_loop_wait code will always be run
        #self.stop()
        for i in range(self.register_size):
            self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_label_reg, [reg_num, i, label])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])

    def taint_label_ram(self, addr, label):
        self.taint_enable(cont=False)
        #if debug:
            #progress(&#34;taint_ram addr=0x%x label=%d&#34; % (addr, label))

        # XXX must ensure labeling is done in a before_block_invalidate that rets 1
        #     or some other safe way where the main_loop_wait code will always be run
        #self.stop()
        self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_label_ram, [addr, label])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])

    # returns true if any bytes in this register have any taint labels
    def taint_check_reg(self, reg_num):
        if not self.taint_enabled: return False
#        if debug:
#            progress(&#34;taint_check_reg %d&#34; % (reg_num))
        for offset in range(self.register_size):
            if self.plugins[&#39;taint2&#39;].taint2_query_reg(reg_num, offset) &gt; 0:
                return True

    # returns true if this physical address is tainted
    def taint_check_ram(self, addr):
        if not self.taint_enabled: return False
        if self.plugins[&#39;taint2&#39;].taint2_query_ram(addr) &gt; 0:
            return True

    def taint_get_reg(self, reg_num):
        &#39;&#39;&#39;
        Returns array of results, one for each byte in this register
        None if no taint.  QueryResult struct otherwise
        &#39;&#39;&#39;
        if not self.taint_enabled: return None
        if debug:
            progress(&#34;taint_get_reg %d&#34; % (reg_num))
        res = []
        for offset in range(self.register_size):
            if self.plugins[&#39;taint2&#39;].taint2_query_reg(reg_num, offset) &gt; 0:
                query_res = self.ffi.new(&#34;QueryResult *&#34;)
                self.plugins[&#39;taint2&#39;].taint2_query_reg_full(reg_num, offset, query_res)
                tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;], self.ffi)
                res.append(tq)
            else:
                res.append(None)
        return res

    # returns array of results, one for each byte in this register
    # None if no taint.  QueryResult struct otherwise
    def taint_get_ram(self, addr):
        if not self.taint_enabled: return None
        if self.plugins[&#39;taint2&#39;].taint2_query_ram(addr) &gt; 0:
            query_res = self.ffi.new(&#34;QueryResult *&#34;)
            self.plugins[&#39;taint2&#39;].taint2_query_ram_full(addr, query_res)
            tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;], self.ffi)
            return tq
        else:
            return None

    # returns true if this laddr is tainted
    def taint_check_laddr(self, addr, off):
        if not self.taint_enabled: return False
        if self.plugins[&#39;taint2&#39;].taint2_query_laddr(addr, off) &gt; 0:
            return True

    # returns array of results, one for each byte in this laddr
    # None if no taint.  QueryResult struct otherwise
    def taint_get_laddr(self, addr, offset):
        if not self.taint_enabled: return None
        if self.plugins[&#39;taint2&#39;].taint2_query_laddr(addr, offset) &gt; 0:
            query_res = self.ffi.new(&#34;QueryResult *&#34;)
            self.plugins[&#39;taint2&#39;].taint2_query_laddr_full(addr, offset, query_res)
            tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;], self.ffi)
            return tq
        else:
            return None

    def taint_sym_enable(self, cont=True):
        &#34;&#34;&#34;
        Inform python that taint is enabled.
        &#34;&#34;&#34;
        if not self.taint_enabled:
            progress(&#34;taint symbolic not enabled -- enabling&#34;)
            self.vm_stop()
            self.load_plugin(&#34;taint2&#34;)
#            self.queue_main_loop_wait_fn(self.load_plugin, [&#34;taint2&#34;])
        if not self.taint_sym_enabled:
            self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_enable_sym, [])
            if cont:
                self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])
            self.taint_enabled = True

    def taint_sym_label_ram(self, addr, label):
        self.taint_sym_enable(cont=False)
        #if debug:
            #progress(&#34;taint_ram addr=0x%x label=%d&#34; % (addr, label))

        # XXX must ensure labeling is done in a before_block_invalidate that rets 1
        #     or some other safe way where the main_loop_wait code will always be run
        #self.stop()
        self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_sym_label_ram, [addr, label])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])

    # label all bytes in this register.
    # or at least four of them
    def taint_sym_label_reg(self, reg_num, label):
        self.taint_sym_enable(cont=False)
        #if debug:
        #    progress(&#34;taint_reg reg=%d label=%d&#34; % (reg_num, label))

        # XXX must ensure labeling is done in a before_block_invalidate that rets 1
        #     or some other safe way where the main_loop_wait code will always be run
        #self.stop()
        for i in range(self.register_size):
            self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_sym_label_reg, [reg_num, i, label])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])


    ############ Volatility mixins
    &#34;&#34;&#34;
    Utilities to integrate Volatility with PANDA. Highly experimental.
    &#34;&#34;&#34;

    def make_panda_file_handler(self, debug=False):
        &#39;&#39;&#39;
        Constructs a file and file handler that volatility can&#39;t ignore to back by PANDA physical memory
        &#39;&#39;&#39;
        from urllib.request import BaseHandler
        if &#39;PandaFileHandler&#39; in globals():  # already initialized
            return
        panda = self

        class PandaFile(object):
            def __init__(self, length, panda):
                self.pos = 0
                self.length = length
                self.closed = False
                self.mode = &#34;rb&#34;
                self.name = &#34;/tmp/panda.panda&#34;
                self.panda = panda
                self.classname = type(self).__name__

            def readable(self):
                return self.closed

            def read(self, size=1):
                if self.panda.bits == 32 and self.panda.arch_name == &#34;i386&#34;:
                    data = self.panda.physical_memory_read(
                        self.pos &amp; 0xfffffff, size)
                else:
                    data = self.panda.physical_memory_read(self.pos, size)
                if debug:
                    print(self.classname+&#34;: Reading &#34; +
                          str(size)+&#34; bytes from &#34;+hex(self.pos))
                self.pos += size
                return data

            def peek(self, size=1):
                return self.panda.physical_memory_read(self.pos, size)

            def seek(self, pos, whence=0):
                if whence == 0:
                    self.pos = pos
                elif whence == 1:
                    self.pos += pos
                else:
                    self.pos = self.length - pos
                if self.pos &gt; self.length:
                    print(self.classname+&#34;: We&#39;ve gone off the deep end&#34;)
                if debug:
                    print(self.classname+&#34; Seeking to address &#34;+hex(self.pos))

            def tell(self):
                return self.pos

            def close(self):
                self.closed = True

        class PandaFileHandler(BaseHandler):
            def default_open(self, req):
                if &#39;panda.panda&#39; in req.full_url:
                    length = panda.libpanda.ram_size
                    if length &gt; 0xc0000000:
                        length += 0x40000000  # 3GB hole
                    if debug:
                        print(type(self).__name__ +
                              &#34;: initializing PandaFile with length=&#34;+hex(length))
                    return PandaFile(length=length, panda=panda)
                else:
                    return None

            def file_close(self):
                return True

        globals()[&#34;PandaFileHandler&#34;] = PandaFileHandler

    def get_volatility_symbols(self, debug=False):
        try:
            from .volatility_cli_classes import CommandLineMoreEfficient
            from volatility.framework import contexts
            from volatility.framework.layers.linear import LinearlyMappedLayer
            from volatility.framework.automagic import linux
        except ImportError:
            print(&#34;Warning: Failed to import volatility&#34;)
            return None
        if &#34;linux&#34; in self.os_type:
            if not hasattr(self, &#34;_vmlinux&#34;):
                self.make_panda_file_handler(debug=debug)
                constructed_original = CommandLineMoreEfficient().run()
                linux.LinuxUtilities.aslr_mask_symbol_table(
                    constructed_original.context, constructed_original.config[&#39;vmlinux&#39;], constructed_original.config[&#39;primary&#39;])
                self._vmlinux = contexts.Module(
                    constructed_original.context, constructed_original.config[&#39;vmlinux&#39;], constructed_original.config[&#39;primary&#39;], 0)
            else:
                LinearlyMappedLayer.read.cache_clear()  # smearing technique
            return self._vmlinux
        else:
            print(&#34;Unsupported.&#34;)
            return None

    def run_volatility(self, plugin, debug=False):
        try:
            from .volatility_cli_classes import CommandLineRunFullCommand, StringTextRenderer
        except ImportError:
            print(&#34;Warning: Failed to import volatility&#34;)
            return None
        self.make_panda_file_handler(debug=debug)
        cmd = CommandLineRunFullCommand().run(&#34;-q -f panda.panda &#34; + plugin)
        output = StringTextRenderer().render(cmd.run())
        return output

    ########## BLOCKING MIXINS ############
    &#39;&#39;&#39;
    Utilities to provide blocking interactions with PANDA. This includes serial and monitor interactions as well as file copy to the guest.
    XXX: Do not call any of the following from the main thread- they depend on the CPU loop running
    &#39;&#39;&#39;
    @blocking
    def stop_run(self):
        &#39;&#39;&#39;
        From a blocking thread, request vl.c loop to break. Returns control flow in main thread.
        In other words, once this is called, panda.run() will finish and your main thread will continue.
        If you also want to unload plugins, use end_analysis instead

        XXX: This doesn&#39;t work in replay mode
        &#39;&#39;&#39;
        self.libpanda.panda_break_vl_loop_req = True

    @blocking
    def run_serial_cmd(self, cmd, no_timeout=False, timeout=None):
        &#39;&#39;&#39;
        Run a command inside the guest through a terminal exposed over a serial port. Can only be used if your guest is configured in this way

        Guest output will be analyzed until we see the expect_prompt regex printed (i.e., the PS1 prompt)

        Args:
            cmd: command to run.
            timeout: maximum time to wait for the command to finish
            no_timeout: if set, don&#39;t ever timeout

        Returns:
            String: all the output (stdout + stderr) printed after typing your command and pressing enter until the next prompt was printed.
        &#39;&#39;&#39;

        if timeout is None:
            timeout = 30

        if self.serial_console is None:
            raise RuntimeError(&#34;Cannot run serial commands without providing PANDA an expect_prompt&#34;)
        self.running.wait() # Can only run serial when guest is running
        self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
        if no_timeout:
            result = self.serial_console.expect(timeout=9999) # &#34;Don&#39;t ever timeout&#34; above is a bit of an exaggeration
        else:
            result = self.serial_console.expect(timeout=timeout)
        return result

    @blocking
    def run_serial_cmd_async(self, cmd, delay=1):
        &#39;&#39;&#39;
        Type a command and press enter in the guest. Return immediately. No results available
        Only use this if you know what you&#39;re doing!
        &#39;&#39;&#39;
        self.running.wait() # Can only run serial when guest is running
        self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
        if delay:
            sleep(delay) # Ensure it has a chance to run

    @blocking
    def type_serial_cmd(self, cmd):
        #Can send message into socket without guest running (no self.running.wait())
        self.serial_console.send(cmd.encode(&#34;utf8&#34;)) # send, not sendline

    def finish_serial_cmd(self):
        result = self.serial_console.send_eol()
        result = self.serial_console.expect()
        return result

    @blocking
    def run_monitor_cmd(self, cmd):
        self.monitor_console.sendline(cmd.encode(&#34;utf8&#34;))
        result = self.monitor_console.expect()
        return result

    @blocking
    def revert_sync(self, snapshot_name):
        &#39;&#39;&#39;
        Args:
            snapshot_name: name of snapshot in the current qcow to load

        Returns:
            String: error message. Empty on success.
        &#39;&#39;&#39;
        result = self.run_monitor_cmd(&#34;loadvm {}&#34;.format(snapshot_name))
        # On success we should get no result

        if result.startswith(&#34;Length mismatch&#34;):
            raise RuntimeError(&#34;QEMU machine&#39;s RAM size doesn&#39;t match snapshot RAM size!&#34;)

        if &#34;does not have the requested snapshot&#34; in result:
            raise ValueError(f&#34;Snapshot &#39;{snapshot_name}&#39; not present in {self.qcow}&#34;)

        result = result.strip()
        if len(result):
            warn(f&#34;snapshot load returned error {result}&#34;)

        return result

    @blocking
    def delvm_sync(self, snapshot_name):
        self.run_monitor_cmd(&#34;delvm {}&#34;.format(snapshot_name))

    @blocking
    def copy_to_guest(self, copy_directory, iso_name=None, absolute_paths=False, setup_script=&#34;setup.sh&#34;, timeout=None):
        &#39;&#39;&#39;

        Copy a directory from the host into the guest by
        1) Creating an .iso image of the directory on the host
        2) Run a bash command to mount it at the exact same path + .ro and then copy the files to the provided path
        3) If the directory contains setup.sh, run it

        Args:
            copy_directory: Local directory to copy into guest
            iso_name: Name of iso file that will be generated. Defaults to [copy_directory].iso
            absolute_paths: is copy_directory an absolute or relative path
            seutp_script: name of a script which, if present inside copy_directory, will be automatically run after the copy
            timeout: maximum time each copy command will be allowed to run for, will use the `run_serial_cmd` default value unless another is provided

        Returns:
            None
        &#39;&#39;&#39;

        if not iso_name:
            iso_name = copy_directory + &#39;.iso&#39;
        make_iso(copy_directory, iso_name)

        if not absolute_paths:
            copy_directory = path.split(copy_directory)[-1] # Copy directory relative, not absolutely


        # Drive the guest to mount the drive
        # setup_sh:
        #   Make sure cdrom didn&#39;t automount
        #   Make sure guest path mirrors host path
        #   if there is a setup.sh script in the directory,
        #   then run that setup.sh script first (good for scripts that need to
        #   prep guest environment before script runs)
        mount_dir = shlex_quote(copy_directory)

        mkdir_result = self.run_serial_cmd(f&#34;mkdir -p {mount_dir} {mount_dir}.ro &amp;&amp; echo \&#34;mkdir_ok\&#34;; echo \&#34;exit code $?\&#34;&#34;, timeout=timeout)

        if &#39;mkdir_ok&#39; not in mkdir_result:
            raise RuntimeError(f&#34;Failed to create mount directories inside guest: {mkdir_result}&#34;)

        # Tell panda to we insert the CD drive
        # TODO: the cd-drive name should be a config option, see the values in qcow.py
        errs = self.run_monitor_cmd(&#34;change ide1-cd0 \&#34;{}\&#34;&#34;.format(iso_name))
        if len(errs):
            warn(f&#34;Warning encountered when connecting media to guest: {errs}&#34;)

        try:
            mount_status = &#34;bad&#34;
            for _ in range(10):
                if &#39;mount_ok&#39; in mount_status:
                    break
                mount_status = self.run_serial_cmd(f&#34;mount /dev/cdrom {mount_dir}.ro &amp;&amp; echo &#39;mount_ok&#39; || (umount /dev/cdrom; echo &#39;bad&#39;)&#34;, timeout=timeout)
                sleep(1)
            else:
                # Didn&#39;t ever break
                raise RuntimeError(f&#34;Failed to mount media inside guest: {mount_status}&#34;)

            # Note the . after our src/. directory - that&#39;s special syntax for cp -a
            copy_result = self.run_serial_cmd(f&#34;cp -a {mount_dir}.ro/. {mount_dir} &amp;&amp; echo &#39;ok&#39;&#34;, timeout=timeout)
            if copy_result != &#39;ok&#39;:
                raise RuntimeError(f&#34;Copy to rw directory failed: {copy_result}&#34;)

        finally:
            # Ensure we disconnect the CD drive after the mount + copy, even if it fails
            self.run_serial_cmd(&#34;umount /dev/cdrom&#34;) # This can fail and that&#39;s okay, we&#39;ll forece eject
            sleep(1)
            errs = self.run_monitor_cmd(&#34;eject -f ide1-cd0&#34;)
            if len(errs):
                warn(f&#34;Warning encountered when disconnecting media from guest: {errs}&#34;)

        if isfile(pjoin(copy_directory, setup_script)):
            setup_result = self.run_serial_cmd(f&#34;{mount_dir}/{setup_script}&#34;, timeout=timeout)
            progress(&#34;[Setup command]: {setup_result}&#34;)

    @blocking
    def record_cmd(self, guest_command, copy_directory=None, iso_name=None, setup_command=None, recording_name=&#34;recording&#34;, snap_name=&#34;root&#34;, ignore_errors=False):
        &#39;&#39;&#39;
        Take a recording as follows:
            0) Revert to the specified snapshot name if one is set. By default &#39;root&#39;. Set to `None` if you have already set up the guest and are ready to record with no revert
            1) Create an ISO of files that need to be copied into the guest if copy_directory is specified. Copy them in
            2) Run the setup_command in the guest, if provided
            3) Type the command you wish to record but do not press enter to begin execution. This avoids the recording capturing the command being typed
            4) Begin the recording (name controlled by recording_name)
            5) Press enter in the guest to begin the command. Wait until it finishes.
            6) End the recording
        &#39;&#39;&#39;
        # 0) Revert to the specified snapshot
        if snap_name is not None:
            self.revert_sync(snap_name) # Can&#39;t use self.revert because that would would run async and we&#39;d keep going before the revert happens

        # 1) Make copy_directory into an iso and copy it into the guest - It will end up at the exact same path
        if copy_directory: # If there&#39;s a directory, build an ISO and put it in the cddrive
            # Make iso
            self.copy_to_guest(copy_directory, iso_name)

        # 2) Run setup_command, if provided before we start the recording (good place to CD or install, etc)
        if setup_command:
            print(f&#34;Running setup command {setup_command}&#34;)
            r = self.run_serial_cmd(setup_command)
            print(f&#34;Setup command results: {r}&#34;)

        # 3) type commmand (note we type command, start recording, finish command)
        self.type_serial_cmd(guest_command)

        # 4) start recording
        self.run_monitor_cmd(&#34;begin_record {}&#34;.format(recording_name))

        # 5) finish command
        result = self.finish_serial_cmd()

        if debug:
            progress(&#34;Result of `{}`:&#34;.format(guest_command))
            print(&#34;\t&#34;+&#34;\n\t&#34;.join(result.split(&#34;\n&#34;))+&#34;\n&#34;)

        if &#34;No such file or directory&#34; in result and not ignore_errors:
            print(&#34;Bad output running command: {}&#34;.format(result))
            raise RuntimeError(&#34;Command not found while taking recording&#34;)

        if &#34;cannot execute binary file&#34; in result and not ignore_errors:
            print(&#34;Bad output running command: {}&#34;.format(result))
            raise RuntimeError(&#34;Could not execute binary while taking recording&#34;)

        # 6) End recording
        self.run_monitor_cmd(&#34;end_record&#34;)

        print(&#34;Finished recording&#34;)

    @blocking
    def interact(self, confirm_quit=True):
        &#39;&#39;&#39;
        Expose console interactively until user types pandaquit
        Must be run in blocking thread.

        TODO: This should probably repace self.serial_console with something
        that directly renders output to the user. Then we don&#39;t have to handle
        buffering and other problems. But we will need to re-enable the serial_console
        interface after this returns
        &#39;&#39;&#39;
        print(&#34;PANDA: entering interactive mode. Type pandaquit to exit&#34;)
        prompt = self.expect_prompt.decode(&#34;utf8&#34;) if self.expect_prompt  else &#34;$ &#34;
        if not prompt.endswith(&#34; &#34;): prompt += &#34; &#34;
        while True:
            cmd = input(prompt) # TODO: Strip all control characters - Ctrl-L breaks things
            if cmd.strip() == &#39;pandaquit&#39;:
                if confirm_quit:
                    q = input(&#34;PANDA: Quitting interactive mode. Are you sure? (y/n) &#34;)
                    if len(q) and q.lower()[0] == &#39;y&#39;:
                        break
                    else:
                        continue
                else: # No confirm - just break
                    break
            r = self.run_serial_cmd(cmd) # XXX: may timeout
            print(r)

    @blocking
    def do_panda_finish(self):
        &#39;&#39;&#39;
        Call panda_finish. Note this isn&#39;t really blocking - the
        guest should have exited by now, but queue this after
        (blocking) shutdown commands in our internal async queue
        so it must also be labeled as blocking.
        &#39;&#39;&#39;
#        assert (not self.running.is_set()), &#34;Can&#39;t finish while still running&#34;
        self.panda_finish()

    ################## CALLBACK FUNCTIONS ################
    # Mixin for handling callbacks and generation of decorators that allow users to register their own callbacks
    # such as panda.cb_before_block_exec()
    def register_cb_decorators(self):
        &#39;&#39;&#39;
        Setup callbacks and generate self.cb_XYZ functions for cb decorators
        XXX Don&#39;t add any other methods with names starting with &#39;cb_&#39;
        Callbacks can be called as @panda.cb_XYZ in which case they&#39;ll take default arguments and be named the same as the decorated function
        Or they can be called as @panda.cb_XYZ(name=&#39;A&#39;, procname=&#39;B&#39;, enabled=True). Defaults: name is function name, procname=None, enabled=True unless procname set
        &#39;&#39;&#39;
        for cb_name, pandatype in zip(self.callback._fields, self.callback):
            def closure(closed_cb_name, closed_pandatype): # Closure on cb_name and pandatype
                def f(*args, **kwargs):
                    if len(args): # Called as @panda.cb_XYZ without ()s- no arguments to decorator but we get the function name instead
                        # Call our decorator with only a name argument ON the function itself
                        fun = args[0]
                        return self._generated_callback(closed_pandatype, **{&#34;name&#34;: fun.__name__})(fun)
                    else:
                        # Otherwise, we were called as @panda.cb_XYZ() with potential args - Just return the decorator and it&#39;s applied to the function
                        return self._generated_callback(closed_pandatype, *args, **kwargs)
                return f

            setattr(self, &#39;cb_&#39;+cb_name, closure(cb_name, pandatype))

    def _generated_callback(self, pandatype, name=None, procname=None, enabled=True):
        &#39;&#39;&#39;
        Actual implementation of self.cb_XYZ. pandatype is pcb.XYZ
        name must uniquely describe a callback
        if procname is specified, callback will only be enabled when that asid is running (requires OSI support)
        &#39;&#39;&#39;

        if procname:
            enabled = False # Process won&#39;t be running at time 0 (probably)
            self._register_internal_asid_changed_cb()

        def decorator(fun):
            local_name = name  # We need a new varaible otherwise we have scoping issues with _generated_callback&#39;s name
            if name is None:
                local_name = fun.__name__

            # 0 works for all callbacks except void. We check later on
            # to see if we need to return None otherwise we return 0
            return_from_exception = 0

            def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
                try:
                    r = fun(*args, **kwargs)
                    #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                    #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                    #print(fun, r) # Stuck with TypeError in _run_and_catch? Enable this to find where the bug is.
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    self.callback_exit_exception = e
                    self.end_analysis()
                    return return_from_exception

            cast_rc = pandatype(_run_and_catch)
            cast_rc_string = str(self.ffi.typeof(cast_rc))
            return_from_exception = 0
            if &#34;void(*)(&#34; in cast_rc_string:
                return_from_exception = None

            self.register_callback(pandatype, cast_rc, local_name, enabled=enabled, procname=procname)
            def wrapper(*args, **kw):
                return _run_and_catch(*args, **kw)
            return wrapper
        return decorator

    def _register_internal_asid_changed_cb(self):
        &#39;&#39;&#39;
        Call this function if you need procname filtering for callbacks. It enables
        an internal callback on asid_changed (and sometimes an after_block_exec cb)
        which will deteremine when the process name changes and enable/disable other callbacks
        that filter on process name.
        &#39;&#39;&#39;
        if self._registered_asid_changed_internal_cb: # Already registered these callbacks
            return

        @self.ppp(&#34;syscalls2&#34;, &#34;on_sys_brk_enter&#34;)
        def on_sys_brk_enter(cpu, pc, brk):
            name = self.get_process_name(cpu)
            asid = self.libpanda.panda_current_asid(cpu)
            if self.asid_mapping.get(asid, None) != name:
                self.asid_mapping[asid] = name
                self._procname_changed(cpu, name)

        @self.callback.after_block_exec
        def __get_pending_procname_change(cpu, tb, exit_code):
            if exit_code: # Didn&#39;t actually execute block
                return None
            if not self.in_kernel(cpu): # Once we&#39;re out of kernel code, grab procname
                process = self.plugins[&#39;osi&#39;].get_current_process(cpu)
                if process != self.ffi.NULL:
                    name = self.ffi.string(process.name).decode(&#34;utf8&#34;, &#34;ignore&#34;)
                else:
                    return None # Couldn&#39;t figure out the process
                asid = self.libpanda.panda_current_asid(cpu)
                self.asid_mapping[asid] = name
                self._procname_changed(cpu, name)
                self.disable_callback(&#39;__get_pending_procname_change&#39;) # Disabled to begin


        # Local function def
        @self.callback.asid_changed
        def __asid_changed(cpustate, old_asid, new_asid):
            &#39;&#39;&#39;
            When the ASID changes, check if we know its procname (in self.asid_mapping),
            if so, call panda._procname_changed(cpu, name). Otherwise, we enable __get_pending_procname_change CB, which
            waits until the procname changes. Then we grab the new procname, update self.asid_mapping and call
            panda._procname_changed(cpu, name)
            &#39;&#39;&#39;
            if old_asid == new_asid:
                return 0

            if new_asid not in self.asid_mapping: # We don&#39;t know this ASID-&gt;procname - turn on __get_pending_procname_change
                if not self.is_callback_enabled(&#39;__get_pending_procname_change&#39;):
                    self.enable_callback(&#39;__get_pending_procname_change&#39;)
            else: # We do know this ASID-&gt;procname, just call procname_changed
                self._procname_changed(cpustate, self.asid_mapping[new_asid])

            return 0

        self.register_callback(self.callback.asid_changed, __asid_changed, &#34;__asid_changed&#34;) # Always call on ASID change

        # This internal callback is only enabled on-demand (later) when we need to figure out ASID-&gt;procname mappings
        self.register_callback(self.callback.after_block_exec, __get_pending_procname_change, &#34;__get_pending_procname_change&#34;, enabled=False)

        self._registered_asid_changed_internal_cb = True

    def register_callback(self, callback, function, name, enabled=True, procname=None):
        # CB   = self.callback.main_loop_wait
        # func = main_loop_wait_cb
        # name = main_loop_wait

        if name in self.registered_callbacks:
            print(f&#34;Warning: replacing existing callback &#39;{name}&#39; since it was re-registered&#34;)
            self.delete_callback(name)

        cb = self.callback_dictionary[callback]

        # Generate a unique handle for each callback type using the number of previously registered CBs of that type added to a constant
        handle = self.ffi.cast(&#39;void *&#39;, 0x8888 + 100*len([x for x in self.registered_callbacks.values() if x[&#39;callback&#39;] == cb]))

        # XXX: We should have another layer of indirection here so we can catch
        #      exceptions raised during execution of the CB and abort analysis
        pcb = self.ffi.new(&#34;panda_cb *&#34;, {cb.name:function})

        if debug:
            progress(&#34;Registered function &#39;{}&#39; to run on callback {}&#34;.format(name, cb.name))

        self.libpanda.panda_register_callback_helper(handle, cb.number, pcb)
        self.registered_callbacks[name] = {&#34;procname&#34;: procname, &#34;enabled&#34;: True, &#34;callback&#34;: cb,
                           &#34;handle&#34;: handle, &#34;pcb&#34;: pcb, &#34;function&#34;: function} # XXX: if function is not saved here it gets GC&#39;d and everything breaks! Watch out!

        if not enabled: # Note the registered_callbacks dict starts with enabled true and then we update it to false as necessary here
            self.disable_callback(name)

        if &#34;block&#34; in cb.name and &#34;start&#34; not in cb.name and &#34;end&#34; not in cb.name:
            if not self.disabled_tb_chaining:
                print(&#34;Warning: disabling TB chaining to support {} callback&#34;.format(cb.name))
                self.disable_tb_chaining()


    def is_callback_enabled(self, name):
        if name not in self.registered_callbacks.keys():
            raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))
        return self.registered_callbacks[name][&#39;enabled&#39;]

    def enable_internal_callbacks(self):
        &#39;&#39;&#39;
        Enable all our internal callbacks that start with __ such as __main_loop_wait
        and __asid_changed. Important in case user has done a panda.end_analysis()
        and then (re)called run
        &#39;&#39;&#39;
        for name in self.registered_callbacks.keys():
            if name.startswith(&#34;__&#34;) and not self.registered_callbacks[name][&#39;enabled&#39;]:
                self.enable_callback(name)

    def enable_all_callbacks(self):
        &#39;&#39;&#39;
        Enable all python callbacks that have been disabled
        &#39;&#39;&#39;
        for name in self.registered_callbacks.keys():
            self.enable_callback(name)

    def enable_callback(self, name):
        &#39;&#39;&#39;
        Enable a panda plugin using its handle and cb.number as a unique ID
        &#39;&#39;&#39;

        # During shutdown callback may be deleted before a request to enable comes through
        if self.ending:
            return

        if name not in self.registered_callbacks.keys():
            raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))

        self.registered_callbacks[name][&#39;enabled&#39;] = True
        handle = self.registered_callbacks[name][&#39;handle&#39;]
        cb = self.registered_callbacks[name][&#39;callback&#39;]
        pcb = self.registered_callbacks[name][&#39;pcb&#39;]
        #progress(&#34;Enabling callback &#39;{}&#39; on &#39;{}&#39; handle = {}&#34;.format(name, cb.name, handle))
        self.libpanda.panda_enable_callback_helper(handle, cb.number, pcb)

    def disable_callback(self, name, forever=False):
        &#39;&#39;&#39;
        Disable a panda plugin using its handle and cb.number as a unique ID
        If forever is specified, we&#39;ll never reenable the call- useful when
        you want to really turn off something with a procname filter.
        &#39;&#39;&#39;
        # During shutdown callback may be deleted before a request to enable comes through
        if self.ending:
            return

        if name not in self.registered_callbacks.keys():
            raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))
        self.registered_callbacks[name][&#39;enabled&#39;] = False
        handle = self.registered_callbacks[name][&#39;handle&#39;]
        cb = self.registered_callbacks[name][&#39;callback&#39;]
        pcb = self.registered_callbacks[name][&#39;pcb&#39;]
        #progress(&#34;Disabling callback &#39;{}&#39; on &#39;{}&#39; handle={}&#34;.format(name, cb.name, handle))
        self.libpanda.panda_disable_callback_helper(handle, cb.number, pcb)

        if forever:
            del self.registered_callbacks[name]

    def delete_callback(self, name):
        &#39;&#39;&#39;
        Completely delete a registered panda callback by name
        &#39;&#39;&#39;
        if name not in self.registered_callbacks.keys():
            raise ValueError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))

        handle = self.registered_callbacks[name][&#39;handle&#39;]
        self.libpanda.panda_unregister_callbacks(handle)
        if not hasattr(self,&#34;old_cb_list&#34;):
            self.old_cb_list = []
        self.old_cb_list.append(self.registered_callbacks[name])
        del self.registered_callbacks[name][&#39;handle&#39;]
        del self.registered_callbacks[name]

    def delete_callbacks(self):
        #for name in self.registered_callbacks.keys():
        while len(self.registered_callbacks.keys()) &gt; 0:
            self.delete_callback(list(self.registered_callbacks.keys())[0])

    ###########################
    ### PPP-style callbacks ###
    ###########################

    def ppp(self, plugin_name, attr, name=None, autoload=True):
        &#39;&#39;&#39;
        Decorator for plugin-to-plugin interface. Note this isn&#39;t in decorators.py
        becuase it uses the panda object.

        Example usage to register my_run with syscalls2 as a &#39;on_sys_open_return&#39;
        @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;)
        def my_fun(cpu, pc, filename, flags, mode):
            ...
        &#39;&#39;&#39;

        if plugin_name not in self.plugins and autoload: # Could automatically load it?
            print(f&#34;PPP automatically loaded plugin {plugin_name}&#34;)

        if not hasattr(self, &#34;ppp_registered_cbs&#34;):
            self.ppp_registered_cbs = {}
            # We use this to traak fn_names-&gt;fn_pointers so we can later disable by name

            # XXX: if  we don&#39;t save the cffi generated callbacks somewhere in Python,
            # they may get garbage collected even though the c-code could still has a
            # reference to them  which will lead to a crash. If we stop using this to track
            # function names, we need to keep it or something similar to ensure the reference
            # count remains &gt;0 in python

        def decorator(fun):
            local_name = name  # We need a new varaible otherwise we have scoping issues, maybe
            if local_name is None:
                local_name = fun.__name__

            def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
                try:
                    r = fun(*args, **kwargs)
                    #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                    #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    self.callback_exit_exception = e
                    self.end_analysis()
                    # this works in all current callback cases. CFFI auto-converts to void, bool, int, and int32_t

            f = self.ffi.callback(attr+&#34;_t&#34;)(_run_and_catch)  # Wrap the python fn in a c-callback.
            if local_name == &#34;&lt;lambda&gt;&#34;:
                local_name = f&#34;&lt;lambda_{self.lambda_cnt}&gt;&#34;
                self.lambda_cnt += 1

            if local_name in self.ppp_registered_cbs:
                print(f&#34;Warning: replacing existing PPP callback &#39;{local_name}&#39; since it was re-registered&#34;)
                self.disable_ppp(local_name)

            assert (local_name not in self.ppp_registered_cbs), f&#34;Two callbacks with conflicting name: {local_name}&#34;

            # Ensure function isn&#39;t garbage collected, and keep the name-&gt;(fn, plugin_name, attr) map for disabling
            self.ppp_registered_cbs[local_name] = (f, plugin_name, attr)

            eval(f&#34;self.plugins[&#39;{plugin_name}&#39;].ppp_add_cb_{attr}&#34;)(f) # All PPP  cbs start with this string. XXX insecure eval
            return f
        return decorator


    def disable_ppp(self, name):
        &#39;&#39;&#39;
        Disable a ppp-style callback by name.
        Unlike regular panda callbacks which can be enabled/disabled/deleted, PPP callbacks are only enabled/deleted (which we call disabled)

        Example usage to register my_run with syscalls2 as a &#39;on_sys_open_return&#39; and then disable:
        ```
        @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;)
        def my_fun(cpu, pc, filename, flags, mode):
            ...

        panda.disable_ppp(&#34;my_fun&#34;)
        ```

        -- OR --

        ```
        @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;, name=&#34;custom&#34;)
        def my_fun(cpu, pc, filename, flags, mode):
            ...
        ```

        panda.disable_ppp(&#34;custom&#34;)
        &#39;&#39;&#39;

        (f, plugin_name, attr) = self.ppp_registered_cbs[name]
        eval(f&#34;self.plugins[&#39;{plugin_name}&#39;].ppp_remove_cb_{attr}&#34;)(f) # All PPP cbs start with this string. XXX insecure eval
        del self.ppp_registered_cbs[name] # It&#39;s now safe to be garbage collected

    ########## GDB MIXINS ##############
    &#34;&#34;&#34;
    Provides the ability to interact with a QEMU attached gdb session by setting and clearing breakpoints. Experimental.
    &#34;&#34;&#34;

    def set_breakpoint(self, cpu, pc):
        &#39;&#39;&#39;
        Set a GDB breakpoint such that when the guest hits PC, execution is paused and an attached
        GDB instance can introspect on guest memory. Requires starting panda with -s, at least for now
        &#39;&#39;&#39;
        BP_GDB = 0x10
        self.libpanda.cpu_breakpoint_insert(cpu, pc, BP_GDB, self.ffi.NULL)

    def clear_breakpoint(self, cpu, pc):
        &#39;&#39;&#39;
        Remove a breakpoint
        &#39;&#39;&#39;
        BP_GDB = 0x10
        self.libpanda.cpu_breakpoint_remove(cpu, pc, BP_GDB)

    ############# HOOKING MIXINS ###############

    def hook(self, addr, enabled=True, kernel=None, asid=None, cb_type=&#34;start_block_exec&#34;):
        &#39;&#39;&#39;
        Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
        the function will be called with args (CPUState, TranslationBlock)
        &#39;&#39;&#39;

        def decorator(fun):
            if cb_type == &#34;before_tcg_codegen&#34; or cb_type == &#34;after_block_translate&#34; or cb_type == &#34;before_block_exec&#34; or cb_type == &#34;start_block_exec&#34; or cb_type == &#34;end_block_exec&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , struct hook *)&#34;)
            elif cb_type == &#34;after_block_exec&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , uint8_t, struct hook *)&#34;)
            elif cb_type == &#34;before_block_translate&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState* env, target_ptr_t pc, struct hook*)&#34;)
            elif cb_type == &#34;before_block_exec_invalidate_opt&#34;:
                hook_cb_type = self.ffi.callback(&#34;bool(CPUState* env, TranslationBlock*, struct hook*)&#34;)
            else:
                print(&#34;function type not supported&#34;)
                return
            type_num = getattr(self.libpanda, &#34;PANDA_CB_&#34;+cb_type.upper())

            if debug:
                print(&#34;Registering breakpoint at 0x{:x} -&gt; {} == {}&#34;.format(addr, fun, &#39;cdata_cb&#39;))

            # Inform the plugin that it has a new breakpoint at addr
            hook_cb_passed = hook_cb_type(fun)
            new_hook = self.ffi.new(&#34;struct hook*&#34;)
            new_hook.type = type_num
            new_hook.addr = addr
            if kernel or asid is None:
                new_hook.asid = 0
            else:
                new_hook.asid = asid

            setattr(new_hook.cb,cb_type, hook_cb_passed)
            if kernel:
                new_hook.km = self.libpanda.MODE_KERNEL_ONLY
            elif kernel == False:
                new_hook.km = self.libpanda.MODE_USER_ONLY
            else:
                new_hook.km = self.libpanda.MODE_ANY
            new_hook.enabled = enabled

            self.plugins[&#39;hooks&#39;].add_hook(new_hook)
            self.hook_list.append((new_hook, hook_cb_passed))

            @hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
            def wrapper(*args, **kw):
                try:
                    r = fun(*args, **kw)
                    #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    self.hook_exit_exception = e
                    self.end_analysis()
                    # this works in all current callback cases. CFFI auto-converts to void, bool, int, and int32_t
                    return 0

            return wrapper
        return decorator


    def hook_symbol(self, libraryname, symbol, kernel=False, name=None, cb_type=&#34;start_block_exec&#34;):
        &#39;&#39;&#39;
        Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
        the function will be called with args (CPUState, TranslationBlock)

        Args:
            libraryname (string): Name of library containing symbol to be hooked. May be None to match any.
            symbol (string, int): Name of symbol or offset into library to hook
            kernel (bool): if hook should be applied exclusively in kernel mode
            name (string): name of hook, defaults to function name
            cb_type (string): callback-type, defaults to start_block_exec

        Returns:
            None: Decorated function is called when (before/after is determined by cb_type) guest goes to call
                  the specified symbol in the specified library.
        &#39;&#39;&#39;

        def decorator(fun):
            if cb_type == &#34;before_tcg_codegen&#34; or cb_type == &#34;after_block_translate&#34; or cb_type == &#34;before_block_exec&#34; or cb_type == &#34;start_block_exec&#34; or cb_type == &#34;end_block_exec&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , struct hook *)&#34;)
            elif cb_type == &#34;after_block_exec&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , uint8_t, struct hook *)&#34;)
            elif cb_type == &#34;before_block_translate&#34;:
                hook_cb_type = self.ffi.callback(&#34;void(CPUState* env, target_ptr_t pc, struct hook*)&#34;)
            elif cb_type == &#34;before_block_exec_invalidate_opt&#34;:
                hook_cb_type = self.ffi.callback(&#34;bool(CPUState* env, TranslationBlock*, struct hook*)&#34;)
            else:
                print(&#34;function type not supported&#34;)
                return

            # Inform the plugin that it has a new breakpoint at addr
            hook_cb_passed = hook_cb_type(fun)
            new_hook = self.ffi.new(&#34;struct symbol_hook*&#34;)
            type_num = getattr(self.libpanda, &#34;PANDA_CB_&#34;+cb_type.upper())
            new_hook.type = type_num
            if libraryname is not None:
                libname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(libraryname,&#34;utf-8&#34;))
            else:
                libname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
            self.ffi.memmove(new_hook.section,libname_ffi,len(libname_ffi))

            new_hook.hook_offset = False
            if symbol is not None:
                if isinstance(symbol, int):
                    new_hook.offset = symbol
                    new_hook.hook_offset = True
                    symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
                else:
                    symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(symbol,&#34;utf-8&#34;))
                    new_hook.hook_offset = False
            else:
                symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
            self.ffi.memmove(new_hook.name,symbolname_ffi,len(symbolname_ffi))
            setattr(new_hook.cb,cb_type, hook_cb_passed)
            hook_ptr = self.plugins[&#39;hooks&#39;].add_symbol_hook(new_hook)
            if name is not None:
                self.named_hooks[name] = hook_ptr
            self.hook_list.append((fun, new_hook,hook_cb_passed, hook_ptr))

            @hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
            def wrapper(*args, **kw):
                try:
                    r = fun(*args, **kw)
                    #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    self.hook_exit_exception = e
                    self.end_analysis()
                    # this works in all current callback cases. CFFI auto-converts to void, bool, int, and int32_t
                    return 0

            return wrapper
        return decorator

    def get_best_matching_symbol(self, cpu, pc=None, asid=None):
        &#39;&#39;&#39;
        Use the dynamic symbols plugin to get the best matching symbol for a given program counter.

        Args:
            cpu (CPUState): CPUState structure
            pc (int): program counter, defaults to current
            asid (int): ASID, defaults to current
        &#39;&#39;&#39;
        if asid is None:
            asid = self.current_asid(cpu)
        if pc is None:
            pc = self.current_pc(cpu)
        return self.plugins[&#39;dynamic_symbols&#39;].get_best_matching_symbol(cpu, pc, asid)


    ################### Hooks2 Functions ############
    # Provides the ability to interact with the hooks2 plugin and receive callbacks based on user-provided criteria.

    def enable_hook2(self,hook_name):
        &#39;&#39;&#39;
        Set a hook2-plugin hook&#39;s status to active.

        .. Deprecated:: Use the hooks plugin instead.
        &#39;&#39;&#39;
        if hook_name in self.hook_list2:
            self.plugins[&#39;hooks2&#39;].enable_hooks2(self.hook_list2[hook_name])
        else:
            print(&#34;ERROR: Your hook name was not in the hook list&#34;)

    def disable_hook2(self,hook_name):
        &#39;&#39;&#39;
        Set a hook2-plugin hook&#39;s status to inactive.

        .. Deprecated:: Use the hooks plugin instead.
        &#39;&#39;&#39;
        if hook_name in self.hook_list2:
            self.plugins[&#39;hooks2&#39;].disable_hooks2(self.hook_list2[hook_name])
        else:
            print(&#34;ERROR: Your hook name was not in the hook list&#34;)

    def hook2(self,name, kernel=True, procname=None, libname=None, trace_start=0, trace_stop=0, range_begin=0, range_end=0):
        &#39;&#39;&#39;
        Decorator to create a hook with the hooks2 plugin.

        .. Deprecated:: Use the hooks plugin instead.
        &#39;&#39;&#39;

        if procname == None:
            procname = self.ffi.NULL
        if libname == None:
            libname = self.ffi.NULL


        if procname != self.ffi.NULL:
            procname = self.ffi.new(&#34;char[]&#34;,bytes(procname,&#34;utf-8&#34;))
        if libname != self.ffi.NULL:
            libname = self.ffi.new(&#34;char[]&#34;,bytes(libname,&#34;utf-8&#34;))
        &#39;&#39;&#39;
        Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
        the function will be called with args (CPUState, TranslationBlock)
        &#39;&#39;&#39;
        def decorator(fun):
            # Ultimately, our hook resolves as a before_block_exec_invalidate_opt callback so we must match its args
            hook_cb_type = self.ffi.callback(&#34;bool (CPUState*, TranslationBlock*, void*)&#34;)
            # Inform the plugin that it has a new breakpoint at addr

            hook_cb_passed = hook_cb_type(fun)
            if not hasattr(self, &#34;hook_gc_list&#34;):
                self.hook_gc_list = [hook_cb_passed]
            else:
                self.hook_gc_list.append(hook_cb_passed)

            # I don&#39;t know what this is/does
            cb_data =self.ffi.NULL
            hook_number = self.plugins[&#39;hooks2&#39;].add_hooks2(hook_cb_passed, cb_data, kernel, \
                procname, libname, trace_start, trace_stop, range_begin,range_end)

            self.hook_list2[name] = hook_number

            @hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
            def wrapper(*args, **kw):
                return fun(*args, **kw)

            return wrapper
        return decorator

    def hook2_single_insn(self, name, pc, kernel=False, procname=None, libname=None):
        &#39;&#39;&#39;
        Helper function to hook a single instruction with the hooks2 plugin.

        .. Deprecated:: Use the hooks plugin instead.
        &#39;&#39;&#39;
        if procname == None:
            procname = self.ffi.NULL
        if libname == None:
            libname = self.ffi.NULL
        return self.hook2(name, kernel=kernel, procname=procname,libname=libname,range_begin=pc, range_end=pc)

    # MEM HOOKS
    def _hook_mem(self, start_address, end_address, before, after, read, write, virtual, physical, enabled):
        def decorator(fun):
            mem_hook_cb_type = self.ffi.callback(&#34;mem_hook_func_t&#34;)
            # Inform the plugin that it has a new breakpoint at addr

            hook_cb_passed = mem_hook_cb_type(fun)
            mem_reg = self.ffi.new(&#34;struct memory_hooks_region*&#34;)
            mem_reg.start_address = start_address
            mem_reg.stop_address = end_address
            mem_reg.on_before = before
            mem_reg.on_after = after
            mem_reg.on_read = read
            mem_reg.on_write = write
            mem_reg.on_virtual = virtual
            mem_reg.on_physical = physical
            mem_reg.enabled = enabled
            mem_reg.cb = hook_cb_passed

            hook = self.plugins[&#39;mem_hooks&#39;].add_mem_hook(mem_reg)

            self.mem_hooks[hook] = [mem_reg, hook_cb_passed]

            @mem_hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
            def wrapper(*args, **kw):
                return fun(*args, **kw)

            return wrapper
        return decorator

    def hook_mem(self, start_address, end_address, on_before, on_after, on_read, on_write, on_virtual, on_physical, enabled):
        &#39;&#39;&#39;
        Decorator to hook a memory range with the mem_hooks plugin

        .. todo:: Fully document mem-hook decorators
        &#39;&#39;&#39;
        return self._hook_mem(start_address,end_address,on_before,on_after,on_read, on_write, on_virtual, on_physical, enabled)

    def hook_phys_mem_read(self, start_address, end_address, on_before=True, on_after=False, enabled=True):
        &#39;&#39;&#39;
        Decorator to hook physical memory reads with the mem_hooks plugin
        &#39;&#39;&#39;
        return self._hook_mem(start_address,end_address,on_before,on_after, True, False, False, True, True)

    def hook_phys_mem_write(self, start_address, end_address, on_before=True, on_after=False):
        &#39;&#39;&#39;
        Decorator to hook physical memory writes with the mem_hooks plugin
        &#39;&#39;&#39;
        return self._hook_mem(start_address,end_address,on_before,on_after, False, True, False, True, True)

    def hook_virt_mem_read(self, start_address, end_address, on_before=True, on_after=False):
        &#39;&#39;&#39;
        Decorator to hook virtual memory reads with the mem_hooks plugin
        &#39;&#39;&#39;
        return self._hook_mem(start_address,end_address,on_before,on_after, True, False, True, False, True)

    def hook_virt_mem_write(self, start_address, end_address, on_before=True, on_after=False):
        &#39;&#39;&#39;
        Decorator to hook virtual memory writes with the mem_hooks plugin
        &#39;&#39;&#39;
        return self._hook_mem(start_address,end_address,on_before,on_after, False, True, True, False, True)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pandare.panda.Panda.arch"><code class="name">var <span class="ident">arch</span></code></dt>
<dd>
<div class="desc"><p>A reference to an auto-instantiated <code><a title="pandare.arch.PandaArch" href="arch.html#pandare.arch.PandaArch">PandaArch</a></code> subclass (e.g., <code><a title="pandare.arch.X86Arch" href="arch.html#pandare.arch.X86Arch">X86Arch</a></code>)</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pandare.panda.Panda.arm_load_kernel"><code class="name flex">
<span>def <span class="ident">arm_load_kernel</span></span>(<span>self, cpu, bootinfo)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arm_load_kernel(self, cpu, bootinfo):
    return self.libpanda.arm_load_kernel(cpu, bootinfo)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.callstack_callers"><code class="name flex">
<span>def <span class="ident">callstack_callers</span></span>(<span>self, lim, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function for callstack_instr plugin
Handle conversion and return get_callers from callstack_instr.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def callstack_callers(self, lim, cpu): # XXX move into new directory, &#39;callstack&#39; ?
    &#39;&#39;&#39;
    Helper function for callstack_instr plugin
    Handle conversion and return get_callers from callstack_instr.
    &#39;&#39;&#39;
    if not &#34;callstack_instr&#34; in self.plugins:
        progress(&#34;enabling callstack_instr plugin&#34;)
        self.load_plugin(&#34;callstack_instr&#34;)

    callers = self.ffi.new(&#34;uint%d_t[%d]&#34; % (self.bits, lim))
    n = self.plugins[&#39;callstack_instr&#39;].get_callers(callers, lim, cpu)
    c = []
    for pc in callers:
        c.append(pc)
    return c</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Unload all plugins and close pandalog.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup(self):
    &#39;&#39;&#39;
    Unload all plugins and close pandalog.

    Returns:
        None
    &#39;&#39;&#39;
    self.libpanda.panda_cleanup()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.clear_breakpoint"><code class="name flex">
<span>def <span class="ident">clear_breakpoint</span></span>(<span>self, cpu, pc)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a breakpoint</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_breakpoint(self, cpu, pc):
    &#39;&#39;&#39;
    Remove a breakpoint
    &#39;&#39;&#39;
    BP_GDB = 0x10
    self.libpanda.cpu_breakpoint_remove(cpu, pc, BP_GDB)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.cont"><code class="name flex">
<span>def <span class="ident">cont</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Continue execution (run after vm_stop)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cont(self):
    &#39;&#39;&#39; Continue execution (run after vm_stop) &#39;&#39;&#39;
    self.libpanda.panda_cont()
    self.running.set()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.copy_to_guest"><code class="name flex">
<span>def <span class="ident">copy_to_guest</span></span>(<span>self, copy_directory, iso_name=None, absolute_paths=False, setup_script='setup.sh', timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy a directory from the host into the guest by
1) Creating an .iso image of the directory on the host
2) Run a bash command to mount it at the exact same path + .ro and then copy the files to the provided path
3) If the directory contains setup.sh, run it</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>copy_directory</code></strong></dt>
<dd>Local directory to copy into guest</dd>
<dt><strong><code>iso_name</code></strong></dt>
<dd>Name of iso file that will be generated. Defaults to [copy_directory].iso</dd>
<dt><strong><code>absolute_paths</code></strong></dt>
<dd>is copy_directory an absolute or relative path</dd>
<dt><strong><code>seutp_script</code></strong></dt>
<dd>name of a script which, if present inside copy_directory, will be automatically run after the copy</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>maximum time each copy command will be allowed to run for, will use the <code>run_serial_cmd</code> default value unless another is provided</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def copy_to_guest(self, copy_directory, iso_name=None, absolute_paths=False, setup_script=&#34;setup.sh&#34;, timeout=None):
    &#39;&#39;&#39;

    Copy a directory from the host into the guest by
    1) Creating an .iso image of the directory on the host
    2) Run a bash command to mount it at the exact same path + .ro and then copy the files to the provided path
    3) If the directory contains setup.sh, run it

    Args:
        copy_directory: Local directory to copy into guest
        iso_name: Name of iso file that will be generated. Defaults to [copy_directory].iso
        absolute_paths: is copy_directory an absolute or relative path
        seutp_script: name of a script which, if present inside copy_directory, will be automatically run after the copy
        timeout: maximum time each copy command will be allowed to run for, will use the `run_serial_cmd` default value unless another is provided

    Returns:
        None
    &#39;&#39;&#39;

    if not iso_name:
        iso_name = copy_directory + &#39;.iso&#39;
    make_iso(copy_directory, iso_name)

    if not absolute_paths:
        copy_directory = path.split(copy_directory)[-1] # Copy directory relative, not absolutely


    # Drive the guest to mount the drive
    # setup_sh:
    #   Make sure cdrom didn&#39;t automount
    #   Make sure guest path mirrors host path
    #   if there is a setup.sh script in the directory,
    #   then run that setup.sh script first (good for scripts that need to
    #   prep guest environment before script runs)
    mount_dir = shlex_quote(copy_directory)

    mkdir_result = self.run_serial_cmd(f&#34;mkdir -p {mount_dir} {mount_dir}.ro &amp;&amp; echo \&#34;mkdir_ok\&#34;; echo \&#34;exit code $?\&#34;&#34;, timeout=timeout)

    if &#39;mkdir_ok&#39; not in mkdir_result:
        raise RuntimeError(f&#34;Failed to create mount directories inside guest: {mkdir_result}&#34;)

    # Tell panda to we insert the CD drive
    # TODO: the cd-drive name should be a config option, see the values in qcow.py
    errs = self.run_monitor_cmd(&#34;change ide1-cd0 \&#34;{}\&#34;&#34;.format(iso_name))
    if len(errs):
        warn(f&#34;Warning encountered when connecting media to guest: {errs}&#34;)

    try:
        mount_status = &#34;bad&#34;
        for _ in range(10):
            if &#39;mount_ok&#39; in mount_status:
                break
            mount_status = self.run_serial_cmd(f&#34;mount /dev/cdrom {mount_dir}.ro &amp;&amp; echo &#39;mount_ok&#39; || (umount /dev/cdrom; echo &#39;bad&#39;)&#34;, timeout=timeout)
            sleep(1)
        else:
            # Didn&#39;t ever break
            raise RuntimeError(f&#34;Failed to mount media inside guest: {mount_status}&#34;)

        # Note the . after our src/. directory - that&#39;s special syntax for cp -a
        copy_result = self.run_serial_cmd(f&#34;cp -a {mount_dir}.ro/. {mount_dir} &amp;&amp; echo &#39;ok&#39;&#34;, timeout=timeout)
        if copy_result != &#39;ok&#39;:
            raise RuntimeError(f&#34;Copy to rw directory failed: {copy_result}&#34;)

    finally:
        # Ensure we disconnect the CD drive after the mount + copy, even if it fails
        self.run_serial_cmd(&#34;umount /dev/cdrom&#34;) # This can fail and that&#39;s okay, we&#39;ll forece eject
        sleep(1)
        errs = self.run_monitor_cmd(&#34;eject -f ide1-cd0&#34;)
        if len(errs):
            warn(f&#34;Warning encountered when disconnecting media from guest: {errs}&#34;)

    if isfile(pjoin(copy_directory, setup_script)):
        setup_result = self.run_serial_cmd(f&#34;{mount_dir}/{setup_script}&#34;, timeout=timeout)
        progress(&#34;[Setup command]: {setup_result}&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.cpu_class_by_name"><code class="name flex">
<span>def <span class="ident">cpu_class_by_name</span></span>(<span>self, name, cpu_model)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets cpu class from name.
Calls cpu_class_by_name QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>typename from python string</dd>
<dt><strong><code>cpu_model</code></strong></dt>
<dd>string specified cpu model</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ObjectClass struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cpu_class_by_name(self, name, cpu_model):
    &#39;&#39;&#39;
    Gets cpu class from name.
    Calls cpu_class_by_name QEMU function.

    Args:
        name: typename from python string
        cpu_model: string specified cpu model

    Returns:
        ObjectClass struct
    &#39;&#39;&#39;
    return self.libpanda.cpu_class_by_name(name, cpu_model)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.create_external_gic"><code class="name flex">
<span>def <span class="ident">create_external_gic</span></span>(<span>self, vbi, irqs, gic_vers, secure)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_external_gic(self, vbi, irqs, gic_vers, secure):
    return self.libpanda.create_external_gic(vbi, irqs, gic_vers, secure)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.create_internal_gic"><code class="name flex">
<span>def <span class="ident">create_internal_gic</span></span>(<span>self, vbi, irqs, gic_vers)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_internal_gic(self, vbi, irqs, gic_vers):
    return self.libpanda.create_internal_gic(vbi, irqs, gic_vers)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.create_one_flash"><code class="name flex">
<span>def <span class="ident">create_one_flash</span></span>(<span>self, name, flashbase, flashsize, filename, mr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_one_flash(self, name, flashbase, flashsize, filename, mr):
    return self.libpanda.create_one_flash(name, flashbase, flashsize, filename, mr)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.create_virtio_devices"><code class="name flex">
<span>def <span class="ident">create_virtio_devices</span></span>(<span>self, vbi, pic)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_virtio_devices(self, vbi, pic):
    return self.libpanda.create_virtio_devices(vbi, pic)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.current_asid"><code class="name flex">
<span>def <span class="ident">current_asid</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get current Application Specific ID</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>integer</code></dt>
<dd>value of current ASID</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def current_asid(self, cpu):
    &#39;&#39;&#39;
    Get current Application Specific ID

    Args:
        cpu (CPUState): CPUState structure

    Returns:
        integer: value of current ASID
    &#39;&#39;&#39;
    return self.libpanda.panda_current_asid(cpu)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.current_pc"><code class="name flex">
<span>def <span class="ident">current_pc</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get current program counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
</dl>
<h2 id="return">Return</h2>
<p>integer value of current program counter</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated:&ensp;Use panda.arch.get_pc(cpu) instead</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def current_pc(self, cpu):
    &#39;&#39;&#39;
    Get current program counter

    Args:
        cpu (CPUState): CPUState structure

    Return:
        integer value of current program counter

    .. Deprecated:: Use panda.arch.get_pc(cpu) instead
    &#39;&#39;&#39;
    return self.libpanda.panda_current_pc(cpu)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.current_sp"><code class="name flex">
<span>def <span class="ident">current_sp</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get current stack pointer</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
</dl>
<h2 id="return">Return</h2>
<p>int: Value of stack pointer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def current_sp(self, cpu):
    &#39;&#39;&#39;
    Get current stack pointer

    Args:
        cpu (CPUState): CPUState structure

    Return:
        int: Value of stack pointer
    &#39;&#39;&#39;
    return self.libpanda.panda_current_sp_external(cpu)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.delete_callback"><code class="name flex">
<span>def <span class="ident">delete_callback</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Completely delete a registered panda callback by name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_callback(self, name):
    &#39;&#39;&#39;
    Completely delete a registered panda callback by name
    &#39;&#39;&#39;
    if name not in self.registered_callbacks.keys():
        raise ValueError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))

    handle = self.registered_callbacks[name][&#39;handle&#39;]
    self.libpanda.panda_unregister_callbacks(handle)
    if not hasattr(self,&#34;old_cb_list&#34;):
        self.old_cb_list = []
    self.old_cb_list.append(self.registered_callbacks[name])
    del self.registered_callbacks[name][&#39;handle&#39;]
    del self.registered_callbacks[name]</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.delete_callbacks"><code class="name flex">
<span>def <span class="ident">delete_callbacks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_callbacks(self):
    #for name in self.registered_callbacks.keys():
    while len(self.registered_callbacks.keys()) &gt; 0:
        self.delete_callback(list(self.registered_callbacks.keys())[0])</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.delvm"><code class="name flex">
<span>def <span class="ident">delvm</span></span>(<span>self, snapshot_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete snapshot with specified name</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>snapshot_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the snapshot</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delvm(self, snapshot_name):
    &#39;&#39;&#39;
    Delete snapshot with specified name
    Args:
        snapshot_name (str): name of the snapshot

    Returns:
        None
    &#39;&#39;&#39;

    if debug:
        progress (&#34;Deleting snapshot &#34; + snapshot_name)

    # Stop guest, queue up delete, then continue
    self.vm_stop()
    charptr = self.ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
    self.queue_main_loop_wait_fn(self.libpanda.panda_delvm, [charptr])</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.delvm_sync"><code class="name flex">
<span>def <span class="ident">delvm_sync</span></span>(<span>self, snapshot_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def delvm_sync(self, snapshot_name):
    self.run_monitor_cmd(&#34;delvm {}&#34;.format(snapshot_name))</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_callback"><code class="name flex">
<span>def <span class="ident">disable_callback</span></span>(<span>self, name, forever=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable a panda plugin using its handle and cb.number as a unique ID
If forever is specified, we'll never reenable the call- useful when
you want to really turn off something with a procname filter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_callback(self, name, forever=False):
    &#39;&#39;&#39;
    Disable a panda plugin using its handle and cb.number as a unique ID
    If forever is specified, we&#39;ll never reenable the call- useful when
    you want to really turn off something with a procname filter.
    &#39;&#39;&#39;
    # During shutdown callback may be deleted before a request to enable comes through
    if self.ending:
        return

    if name not in self.registered_callbacks.keys():
        raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))
    self.registered_callbacks[name][&#39;enabled&#39;] = False
    handle = self.registered_callbacks[name][&#39;handle&#39;]
    cb = self.registered_callbacks[name][&#39;callback&#39;]
    pcb = self.registered_callbacks[name][&#39;pcb&#39;]
    #progress(&#34;Disabling callback &#39;{}&#39; on &#39;{}&#39; handle={}&#34;.format(name, cb.name, handle))
    self.libpanda.panda_disable_callback_helper(handle, cb.number, pcb)

    if forever:
        del self.registered_callbacks[name]</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_hook2"><code class="name flex">
<span>def <span class="ident">disable_hook2</span></span>(<span>self, hook_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a hook2-plugin hook's status to inactive.</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated:&ensp;Use the hooks plugin instead.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_hook2(self,hook_name):
    &#39;&#39;&#39;
    Set a hook2-plugin hook&#39;s status to inactive.

    .. Deprecated:: Use the hooks plugin instead.
    &#39;&#39;&#39;
    if hook_name in self.hook_list2:
        self.plugins[&#39;hooks2&#39;].disable_hooks2(self.hook_list2[hook_name])
    else:
        print(&#34;ERROR: Your hook name was not in the hook list&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_llvm"><code class="name flex">
<span>def <span class="ident">disable_llvm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_llvm(self):
    &#39;&#39;&#39;
    Disables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
    &#39;&#39;&#39;
    self.libpanda.panda_disable_llvm()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_llvm_helpers"><code class="name flex">
<span>def <span class="ident">disable_llvm_helpers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_llvm_helpers(self):
    &#39;&#39;&#39;
    Disables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
    &#39;&#39;&#39;
    self.libpanda.panda_disable_llvm_helpers()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_memcb"><code class="name flex">
<span>def <span class="ident">disable_memcb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable memory callbacks. Must be enabled for memory callbacks to work.
pypanda enables this automatically with some callbacks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_memcb(self):
    &#39;&#39;&#39;
    Disable memory callbacks. Must be enabled for memory callbacks to work.
    pypanda enables this automatically with some callbacks.
    &#39;&#39;&#39;
    self._memcb = False
    self.libpanda.panda_disable_memcb()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_plugin"><code class="name flex">
<span>def <span class="ident">disable_plugin</span></span>(<span>self, handle)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable plugin.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>handle</code></strong> :&ensp;<code>int</code></dt>
<dd>pointer to handle returned by plugin</dd>
</dl>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_plugin(self, handle):
    &#39;&#39;&#39;
    Disable plugin.

    Args:
        handle (int): pointer to handle returned by plugin

    Return:
        None
    &#39;&#39;&#39;
    self.libpanda.panda_disable_plugin(handle)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_ppp"><code class="name flex">
<span>def <span class="ident">disable_ppp</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable a ppp-style callback by name.
Unlike regular panda callbacks which can be enabled/disabled/deleted, PPP callbacks are only enabled/deleted (which we call disabled)</p>
<p>Example usage to register my_run with syscalls2 as a 'on_sys_open_return' and then disable:</p>
<pre><code>@ppp(&quot;syscalls2&quot;, &quot;on_sys_open_return&quot;)
def my_fun(cpu, pc, filename, flags, mode):
    ...

panda.disable_ppp(&quot;my_fun&quot;)
</code></pre>
<p>&ndash; OR &ndash;</p>
<pre><code>@ppp(&quot;syscalls2&quot;, &quot;on_sys_open_return&quot;, name=&quot;custom&quot;)
def my_fun(cpu, pc, filename, flags, mode):
    ...
</code></pre>
<p>panda.disable_ppp("custom")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_ppp(self, name):
    &#39;&#39;&#39;
    Disable a ppp-style callback by name.
    Unlike regular panda callbacks which can be enabled/disabled/deleted, PPP callbacks are only enabled/deleted (which we call disabled)

    Example usage to register my_run with syscalls2 as a &#39;on_sys_open_return&#39; and then disable:
    ```
    @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;)
    def my_fun(cpu, pc, filename, flags, mode):
        ...

    panda.disable_ppp(&#34;my_fun&#34;)
    ```

    -- OR --

    ```
    @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;, name=&#34;custom&#34;)
    def my_fun(cpu, pc, filename, flags, mode):
        ...
    ```

    panda.disable_ppp(&#34;custom&#34;)
    &#39;&#39;&#39;

    (f, plugin_name, attr) = self.ppp_registered_cbs[name]
    eval(f&#34;self.plugins[&#39;{plugin_name}&#39;].ppp_remove_cb_{attr}&#34;)(f) # All PPP cbs start with this string. XXX insecure eval
    del self.ppp_registered_cbs[name] # It&#39;s now safe to be garbage collected</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_precise_pc"><code class="name flex">
<span>def <span class="ident">disable_precise_pc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>By default, QEMU does not update the program counter after every instruction.
This function disables precise tracking of the program counter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_precise_pc(self):
    &#39;&#39;&#39;
    By default, QEMU does not update the program counter after every instruction.
    This function disables precise tracking of the program counter.
    &#39;&#39;&#39;
    self.libpanda.panda_disable_precise_pc()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_tb_chaining"><code class="name flex">
<span>def <span class="ident">disable_tb_chaining</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function disables translation block chaining in QEMU</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_tb_chaining(self):
    &#39;&#39;&#39;
    This function disables translation block chaining in QEMU
    &#39;&#39;&#39;
    if not self.disabled_tb_chaining:
        if debug:
            progress(&#34;Disabling TB chaining&#34;)
        self.disabled_tb_chaining = True
        self.libpanda.panda_disable_tb_chaining()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disas2"><code class="name flex">
<span>def <span class="ident">disas2</span></span>(<span>self, code, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Call panda_disas to diasassemble an amount of code at a pointer.
FIXME: seem to not match up to PANDA definition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disas2(self, code, size):
    &#39;&#39;&#39;
    Call panda_disas to diasassemble an amount of code at a pointer.
    FIXME: seem to not match up to PANDA definition
    &#39;&#39;&#39;
    self.libpanda.panda_disas(code, size)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.do_panda_finish"><code class="name flex">
<span>def <span class="ident">do_panda_finish</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Call panda_finish. Note this isn't really blocking - the
guest should have exited by now, but queue this after
(blocking) shutdown commands in our internal async queue
so it must also be labeled as blocking.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @blocking
    def do_panda_finish(self):
        &#39;&#39;&#39;
        Call panda_finish. Note this isn&#39;t really blocking - the
        guest should have exited by now, but queue this after
        (blocking) shutdown commands in our internal async queue
        so it must also be labeled as blocking.
        &#39;&#39;&#39;
#        assert (not self.running.is_set()), &#34;Can&#39;t finish while still running&#34;
        self.panda_finish()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.drive_get"><code class="name flex">
<span>def <span class="ident">drive_get</span></span>(<span>self, blocktype, bus, unit)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets DriveInfo struct from user specified information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>blocktype</code></strong></dt>
<dd>BlockInterfaceType structure</dd>
<dt><strong><code>bus</code></strong></dt>
<dd>integer bus</dd>
<dt><strong><code>unit</code></strong></dt>
<dd>integer unit</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DriveInfo struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drive_get(self, blocktype, bus, unit):
    &#39;&#39;&#39;
    Gets DriveInfo struct from user specified information.

    Args:
        blocktype: BlockInterfaceType structure
        bus: integer bus
        unit: integer unit

    Returns:
        DriveInfo struct
    &#39;&#39;&#39;
    return self.libpanda.drive_get(blocktype,bus,unit)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_all_callbacks"><code class="name flex">
<span>def <span class="ident">enable_all_callbacks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable all python callbacks that have been disabled</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_all_callbacks(self):
    &#39;&#39;&#39;
    Enable all python callbacks that have been disabled
    &#39;&#39;&#39;
    for name in self.registered_callbacks.keys():
        self.enable_callback(name)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_callback"><code class="name flex">
<span>def <span class="ident">enable_callback</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable a panda plugin using its handle and cb.number as a unique ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_callback(self, name):
    &#39;&#39;&#39;
    Enable a panda plugin using its handle and cb.number as a unique ID
    &#39;&#39;&#39;

    # During shutdown callback may be deleted before a request to enable comes through
    if self.ending:
        return

    if name not in self.registered_callbacks.keys():
        raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))

    self.registered_callbacks[name][&#39;enabled&#39;] = True
    handle = self.registered_callbacks[name][&#39;handle&#39;]
    cb = self.registered_callbacks[name][&#39;callback&#39;]
    pcb = self.registered_callbacks[name][&#39;pcb&#39;]
    #progress(&#34;Enabling callback &#39;{}&#39; on &#39;{}&#39; handle = {}&#34;.format(name, cb.name, handle))
    self.libpanda.panda_enable_callback_helper(handle, cb.number, pcb)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_hook2"><code class="name flex">
<span>def <span class="ident">enable_hook2</span></span>(<span>self, hook_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a hook2-plugin hook's status to active.</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated:&ensp;Use the hooks plugin instead.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_hook2(self,hook_name):
    &#39;&#39;&#39;
    Set a hook2-plugin hook&#39;s status to active.

    .. Deprecated:: Use the hooks plugin instead.
    &#39;&#39;&#39;
    if hook_name in self.hook_list2:
        self.plugins[&#39;hooks2&#39;].enable_hooks2(self.hook_list2[hook_name])
    else:
        print(&#34;ERROR: Your hook name was not in the hook list&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_internal_callbacks"><code class="name flex">
<span>def <span class="ident">enable_internal_callbacks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable all our internal callbacks that start with __ such as __main_loop_wait
and __asid_changed. Important in case user has done a panda.end_analysis()
and then (re)called run</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_internal_callbacks(self):
    &#39;&#39;&#39;
    Enable all our internal callbacks that start with __ such as __main_loop_wait
    and __asid_changed. Important in case user has done a panda.end_analysis()
    and then (re)called run
    &#39;&#39;&#39;
    for name in self.registered_callbacks.keys():
        if name.startswith(&#34;__&#34;) and not self.registered_callbacks[name][&#39;enabled&#39;]:
            self.enable_callback(name)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_llvm"><code class="name flex">
<span>def <span class="ident">enable_llvm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_llvm(self):
    &#39;&#39;&#39;
    Enables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
    &#39;&#39;&#39;
    self.libpanda.panda_enable_llvm()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_llvm_helpers"><code class="name flex">
<span>def <span class="ident">enable_llvm_helpers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_llvm_helpers(self):
    &#39;&#39;&#39;
    Enables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.
    &#39;&#39;&#39;
    self.libpanda.panda_enable_llvm_helpers()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_memcb"><code class="name flex">
<span>def <span class="ident">enable_memcb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable memory callbacks. Must be called for memory callbacks to work.
pypanda enables this automatically with some callbacks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_memcb(self):
    &#39;&#39;&#39;
    Enable memory callbacks. Must be called for memory callbacks to work.
    pypanda enables this automatically with some callbacks.
    &#39;&#39;&#39;
    self._memcb = True
    self.libpanda.panda_enable_memcb()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_plugin"><code class="name flex">
<span>def <span class="ident">enable_plugin</span></span>(<span>self, handle)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable plugin.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>handle</code></strong> :&ensp;<code>int</code></dt>
<dd>pointer to handle returned by plugin</dd>
</dl>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_plugin(self, handle):
    &#39;&#39;&#39;
    Enable plugin.

    Args:
        handle (int): pointer to handle returned by plugin

    Return:
        None
    &#39;&#39;&#39;
    self.libpanda.panda_enable_plugin(handle)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_precise_pc"><code class="name flex">
<span>def <span class="ident">enable_precise_pc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>By default, QEMU does not update the program counter after every instruction.
This function enables precise tracking of the program counter. After enabling precise PC tracking, the program counter will be available in env-&gt;panda_guest_pc and can be assumed to accurately reflect the guest state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_precise_pc(self):
    &#39;&#39;&#39;
    By default, QEMU does not update the program counter after every instruction.
    This function enables precise tracking of the program counter. After enabling precise PC tracking, the program counter will be available in env-&gt;panda_guest_pc and can be assumed to accurately reflect the guest state.
    &#39;&#39;&#39;
    self.libpanda.panda_enable_precise_pc()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_tb_chaining"><code class="name flex">
<span>def <span class="ident">enable_tb_chaining</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function enables translation block chaining in QEMU</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_tb_chaining(self):
    &#39;&#39;&#39;
    This function enables translation block chaining in QEMU
    &#39;&#39;&#39;
    if debug:
        progress(&#34;Enabling TB chaining&#34;)
    self.disabled_tb_chaining = False
    self.libpanda.panda_enable_tb_chaining()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.end_analysis"><code class="name flex">
<span>def <span class="ident">end_analysis</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop running machine.</p>
<p>Call from any thread to unload all plugins and stop all queued functions.
If called from async thread or a callback, it will also unblock panda.run()</p>
<p>Note here we use the async class's internal thread to process these
without needing to wait for tasks in the main async thread</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_analysis(self):
    &#39;&#39;&#39;
    Stop running machine.

    Call from any thread to unload all plugins and stop all queued functions.
    If called from async thread or a callback, it will also unblock panda.run()

    Note here we use the async class&#39;s internal thread to process these
    without needing to wait for tasks in the main async thread
    &#39;&#39;&#39;
    self.athread.ending = True
    self.ending = True
    self.unload_plugins()
    if self.running.is_set() or self.initializing.is_set():

        # If we were running, stop the execution and check if we crashed
        self.queue_async(self.stop_run, internal=True)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.end_record"><code class="name flex">
<span>def <span class="ident">end_record</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop active recording.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>raises exception if there was an error stopping recording.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_record(self):
    &#34;&#34;&#34;Stop active recording.

    Raises:
        Exception: raises exception if there was an error stopping recording.
    &#34;&#34;&#34;
    result = self.libpanda.panda_record_end()
    res_string_enum = self.ffi.string(self.ffi.cast(&#34;RRCTRL_ret&#34;,result))
    if res_string_enum != &#34;RRCTRL_OK&#34;:
       raise Exception(f&#34;record method failed with RTCTL_ret {res_string_enum} ({result})&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.end_replay"><code class="name flex">
<span>def <span class="ident">end_replay</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Terminates a currently running replay</p>
<pre><code>Returns:
    None

Raises:
    Exception: raises exception if no replay is active or termination failed.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_replay(self):
    &#39;&#39;&#39;
    Terminates a currently running replay

        Returns:
            None

        Raises:
            Exception: raises exception if no replay is active or termination failed.
    &#39;&#39;&#39;

    if self._in_replay is False:
        raise Exception(&#34;Tried to terminate replay while not in replay mode!&#34;)

    result = self.libpanda.panda_replay_end()

    res_string_enum = self.ffi.string(self.ffi.cast(&#34;RRCTRL_ret&#34;,result))
    if res_string_enum != &#34;RRCTRL_OK&#34;:
       raise Exception(f&#34;ending record method failed with RTCTL_ret {res_string_enum} ({result})&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.error_report"><code class="name flex">
<span>def <span class="ident">error_report</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_report(self, s):
    return self.libpanda.error_report(s)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.exit_cpu_loop"><code class="name flex">
<span>def <span class="ident">exit_cpu_loop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop cpu execution at nearest juncture.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit_cpu_loop(self):
    &#39;&#39;&#39;
    Stop cpu execution at nearest juncture.
    &#39;&#39;&#39;
    self.libpanda.panda_exit_loop = True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.finish_serial_cmd"><code class="name flex">
<span>def <span class="ident">finish_serial_cmd</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish_serial_cmd(self):
    result = self.serial_console.send_eol()
    result = self.serial_console.expect()
    return result</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.flush_tb"><code class="name flex">
<span>def <span class="ident">flush_tb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function requests that the translation block cache be flushed as soon as possible. If running with translation block chaining turned off (e.g. when in LLVM mode or replay mode), this will happen when the current translation block is done executing.
Flushing the translation block cache is additionally necessary if the plugin makes changes to the way code is translated. For example, by using panda_enable_precise_pc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush_tb(self):
    &#39;&#39;&#39;
    This function requests that the translation block cache be flushed as soon as possible. If running with translation block chaining turned off (e.g. when in LLVM mode or replay mode), this will happen when the current translation block is done executing.
    Flushing the translation block cache is additionally necessary if the plugin makes changes to the way code is translated. For example, by using panda_enable_precise_pc.
    &#39;&#39;&#39;
    return self.libpanda.panda_do_flush_tb()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.from_unsigned_guest"><code class="name flex">
<span>def <span class="ident">from_unsigned_guest</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an unsigned int32/unsigned int64 from the guest
(depending on guest bit-size) to a (signed) python int</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>Python integer representing an unsigned value in the guest's pointer-size</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Python integer representing x as a signed value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_unsigned_guest(self, x):
    &#39;&#39;&#39;
    Convert an unsigned int32/unsigned int64 from the guest
    (depending on guest bit-size) to a (signed) python int

    Args:
        x (int): Python integer representing an unsigned value in the guest&#39;s pointer-size

    Returns:
        int: Python integer representing x as a signed value
    &#39;&#39;&#39;
    if x &gt;= 2**(self.bits-1): # If highest bit is set, it&#39;s negative
        return (x - 2**self.bits)
    else: # Else it&#39;s positive
        return x</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.g_malloc0"><code class="name flex">
<span>def <span class="ident">g_malloc0</span></span>(<span>self, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to call glib malloc</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>size to call with malloc</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>buffer of the requested size from g_malloc</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g_malloc0(self, size):
    &#39;&#39;&#39;
    Helper function to call glib malloc

    Args:
        size (int): size to call with malloc

    Returns:
        buffer of the requested size from g_malloc
    &#39;&#39;&#39;
    return self.libpanda.g_malloc0(size)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.garray_len"><code class="name flex">
<span>def <span class="ident">garray_len</span></span>(<span>self, garray)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience function to get array length of glibc array.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>g</code></strong> :&ensp;<code>garray</code></dt>
<dd>Pointer to a glibc array</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>length of the array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def garray_len(self, garray):
    &#39;&#39;&#39;
    Convenience function to get array length of glibc array.

    Args:
        g (garray): Pointer to a glibc array
            
    Returns:
        int: length of the array
    &#39;&#39;&#39;
    return self.libpanda.garray_len(garray)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.get_best_matching_symbol"><code class="name flex">
<span>def <span class="ident">get_best_matching_symbol</span></span>(<span>self, cpu, pc=None, asid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Use the dynamic symbols plugin to get the best matching symbol for a given program counter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
<dt><strong><code>pc</code></strong> :&ensp;<code>int</code></dt>
<dd>program counter, defaults to current</dd>
<dt><strong><code>asid</code></strong> :&ensp;<code>int</code></dt>
<dd>ASID, defaults to current</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_best_matching_symbol(self, cpu, pc=None, asid=None):
    &#39;&#39;&#39;
    Use the dynamic symbols plugin to get the best matching symbol for a given program counter.

    Args:
        cpu (CPUState): CPUState structure
        pc (int): program counter, defaults to current
        asid (int): ASID, defaults to current
    &#39;&#39;&#39;
    if asid is None:
        asid = self.current_asid(cpu)
    if pc is None:
        pc = self.current_pc(cpu)
    return self.plugins[&#39;dynamic_symbols&#39;].get_best_matching_symbol(cpu, pc, asid)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.get_cpu"><code class="name flex">
<span>def <span class="ident">get_cpu</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function returns first_cpu CPUState object from QEMU.
XXX: You rarely want this</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CPUState</code></dt>
<dd>cpu</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cpu(self):
    &#39;&#39;&#39;
    This function returns first_cpu CPUState object from QEMU.
    XXX: You rarely want this

    Returns:
        CPUState: cpu
    &#39;&#39;&#39;
    return self.libpanda.get_cpu()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.get_mappings"><code class="name flex">
<span>def <span class="ident">get_mappings</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all active memory mappings in the system.</p>
<p>Requires: OSI</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong></dt>
<dd>CPUState struct</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pandare.utils.GArrayIterator" href="utils.html#pandare.utils.GArrayIterator">GArrayIterator</a></code></dt>
<dd>iterator of OsiModule structures</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mappings(self, cpu):
    &#39;&#39;&#39;
    Get all active memory mappings in the system.

    Requires: OSI

    Args:
        cpu: CPUState struct

    Returns:
        pandare.utils.GArrayIterator: iterator of OsiModule structures
    &#39;&#39;&#39;
    current = self.plugins[&#39;osi&#39;].get_current_process(cpu)
    maps = self.plugins[&#39;osi&#39;].get_mappings(cpu, current)
    map_len = self.garray_len(maps)
    return GArrayIterator(self.plugins[&#39;osi&#39;].get_one_module, maps, map_len, self.plugins[&#39;osi&#39;].cleanup_garray)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.get_process_name"><code class="name flex">
<span>def <span class="ident">get_process_name</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the name of the current process. May return None if OSI cannot identify the current process</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_process_name(self, cpu):
    &#39;&#39;&#39;
    Get the name of the current process. May return None if OSI cannot identify the current process
    &#39;&#39;&#39;
    proc = self.plugins[&#39;osi&#39;].get_current_process(cpu)
    if proc == self.ffi.NULL or proc.name == self.ffi.NULL:
        return None

    procname = self.ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;)
    return self.ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.get_processes"><code class="name flex">
<span>def <span class="ident">get_processes</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all running processes in the system. Includes kernel modules on Linux.</p>
<p>Requires: OSI</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong></dt>
<dd>CPUState struct</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pandare.utils.GArrayIterator" href="utils.html#pandare.utils.GArrayIterator">GArrayIterator</a></code></dt>
<dd>iterator of OsiProc structures</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_processes(self, cpu):
    &#39;&#39;&#39;
    Get all running processes in the system. Includes kernel modules on Linux.

    Requires: OSI

    Args:
        cpu: CPUState struct

    Returns:
        pandare.utils.GArrayIterator: iterator of OsiProc structures
    &#39;&#39;&#39;
    processes = self.plugins[&#39;osi&#39;].get_processes(cpu)
    processes_len = self.garray_len(processes)
    return GArrayIterator(self.plugins[&#39;osi&#39;].get_one_proc, processes, processes_len, self.plugins[&#39;osi&#39;].cleanup_garray)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.get_processes_dict"><code class="name flex">
<span>def <span class="ident">get_processes_dict</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all running processes for the system at this moment in time as a dictionary.</p>
<p>The dictionary maps proceses by their PID. Each mapping returns a dictionary containing the process name, its pid,
and its parent pid (ppid).</p>
<p>Requires: OSI</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong></dt>
<dd>CPUState struct</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>processes as described above</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_processes_dict(self, cpu):
    &#39;&#39;&#39;
    Get all running processes for the system at this moment in time as a dictionary.

    The dictionary maps proceses by their PID. Each mapping returns a dictionary containing the process name, its pid,
    and its parent pid (ppid).

    Requires: OSI

    Args:
        cpu: CPUState struct

    Returns:
        Dict: processes as described above
    &#39;&#39;&#39;

    procs = {} #pid: {name: X, pid: Y, parent_pid: Z})

    for proc in self.get_processes(cpu):
        assert(proc != self.ffi.NULL)
        assert(proc.pid not in procs)
        procs[proc.pid] = {&#34;name&#34;: self.ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;), &#39;pid&#39;: proc.pid, &#39;parent_pid&#39;: proc.ppid}
        assert(not (proc.pid != 0 and proc.pid == proc.ppid)) # No cycles allowed other than at 0
    return procs</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.get_system_memory"><code class="name flex">
<span>def <span class="ident">get_system_memory</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_system_memory(self):
    return self.libpanda.get_system_memory()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.get_volatility_symbols"><code class="name flex">
<span>def <span class="ident">get_volatility_symbols</span></span>(<span>self, debug=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_volatility_symbols(self, debug=False):
    try:
        from .volatility_cli_classes import CommandLineMoreEfficient
        from volatility.framework import contexts
        from volatility.framework.layers.linear import LinearlyMappedLayer
        from volatility.framework.automagic import linux
    except ImportError:
        print(&#34;Warning: Failed to import volatility&#34;)
        return None
    if &#34;linux&#34; in self.os_type:
        if not hasattr(self, &#34;_vmlinux&#34;):
            self.make_panda_file_handler(debug=debug)
            constructed_original = CommandLineMoreEfficient().run()
            linux.LinuxUtilities.aslr_mask_symbol_table(
                constructed_original.context, constructed_original.config[&#39;vmlinux&#39;], constructed_original.config[&#39;primary&#39;])
            self._vmlinux = contexts.Module(
                constructed_original.context, constructed_original.config[&#39;vmlinux&#39;], constructed_original.config[&#39;primary&#39;], 0)
        else:
            LinearlyMappedLayer.read.cache_clear()  # smearing technique
        return self._vmlinux
    else:
        print(&#34;Unsupported.&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.hook"><code class="name flex">
<span>def <span class="ident">hook</span></span>(<span>self, addr, enabled=True, kernel=None, asid=None, cb_type='start_block_exec')</span>
</code></dt>
<dd>
<div class="desc"><p>Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
the function will be called with args (CPUState, TranslationBlock)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook(self, addr, enabled=True, kernel=None, asid=None, cb_type=&#34;start_block_exec&#34;):
    &#39;&#39;&#39;
    Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
    the function will be called with args (CPUState, TranslationBlock)
    &#39;&#39;&#39;

    def decorator(fun):
        if cb_type == &#34;before_tcg_codegen&#34; or cb_type == &#34;after_block_translate&#34; or cb_type == &#34;before_block_exec&#34; or cb_type == &#34;start_block_exec&#34; or cb_type == &#34;end_block_exec&#34;:
            hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , struct hook *)&#34;)
        elif cb_type == &#34;after_block_exec&#34;:
            hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , uint8_t, struct hook *)&#34;)
        elif cb_type == &#34;before_block_translate&#34;:
            hook_cb_type = self.ffi.callback(&#34;void(CPUState* env, target_ptr_t pc, struct hook*)&#34;)
        elif cb_type == &#34;before_block_exec_invalidate_opt&#34;:
            hook_cb_type = self.ffi.callback(&#34;bool(CPUState* env, TranslationBlock*, struct hook*)&#34;)
        else:
            print(&#34;function type not supported&#34;)
            return
        type_num = getattr(self.libpanda, &#34;PANDA_CB_&#34;+cb_type.upper())

        if debug:
            print(&#34;Registering breakpoint at 0x{:x} -&gt; {} == {}&#34;.format(addr, fun, &#39;cdata_cb&#39;))

        # Inform the plugin that it has a new breakpoint at addr
        hook_cb_passed = hook_cb_type(fun)
        new_hook = self.ffi.new(&#34;struct hook*&#34;)
        new_hook.type = type_num
        new_hook.addr = addr
        if kernel or asid is None:
            new_hook.asid = 0
        else:
            new_hook.asid = asid

        setattr(new_hook.cb,cb_type, hook_cb_passed)
        if kernel:
            new_hook.km = self.libpanda.MODE_KERNEL_ONLY
        elif kernel == False:
            new_hook.km = self.libpanda.MODE_USER_ONLY
        else:
            new_hook.km = self.libpanda.MODE_ANY
        new_hook.enabled = enabled

        self.plugins[&#39;hooks&#39;].add_hook(new_hook)
        self.hook_list.append((new_hook, hook_cb_passed))

        @hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
        def wrapper(*args, **kw):
            try:
                r = fun(*args, **kw)
                #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                return r
            except Exception as e:
                # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                # machine exits.
                self.hook_exit_exception = e
                self.end_analysis()
                # this works in all current callback cases. CFFI auto-converts to void, bool, int, and int32_t
                return 0

        return wrapper
    return decorator</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.hook2"><code class="name flex">
<span>def <span class="ident">hook2</span></span>(<span>self, name, kernel=True, procname=None, libname=None, trace_start=0, trace_stop=0, range_begin=0, range_end=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to create a hook with the hooks2 plugin.</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated:&ensp;Use the hooks plugin instead.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook2(self,name, kernel=True, procname=None, libname=None, trace_start=0, trace_stop=0, range_begin=0, range_end=0):
    &#39;&#39;&#39;
    Decorator to create a hook with the hooks2 plugin.

    .. Deprecated:: Use the hooks plugin instead.
    &#39;&#39;&#39;

    if procname == None:
        procname = self.ffi.NULL
    if libname == None:
        libname = self.ffi.NULL


    if procname != self.ffi.NULL:
        procname = self.ffi.new(&#34;char[]&#34;,bytes(procname,&#34;utf-8&#34;))
    if libname != self.ffi.NULL:
        libname = self.ffi.new(&#34;char[]&#34;,bytes(libname,&#34;utf-8&#34;))
    &#39;&#39;&#39;
    Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
    the function will be called with args (CPUState, TranslationBlock)
    &#39;&#39;&#39;
    def decorator(fun):
        # Ultimately, our hook resolves as a before_block_exec_invalidate_opt callback so we must match its args
        hook_cb_type = self.ffi.callback(&#34;bool (CPUState*, TranslationBlock*, void*)&#34;)
        # Inform the plugin that it has a new breakpoint at addr

        hook_cb_passed = hook_cb_type(fun)
        if not hasattr(self, &#34;hook_gc_list&#34;):
            self.hook_gc_list = [hook_cb_passed]
        else:
            self.hook_gc_list.append(hook_cb_passed)

        # I don&#39;t know what this is/does
        cb_data =self.ffi.NULL
        hook_number = self.plugins[&#39;hooks2&#39;].add_hooks2(hook_cb_passed, cb_data, kernel, \
            procname, libname, trace_start, trace_stop, range_begin,range_end)

        self.hook_list2[name] = hook_number

        @hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
        def wrapper(*args, **kw):
            return fun(*args, **kw)

        return wrapper
    return decorator</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.hook2_single_insn"><code class="name flex">
<span>def <span class="ident">hook2_single_insn</span></span>(<span>self, name, pc, kernel=False, procname=None, libname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to hook a single instruction with the hooks2 plugin.</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated:&ensp;Use the hooks plugin instead.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook2_single_insn(self, name, pc, kernel=False, procname=None, libname=None):
    &#39;&#39;&#39;
    Helper function to hook a single instruction with the hooks2 plugin.

    .. Deprecated:: Use the hooks plugin instead.
    &#39;&#39;&#39;
    if procname == None:
        procname = self.ffi.NULL
    if libname == None:
        libname = self.ffi.NULL
    return self.hook2(name, kernel=kernel, procname=procname,libname=libname,range_begin=pc, range_end=pc)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.hook_mem"><code class="name flex">
<span>def <span class="ident">hook_mem</span></span>(<span>self, start_address, end_address, on_before, on_after, on_read, on_write, on_virtual, on_physical, enabled)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to hook a memory range with the mem_hooks plugin</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Fully document mem-hook decorators</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook_mem(self, start_address, end_address, on_before, on_after, on_read, on_write, on_virtual, on_physical, enabled):
    &#39;&#39;&#39;
    Decorator to hook a memory range with the mem_hooks plugin

    .. todo:: Fully document mem-hook decorators
    &#39;&#39;&#39;
    return self._hook_mem(start_address,end_address,on_before,on_after,on_read, on_write, on_virtual, on_physical, enabled)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.hook_phys_mem_read"><code class="name flex">
<span>def <span class="ident">hook_phys_mem_read</span></span>(<span>self, start_address, end_address, on_before=True, on_after=False, enabled=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to hook physical memory reads with the mem_hooks plugin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook_phys_mem_read(self, start_address, end_address, on_before=True, on_after=False, enabled=True):
    &#39;&#39;&#39;
    Decorator to hook physical memory reads with the mem_hooks plugin
    &#39;&#39;&#39;
    return self._hook_mem(start_address,end_address,on_before,on_after, True, False, False, True, True)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.hook_phys_mem_write"><code class="name flex">
<span>def <span class="ident">hook_phys_mem_write</span></span>(<span>self, start_address, end_address, on_before=True, on_after=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to hook physical memory writes with the mem_hooks plugin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook_phys_mem_write(self, start_address, end_address, on_before=True, on_after=False):
    &#39;&#39;&#39;
    Decorator to hook physical memory writes with the mem_hooks plugin
    &#39;&#39;&#39;
    return self._hook_mem(start_address,end_address,on_before,on_after, False, True, False, True, True)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.hook_symbol"><code class="name flex">
<span>def <span class="ident">hook_symbol</span></span>(<span>self, libraryname, symbol, kernel=False, name=None, cb_type='start_block_exec')</span>
</code></dt>
<dd>
<div class="desc"><p>Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
the function will be called with args (CPUState, TranslationBlock)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>libraryname</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of library containing symbol to be hooked. May be None to match any.</dd>
<dt><strong><code>symbol</code></strong> :&ensp;<code>string, int</code></dt>
<dd>Name of symbol or offset into library to hook</dd>
<dt><strong><code>kernel</code></strong> :&ensp;<code>bool</code></dt>
<dd>if hook should be applied exclusively in kernel mode</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>name of hook, defaults to function name</dd>
<dt><strong><code>cb_type</code></strong> :&ensp;<code>string</code></dt>
<dd>callback-type, defaults to start_block_exec</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>Decorated function is called when (before/after is determined by cb_type) guest goes to call
the specified symbol in the specified library.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook_symbol(self, libraryname, symbol, kernel=False, name=None, cb_type=&#34;start_block_exec&#34;):
    &#39;&#39;&#39;
    Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
    the function will be called with args (CPUState, TranslationBlock)

    Args:
        libraryname (string): Name of library containing symbol to be hooked. May be None to match any.
        symbol (string, int): Name of symbol or offset into library to hook
        kernel (bool): if hook should be applied exclusively in kernel mode
        name (string): name of hook, defaults to function name
        cb_type (string): callback-type, defaults to start_block_exec

    Returns:
        None: Decorated function is called when (before/after is determined by cb_type) guest goes to call
              the specified symbol in the specified library.
    &#39;&#39;&#39;

    def decorator(fun):
        if cb_type == &#34;before_tcg_codegen&#34; or cb_type == &#34;after_block_translate&#34; or cb_type == &#34;before_block_exec&#34; or cb_type == &#34;start_block_exec&#34; or cb_type == &#34;end_block_exec&#34;:
            hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , struct hook *)&#34;)
        elif cb_type == &#34;after_block_exec&#34;:
            hook_cb_type = self.ffi.callback(&#34;void(CPUState*, TranslationBlock* , uint8_t, struct hook *)&#34;)
        elif cb_type == &#34;before_block_translate&#34;:
            hook_cb_type = self.ffi.callback(&#34;void(CPUState* env, target_ptr_t pc, struct hook*)&#34;)
        elif cb_type == &#34;before_block_exec_invalidate_opt&#34;:
            hook_cb_type = self.ffi.callback(&#34;bool(CPUState* env, TranslationBlock*, struct hook*)&#34;)
        else:
            print(&#34;function type not supported&#34;)
            return

        # Inform the plugin that it has a new breakpoint at addr
        hook_cb_passed = hook_cb_type(fun)
        new_hook = self.ffi.new(&#34;struct symbol_hook*&#34;)
        type_num = getattr(self.libpanda, &#34;PANDA_CB_&#34;+cb_type.upper())
        new_hook.type = type_num
        if libraryname is not None:
            libname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(libraryname,&#34;utf-8&#34;))
        else:
            libname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
        self.ffi.memmove(new_hook.section,libname_ffi,len(libname_ffi))

        new_hook.hook_offset = False
        if symbol is not None:
            if isinstance(symbol, int):
                new_hook.offset = symbol
                new_hook.hook_offset = True
                symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
            else:
                symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(symbol,&#34;utf-8&#34;))
                new_hook.hook_offset = False
        else:
            symbolname_ffi = self.ffi.new(&#34;char[]&#34;,bytes(&#34;\x00\x00\x00\x00&#34;,&#34;utf-8&#34;))
        self.ffi.memmove(new_hook.name,symbolname_ffi,len(symbolname_ffi))
        setattr(new_hook.cb,cb_type, hook_cb_passed)
        hook_ptr = self.plugins[&#39;hooks&#39;].add_symbol_hook(new_hook)
        if name is not None:
            self.named_hooks[name] = hook_ptr
        self.hook_list.append((fun, new_hook,hook_cb_passed, hook_ptr))

        @hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
        def wrapper(*args, **kw):
            try:
                r = fun(*args, **kw)
                #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                return r
            except Exception as e:
                # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                # machine exits.
                self.hook_exit_exception = e
                self.end_analysis()
                # this works in all current callback cases. CFFI auto-converts to void, bool, int, and int32_t
                return 0

        return wrapper
    return decorator</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.hook_virt_mem_read"><code class="name flex">
<span>def <span class="ident">hook_virt_mem_read</span></span>(<span>self, start_address, end_address, on_before=True, on_after=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to hook virtual memory reads with the mem_hooks plugin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook_virt_mem_read(self, start_address, end_address, on_before=True, on_after=False):
    &#39;&#39;&#39;
    Decorator to hook virtual memory reads with the mem_hooks plugin
    &#39;&#39;&#39;
    return self._hook_mem(start_address,end_address,on_before,on_after, True, False, True, False, True)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.hook_virt_mem_write"><code class="name flex">
<span>def <span class="ident">hook_virt_mem_write</span></span>(<span>self, start_address, end_address, on_before=True, on_after=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to hook virtual memory writes with the mem_hooks plugin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook_virt_mem_write(self, start_address, end_address, on_before=True, on_after=False):
    &#39;&#39;&#39;
    Decorator to hook virtual memory writes with the mem_hooks plugin
    &#39;&#39;&#39;
    return self._hook_mem(start_address,end_address,on_before,on_after, False, True, True, False, True)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.in_kernel"><code class="name flex">
<span>def <span class="ident">in_kernel</span></span>(<span>self, cpustate)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the processor is in the privilege level corresponding to kernel mode for any of the PANDA supported architectures.
Legacy alias for in_kernel_mode().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_kernel(self, cpustate):
    &#39;&#39;&#39;
    Returns true if the processor is in the privilege level corresponding to kernel mode for any of the PANDA supported architectures.
    Legacy alias for in_kernel_mode().
    &#39;&#39;&#39;
    return self.libpanda.panda_in_kernel_external(cpustate)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.in_kernel_code_linux"><code class="name flex">
<span>def <span class="ident">in_kernel_code_linux</span></span>(<span>self, cpustate)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the processor is running in linux kernelspace.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Bool</code></dt>
<dd>If the processor is running in Linux kernel space code.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_kernel_code_linux(self, cpustate):
    &#39;&#39;&#39;
    Check if the processor is running in linux kernelspace.

    Args:
        cpu (CPUState): CPUState structure

    Returns:
        Bool: If the processor is running in Linux kernel space code.
    &#39;&#39;&#39;
    return self.libpanda.panda_in_kernel_code_linux_external(cpustate)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.in_kernel_mode"><code class="name flex">
<span>def <span class="ident">in_kernel_mode</span></span>(<span>self, cpustate)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the processor is running in priviliged mode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Bool</code></dt>
<dd>If the processor is in the privilege level corresponding to kernel mode
for the given architecture</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_kernel_mode(self, cpustate):
    &#39;&#39;&#39;
    Check if the processor is running in priviliged mode.

    Args:
        cpu (CPUState): CPUState structure

    Returns:
        Bool: If the processor is in the privilege level corresponding to kernel mode
              for the given architecture
    &#39;&#39;&#39;
    return self.libpanda.panda_in_kernel_mode_external(cpustate)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.interact"><code class="name flex">
<span>def <span class="ident">interact</span></span>(<span>self, confirm_quit=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Expose console interactively until user types pandaquit
Must be run in blocking thread.</p>
<p>TODO: This should probably repace self.serial_console with something
that directly renders output to the user. Then we don't have to handle
buffering and other problems. But we will need to re-enable the serial_console
interface after this returns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def interact(self, confirm_quit=True):
    &#39;&#39;&#39;
    Expose console interactively until user types pandaquit
    Must be run in blocking thread.

    TODO: This should probably repace self.serial_console with something
    that directly renders output to the user. Then we don&#39;t have to handle
    buffering and other problems. But we will need to re-enable the serial_console
    interface after this returns
    &#39;&#39;&#39;
    print(&#34;PANDA: entering interactive mode. Type pandaquit to exit&#34;)
    prompt = self.expect_prompt.decode(&#34;utf8&#34;) if self.expect_prompt  else &#34;$ &#34;
    if not prompt.endswith(&#34; &#34;): prompt += &#34; &#34;
    while True:
        cmd = input(prompt) # TODO: Strip all control characters - Ctrl-L breaks things
        if cmd.strip() == &#39;pandaquit&#39;:
            if confirm_quit:
                q = input(&#34;PANDA: Quitting interactive mode. Are you sure? (y/n) &#34;)
                if len(q) and q.lower()[0] == &#39;y&#39;:
                    break
                else:
                    continue
            else: # No confirm - just break
                break
        r = self.run_serial_cmd(cmd) # XXX: may timeout
        print(r)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.is_callback_enabled"><code class="name flex">
<span>def <span class="ident">is_callback_enabled</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_callback_enabled(self, name):
    if name not in self.registered_callbacks.keys():
        raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))
    return self.registered_callbacks[name][&#39;enabled&#39;]</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.load_plugin"><code class="name flex">
<span>def <span class="ident">load_plugin</span></span>(<span>self, name, args={})</span>
</code></dt>
<dd>
<div class="desc"><p>Load a C plugin, optionally with arguments</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of plugin</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments matching key to value. e.g. {"key": "value"} sets option <code>key</code> to <code>value</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_plugin(self, name, args={}):
    &#39;&#39;&#39;
    Load a C plugin, optionally with arguments

    Args:
        name (str): Name of plugin
        args (dict): Arguments matching key to value. e.g. {&#34;key&#34;: &#34;value&#34;} sets option `key` to `value`.

    Returns:
        None.
    &#39;&#39;&#39;
    if debug:
        progress (&#34;Loading plugin %s&#34; % name),

    argstrs_ffi = []
    if isinstance(args, dict):
        for k,v in args.items():
            this_arg_s = &#34;{}={}&#34;.format(k,v)
            this_arg = self.ffi.new(&#34;char[]&#34;, bytes(this_arg_s, &#34;utf-8&#34;))
            argstrs_ffi.append(this_arg)

        n = len(args.keys())
    elif isinstance(args, list):
        for arg in args:
            this_arg = self.ffi.new(&#34;char[]&#34;, bytes(arg, &#34;utf-8&#34;))
            argstrs_ffi.append(this_arg)
        n = len(args)

    else:
        raise ValueError(&#34;Arguments to load plugin must be a list or dict of key/value pairs&#34;)

    # First set qemu_path so plugins can load (may be unnecessary after the first time)
    assert(self.panda), &#34;Unknown location of PANDA&#34;
    panda_name_ffi = self.ffi.new(&#34;char[]&#34;, bytes(self.panda,&#34;utf-8&#34;))
    self.libpanda.panda_set_qemu_path(panda_name_ffi)

    if len(argstrs_ffi):
        plugin_args = argstrs_ffi
    else:
        plugin_args = self.ffi.NULL

    charptr = self.ffi.new(&#34;char[]&#34;, bytes(name,&#34;utf-8&#34;))
    self.libpanda.panda_require_from_library(charptr, plugin_args, len(argstrs_ffi))
    self._load_plugin_library(name)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.lookup_gic"><code class="name flex">
<span>def <span class="ident">lookup_gic</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lookup_gic(self,n):
    return self.libpanda.lookup_gic(n)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.make_panda_file_handler"><code class="name flex">
<span>def <span class="ident">make_panda_file_handler</span></span>(<span>self, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Constructs a file and file handler that volatility can't ignore to back by PANDA physical memory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_panda_file_handler(self, debug=False):
    &#39;&#39;&#39;
    Constructs a file and file handler that volatility can&#39;t ignore to back by PANDA physical memory
    &#39;&#39;&#39;
    from urllib.request import BaseHandler
    if &#39;PandaFileHandler&#39; in globals():  # already initialized
        return
    panda = self

    class PandaFile(object):
        def __init__(self, length, panda):
            self.pos = 0
            self.length = length
            self.closed = False
            self.mode = &#34;rb&#34;
            self.name = &#34;/tmp/panda.panda&#34;
            self.panda = panda
            self.classname = type(self).__name__

        def readable(self):
            return self.closed

        def read(self, size=1):
            if self.panda.bits == 32 and self.panda.arch_name == &#34;i386&#34;:
                data = self.panda.physical_memory_read(
                    self.pos &amp; 0xfffffff, size)
            else:
                data = self.panda.physical_memory_read(self.pos, size)
            if debug:
                print(self.classname+&#34;: Reading &#34; +
                      str(size)+&#34; bytes from &#34;+hex(self.pos))
            self.pos += size
            return data

        def peek(self, size=1):
            return self.panda.physical_memory_read(self.pos, size)

        def seek(self, pos, whence=0):
            if whence == 0:
                self.pos = pos
            elif whence == 1:
                self.pos += pos
            else:
                self.pos = self.length - pos
            if self.pos &gt; self.length:
                print(self.classname+&#34;: We&#39;ve gone off the deep end&#34;)
            if debug:
                print(self.classname+&#34; Seeking to address &#34;+hex(self.pos))

        def tell(self):
            return self.pos

        def close(self):
            self.closed = True

    class PandaFileHandler(BaseHandler):
        def default_open(self, req):
            if &#39;panda.panda&#39; in req.full_url:
                length = panda.libpanda.ram_size
                if length &gt; 0xc0000000:
                    length += 0x40000000  # 3GB hole
                if debug:
                    print(type(self).__name__ +
                          &#34;: initializing PandaFile with length=&#34;+hex(length))
                return PandaFile(length=length, panda=panda)
            else:
                return None

        def file_close(self):
            return True

    globals()[&#34;PandaFileHandler&#34;] = PandaFileHandler</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.map_memory"><code class="name flex">
<span>def <span class="ident">map_memory</span></span>(<span>self, name, size, address)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a new memory region.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>This is an internal reference name for this region. Must be unique.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>number of bytes the region should be.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>int</code></dt>
<dd>start address of region</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_memory(self, name, size, address):

    &#39;&#39;&#39;
    Make a new memory region.

    Args:
        name (str): This is an internal reference name for this region. Must be unique.
        size (int): number of bytes the region should be.
        address (int): start address of region

    Returns:
        None
    &#39;&#39;&#39;

    name_c = self.ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
    size = ceil(size/1024)*1024 # Must be page-aligned
    return self.libpanda.map_memory(name_c, size, address)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.memory_region_add_subregion"><code class="name flex">
<span>def <span class="ident">memory_region_add_subregion</span></span>(<span>self, mr, offset, sr)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls memory_region_add_subregion from QEMU.
memory_region_add_subregion: Add a subregion to a container.</p>
<p>Adds a subregion at @offset.
The subregion may not overlap with other
subregions (except for those explicitly marked as overlapping).
A region
may only be added once as a subregion (unless removed with
memory_region_del_subregion()); use memory_region_init_alias() if you
want a region to be a subregion in multiple locations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mr</code></strong></dt>
<dd>the region to contain the new subregion; must be a container initialized with memory_region_init().</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>the offset relative to @mr where @subregion is added.</dd>
<dt><strong><code>subregion</code></strong></dt>
<dd>the subregion to be added.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memory_region_add_subregion(self, mr, offset, sr):
    &#39;&#39;&#39;
    Calls memory_region_add_subregion from QEMU.
    memory_region_add_subregion: Add a subregion to a container.

    Adds a subregion at @offset.  The subregion may not overlap with other
    subregions (except for those explicitly marked as overlapping).  A region
    may only be added once as a subregion (unless removed with
    memory_region_del_subregion()); use memory_region_init_alias() if you
    want a region to be a subregion in multiple locations.

    Args:
        mr: the region to contain the new subregion; must be a container initialized with memory_region_init().
        offset: the offset relative to @mr where @subregion is added.
        subregion: the subregion to be added.

    Returns:
        None
    &#39;&#39;&#39;
    return self.libpanda.memory_region_add_subregion(mr,offset,sr)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.memory_region_allocate_system_memory"><code class="name flex">
<span>def <span class="ident">memory_region_allocate_system_memory</span></span>(<span>self, mr, obj, name, ram_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Allocates Memory region by user specificiation.
Calls memory_region_allocation_system_memory QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mr</code></strong></dt>
<dd>MemoryRegion struct</dd>
<dt><strong><code>obj</code></strong></dt>
<dd>Object struct</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Region name</dd>
<dt><strong><code>ram_size</code></strong> :&ensp;<code>int</code></dt>
<dd>RAM size</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memory_region_allocate_system_memory(self, mr, obj, name, ram_size):
    &#39;&#39;&#39;
    Allocates Memory region by user specificiation.
    Calls memory_region_allocation_system_memory QEMU function.

    Args:
        mr: MemoryRegion struct
        obj: Object struct
        name (str): Region name
        ram_size (int): RAM size

    Returns:
        None
    &#39;&#39;&#39;
    return self.libpanda.memory_region_allocate_system_memory(mr, obj, name, ram_size)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.memory_region_init_ram_from_file"><code class="name flex">
<span>def <span class="ident">memory_region_init_ram_from_file</span></span>(<span>self, mr, owner, name, size, share, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls memory_region_init_ram_from_file from QEMU.
memory_region_init_ram_from_file:
Initialize RAM memory region with a mmap-ed backend.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mr</code></strong></dt>
<dd>the #MemoryRegion to be initialized.</dd>
<dt><strong><code>owner</code></strong></dt>
<dd>the object that tracks the region's reference count</dd>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the region.</dd>
<dt><strong><code>size</code></strong></dt>
<dd>size of the region.</dd>
<dt><strong><code>share</code></strong></dt>
<dd>%true if memory must be mmaped with the MAP_SHARED flag</dd>
<dt><strong><code>path</code></strong></dt>
<dd>the path in which to allocate the RAM.</dd>
<dt><strong><code>errp</code></strong></dt>
<dd>pointer to Error*, to store an error if it happens.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memory_region_init_ram_from_file(self, mr, owner, name, size, share, path):
    &#39;&#39;&#39;
    Calls memory_region_init_ram_from_file from QEMU.
    memory_region_init_ram_from_file:  Initialize RAM memory region with a mmap-ed backend.

    Args:
        mr: the #MemoryRegion to be initialized.
        owner: the object that tracks the region&#39;s reference count
        name: the name of the region.
        size: size of the region.
        share: %true if memory must be mmaped with the MAP_SHARED flag
        path: the path in which to allocate the RAM.
        errp: pointer to Error*, to store an error if it happens.

    Returns:
        None
    &#39;&#39;&#39;
    return self.libpanda.memory_region_init_ram_from_file(mr, owner, name, size, share, path, self.libpanda.error_fatal)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.memsavep"><code class="name flex">
<span>def <span class="ident">memsavep</span></span>(<span>self, file_out)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls QEMU memsavep on your specified python file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memsavep(self, file_out):
    &#39;&#39;&#39;
    Calls QEMU memsavep on your specified python file.
    &#39;&#39;&#39;
    # this part was largely copied from https://cffi.readthedocs.io/en/latest/ref.html#support-for-file

    file_out.flush()                 # make sure the file is flushed
    newfd = dup(file_out.fileno())   # make a copy of the file descriptor
    fileptr = self.C.fdopen(newfd, b&#34;w&#34;)
    self.libpanda.panda_memsavep(fileptr)
    self.C.fclose(fileptr)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_class_by_name"><code class="name flex">
<span>def <span class="ident">object_class_by_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns class as ObjectClass from name specified.
Calls object_class_by_name QEMU function.</p>
<p>Args
name (str): string defined by user</p>
<h2 id="returns">Returns</h2>
<p>struct as specified by name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_class_by_name(self, name):
    &#39;&#39;&#39;
    Returns class as ObjectClass from name specified.
    Calls object_class_by_name QEMU function.

    Args
        name (str): string defined by user

    Returns:
        struct as specified by name
    &#39;&#39;&#39;
    return self.libpanda.object_class_by_name(name)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_class_get_name"><code class="name flex">
<span>def <span class="ident">object_class_get_name</span></span>(<span>self, objclass)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets String QOM typename from object class.
Calls object_class_get_name QEMU function.</p>
<p>Args::
objclass: class to obtain the QOM typename for.</p>
<h2 id="returns">Returns</h2>
<p>String QOM typename for klass.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_class_get_name(self, objclass):
    &#39;&#39;&#39;
    Gets String QOM typename from object class.
    Calls object_class_get_name QEMU function.

    Args::
        objclass: class to obtain the QOM typename for.

    Returns:
        String QOM typename for klass.
    &#39;&#39;&#39;
    return self.libpanda.object_class_get_name(objclass)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_new"><code class="name flex">
<span>def <span class="ident">object_new</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new QEMU object from typename.
This function will initialize a new object using heap allocated memory.
The returned object has a reference count of 1, and will be freed when
the last reference is dropped.
Calls object_new QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the type of the object to instantiate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The newly allocated and instantiated object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_new(self, name):
    &#39;&#39;&#39;
    Creates a new QEMU object from typename.
    This function will initialize a new object using heap allocated memory.
    The returned object has a reference count of 1, and will be freed when
    the last reference is dropped.
    Calls object_new QEMU function.

    Args:
        name (str): The name of the type of the object to instantiate.

    Returns:
        The newly allocated and instantiated object.
    &#39;&#39;&#39;
    return self.libpanda.object_new(name)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_property_find"><code class="name flex">
<span>def <span class="ident">object_property_find</span></span>(<span>self, obj, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Look up a property for an object and return its #ObjectProperty if found.
Calls object_property_find QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>the object</dd>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the property</dd>
<dt><strong><code>errp</code></strong></dt>
<dd>returns an error if this function fails</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>struct ObjectProperty pointer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_find(self, obj, name):
    &#39;&#39;&#39;
    Look up a property for an object and return its #ObjectProperty if found.
    Calls object_property_find QEMU function.

    Args:
        obj: the object
        name: the name of the property
        errp: returns an error if this function fails

    Returns:
        struct ObjectProperty pointer
    &#39;&#39;&#39;
    return self.libpanda.object_property_find(obj,name,ffi.NULL)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_property_get_bool"><code class="name flex">
<span>def <span class="ident">object_property_get_bool</span></span>(<span>self, obj, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Pull boolean from object.
Calls object_property_get_bool QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>the object</dd>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the property</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the value of the property, converted to a boolean, or NULL if an error occurs (including when the property value is not a bool).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_get_bool(self, obj, name):
    &#39;&#39;&#39;
    Pull boolean from object.
    Calls object_property_get_bool QEMU function.

    Args:
        obj: the object
        name: the name of the property

    Returns:
        the value of the property, converted to a boolean, or NULL if an error occurs (including when the property value is not a bool).
    &#39;&#39;&#39;
    return self.libpanda.object_property_get_bool(obj,name,self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_property_get_int"><code class="name flex">
<span>def <span class="ident">object_property_get_int</span></span>(<span>self, obj, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets integer in QEMU object. Reads an integer value from this property.
Calls object_property_get_int QEMU function.</p>
<pre><code>Paramaters:
    obj: the object
    name: the name of the property

Returns:
    the value of the property, converted to an integer, or negative if an error occurs (including when the property value is not an integer).
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_get_int(self, obj, name):
    &#39;&#39;&#39;
    Gets integer in QEMU object. Reads an integer value from this property.
    Calls object_property_get_int QEMU function.

        Paramaters:
            obj: the object
            name: the name of the property

        Returns:
            the value of the property, converted to an integer, or negative if an error occurs (including when the property value is not an integer).
    &#39;&#39;&#39;
    return self.libpanda.object_property_get_int(obj, name, self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_property_get_link"><code class="name flex">
<span>def <span class="ident">object_property_get_link</span></span>(<span>self, obj, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads an object's canonical path to a property.
Calls object_property_get_link QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>the object</dd>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the property</dd>
<dt><strong><code>errp</code></strong></dt>
<dd>returns an error if this function fails</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the value of the property, resolved from a path to an Object, or NULL if an error occurs (including when the property value is not a string or not a valid object path).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_get_link(self, obj, name):
    &#39;&#39;&#39;
    Reads an object&#39;s canonical path to a property.
    Calls object_property_get_link QEMU function.

    Args:
        obj: the object
        name: the name of the property
        errp: returns an error if this function fails

    Returns:
        the value of the property, resolved from a path to an Object, or NULL if an error occurs (including when the property value is not a string or not a valid object path).
    &#39;&#39;&#39;
    return self.libpanda.object_property_get_link(obj,name,self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_property_set_bool"><code class="name flex">
<span>def <span class="ident">object_property_set_bool</span></span>(<span>self, obj, value, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a bool value to a property.
Calls object_property_set_bool QEMU function.</p>
<p>Args::
value: the value to be written to the property
name: the name of the property
errp: returns an error if this function fails</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_set_bool(self, obj, value, name):
    &#39;&#39;&#39;
    Writes a bool value to a property.
    Calls object_property_set_bool QEMU function.

    Args::
        value: the value to be written to the property
        name: the name of the property
        errp: returns an error if this function fails

    Returns:
        None
    &#39;&#39;&#39;
    return self.libpanda.object_property_set_bool(obj,value,name,self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_property_set_int"><code class="name flex">
<span>def <span class="ident">object_property_set_int</span></span>(<span>self, obj, value, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set integer in QEMU object. Writes an integer value to a property.
Calls object_property_set_int QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>the value to be written to the property</dd>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the property</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_set_int(self,obj, value, name):
    &#39;&#39;&#39;
    Set integer in QEMU object. Writes an integer value to a property.
    Calls object_property_set_int QEMU function.

    Args:
        value: the value to be written to the property
        name: the name of the property

    Returns:
        None
    &#39;&#39;&#39;
    return self.libpanda.object_property_set_int(obj, value, name, self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_property_set_link"><code class="name flex">
<span>def <span class="ident">object_property_set_link</span></span>(<span>self, obj, val, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes an object's canonical path to a property.
Calls object_property_set_link QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>the value to be written to the property</dd>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the property</dd>
<dt><strong><code>errp</code></strong></dt>
<dd>returns an error if this function fails</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_set_link(self, obj, val, name):
    &#39;&#39;&#39;
    Writes an object&#39;s canonical path to a property.
    Calls object_property_set_link QEMU function.

    Args:
        value: the value to be written to the property
        name: the name of the property
        errp: returns an error if this function fails

    Returns:
        None
    &#39;&#39;&#39;
    return self.libpanda.object_property_set_link(obj,val,name,self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.panda_finish"><code class="name flex">
<span>def <span class="ident">panda_finish</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Final stage call to underlying panda_finish with initialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def panda_finish(self):
    &#39;&#39;&#39;
    Final stage call to underlying panda_finish with initialization.
    &#39;&#39;&#39;
    return self.libpanda.panda_finish()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.physical_memory_read"><code class="name flex">
<span>def <span class="ident">physical_memory_read</span></span>(<span>self, addr, length, fmt='bytearray')</span>
</code></dt>
<dd>
<div class="desc"><p>Read guest physical memory. In the specified format. Note that the <code>ptrlist</code> format
returns a list of integers, each of the specified architecture's pointer size.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>addr</code></strong> :&ensp;<code>int</code></dt>
<dd>Address</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>length of array you would like returned</dd>
<dt><strong><code>fmt</code></strong> :&ensp;<code>str</code></dt>
<dd>format for returned array. Options: 'bytearray', 'int', 'str', 'ptrlist'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[bytearray, int, str, list[int]]</code></dt>
<dd>memory data</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ValueError if memory access fails or fmt is unsupported</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def physical_memory_read(self, addr, length, fmt=&#39;bytearray&#39;):
    &#39;&#39;&#39;
    Read guest physical memory. In the specified format. Note that the `ptrlist` format
    returns a list of integers, each of the specified architecture&#39;s pointer size.

    Args:
        addr (int): Address
        length (int): length of array you would like returned
        fmt (str): format for returned array. Options: &#39;bytearray&#39;, &#39;int&#39;, &#39;str&#39;, &#39;ptrlist&#39;

    Returns:
        Union[bytearray, int, str, list[int]]: memory data

    Raises:
        ValueError if memory access fails or fmt is unsupported
    &#39;&#39;&#39;
    return self._memory_read(None, addr, length, physical=True, fmt=fmt)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.physical_memory_write"><code class="name flex">
<span>def <span class="ident">physical_memory_write</span></span>(<span>self, addr, buf)</span>
</code></dt>
<dd>
<div class="desc"><p>Write guest physical memory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>addr</code></strong> :&ensp;<code>int</code></dt>
<dd>Address</dd>
<dt><strong><code>buf</code></strong> :&ensp;<code>bytestring</code></dt>
<dd>byte string to write into memory</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>error</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def physical_memory_write(self, addr, buf):
    &#39;&#39;&#39;
    Write guest physical memory.

    Args:
        addr (int): Address
        buf (bytestring):  byte string to write into memory

    Returns:
        bool: error
    &#39;&#39;&#39;
    return self._memory_write(None, addr, buf, physical=True)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.ppp"><code class="name flex">
<span>def <span class="ident">ppp</span></span>(<span>self, plugin_name, attr, name=None, autoload=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator for plugin-to-plugin interface. Note this isn't in decorators.py
becuase it uses the panda object.</p>
<p>Example usage to register my_run with syscalls2 as a 'on_sys_open_return'
@ppp("syscalls2", "on_sys_open_return")
def my_fun(cpu, pc, filename, flags, mode):
&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ppp(self, plugin_name, attr, name=None, autoload=True):
    &#39;&#39;&#39;
    Decorator for plugin-to-plugin interface. Note this isn&#39;t in decorators.py
    becuase it uses the panda object.

    Example usage to register my_run with syscalls2 as a &#39;on_sys_open_return&#39;
    @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;)
    def my_fun(cpu, pc, filename, flags, mode):
        ...
    &#39;&#39;&#39;

    if plugin_name not in self.plugins and autoload: # Could automatically load it?
        print(f&#34;PPP automatically loaded plugin {plugin_name}&#34;)

    if not hasattr(self, &#34;ppp_registered_cbs&#34;):
        self.ppp_registered_cbs = {}
        # We use this to traak fn_names-&gt;fn_pointers so we can later disable by name

        # XXX: if  we don&#39;t save the cffi generated callbacks somewhere in Python,
        # they may get garbage collected even though the c-code could still has a
        # reference to them  which will lead to a crash. If we stop using this to track
        # function names, we need to keep it or something similar to ensure the reference
        # count remains &gt;0 in python

    def decorator(fun):
        local_name = name  # We need a new varaible otherwise we have scoping issues, maybe
        if local_name is None:
            local_name = fun.__name__

        def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
            try:
                r = fun(*args, **kwargs)
                #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                return r
            except Exception as e:
                # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                # machine exits.
                self.callback_exit_exception = e
                self.end_analysis()
                # this works in all current callback cases. CFFI auto-converts to void, bool, int, and int32_t

        f = self.ffi.callback(attr+&#34;_t&#34;)(_run_and_catch)  # Wrap the python fn in a c-callback.
        if local_name == &#34;&lt;lambda&gt;&#34;:
            local_name = f&#34;&lt;lambda_{self.lambda_cnt}&gt;&#34;
            self.lambda_cnt += 1

        if local_name in self.ppp_registered_cbs:
            print(f&#34;Warning: replacing existing PPP callback &#39;{local_name}&#39; since it was re-registered&#34;)
            self.disable_ppp(local_name)

        assert (local_name not in self.ppp_registered_cbs), f&#34;Two callbacks with conflicting name: {local_name}&#34;

        # Ensure function isn&#39;t garbage collected, and keep the name-&gt;(fn, plugin_name, attr) map for disabling
        self.ppp_registered_cbs[local_name] = (f, plugin_name, attr)

        eval(f&#34;self.plugins[&#39;{plugin_name}&#39;].ppp_add_cb_{attr}&#34;)(f) # All PPP  cbs start with this string. XXX insecure eval
        return f
    return decorator</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.pyperiph_read_cb"><code class="name flex">
<span>def <span class="ident">pyperiph_read_cb</span></span>(<span>self, cpu, pc, physaddr, size, val_ptr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pyperiph_read_cb(self, cpu, pc, physaddr, size, val_ptr):
    pp = self._addr_to_pyperipheral(physaddr)
    if pp is None:
        return False

    val = pp.read_memory(physaddr, size)
    buf = self.ffi.buffer(val_ptr, size)

    fmt = &#34;{}{}&#34;.format(self._end2fmt[self.endianness], self._num2fmt[size])

    pack_into(fmt, buf, 0, val)

    return True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.pyperiph_write_cb"><code class="name flex">
<span>def <span class="ident">pyperiph_write_cb</span></span>(<span>self, cpu, pc, physaddr, size, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pyperiph_write_cb(self, cpu, pc, physaddr, size, val):
    pp = self._addr_to_pyperipheral(physaddr)
    if pp is None:
        return False

    pp.write_memory(physaddr, size, val)
    return True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.queue_async"><code class="name flex">
<span>def <span class="ident">queue_async</span></span>(<span>self, f, internal=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Explicitly queue work in the asynchronous work queue.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>A python function with no arguments to be called at a later time. The function should</dd>
</dl>
<p>be decorated with <code>@pandare.blocking</code>. You generally want to use <code>panda.queue_blocking</code> over this function.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_async(self, f, internal=False):
    &#39;&#39;&#39;
    Explicitly queue work in the asynchronous work queue.

    Args:
        f: A python function with no arguments to be called at a later time. The function should
        be decorated with `@pandare.blocking`. You generally want to use `panda.queue_blocking` over this function.

    Returns:
        None
    &#39;&#39;&#39;

    # this takes the blocking function and handles errors
    @blocking
    def wrapper():
        try:
            f()
        except Exception as e:
            self.blocking_queue_error = e
            self.end_analysis()


    # Keep the original function name instead of replacing it with &#39;wrapper&#39;
    wrapper.__name__ = f.__name__
    self.athread.queue(wrapper, internal=internal)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.queue_blocking"><code class="name flex">
<span>def <span class="ident">queue_blocking</span></span>(<span>self, func, queue=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to mark a function as <code>blocking</code>, and (by default) queue it to run asynchronously.
This should be used to mark functions that will drive guest execution. Functions will be run
in the order they are defined. For more precise control, use <code>panda.queue_async</code>.</p>
<pre><code>@panda.queue_blocking
def do_something():
    panda.revert_sync('root')
    print(panda.run_serial_cmd('whoami'))
    panda.end_analysis()
</code></pre>
<p>is equivalent to</p>
<pre><code>@blocking
def run_whoami():
    panda.revert_sync('root')
    print(panda.run_serial_cmd('whoami'))
    panda.end_analysis()

panda.queue_async(run_whoami)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>function</code></dt>
<dd>Function to queue</dd>
<dt><strong><code>queue</code></strong> :&ensp;<code>bool</code></dt>
<dd>Should function automatically be queued</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_blocking(self, func, queue=True):
    &#34;&#34;&#34;
    Decorator to mark a function as `blocking`, and (by default) queue it to run asynchronously.
    This should be used to mark functions that will drive guest execution. Functions will be run
    in the order they are defined. For more precise control, use `panda.queue_async`.


    ```
    @panda.queue_blocking
    def do_something():
        panda.revert_sync(&#39;root&#39;)
        print(panda.run_serial_cmd(&#39;whoami&#39;))
        panda.end_analysis()
    ```

    is equivalent to

    ```
    @blocking
    def run_whoami():
        panda.revert_sync(&#39;root&#39;)
        print(panda.run_serial_cmd(&#39;whoami&#39;))
        panda.end_analysis()

    panda.queue_async(run_whoami)
    ```

    Args:
        func (function): Function to queue
        queue (bool): Should function automatically be queued

    Returns:
        None

    &#34;&#34;&#34;
    f = blocking(func)
    if queue:
        self.queue_async(f)
    return f</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.queue_main_loop_wait_fn"><code class="name flex">
<span>def <span class="ident">queue_main_loop_wait_fn</span></span>(<span>self, fn, args=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Queue a function to run at the next main loop
fn is a function we want to run, args are arguments to apss to it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_main_loop_wait_fn(self, fn, args=[]):
    &#39;&#39;&#39;
    Queue a function to run at the next main loop
    fn is a function we want to run, args are arguments to apss to it
    &#39;&#39;&#39;
    self.main_loop_wait_fnargs.append((fn, args))</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.read_str"><code class="name flex">
<span>def <span class="ident">read_str</span></span>(<span>self, cpu, ptr, max_length=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper to read a null-terminated string from guest memory given a pointer and CPU state
May return an exception if the call to panda.virtual_memory_read fails (e.g., if you pass a
pointer to an unmapped page)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
<dt><strong><code>ptr</code></strong> :&ensp;<code>int</code></dt>
<dd>Pointer to start of string</dd>
<dt><strong><code>max_length</code></strong> :&ensp;<code>int</code></dt>
<dd>Optional length to stop reading at</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>Data read from memory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_str(self, cpu, ptr, max_length=None):
    &#39;&#39;&#39;
    Helper to read a null-terminated string from guest memory given a pointer and CPU state
    May return an exception if the call to panda.virtual_memory_read fails (e.g., if you pass a
    pointer to an unmapped page)

    Args:
        cpu (CPUState): CPUState structure
        ptr (int): Pointer to start of string
        max_length (int): Optional length to stop reading at

    Returns:
        string: Data read from memory

    &#39;&#39;&#39;
    r = b&#34;&#34;
    idx = 0
    while (max_length is None or idx &lt; max_length):
        next_char = self.virtual_memory_read(cpu, ptr, 1) # If this raises an exn, don&#39;t mask it
        if next_char == b&#34;\x00&#34;:
            break
        r += next_char
        ptr += 1
        idx += 1
    return r.decode(&#34;utf8&#34;, &#34;ignore&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.record"><code class="name flex">
<span>def <span class="ident">record</span></span>(<span>self, recording_name, snapshot_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Begins active recording with name provided.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>recording_name</code></strong> :&ensp;<code>string</code></dt>
<dd>name of recording to save.</dd>
<dt><strong><code>snapshot_name</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Before recording starts restore to this snapshot name. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>raises exception if there was an error starting recording.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def record(self, recording_name, snapshot_name=None):
    &#34;&#34;&#34;Begins active recording with name provided.

    Args:
        recording_name (string): name of recording to save.
        snapshot_name (string, optional): Before recording starts restore to this snapshot name. Defaults to None.

    Raises:
        Exception: raises exception if there was an error starting recording.
    &#34;&#34;&#34;
    if snapshot_name == None:
        snapshot_name_ffi = self.ffi.NULL
    else:
        snapshot_name_ffi = self.ffi.new(&#34;char[]&#34;,snapshot_name.encode())
    recording_name_ffi = self.ffi.new(&#34;char[]&#34;, recording_name.encode())
    result = self.libpanda.panda_record_begin(recording_name_ffi,snapshot_name_ffi)
    res_string_enum = self.ffi.string(self.ffi.cast(&#34;RRCTRL_ret&#34;,result))
    if res_string_enum != &#34;RRCTRL_OK&#34;:
       raise Exception(f&#34;record method failed with RTCTL_ret {res_string_enum} ({result})&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.record_cmd"><code class="name flex">
<span>def <span class="ident">record_cmd</span></span>(<span>self, guest_command, copy_directory=None, iso_name=None, setup_command=None, recording_name='recording', snap_name='root', ignore_errors=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Take a recording as follows:
0) Revert to the specified snapshot name if one is set. By default 'root'. Set to <code>None</code> if you have already set up the guest and are ready to record with no revert
1) Create an ISO of files that need to be copied into the guest if copy_directory is specified. Copy them in
2) Run the setup_command in the guest, if provided
3) Type the command you wish to record but do not press enter to begin execution. This avoids the recording capturing the command being typed
4) Begin the recording (name controlled by recording_name)
5) Press enter in the guest to begin the command. Wait until it finishes.
6) End the recording</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def record_cmd(self, guest_command, copy_directory=None, iso_name=None, setup_command=None, recording_name=&#34;recording&#34;, snap_name=&#34;root&#34;, ignore_errors=False):
    &#39;&#39;&#39;
    Take a recording as follows:
        0) Revert to the specified snapshot name if one is set. By default &#39;root&#39;. Set to `None` if you have already set up the guest and are ready to record with no revert
        1) Create an ISO of files that need to be copied into the guest if copy_directory is specified. Copy them in
        2) Run the setup_command in the guest, if provided
        3) Type the command you wish to record but do not press enter to begin execution. This avoids the recording capturing the command being typed
        4) Begin the recording (name controlled by recording_name)
        5) Press enter in the guest to begin the command. Wait until it finishes.
        6) End the recording
    &#39;&#39;&#39;
    # 0) Revert to the specified snapshot
    if snap_name is not None:
        self.revert_sync(snap_name) # Can&#39;t use self.revert because that would would run async and we&#39;d keep going before the revert happens

    # 1) Make copy_directory into an iso and copy it into the guest - It will end up at the exact same path
    if copy_directory: # If there&#39;s a directory, build an ISO and put it in the cddrive
        # Make iso
        self.copy_to_guest(copy_directory, iso_name)

    # 2) Run setup_command, if provided before we start the recording (good place to CD or install, etc)
    if setup_command:
        print(f&#34;Running setup command {setup_command}&#34;)
        r = self.run_serial_cmd(setup_command)
        print(f&#34;Setup command results: {r}&#34;)

    # 3) type commmand (note we type command, start recording, finish command)
    self.type_serial_cmd(guest_command)

    # 4) start recording
    self.run_monitor_cmd(&#34;begin_record {}&#34;.format(recording_name))

    # 5) finish command
    result = self.finish_serial_cmd()

    if debug:
        progress(&#34;Result of `{}`:&#34;.format(guest_command))
        print(&#34;\t&#34;+&#34;\n\t&#34;.join(result.split(&#34;\n&#34;))+&#34;\n&#34;)

    if &#34;No such file or directory&#34; in result and not ignore_errors:
        print(&#34;Bad output running command: {}&#34;.format(result))
        raise RuntimeError(&#34;Command not found while taking recording&#34;)

    if &#34;cannot execute binary file&#34; in result and not ignore_errors:
        print(&#34;Bad output running command: {}&#34;.format(result))
        raise RuntimeError(&#34;Could not execute binary while taking recording&#34;)

    # 6) End recording
    self.run_monitor_cmd(&#34;end_record&#34;)

    print(&#34;Finished recording&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.recording_exists"><code class="name flex">
<span>def <span class="ident">recording_exists</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a recording file exists on disk.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the recording to check for (e.g., <code>foo</code> which uses <code>foo-rr-snp</code> and <code>foo-rr-nondet.log</code>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>true if file exists, false otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recording_exists(self, name):
    &#39;&#39;&#39;
    Checks if a recording file exists on disk.

    Args:
        name (str): name of the recording to check for (e.g., `foo` which uses `foo-rr-snp` and `foo-rr-nondet.log`)
    
    Returns:
        boolean: true if file exists, false otherwise
    &#39;&#39;&#39;
    if exists(name + &#34;-rr-snp&#34;):
        return True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.register_callback"><code class="name flex">
<span>def <span class="ident">register_callback</span></span>(<span>self, callback, function, name, enabled=True, procname=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_callback(self, callback, function, name, enabled=True, procname=None):
    # CB   = self.callback.main_loop_wait
    # func = main_loop_wait_cb
    # name = main_loop_wait

    if name in self.registered_callbacks:
        print(f&#34;Warning: replacing existing callback &#39;{name}&#39; since it was re-registered&#34;)
        self.delete_callback(name)

    cb = self.callback_dictionary[callback]

    # Generate a unique handle for each callback type using the number of previously registered CBs of that type added to a constant
    handle = self.ffi.cast(&#39;void *&#39;, 0x8888 + 100*len([x for x in self.registered_callbacks.values() if x[&#39;callback&#39;] == cb]))

    # XXX: We should have another layer of indirection here so we can catch
    #      exceptions raised during execution of the CB and abort analysis
    pcb = self.ffi.new(&#34;panda_cb *&#34;, {cb.name:function})

    if debug:
        progress(&#34;Registered function &#39;{}&#39; to run on callback {}&#34;.format(name, cb.name))

    self.libpanda.panda_register_callback_helper(handle, cb.number, pcb)
    self.registered_callbacks[name] = {&#34;procname&#34;: procname, &#34;enabled&#34;: True, &#34;callback&#34;: cb,
                       &#34;handle&#34;: handle, &#34;pcb&#34;: pcb, &#34;function&#34;: function} # XXX: if function is not saved here it gets GC&#39;d and everything breaks! Watch out!

    if not enabled: # Note the registered_callbacks dict starts with enabled true and then we update it to false as necessary here
        self.disable_callback(name)

    if &#34;block&#34; in cb.name and &#34;start&#34; not in cb.name and &#34;end&#34; not in cb.name:
        if not self.disabled_tb_chaining:
            print(&#34;Warning: disabling TB chaining to support {} callback&#34;.format(cb.name))
            self.disable_tb_chaining()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.register_cb_decorators"><code class="name flex">
<span>def <span class="ident">register_cb_decorators</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Setup callbacks and generate self.cb_XYZ functions for cb decorators
XXX Don't add any other methods with names starting with 'cb_'
Callbacks can be called as @panda.cb_XYZ in which case they'll take default arguments and be named the same as the decorated function
Or they can be called as @panda.cb_XYZ(name='A', procname='B', enabled=True). Defaults: name is function name, procname=None, enabled=True unless procname set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_cb_decorators(self):
    &#39;&#39;&#39;
    Setup callbacks and generate self.cb_XYZ functions for cb decorators
    XXX Don&#39;t add any other methods with names starting with &#39;cb_&#39;
    Callbacks can be called as @panda.cb_XYZ in which case they&#39;ll take default arguments and be named the same as the decorated function
    Or they can be called as @panda.cb_XYZ(name=&#39;A&#39;, procname=&#39;B&#39;, enabled=True). Defaults: name is function name, procname=None, enabled=True unless procname set
    &#39;&#39;&#39;
    for cb_name, pandatype in zip(self.callback._fields, self.callback):
        def closure(closed_cb_name, closed_pandatype): # Closure on cb_name and pandatype
            def f(*args, **kwargs):
                if len(args): # Called as @panda.cb_XYZ without ()s- no arguments to decorator but we get the function name instead
                    # Call our decorator with only a name argument ON the function itself
                    fun = args[0]
                    return self._generated_callback(closed_pandatype, **{&#34;name&#34;: fun.__name__})(fun)
                else:
                    # Otherwise, we were called as @panda.cb_XYZ() with potential args - Just return the decorator and it&#39;s applied to the function
                    return self._generated_callback(closed_pandatype, *args, **kwargs)
            return f

        setattr(self, &#39;cb_&#39;+cb_name, closure(cb_name, pandatype))</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.register_pyperipheral"><code class="name flex">
<span>def <span class="ident">register_pyperipheral</span></span>(<span>self, object)</span>
</code></dt>
<dd>
<div class="desc"><p>Registers a python peripheral, and the necessary attributes to the
panda-object, if not present yet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_pyperipheral(self, object):
    &#34;&#34;&#34;
    Registers a python peripheral, and the necessary attributes to the
    panda-object, if not present yet.
    &#34;&#34;&#34;

    # if we are the first pyperipheral, register the pp-dict
    if not hasattr(self, &#34;pyperipherals&#34;):
        self.pyperipherals = []
        self.pyperipherals_registered_cb = False
        self._num2fmt = {1: &#34;B&#34;, 2: &#34;H&#34;, 4: &#34;I&#34;, 8: &#34;Q&#34;}
        self._end2fmt = {&#34;little&#34;: &#34;&lt;&#34;, &#34;big&#34;: &#34;&gt;&#34;}

    self._validate_object(object)

    if self.pyperipherals_registered_cb is False:
        self.register_callback(
            self.callback.unassigned_io_read,
            self.callback.unassigned_io_read(self.pyperiph_read_cb),
            &#34;pyperipheral_read_callback&#34;,
        )

        self.register_callback(
            self.callback.unassigned_io_write,
            self.callback.unassigned_io_write(self.pyperiph_write_cb),
            &#34;pyperipheral_write_callback&#34;,
        )

        self.pyperipherals_registered_cb = True

    self.pyperipherals.append(object)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.require"><code class="name flex">
<span>def <span class="ident">require</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a C plugin with no arguments. Deprecated. Use load_plugin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def require(self, name):
    &#39;&#39;&#39;
    Load a C plugin with no arguments. Deprecated. Use load_plugin
    &#39;&#39;&#39;
    self.load_plugin(name, args={})</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>In the next main loop, reset to boot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;In the next main loop, reset to boot&#34;&#34;&#34;
    if debug:
        progress (&#34;Resetting machine to start state&#34;)

    # Stop guest, queue up revert, then continue
    self.vm_stop()
    self.queue_main_loop_wait_fn(self.libpanda.panda_reset)
    self.queue_main_loop_wait_fn(self.libpanda.panda_cont)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.revert_async"><code class="name flex">
<span>def <span class="ident">revert_async</span></span>(<span>self, snapshot_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Request a snapshot revert, eventually. This is fairly dangerous
because you don't know when it finishes. You should be using revert_sync
from a blocking function instead</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def revert_async(self, snapshot_name): # In the next main loop, revert
    &#39;&#39;&#39;
    Request a snapshot revert, eventually. This is fairly dangerous
    because you don&#39;t know when it finishes. You should be using revert_sync
    from a blocking function instead
    &#39;&#39;&#39;
    print(&#34;WARNING: panda.revert_async may be deprecated in the near future&#34;)
    if debug:
        progress (&#34;Loading snapshot &#34; + snapshot_name)

    # Stop guest, queue up revert, then continue
    timer_start = time()
    self.vm_stop()
    charptr = self.ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
    self.queue_main_loop_wait_fn(self.libpanda.panda_revert, [charptr])
    self.queue_main_loop_wait_fn(self.libpanda.panda_cont)
    if debug:
        self.queue_main_loop_wait_fn(self._finish_timer, [timer_start, &#34;Loaded snapshot&#34;])</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.revert_sync"><code class="name flex">
<span>def <span class="ident">revert_sync</span></span>(<span>self, snapshot_name)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>snapshot_name</code></strong></dt>
<dd>name of snapshot in the current qcow to load</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>String</code></dt>
<dd>error message. Empty on success.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def revert_sync(self, snapshot_name):
    &#39;&#39;&#39;
    Args:
        snapshot_name: name of snapshot in the current qcow to load

    Returns:
        String: error message. Empty on success.
    &#39;&#39;&#39;
    result = self.run_monitor_cmd(&#34;loadvm {}&#34;.format(snapshot_name))
    # On success we should get no result

    if result.startswith(&#34;Length mismatch&#34;):
        raise RuntimeError(&#34;QEMU machine&#39;s RAM size doesn&#39;t match snapshot RAM size!&#34;)

    if &#34;does not have the requested snapshot&#34; in result:
        raise ValueError(f&#34;Snapshot &#39;{snapshot_name}&#39; not present in {self.qcow}&#34;)

    result = result.strip()
    if len(result):
        warn(f&#34;snapshot load returned error {result}&#34;)

    return result</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.rr_get_guest_instr_count"><code class="name flex">
<span>def <span class="ident">rr_get_guest_instr_count</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns record/replay guest instruction count.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Current instruction count</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rr_get_guest_instr_count(self):
    &#39;&#39;&#39;
    Returns record/replay guest instruction count.

    Returns:
        int: Current instruction count
    &#39;&#39;&#39;
    return self.libpanda.rr_get_guest_instr_count_external()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function starts our running PANDA instance from Python. At termination this function returns and the script continues to run after it.</p>
<p>This function starts execution of the guest. It blocks until guest finishes.
It also initializes panda object, clears main_loop_wait fns, and sets up internal callbacks.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>When emulation has finished due to guest termination, replay conclusion or a call to <code><a title="pandare.panda.Panda.end_analysis" href="#pandare.panda.Panda.end_analysis">Panda.end_analysis()</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#39;&#39;&#39;
    This function starts our running PANDA instance from Python. At termination this function returns and the script continues to run after it.

    This function starts execution of the guest. It blocks until guest finishes.
    It also initializes panda object, clears main_loop_wait fns, and sets up internal callbacks.

    Args:
        None

    Returns:
        None: When emulation has finished due to guest termination, replay conclusion or a call to `Panda.end_analysis`
    &#39;&#39;&#39;

    if len(self.main_loop_wait_fnargs):
        if debug:
            print(&#34;Clearing prior main_loop_wait fns:&#34;, self.main_loop_wait_fnargs)
        self.main_loop_wait_fnargs = [] # [(fn, args), ...]

    self.ending = False

    if debug:
        progress (&#34;Running&#34;)

    self.initializing.set()
    if not self._initialized_panda:
        self._initialize_panda()
    self.initializing.clear()

    if not self.started.is_set():
        self.started.set()

    self.athread.ending = False

    # Ensure our internal CBs are always enabled
    self.enable_internal_callbacks()
    self._setup_internal_signal_handler()
    self.running.set()
    self.libpanda.panda_run() # Give control to panda
    self.running.clear() # Back from panda&#39;s execution (due to shutdown or monitor quit)
    self.delete_callbacks()
    self.libpanda.panda_unload_plugins() # Unload c plugins - should be safe now since exec has stopped
    self.plugins = plugin_list(self)
    # Write PANDALOG, if any
    #self.libpanda.panda_cleanup_record()
    if self._in_replay:
        self.reset()
    if hasattr(self, &#34;end_run_raise_signal&#34;):
        saved_exception = self.end_run_raise_signal
        del self.end_run_raise_signal
        raise saved_exception
    if hasattr(self, &#34;callback_exit_exception&#34;):
        saved_exception = self.callback_exit_exception
        del self.callback_exit_exception
        raise saved_exception
    if hasattr(self, &#34;blocking_queue_error&#34;):
        saved_exception = self.blocking_queue_error
        del self.blocking_queue_error
        raise saved_exception
    if hasattr(self, &#34;hook_exit_exception&#34;):
        saved_exception = self.hook_exit_exception
        del self.hook_exit_exception
        raise saved_exception</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.run_monitor_cmd"><code class="name flex">
<span>def <span class="ident">run_monitor_cmd</span></span>(<span>self, cmd)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def run_monitor_cmd(self, cmd):
    self.monitor_console.sendline(cmd.encode(&#34;utf8&#34;))
    result = self.monitor_console.expect()
    return result</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.run_replay"><code class="name flex">
<span>def <span class="ident">run_replay</span></span>(<span>self, replaypfx)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a replay and run it. Starts PANDA execution and returns after end of VM execution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>replaypfx</code></strong> :&ensp;<code>str</code></dt>
<dd>Replay name/path (e.g., "foo" or "./dir/foo")</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_replay(self, replaypfx):
    &#39;&#39;&#39;
    Load a replay and run it. Starts PANDA execution and returns after end of VM execution.

    Args:
        replaypfx (str): Replay name/path (e.g., &#34;foo&#34; or &#34;./dir/foo&#34;)

    Returns:
        None
    &#39;&#39;&#39;
    if not isfile(replaypfx+&#34;-rr-snp&#34;) or not isfile(replaypfx+&#34;-rr-nondet.log&#34;):
        raise ValueError(&#34;Replay files not present to run replay of {}&#34;.format(replaypfx))

    self.ending = False

    if debug:
        progress (&#34;Replaying %s&#34; % replaypfx)

    charptr = self.ffi.new(&#34;char[]&#34;,bytes(replaypfx,&#34;utf-8&#34;))
    self.libpanda.panda_replay_begin(charptr)
    self._in_replay = True
    self.run()
    self._in_replay = False</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.run_serial_cmd"><code class="name flex">
<span>def <span class="ident">run_serial_cmd</span></span>(<span>self, cmd, no_timeout=False, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a command inside the guest through a terminal exposed over a serial port. Can only be used if your guest is configured in this way</p>
<p>Guest output will be analyzed until we see the expect_prompt regex printed (i.e., the PS1 prompt)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cmd</code></strong></dt>
<dd>command to run.</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>maximum time to wait for the command to finish</dd>
<dt><strong><code>no_timeout</code></strong></dt>
<dd>if set, don't ever timeout</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>String</code></dt>
<dd>all the output (stdout + stderr) printed after typing your command and pressing enter until the next prompt was printed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def run_serial_cmd(self, cmd, no_timeout=False, timeout=None):
    &#39;&#39;&#39;
    Run a command inside the guest through a terminal exposed over a serial port. Can only be used if your guest is configured in this way

    Guest output will be analyzed until we see the expect_prompt regex printed (i.e., the PS1 prompt)

    Args:
        cmd: command to run.
        timeout: maximum time to wait for the command to finish
        no_timeout: if set, don&#39;t ever timeout

    Returns:
        String: all the output (stdout + stderr) printed after typing your command and pressing enter until the next prompt was printed.
    &#39;&#39;&#39;

    if timeout is None:
        timeout = 30

    if self.serial_console is None:
        raise RuntimeError(&#34;Cannot run serial commands without providing PANDA an expect_prompt&#34;)
    self.running.wait() # Can only run serial when guest is running
    self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
    if no_timeout:
        result = self.serial_console.expect(timeout=9999) # &#34;Don&#39;t ever timeout&#34; above is a bit of an exaggeration
    else:
        result = self.serial_console.expect(timeout=timeout)
    return result</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.run_serial_cmd_async"><code class="name flex">
<span>def <span class="ident">run_serial_cmd_async</span></span>(<span>self, cmd, delay=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Type a command and press enter in the guest. Return immediately. No results available
Only use this if you know what you're doing!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def run_serial_cmd_async(self, cmd, delay=1):
    &#39;&#39;&#39;
    Type a command and press enter in the guest. Return immediately. No results available
    Only use this if you know what you&#39;re doing!
    &#39;&#39;&#39;
    self.running.wait() # Can only run serial when guest is running
    self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
    if delay:
        sleep(delay) # Ensure it has a chance to run</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.run_volatility"><code class="name flex">
<span>def <span class="ident">run_volatility</span></span>(<span>self, plugin, debug=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_volatility(self, plugin, debug=False):
    try:
        from .volatility_cli_classes import CommandLineRunFullCommand, StringTextRenderer
    except ImportError:
        print(&#34;Warning: Failed to import volatility&#34;)
        return None
    self.make_panda_file_handler(debug=debug)
    cmd = CommandLineRunFullCommand().run(&#34;-q -f panda.panda &#34; + plugin)
    output = StringTextRenderer().render(cmd.run())
    return output</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.set_breakpoint"><code class="name flex">
<span>def <span class="ident">set_breakpoint</span></span>(<span>self, cpu, pc)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a GDB breakpoint such that when the guest hits PC, execution is paused and an attached
GDB instance can introspect on guest memory. Requires starting panda with -s, at least for now</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_breakpoint(self, cpu, pc):
    &#39;&#39;&#39;
    Set a GDB breakpoint such that when the guest hits PC, execution is paused and an attached
    GDB instance can introspect on guest memory. Requires starting panda with -s, at least for now
    &#39;&#39;&#39;
    BP_GDB = 0x10
    self.libpanda.cpu_breakpoint_insert(cpu, pc, BP_GDB, self.ffi.NULL)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.set_os_name"><code class="name flex">
<span>def <span class="ident">set_os_name</span></span>(<span>self, os_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set OS target. Equivalent to "-os" flag on the command line. Matches the form of:</p>
<pre><code>"windows[-_]32[-_]xpsp[23]",
"windows[-_]32[-_]7",
"windows[-_]32[-_]2000",
"linux[-_]32[-_].+",
"linux[-_]64[-_].+",

Args:
    os_name (str): Name that matches the format for the os flag.

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_os_name(self, os_name):
    &#34;&#34;&#34;
    Set OS target. Equivalent to &#34;-os&#34; flag on the command line. Matches the form of:

        &#34;windows[-_]32[-_]xpsp[23]&#34;,
        &#34;windows[-_]32[-_]7&#34;,
        &#34;windows[-_]32[-_]2000&#34;,
        &#34;linux[-_]32[-_].+&#34;,
        &#34;linux[-_]64[-_].+&#34;,

        Args:
            os_name (str): Name that matches the format for the os flag.

        Returns:
            None
    &#34;&#34;&#34;
    os_name_new = self.ffi.new(&#34;char[]&#34;, bytes(os_name, &#34;utf-8&#34;))
    self.libpanda.panda_set_os_name(os_name_new)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.set_pandalog"><code class="name flex">
<span>def <span class="ident">set_pandalog</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable recording to a pandalog (plog) named <code>name</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>filename to output data to</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pandalog(self, name):
    &#39;&#39;&#39;
    Enable recording to a pandalog (plog) named `name`

    Args:
        name (str): filename to output data to

    Returns:
        None
    &#39;&#39;&#39;
    charptr = self.ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
    self.libpanda.panda_start_pandalog(charptr)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.snap"><code class="name flex">
<span>def <span class="ident">snap</span></span>(<span>self, snapshot_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Create snapshot with specified name</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>snapshot_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the snapshot</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def snap(self, snapshot_name):
    &#39;&#39;&#39;
    Create snapshot with specified name

    Args:
        snapshot_name (str): name of the snapshot

    Returns:
        None
    &#39;&#39;&#39;
    if debug:
        progress (&#34;Creating snapshot &#34; + snapshot_name)

    # Stop guest execution, queue up a snapshot, then continue
    timer_start = time()
    self.vm_stop()
    charptr = self.ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
    self.queue_main_loop_wait_fn(self.libpanda.panda_snap, [charptr])
    self.queue_main_loop_wait_fn(self.libpanda.panda_cont)
    if debug:
        self.queue_main_loop_wait_fn(self._finish_timer, [timer_start, &#34;Saved snapshot&#34;])</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.stop_run"><code class="name flex">
<span>def <span class="ident">stop_run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>From a blocking thread, request vl.c loop to break. Returns control flow in main thread.
In other words, once this is called, panda.run() will finish and your main thread will continue.
If you also want to unload plugins, use end_analysis instead</p>
<p>XXX: This doesn't work in replay mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def stop_run(self):
    &#39;&#39;&#39;
    From a blocking thread, request vl.c loop to break. Returns control flow in main thread.
    In other words, once this is called, panda.run() will finish and your main thread will continue.
    If you also want to unload plugins, use end_analysis instead

    XXX: This doesn&#39;t work in replay mode
    &#39;&#39;&#39;
    self.libpanda.panda_break_vl_loop_req = True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.sysbus_create_varargs"><code class="name flex">
<span>def <span class="ident">sysbus_create_varargs</span></span>(<span>self, name, addr)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns DeviceState struct from user specified information
Calls sysbus_create_varargs QEMU function.</p>
<h2 id="args">Args</h2>
<dl>
<dt>name (str):</dt>
<dt><strong><code>addr</code></strong> :&ensp;<code>int</code></dt>
<dd>hwaddr</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DeviceState struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sysbus_create_varargs(self, name, addr):
    &#39;&#39;&#39;
    Returns DeviceState struct from user specified information
    Calls sysbus_create_varargs QEMU function.

    Args:
        name (str):
        addr (int): hwaddr

    Returns:
        DeviceState struct
    &#39;&#39;&#39;
    return self.libpanda.sysbus_create_varargs(name,addr,ffi.NULL)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_check_laddr"><code class="name flex">
<span>def <span class="ident">taint_check_laddr</span></span>(<span>self, addr, off)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_check_laddr(self, addr, off):
    if not self.taint_enabled: return False
    if self.plugins[&#39;taint2&#39;].taint2_query_laddr(addr, off) &gt; 0:
        return True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_check_ram"><code class="name flex">
<span>def <span class="ident">taint_check_ram</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_check_ram(self, addr):
    if not self.taint_enabled: return False
    if self.plugins[&#39;taint2&#39;].taint2_query_ram(addr) &gt; 0:
        return True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_check_reg"><code class="name flex">
<span>def <span class="ident">taint_check_reg</span></span>(<span>self, reg_num)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def taint_check_reg(self, reg_num):
        if not self.taint_enabled: return False
#        if debug:
#            progress(&#34;taint_check_reg %d&#34; % (reg_num))
        for offset in range(self.register_size):
            if self.plugins[&#39;taint2&#39;].taint2_query_reg(reg_num, offset) &gt; 0:
                return True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_enable"><code class="name flex">
<span>def <span class="ident">taint_enable</span></span>(<span>self, cont=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Inform python that taint is enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def taint_enable(self, cont=True):
        &#34;&#34;&#34;
        Inform python that taint is enabled.
        &#34;&#34;&#34;
        if not self.taint_enabled:
            progress(&#34;taint not enabled -- enabling&#34;)
            self.vm_stop()
            self.load_plugin(&#34;taint2&#34;)
#            self.queue_main_loop_wait_fn(self.load_plugin, [&#34;taint2&#34;])
            self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_enable_taint, [])
            if cont:
                self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])
            self.taint_enabled = True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_get_laddr"><code class="name flex">
<span>def <span class="ident">taint_get_laddr</span></span>(<span>self, addr, offset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_get_laddr(self, addr, offset):
    if not self.taint_enabled: return None
    if self.plugins[&#39;taint2&#39;].taint2_query_laddr(addr, offset) &gt; 0:
        query_res = self.ffi.new(&#34;QueryResult *&#34;)
        self.plugins[&#39;taint2&#39;].taint2_query_laddr_full(addr, offset, query_res)
        tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;], self.ffi)
        return tq
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_get_ram"><code class="name flex">
<span>def <span class="ident">taint_get_ram</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_get_ram(self, addr):
    if not self.taint_enabled: return None
    if self.plugins[&#39;taint2&#39;].taint2_query_ram(addr) &gt; 0:
        query_res = self.ffi.new(&#34;QueryResult *&#34;)
        self.plugins[&#39;taint2&#39;].taint2_query_ram_full(addr, query_res)
        tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;], self.ffi)
        return tq
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_get_reg"><code class="name flex">
<span>def <span class="ident">taint_get_reg</span></span>(<span>self, reg_num)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns array of results, one for each byte in this register
None if no taint.
QueryResult struct otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_get_reg(self, reg_num):
    &#39;&#39;&#39;
    Returns array of results, one for each byte in this register
    None if no taint.  QueryResult struct otherwise
    &#39;&#39;&#39;
    if not self.taint_enabled: return None
    if debug:
        progress(&#34;taint_get_reg %d&#34; % (reg_num))
    res = []
    for offset in range(self.register_size):
        if self.plugins[&#39;taint2&#39;].taint2_query_reg(reg_num, offset) &gt; 0:
            query_res = self.ffi.new(&#34;QueryResult *&#34;)
            self.plugins[&#39;taint2&#39;].taint2_query_reg_full(reg_num, offset, query_res)
            tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;], self.ffi)
            res.append(tq)
        else:
            res.append(None)
    return res</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_label_ram"><code class="name flex">
<span>def <span class="ident">taint_label_ram</span></span>(<span>self, addr, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_label_ram(self, addr, label):
    self.taint_enable(cont=False)
    #if debug:
        #progress(&#34;taint_ram addr=0x%x label=%d&#34; % (addr, label))

    # XXX must ensure labeling is done in a before_block_invalidate that rets 1
    #     or some other safe way where the main_loop_wait code will always be run
    #self.stop()
    self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_label_ram, [addr, label])
    self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_label_reg"><code class="name flex">
<span>def <span class="ident">taint_label_reg</span></span>(<span>self, reg_num, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_label_reg(self, reg_num, label):
    self.taint_enable(cont=False)
    #if debug:
    #    progress(&#34;taint_reg reg=%d label=%d&#34; % (reg_num, label))

    # XXX must ensure labeling is done in a before_block_invalidate that rets 1
    #     or some other safe way where the main_loop_wait code will always be run
    #self.stop()
    for i in range(self.register_size):
        self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_label_reg, [reg_num, i, label])
    self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_sym_enable"><code class="name flex">
<span>def <span class="ident">taint_sym_enable</span></span>(<span>self, cont=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Inform python that taint is enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def taint_sym_enable(self, cont=True):
        &#34;&#34;&#34;
        Inform python that taint is enabled.
        &#34;&#34;&#34;
        if not self.taint_enabled:
            progress(&#34;taint symbolic not enabled -- enabling&#34;)
            self.vm_stop()
            self.load_plugin(&#34;taint2&#34;)
#            self.queue_main_loop_wait_fn(self.load_plugin, [&#34;taint2&#34;])
        if not self.taint_sym_enabled:
            self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_enable_sym, [])
            if cont:
                self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])
            self.taint_enabled = True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_sym_label_ram"><code class="name flex">
<span>def <span class="ident">taint_sym_label_ram</span></span>(<span>self, addr, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_sym_label_ram(self, addr, label):
    self.taint_sym_enable(cont=False)
    #if debug:
        #progress(&#34;taint_ram addr=0x%x label=%d&#34; % (addr, label))

    # XXX must ensure labeling is done in a before_block_invalidate that rets 1
    #     or some other safe way where the main_loop_wait code will always be run
    #self.stop()
    self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_sym_label_ram, [addr, label])
    self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_sym_label_reg"><code class="name flex">
<span>def <span class="ident">taint_sym_label_reg</span></span>(<span>self, reg_num, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_sym_label_reg(self, reg_num, label):
    self.taint_sym_enable(cont=False)
    #if debug:
    #    progress(&#34;taint_reg reg=%d label=%d&#34; % (reg_num, label))

    # XXX must ensure labeling is done in a before_block_invalidate that rets 1
    #     or some other safe way where the main_loop_wait code will always be run
    #self.stop()
    for i in range(self.register_size):
        self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_sym_label_reg, [reg_num, i, label])
    self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.to_unsigned_guest"><code class="name flex">
<span>def <span class="ident">to_unsigned_guest</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a singed python int to an unsigned int32/unsigned int64
depending on guest bit-size</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>Python integer</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Python integer representing x as an unsigned value in the guest's pointer-size.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_unsigned_guest(self, x):
    &#39;&#39;&#39;
    Convert a singed python int to an unsigned int32/unsigned int64
    depending on guest bit-size

    Args:
        x (int): Python integer

    Returns:
        int: Python integer representing x as an unsigned value in the guest&#39;s pointer-size.
    &#39;&#39;&#39;
    import ctypes
    if self.bits == 32:
        return ctypes.c_uint32(x).value
    elif self.bits == 64:
        return ctypes.c_uint64(x).value
    else:
        raise ValueError(&#34;Unsupported number of bits&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.type_serial_cmd"><code class="name flex">
<span>def <span class="ident">type_serial_cmd</span></span>(<span>self, cmd)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def type_serial_cmd(self, cmd):
    #Can send message into socket without guest running (no self.running.wait())
    self.serial_console.send(cmd.encode(&#34;utf8&#34;)) # send, not sendline</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.unload_plugin"><code class="name flex">
<span>def <span class="ident">unload_plugin</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Unload plugin with given name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of plug</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unload_plugin(self, name):
    &#39;&#39;&#39;
    Unload plugin with given name.

    Args:
        name (str): Name of plug

    Returns:
        None
    &#39;&#39;&#39;
    if debug:
        progress (&#34;Unloading plugin %s&#34; % name),
    name_ffi = self.ffi.new(&#34;char[]&#34;, bytes(name,&#34;utf-8&#34;))
    self.libpanda.panda_unload_plugin_by_name(name_ffi)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.unload_plugins"><code class="name flex">
<span>def <span class="ident">unload_plugins</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable all python plugins and request to unload all c plugins
at the next main_loop_wait.</p>
<p>XXX: If called during shutdown/exit, c plugins won't be unloaded
because the next main_loop_wait will never happen. Instead, call
panda.panda_finish directly (which is done at the end of panda.run())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unload_plugins(self):
    &#39;&#39;&#39;
    Disable all python plugins and request to unload all c plugins
    at the next main_loop_wait.

    XXX: If called during shutdown/exit, c plugins won&#39;t be unloaded
    because the next main_loop_wait will never happen. Instead, call
    panda.panda_finish directly (which is done at the end of panda.run())
    &#39;&#39;&#39;
    if debug:
        progress (&#34;Disabling all python plugins, unloading all C plugins&#34;)

    # First unload python plugins, should be safe to do anytime
    #for name in self.registered_callbacks.keys():
    while len(list(self.registered_callbacks)) &gt; 0:
        try:
            self.delete_callback(list(self.registered_callbacks.keys())[0])
        except IndexError:
            continue
        #self.disable_callback(name)

    # Then unload C plugins. May be unsafe to do except from the top of the main loop (taint segfaults otherwise)
    self.queue_main_loop_wait_fn(self.libpanda.panda_unload_plugins)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.unregister_pyperipheral"><code class="name flex">
<span>def <span class="ident">unregister_pyperipheral</span></span>(<span>self, pyperiph)</span>
</code></dt>
<dd>
<div class="desc"><p>deregisters a python peripheral.
The pyperiph parameter can be either an object, or an address
Returns true if the pyperipheral was successfully removed, else false.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister_pyperipheral(self, pyperiph):
    &#34;&#34;&#34;
    deregisters a python peripheral.
    The pyperiph parameter can be either an object, or an address
    Returns true if the pyperipheral was successfully removed, else false.
    &#34;&#34;&#34;

    if isinstance(pyperiph, int) is True:
        pp = self._addr_to_pyperipheral(pyperiph)
        if pp is None:
            return False
    else:
        if pyperiph not in self.pyperipherals:
            return False
        pp = pyperiph

    self.pyperipherals.remove(pp)

    # If we dont have any pyperipherals left, unregister callbacks
    if len(self.pyperipherals) == 0:
        self.disable_callback(&#34;pyperipheral_read_callback&#34;, forever=True)
        self.disable_callback(&#34;pyperipheral_write_callback&#34;, forever=True)
        self.pyperipherals_registered_cb = False
    return True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.virt_to_phys"><code class="name flex">
<span>def <span class="ident">virt_to_phys</span></span>(<span>self, cpu, addr)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert virtual address to physical address.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState struct</dd>
<dt><strong><code>addr</code></strong> :&ensp;<code>int</code></dt>
<dd>virtual address to convert</dd>
</dl>
<h2 id="return">Return</h2>
<p>int: physical address</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def virt_to_phys(self, cpu, addr):
    &#39;&#39;&#39;
    Convert virtual address to physical address.

    Args:
        cpu (CPUState): CPUState struct
        addr (int): virtual address to convert

    Return:
        int: physical address
    &#39;&#39;&#39;
    return self.libpanda.panda_virt_to_phys_external(cpu, addr)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.virtual_memory_read"><code class="name flex">
<span>def <span class="ident">virtual_memory_read</span></span>(<span>self, cpu, addr, length, fmt='bytearray')</span>
</code></dt>
<dd>
<div class="desc"><p>Read guest virtual memory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
<dt><strong><code>addr</code></strong> :&ensp;<code>int</code></dt>
<dd>Address</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>length of data you would like returned</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>format for returned array. See <code>physical_memory_read</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[bytearray, int, str, list[int]]</code></dt>
<dd>memory data</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ValueError if memory access fails or fmt is unsupported</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def virtual_memory_read(self, cpu, addr, length, fmt=&#39;bytearray&#39;):
    &#39;&#39;&#39;
    Read guest virtual memory.

    Args:
        cpu (CPUState): CPUState structure
        addr (int): Address
        length (int): length of data you would like returned
        fmt: format for returned array. See `physical_memory_read`.

    Returns:
        Union[bytearray, int, str, list[int]]: memory data

    Raises:
        ValueError if memory access fails or fmt is unsupported
    &#39;&#39;&#39;

    return self._memory_read(cpu, addr, length, physical=False, fmt=fmt)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.virtual_memory_write"><code class="name flex">
<span>def <span class="ident">virtual_memory_write</span></span>(<span>self, cpu, addr, buf)</span>
</code></dt>
<dd>
<div class="desc"><p>Write guest virtual memory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cpu</code></strong> :&ensp;<code>CPUState</code></dt>
<dd>CPUState structure</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>int</code></dt>
<dd>Address</dd>
<dt><strong><code>buf</code></strong> :&ensp;<code>bytestr</code></dt>
<dd>byte string to write into memory</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>error</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def virtual_memory_write(self, cpu, addr, buf):
    &#39;&#39;&#39;
    Write guest virtual memory.

    Args:
        cpu (CPUState): CPUState structure
        address (int): Address
        buf (bytestr): byte string to write into memory

    Returns:
        bool: error

    &#39;&#39;&#39;
    return self._memory_write(cpu, addr, buf, physical=False)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.vm_stop"><code class="name flex">
<span>def <span class="ident">vm_stop</span></span>(<span>self, code=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop execution, default code means RUN_STATE_PAUSED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vm_stop(self, code=4):
    &#39;&#39;&#39; Stop execution, default code means RUN_STATE_PAUSED &#39;&#39;&#39;
    self.libpanda.panda_stop(code)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.was_aborted"><code class="name flex">
<span>def <span class="ident">was_aborted</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if panda was aborted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def was_aborted(self):
    &#39;&#39;&#39;
    Returns true if panda was aborted.
    &#39;&#39;&#39;
    return self.libpanda.panda_was_aborted()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="panda.re Docs" href="/">
<img src="//panda.re/img/logo.png" alt="logo"> PANDA.re Docs
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pandare" href="index.html">pandare</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pandare.panda.Panda" href="#pandare.panda.Panda">Panda</a></code></h4>
<ul class="">
<li><code><a title="pandare.panda.Panda.arch" href="#pandare.panda.Panda.arch">arch</a></code></li>
<li><code><a title="pandare.panda.Panda.arm_load_kernel" href="#pandare.panda.Panda.arm_load_kernel">arm_load_kernel</a></code></li>
<li><code><a title="pandare.panda.Panda.callstack_callers" href="#pandare.panda.Panda.callstack_callers">callstack_callers</a></code></li>
<li><code><a title="pandare.panda.Panda.cleanup" href="#pandare.panda.Panda.cleanup">cleanup</a></code></li>
<li><code><a title="pandare.panda.Panda.clear_breakpoint" href="#pandare.panda.Panda.clear_breakpoint">clear_breakpoint</a></code></li>
<li><code><a title="pandare.panda.Panda.cont" href="#pandare.panda.Panda.cont">cont</a></code></li>
<li><code><a title="pandare.panda.Panda.copy_to_guest" href="#pandare.panda.Panda.copy_to_guest">copy_to_guest</a></code></li>
<li><code><a title="pandare.panda.Panda.cpu_class_by_name" href="#pandare.panda.Panda.cpu_class_by_name">cpu_class_by_name</a></code></li>
<li><code><a title="pandare.panda.Panda.create_external_gic" href="#pandare.panda.Panda.create_external_gic">create_external_gic</a></code></li>
<li><code><a title="pandare.panda.Panda.create_internal_gic" href="#pandare.panda.Panda.create_internal_gic">create_internal_gic</a></code></li>
<li><code><a title="pandare.panda.Panda.create_one_flash" href="#pandare.panda.Panda.create_one_flash">create_one_flash</a></code></li>
<li><code><a title="pandare.panda.Panda.create_virtio_devices" href="#pandare.panda.Panda.create_virtio_devices">create_virtio_devices</a></code></li>
<li><code><a title="pandare.panda.Panda.current_asid" href="#pandare.panda.Panda.current_asid">current_asid</a></code></li>
<li><code><a title="pandare.panda.Panda.current_pc" href="#pandare.panda.Panda.current_pc">current_pc</a></code></li>
<li><code><a title="pandare.panda.Panda.current_sp" href="#pandare.panda.Panda.current_sp">current_sp</a></code></li>
<li><code><a title="pandare.panda.Panda.delete_callback" href="#pandare.panda.Panda.delete_callback">delete_callback</a></code></li>
<li><code><a title="pandare.panda.Panda.delete_callbacks" href="#pandare.panda.Panda.delete_callbacks">delete_callbacks</a></code></li>
<li><code><a title="pandare.panda.Panda.delvm" href="#pandare.panda.Panda.delvm">delvm</a></code></li>
<li><code><a title="pandare.panda.Panda.delvm_sync" href="#pandare.panda.Panda.delvm_sync">delvm_sync</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_callback" href="#pandare.panda.Panda.disable_callback">disable_callback</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_hook2" href="#pandare.panda.Panda.disable_hook2">disable_hook2</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_llvm" href="#pandare.panda.Panda.disable_llvm">disable_llvm</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_llvm_helpers" href="#pandare.panda.Panda.disable_llvm_helpers">disable_llvm_helpers</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_memcb" href="#pandare.panda.Panda.disable_memcb">disable_memcb</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_plugin" href="#pandare.panda.Panda.disable_plugin">disable_plugin</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_ppp" href="#pandare.panda.Panda.disable_ppp">disable_ppp</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_precise_pc" href="#pandare.panda.Panda.disable_precise_pc">disable_precise_pc</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_tb_chaining" href="#pandare.panda.Panda.disable_tb_chaining">disable_tb_chaining</a></code></li>
<li><code><a title="pandare.panda.Panda.disas2" href="#pandare.panda.Panda.disas2">disas2</a></code></li>
<li><code><a title="pandare.panda.Panda.do_panda_finish" href="#pandare.panda.Panda.do_panda_finish">do_panda_finish</a></code></li>
<li><code><a title="pandare.panda.Panda.drive_get" href="#pandare.panda.Panda.drive_get">drive_get</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_all_callbacks" href="#pandare.panda.Panda.enable_all_callbacks">enable_all_callbacks</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_callback" href="#pandare.panda.Panda.enable_callback">enable_callback</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_hook2" href="#pandare.panda.Panda.enable_hook2">enable_hook2</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_internal_callbacks" href="#pandare.panda.Panda.enable_internal_callbacks">enable_internal_callbacks</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_llvm" href="#pandare.panda.Panda.enable_llvm">enable_llvm</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_llvm_helpers" href="#pandare.panda.Panda.enable_llvm_helpers">enable_llvm_helpers</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_memcb" href="#pandare.panda.Panda.enable_memcb">enable_memcb</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_plugin" href="#pandare.panda.Panda.enable_plugin">enable_plugin</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_precise_pc" href="#pandare.panda.Panda.enable_precise_pc">enable_precise_pc</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_tb_chaining" href="#pandare.panda.Panda.enable_tb_chaining">enable_tb_chaining</a></code></li>
<li><code><a title="pandare.panda.Panda.end_analysis" href="#pandare.panda.Panda.end_analysis">end_analysis</a></code></li>
<li><code><a title="pandare.panda.Panda.end_record" href="#pandare.panda.Panda.end_record">end_record</a></code></li>
<li><code><a title="pandare.panda.Panda.end_replay" href="#pandare.panda.Panda.end_replay">end_replay</a></code></li>
<li><code><a title="pandare.panda.Panda.error_report" href="#pandare.panda.Panda.error_report">error_report</a></code></li>
<li><code><a title="pandare.panda.Panda.exit_cpu_loop" href="#pandare.panda.Panda.exit_cpu_loop">exit_cpu_loop</a></code></li>
<li><code><a title="pandare.panda.Panda.finish_serial_cmd" href="#pandare.panda.Panda.finish_serial_cmd">finish_serial_cmd</a></code></li>
<li><code><a title="pandare.panda.Panda.flush_tb" href="#pandare.panda.Panda.flush_tb">flush_tb</a></code></li>
<li><code><a title="pandare.panda.Panda.from_unsigned_guest" href="#pandare.panda.Panda.from_unsigned_guest">from_unsigned_guest</a></code></li>
<li><code><a title="pandare.panda.Panda.g_malloc0" href="#pandare.panda.Panda.g_malloc0">g_malloc0</a></code></li>
<li><code><a title="pandare.panda.Panda.garray_len" href="#pandare.panda.Panda.garray_len">garray_len</a></code></li>
<li><code><a title="pandare.panda.Panda.get_best_matching_symbol" href="#pandare.panda.Panda.get_best_matching_symbol">get_best_matching_symbol</a></code></li>
<li><code><a title="pandare.panda.Panda.get_cpu" href="#pandare.panda.Panda.get_cpu">get_cpu</a></code></li>
<li><code><a title="pandare.panda.Panda.get_mappings" href="#pandare.panda.Panda.get_mappings">get_mappings</a></code></li>
<li><code><a title="pandare.panda.Panda.get_process_name" href="#pandare.panda.Panda.get_process_name">get_process_name</a></code></li>
<li><code><a title="pandare.panda.Panda.get_processes" href="#pandare.panda.Panda.get_processes">get_processes</a></code></li>
<li><code><a title="pandare.panda.Panda.get_processes_dict" href="#pandare.panda.Panda.get_processes_dict">get_processes_dict</a></code></li>
<li><code><a title="pandare.panda.Panda.get_system_memory" href="#pandare.panda.Panda.get_system_memory">get_system_memory</a></code></li>
<li><code><a title="pandare.panda.Panda.get_volatility_symbols" href="#pandare.panda.Panda.get_volatility_symbols">get_volatility_symbols</a></code></li>
<li><code><a title="pandare.panda.Panda.hook" href="#pandare.panda.Panda.hook">hook</a></code></li>
<li><code><a title="pandare.panda.Panda.hook2" href="#pandare.panda.Panda.hook2">hook2</a></code></li>
<li><code><a title="pandare.panda.Panda.hook2_single_insn" href="#pandare.panda.Panda.hook2_single_insn">hook2_single_insn</a></code></li>
<li><code><a title="pandare.panda.Panda.hook_mem" href="#pandare.panda.Panda.hook_mem">hook_mem</a></code></li>
<li><code><a title="pandare.panda.Panda.hook_phys_mem_read" href="#pandare.panda.Panda.hook_phys_mem_read">hook_phys_mem_read</a></code></li>
<li><code><a title="pandare.panda.Panda.hook_phys_mem_write" href="#pandare.panda.Panda.hook_phys_mem_write">hook_phys_mem_write</a></code></li>
<li><code><a title="pandare.panda.Panda.hook_symbol" href="#pandare.panda.Panda.hook_symbol">hook_symbol</a></code></li>
<li><code><a title="pandare.panda.Panda.hook_virt_mem_read" href="#pandare.panda.Panda.hook_virt_mem_read">hook_virt_mem_read</a></code></li>
<li><code><a title="pandare.panda.Panda.hook_virt_mem_write" href="#pandare.panda.Panda.hook_virt_mem_write">hook_virt_mem_write</a></code></li>
<li><code><a title="pandare.panda.Panda.in_kernel" href="#pandare.panda.Panda.in_kernel">in_kernel</a></code></li>
<li><code><a title="pandare.panda.Panda.in_kernel_code_linux" href="#pandare.panda.Panda.in_kernel_code_linux">in_kernel_code_linux</a></code></li>
<li><code><a title="pandare.panda.Panda.in_kernel_mode" href="#pandare.panda.Panda.in_kernel_mode">in_kernel_mode</a></code></li>
<li><code><a title="pandare.panda.Panda.interact" href="#pandare.panda.Panda.interact">interact</a></code></li>
<li><code><a title="pandare.panda.Panda.is_callback_enabled" href="#pandare.panda.Panda.is_callback_enabled">is_callback_enabled</a></code></li>
<li><code><a title="pandare.panda.Panda.load_plugin" href="#pandare.panda.Panda.load_plugin">load_plugin</a></code></li>
<li><code><a title="pandare.panda.Panda.lookup_gic" href="#pandare.panda.Panda.lookup_gic">lookup_gic</a></code></li>
<li><code><a title="pandare.panda.Panda.make_panda_file_handler" href="#pandare.panda.Panda.make_panda_file_handler">make_panda_file_handler</a></code></li>
<li><code><a title="pandare.panda.Panda.map_memory" href="#pandare.panda.Panda.map_memory">map_memory</a></code></li>
<li><code><a title="pandare.panda.Panda.memory_region_add_subregion" href="#pandare.panda.Panda.memory_region_add_subregion">memory_region_add_subregion</a></code></li>
<li><code><a title="pandare.panda.Panda.memory_region_allocate_system_memory" href="#pandare.panda.Panda.memory_region_allocate_system_memory">memory_region_allocate_system_memory</a></code></li>
<li><code><a title="pandare.panda.Panda.memory_region_init_ram_from_file" href="#pandare.panda.Panda.memory_region_init_ram_from_file">memory_region_init_ram_from_file</a></code></li>
<li><code><a title="pandare.panda.Panda.memsavep" href="#pandare.panda.Panda.memsavep">memsavep</a></code></li>
<li><code><a title="pandare.panda.Panda.object_class_by_name" href="#pandare.panda.Panda.object_class_by_name">object_class_by_name</a></code></li>
<li><code><a title="pandare.panda.Panda.object_class_get_name" href="#pandare.panda.Panda.object_class_get_name">object_class_get_name</a></code></li>
<li><code><a title="pandare.panda.Panda.object_new" href="#pandare.panda.Panda.object_new">object_new</a></code></li>
<li><code><a title="pandare.panda.Panda.object_property_find" href="#pandare.panda.Panda.object_property_find">object_property_find</a></code></li>
<li><code><a title="pandare.panda.Panda.object_property_get_bool" href="#pandare.panda.Panda.object_property_get_bool">object_property_get_bool</a></code></li>
<li><code><a title="pandare.panda.Panda.object_property_get_int" href="#pandare.panda.Panda.object_property_get_int">object_property_get_int</a></code></li>
<li><code><a title="pandare.panda.Panda.object_property_get_link" href="#pandare.panda.Panda.object_property_get_link">object_property_get_link</a></code></li>
<li><code><a title="pandare.panda.Panda.object_property_set_bool" href="#pandare.panda.Panda.object_property_set_bool">object_property_set_bool</a></code></li>
<li><code><a title="pandare.panda.Panda.object_property_set_int" href="#pandare.panda.Panda.object_property_set_int">object_property_set_int</a></code></li>
<li><code><a title="pandare.panda.Panda.object_property_set_link" href="#pandare.panda.Panda.object_property_set_link">object_property_set_link</a></code></li>
<li><code><a title="pandare.panda.Panda.panda_finish" href="#pandare.panda.Panda.panda_finish">panda_finish</a></code></li>
<li><code><a title="pandare.panda.Panda.physical_memory_read" href="#pandare.panda.Panda.physical_memory_read">physical_memory_read</a></code></li>
<li><code><a title="pandare.panda.Panda.physical_memory_write" href="#pandare.panda.Panda.physical_memory_write">physical_memory_write</a></code></li>
<li><code><a title="pandare.panda.Panda.ppp" href="#pandare.panda.Panda.ppp">ppp</a></code></li>
<li><code><a title="pandare.panda.Panda.pyperiph_read_cb" href="#pandare.panda.Panda.pyperiph_read_cb">pyperiph_read_cb</a></code></li>
<li><code><a title="pandare.panda.Panda.pyperiph_write_cb" href="#pandare.panda.Panda.pyperiph_write_cb">pyperiph_write_cb</a></code></li>
<li><code><a title="pandare.panda.Panda.queue_async" href="#pandare.panda.Panda.queue_async">queue_async</a></code></li>
<li><code><a title="pandare.panda.Panda.queue_blocking" href="#pandare.panda.Panda.queue_blocking">queue_blocking</a></code></li>
<li><code><a title="pandare.panda.Panda.queue_main_loop_wait_fn" href="#pandare.panda.Panda.queue_main_loop_wait_fn">queue_main_loop_wait_fn</a></code></li>
<li><code><a title="pandare.panda.Panda.read_str" href="#pandare.panda.Panda.read_str">read_str</a></code></li>
<li><code><a title="pandare.panda.Panda.record" href="#pandare.panda.Panda.record">record</a></code></li>
<li><code><a title="pandare.panda.Panda.record_cmd" href="#pandare.panda.Panda.record_cmd">record_cmd</a></code></li>
<li><code><a title="pandare.panda.Panda.recording_exists" href="#pandare.panda.Panda.recording_exists">recording_exists</a></code></li>
<li><code><a title="pandare.panda.Panda.register_callback" href="#pandare.panda.Panda.register_callback">register_callback</a></code></li>
<li><code><a title="pandare.panda.Panda.register_cb_decorators" href="#pandare.panda.Panda.register_cb_decorators">register_cb_decorators</a></code></li>
<li><code><a title="pandare.panda.Panda.register_pyperipheral" href="#pandare.panda.Panda.register_pyperipheral">register_pyperipheral</a></code></li>
<li><code><a title="pandare.panda.Panda.require" href="#pandare.panda.Panda.require">require</a></code></li>
<li><code><a title="pandare.panda.Panda.reset" href="#pandare.panda.Panda.reset">reset</a></code></li>
<li><code><a title="pandare.panda.Panda.revert_async" href="#pandare.panda.Panda.revert_async">revert_async</a></code></li>
<li><code><a title="pandare.panda.Panda.revert_sync" href="#pandare.panda.Panda.revert_sync">revert_sync</a></code></li>
<li><code><a title="pandare.panda.Panda.rr_get_guest_instr_count" href="#pandare.panda.Panda.rr_get_guest_instr_count">rr_get_guest_instr_count</a></code></li>
<li><code><a title="pandare.panda.Panda.run" href="#pandare.panda.Panda.run">run</a></code></li>
<li><code><a title="pandare.panda.Panda.run_monitor_cmd" href="#pandare.panda.Panda.run_monitor_cmd">run_monitor_cmd</a></code></li>
<li><code><a title="pandare.panda.Panda.run_replay" href="#pandare.panda.Panda.run_replay">run_replay</a></code></li>
<li><code><a title="pandare.panda.Panda.run_serial_cmd" href="#pandare.panda.Panda.run_serial_cmd">run_serial_cmd</a></code></li>
<li><code><a title="pandare.panda.Panda.run_serial_cmd_async" href="#pandare.panda.Panda.run_serial_cmd_async">run_serial_cmd_async</a></code></li>
<li><code><a title="pandare.panda.Panda.run_volatility" href="#pandare.panda.Panda.run_volatility">run_volatility</a></code></li>
<li><code><a title="pandare.panda.Panda.set_breakpoint" href="#pandare.panda.Panda.set_breakpoint">set_breakpoint</a></code></li>
<li><code><a title="pandare.panda.Panda.set_os_name" href="#pandare.panda.Panda.set_os_name">set_os_name</a></code></li>
<li><code><a title="pandare.panda.Panda.set_pandalog" href="#pandare.panda.Panda.set_pandalog">set_pandalog</a></code></li>
<li><code><a title="pandare.panda.Panda.snap" href="#pandare.panda.Panda.snap">snap</a></code></li>
<li><code><a title="pandare.panda.Panda.stop_run" href="#pandare.panda.Panda.stop_run">stop_run</a></code></li>
<li><code><a title="pandare.panda.Panda.sysbus_create_varargs" href="#pandare.panda.Panda.sysbus_create_varargs">sysbus_create_varargs</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_check_laddr" href="#pandare.panda.Panda.taint_check_laddr">taint_check_laddr</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_check_ram" href="#pandare.panda.Panda.taint_check_ram">taint_check_ram</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_check_reg" href="#pandare.panda.Panda.taint_check_reg">taint_check_reg</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_enable" href="#pandare.panda.Panda.taint_enable">taint_enable</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_get_laddr" href="#pandare.panda.Panda.taint_get_laddr">taint_get_laddr</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_get_ram" href="#pandare.panda.Panda.taint_get_ram">taint_get_ram</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_get_reg" href="#pandare.panda.Panda.taint_get_reg">taint_get_reg</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_label_ram" href="#pandare.panda.Panda.taint_label_ram">taint_label_ram</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_label_reg" href="#pandare.panda.Panda.taint_label_reg">taint_label_reg</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_sym_enable" href="#pandare.panda.Panda.taint_sym_enable">taint_sym_enable</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_sym_label_ram" href="#pandare.panda.Panda.taint_sym_label_ram">taint_sym_label_ram</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_sym_label_reg" href="#pandare.panda.Panda.taint_sym_label_reg">taint_sym_label_reg</a></code></li>
<li><code><a title="pandare.panda.Panda.to_unsigned_guest" href="#pandare.panda.Panda.to_unsigned_guest">to_unsigned_guest</a></code></li>
<li><code><a title="pandare.panda.Panda.type_serial_cmd" href="#pandare.panda.Panda.type_serial_cmd">type_serial_cmd</a></code></li>
<li><code><a title="pandare.panda.Panda.unload_plugin" href="#pandare.panda.Panda.unload_plugin">unload_plugin</a></code></li>
<li><code><a title="pandare.panda.Panda.unload_plugins" href="#pandare.panda.Panda.unload_plugins">unload_plugins</a></code></li>
<li><code><a title="pandare.panda.Panda.unregister_pyperipheral" href="#pandare.panda.Panda.unregister_pyperipheral">unregister_pyperipheral</a></code></li>
<li><code><a title="pandare.panda.Panda.virt_to_phys" href="#pandare.panda.Panda.virt_to_phys">virt_to_phys</a></code></li>
<li><code><a title="pandare.panda.Panda.virtual_memory_read" href="#pandare.panda.Panda.virtual_memory_read">virtual_memory_read</a></code></li>
<li><code><a title="pandare.panda.Panda.virtual_memory_write" href="#pandare.panda.Panda.virtual_memory_write">virtual_memory_write</a></code></li>
<li><code><a title="pandare.panda.Panda.vm_stop" href="#pandare.panda.Panda.vm_stop">vm_stop</a></code></li>
<li><code><a title="pandare.panda.Panda.was_aborted" href="#pandare.panda.Panda.was_aborted">was_aborted</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>