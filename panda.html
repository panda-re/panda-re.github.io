<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>pandare.panda API documentation</title>
<meta name="description" content="This module simply contains the Panda class" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pandare.panda</code></h1>
</header>
<section id="section-intro">
<p>This module simply contains the Panda class</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module simply contains the Panda class
&#34;&#34;&#34;

from sys import version_info, exit

if version_info[0] &lt; 3:
    print(&#34;Please run with Python 3!&#34;)
    exit(0)

import socket
import threading

from os.path import realpath, exists, abspath, isfile, dirname, join as pjoin
from os import dup, getenv, environ, path
from random import randint
from inspect import signature
from tempfile import NamedTemporaryFile
from time import time
from math import ceil
from inspect import signature
from struct import pack_into
from shlex import quote as shlex_quote
from time import sleep
from cffi import FFI

from .ffi_importer import ffi, set_ffi
from .utils import progress, make_iso, debug, blocking, GArrayIterator, plugin_list, Hook
from .taint import TaintQuery
from .panda_expect import Expect
from .asyncthread import AsyncThread
from .qcows import Qcows
from .arch import ArmArch, MipsArch, X86Arch, X86_64Arch

# Might be worth importing and auto-initilizing a PLogReader
# object within Panda for the current architecture?
#from .plog import PLogReader


class Panda():
    &#39;&#39;&#39;
    This is the object used to interact with PANDA. Initializing it creates a virtual machine to interact with.

        Parameters:
            arch : architecture string (e.g. &#34;i386&#34;, &#34;x86_64&#34;, &#34;arm&#34;, &#34;mips&#34;, &#34;mipsel&#34;)
            mem : size of memory for machine (e.g. &#34;128M&#34;, &#34;1G&#34;)
            expect_prompt : Regular expression describing the prompt exposed by the guest 
                on a serial console. Used so we know when a running command has finished 
                with its output.
            os_version : analagous to -os string.
            qcow : qcow file to load as a path
            os : type of OS (e.g. &#34;linux&#34;)
            generic : specify a generic qcow to use and set other arguments. Supported 
                values: arm/ppc/x86_64/i386. Will download qcow automatically
            raw_monitor : When set, don&#39;t specify a -monitor. arg Allows for use of 
                -nographic in args with ctrl-A+C for interactive qemu prompt.
            extra_args : extra arguments to pass to PANDA as either a string or an 
                array. (e.g. &#34;-nographic&#34; or [&#34;-nographic&#34;, &#34;-net&#34;, &#34;none&#34;])

    Note that multiple PANDA objects cannot coexist in the same Python instance.
    &#39;&#39;&#39;
    def __init__(self, arch=&#34;i386&#34;, mem=&#34;128M&#34;,
            expect_prompt=None, # Regular expression describing the prompt exposed by the guest on a serial console. Used so we know when a running command has finished with its output
            os_version=None,
            qcow=None, # Qcow file to load
            os=&#34;linux&#34;,
            generic=None, # Helper: specify a generic qcow to use and set other arguments. Supported values: arm/ppc/x86_64/i386. Will download qcow automatically
            raw_monitor = False, # When set, don&#39;t specify a -monitor. arg Allows for use of -nographic in args with ctrl-A+C for interactive qemu prompt.
            extra_args=[]):
        self.arch_name = arch
        self.mem = mem
        self.os = os_version
        self.os_type = os
        self.qcow = qcow
        self.plugins = plugin_list(self)
        self.expect_prompt = expect_prompt
        self.lambda_cnt = 0
        self.arch = None
        &#34;&#34;&#34;
        A reference to an auto-instantiated `pandare.arch.PandaArch` subclass (e.g., `pandare.arch.X86Arch`)
        &#34;&#34;&#34;

        if isinstance(extra_args, str): # Extra args can be a string or array
            extra_args = extra_args.split()

        # If specified use a generic (x86_64, i386, arm, ppc) qcow from mit and ignore
        if generic:                                 # other args. See details in images.py
            print(&#34;using generic &#34; +str(generic))
            q = Qcows.get_qcow_info(generic)
            self.arch_name     = q.arch
            self.os       = q.os
            self.mem      = q.default_mem # Might clobber a specified argument, but required if you want snapshots
            self.qcow     = Qcows.get_qcow(generic)
            self.expect_prompt = q.prompt
            if q.extra_args:
                extra_args.extend(q.extra_args.split(&#34; &#34;))

        if self.qcow: # Otherwise we shuld be able to do a replay with no qcow but this is probably broken
            if not (exists(self.qcow)):
                print(&#34;Missing qcow &#39;{}&#39; Please go create that qcow and give it to the PANDA maintainers&#34;.format(self.qcow))

        # panda.arch is a subclass with architecture-specific functions

        if self.arch_name == &#34;i386&#34;:
            self.arch = X86Arch(self)
        elif self.arch_name == &#34;x86_64&#34;:
            self.arch = X86_64Arch(self)
        elif self.arch_name == &#34;arm&#34;:
            self.arch = ArmArch(self)
        elif self.arch_name in [&#34;mips&#34;, &#34;mipsel&#34;]:
            self.arch = MipsArch(self)
        else:
            raise ValueError(f&#34;Unsupported architecture {self.arch_name}&#34;)
        self.bits, self.endianness, self.register_size = self.arch._determine_bits()

        self.build_dir  = self._find_build_dir()
        environ[&#34;PANDA_DIR&#34;] = self.build_dir
        self.libpanda_path = pjoin(self.build_dir, &#34;{0}-softmmu/libpanda-{0}.so&#34;.format(self.arch_name))
        self.panda = self.libpanda_path # Necessary for realpath to work inside core-panda, may cause issues?

        self.ffi = self._do_types_import()
        self.libpanda = self.ffi.dlopen(self.libpanda_path)
        self.C = ffi.dlopen(None)

        # set OS name if we have one
        if self.os:
            self.set_os_name(self.os)

        # Setup argv for panda
        self.panda_args = [self.panda]
        biospath = realpath(pjoin(self.build_dir, &#34;pc-bios&#34;)) # XXX: necessary for network drivers for arm, so &#39;pc-bios&#39; is a misleading name
        self.panda_args.append(&#34;-L&#34;)
        self.panda_args.append(biospath)

        if self.qcow:
            self.panda_args.append(self.qcow)

        self.panda_args += extra_args

        # Configure memory options
        self.panda_args.extend([&#39;-m&#39;, self.mem])

        # Configure serial - if we have an expect_prompt set. Otherwise how can we know what guest cmds are outputting?
        if self.expect_prompt:
            self.serial_file = NamedTemporaryFile(prefix=&#34;pypanda_s&#34;).name
            self.serial_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            self.serial_console = Expect(expectation=self.expect_prompt, quiet=True, consume_first=False)
            self.panda_args.extend([&#39;-serial&#39;, &#39;unix:{},server,nowait&#39;.format(self.serial_file)])
        else:
            self.serial_file = None
            self.serial_socket = None
            self.serial_console = None

        # Configure monitor - Always enabled for now
        self.monitor_file = NamedTemporaryFile(prefix=&#34;pypanda_m&#34;).name
        self.monitor_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.raw_monitor = raw_monitor
        if not self.raw_monitor:
            self.monitor_console = Expect(expectation=rb&#34;(qemu)&#34;, quiet=True, consume_first=True)
            self.panda_args.extend([&#39;-monitor&#39;, &#39;unix:{},server,nowait&#39;.format(self.monitor_file)])

        self.running = threading.Event()
        self.started = threading.Event()
        self.athread = AsyncThread(self.started) # athread manages actions that need to occur outside qemu&#39;s CPU loop

        # Callbacks
        self.register_cb_decorators()
        self.registered_callbacks = {} # name -&gt; {procname: &#34;bash&#34;, enabled: False, callback: None}

        # Register asid_changed CB if and only if a callback requires procname
        self._registered_asid_changed_internal_cb = False
        self._registered_mmap_cb = False

        self._initialized_panda = False
        self.disabled_tb_chaining = False
        self.taint_enabled = False
        self.hook_list = []
        self.hook_list2 = {}

        # Asid stuff
        self.current_asid_name = None
        self.asid_mapping = {}

        # Shutdown stuff
        self.exception = None # When set to an exn, we&#39;ll raise and exit

        # main_loop_wait functions and callbacks
        self.main_loop_wait_fnargs = [] # [(fn, args), ...]
        progress (&#34;Panda args: [&#34; + (&#34; &#34;.join(self.panda_args)) + &#34;]&#34;)
    # /__init__

    def _do_types_import(self):
        # Import objects from panda_datatypes which are configured by the environment variables
        # Store these objects in self.callback and self.callback_dictionary
        global ffi
        from importlib import import_module
        panda_arch_support = import_module(f&#34;.autogen.panda_{self.arch_name}_{self.bits}&#34;,package=&#39;pandare&#39;)
        ffi = panda_arch_support.ffi
        self.ffi = ffi
        set_ffi(ffi)
        from .autogen.panda_datatypes import pcb, C, callback_dictionary # XXX: What is C and do we need it?
        self.callback_dictionary = callback_dictionary
        self.callback = pcb
        return ffi

    def _initialize_panda(self):
        &#39;&#39;&#39;
        After initializing the class, the user has a chance to do something
        (TODO: what? register callbacks? It&#39;s something important...) before we finish initializing
        &#39;&#39;&#39;
        self.libpanda._panda_set_library_mode(True)

        cenvp = ffi.new(&#34;char**&#34;, ffi.new(&#34;char[]&#34;, b&#34;&#34;))
        len_cargs = ffi.cast(&#34;int&#34;, len(self.panda_args))
        panda_args_ffi = [ffi.new(&#34;char[]&#34;, bytes(str(i),&#34;utf-8&#34;)) for i in self.panda_args]
        self.libpanda.panda_init(len_cargs, panda_args_ffi, cenvp)

        # Now we&#39;ve run qemu init so we can connect to the sockets for the monitor and serial
        if self.serial_console and not self.serial_console.is_connected():
            self.serial_socket.connect(self.serial_file)
            self.serial_console.connect(self.serial_socket)
        if not self.raw_monitor and not self.monitor_console.is_connected():
            self.monitor_socket.connect(self.monitor_file)
            self.monitor_console.connect(self.monitor_socket)

        # Register __main_loop_wait_callback
        self.register_callback(self.callback.main_loop_wait,
                self.callback.main_loop_wait(self.__main_loop_wait_cb), &#39;__main_loop_wait&#39;)

        self._initialized_panda = True


    def __main_loop_wait_cb(self):
        &#39;&#39;&#39;
        __main_loop_wait_cb is called at the start of the main cpu loop in qemu.
        This is a fairly safe place to call into qemu internals but watch out for deadlocks caused
        by your request blocking on the guest&#39;s execution. Here any functions in main_loop_wait_fnargs will be called
        &#39;&#39;&#39;
        try:
            # Then run any and all requested commands
            if len(self.main_loop_wait_fnargs) == 0: return
            #progress(&#34;Entering main_loop_wait_cb&#34;)
            for fnargs in self.main_loop_wait_fnargs:
                (fn, args) = fnargs
                ret = fn(*args)
            self.main_loop_wait_fnargs = []
        except KeyboardInterrupt:
            self.end_analysis()

    def _find_build_dir(self):
        &#39;&#39;&#39;
        Find build directory containing ARCH-softmmu/libpanda-ARCH.so and ARCH-softmmu/panda/plugins/
        1) check relative to file (in the case of installed packages)
        2) Check in../ ../../../build/
        3) raise RuntimeError
        &#39;&#39;&#39;
        archs = [&#39;i386&#39;, &#39;x86_64&#39;, &#39;arm&#39;, &#39;ppc&#39;]
        python_package = pjoin(*[dirname(__file__), &#34;data&#34;])
        local_build = realpath(pjoin(dirname(__file__), &#34;../../../../build&#34;))
        path_end = &#34;{0}-softmmu/libpanda-{0}.so&#34;.format(self.arch_name)

        pot_paths = [python_package, local_build]
        for potential_path in pot_paths:
            if isfile(pjoin(potential_path, path_end)):
                print(&#34;Loading libpanda from {}&#34;.format(potential_path))
                return potential_path

        searched_paths = &#34;\n&#34;.join([&#34;\t&#34;+p for p in  pot_paths])
        raise RuntimeError((&#34;Couldn&#39;t find libpanda-{}.so.\n&#34;
                            &#34;Did you built PANDA for this architecture?\n&#34;
                            &#34;Searched paths:\n{}&#34;
                           ).format(self.arch_name, searched_paths))


    def queue_main_loop_wait_fn(self, fn, args=[]):
        &#39;&#39;&#39;
        Queue a function to run at the next main loop
        fn is a function we want to run, args are arguments to apss to it
        &#39;&#39;&#39;
        self.main_loop_wait_fnargs.append((fn, args))

    def exit_cpu_loop(self):
        &#39;&#39;&#39;
        Stop cpu execution at nearest juncture.
        &#39;&#39;&#39;
        self.libpanda.panda_exit_loop = True

    def revert_async(self, snapshot_name): # In the next main loop, revert
        &#39;&#39;&#39;
        Request a snapshot revert, eventually. This is fairly dangerous
        because you don&#39;t know when it finishes. You should be using revert_sync
        from a blocking function instead
        &#39;&#39;&#39;
        print(&#34;WARNING: panda.revert_async may be deprecated in the near future&#34;)
        if debug:
            progress (&#34;Loading snapshot &#34; + snapshot_name)

        # Stop guest, queue up revert, then continue
        timer_start = time()
        self.vm_stop()
        charptr = ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
        self.queue_main_loop_wait_fn(self.libpanda.panda_revert, [charptr])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont)
        if debug:
            self.queue_main_loop_wait_fn(self.finish_timer, [timer_start, &#34;Loaded snapshot&#34;])

    def reset(self): 
        &#34;&#34;&#34;In the next main loop, reset to boot&#34;&#34;&#34;
        if debug:
            progress (&#34;Resetting machine to start state&#34;)

        # Stop guest, queue up revert, then continue
        self.vm_stop()
        self.queue_main_loop_wait_fn(self.libpanda.panda_reset)
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont)

    def cont(self):
        &#39;&#39;&#39; Continue execution (run after vm_stop) &#39;&#39;&#39;
        self.libpanda.panda_cont()
        self.running.set()

    def vm_stop(self, code=4):
        &#39;&#39;&#39; Stop execution, default code means RUN_STATE_PAUSED &#39;&#39;&#39;
        self.libpanda.panda_stop(code)

    def snap(self, snapshot_name):
        &#39;&#39;&#39; Create snapshot with specified name &#39;&#39;&#39;
        if debug:
            progress (&#34;Creating snapshot &#34; + snapshot_name)

        # Stop guest execution, queue up a snapshot, then continue
        timer_start = time()
        self.vm_stop()
        charptr = ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
        self.queue_main_loop_wait_fn(self.libpanda.panda_snap, [charptr])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont)
        if debug:
            self.queue_main_loop_wait_fn(self.finish_timer, [timer_start, &#34;Saved snapshot&#34;])

    def delvm(self, snapshot_name):
        &#39;&#39;&#39; Delete snapshot with specified name &#39;&#39;&#39;
        if debug:
            progress (&#34;Deleting snapshot &#34; + snapshot_name)

        # Stop guest, queue up delete, then continue
        self.vm_stop()
        charptr = ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
        self.queue_main_loop_wait_fn(self.libpanda.panda_delvm, [charptr])

    def finish_timer(self, start, msg):
        &#39;&#39;&#39; Print how long some (main_loop_wait) task took &#39;&#39;&#39;
        t = time() - start
        print(&#34;{} in {1:.08f} seconds&#34;.format(msg, t))


    def enable_tb_chaining(self):
        &#39;&#39;&#39; This function enables translation block chaining in QEMU &#39;&#39;&#39;
        if debug:
            progress(&#34;Enabling TB chaining&#34;)
        self.disabled_tb_chaining = False
        self.libpanda.panda_enable_tb_chaining()

    def disable_tb_chaining(self):
        &#39;&#39;&#39; This function disables translation block chaining in QEMU &#39;&#39;&#39;
        if not self.disabled_tb_chaining:
            if debug:
                progress(&#34;Disabling TB chaining&#34;)
            self.disabled_tb_chaining = True
            self.libpanda.panda_disable_tb_chaining()
    
    def setup_internal_signal_handler(self):
       # ffi.cdef(&#34;void panda_setup_signal_handling(void (*f) (int,void*,void*));&#34;,override=True)
        @ffi.callback(&#34;void(int,void*,void*)&#34;)
        def SigHandler(SIG,a,b):
            from signal import SIGINT, SIGHUP, SIGTERM
            if SIG == SIGINT:
                self.end_run_raise_signal = KeyboardInterrupt
                self.end_analysis()
            elif SIG == SIGHUP:
                self.end_run_raise_signal = KeyboardInterrupt
                self.end_analysis()
            elif SIG == SIGTERM:
                self.end_run_raise_signal = KeyboardInterrupt
                self.end_analysis()
            else:
                print(f&#34;PyPanda Signal handler received unhandled signal {SIG}&#34;)
        
        self.__sighandler = SigHandler
        self.libpanda.panda_setup_signal_handling(self.__sighandler)

    
    def run(self):
        &#39;&#39;&#39;
        This function starts our running PANDA instance from Python. At termination this function returns and the script continues to run after it.
        
        This function starts execution of the guest. It blocks until guest finishes.
        It also initializes panda object, clears main_loop_wait fns, and sets up internal callbacks.
        &#39;&#39;&#39;

        if len(self.main_loop_wait_fnargs):
            if debug:
                print(&#34;Clearing prior main_loop_wait fns:&#34;, self.main_loop_wait_fnargs)
            self.main_loop_wait_fnargs = [] # [(fn, args), ...]

        if debug:
            progress (&#34;Running&#34;)

        if not self._initialized_panda:
            self._initialize_panda()

        if not self.started.is_set():
            self.started.set()

        # Ensure our internal CBs are always enabled
        self.enable_internal_callbacks()
        self.setup_internal_signal_handler()
        self.running.set()
        self.libpanda.panda_run() # Give control to panda
        self.running.clear() # Back from panda&#39;s execution (due to shutdown or monitor quit)
        self.libpanda.panda_unload_plugins() # Unload c plugins - should be safe now since exec has stopped
        if hasattr(self, &#34;end_run_raise_signal&#34;):
            raise self.end_run_raise_signal
        if hasattr(self, &#34;callback_exit_exception&#34;):
            raise self.callback_exit_exception
            

    def end_analysis(self):
        &#39;&#39;&#39;
        Stop running machine.

        Call from any thread to unload all plugins and stop all queued functions.
        If called from async thread or a callback, it will also unblock panda.run()

        Note here we use the async class&#39;s internal thread to process these
        without needing to wait for tasks in the main async thread
        &#39;&#39;&#39;
        self.unload_plugins()
        if self.running.is_set():
            # If we were running, stop the execution and check if we crashed
            self.queue_async(self.stop_run, internal=True)
    
    def record(self, recording_name, snapshot_name=None):
        &#34;&#34;&#34;Begins active recording with name provided.

        Args:
            recording_name (string): name of recording to save.
            snapshot_name (string, optional): Before recording starts restore to this snapshot name. Defaults to None.

        Raises:
            Exception: raises exception if there was an error starting recording.
        &#34;&#34;&#34;
        if snapshot_name == None:
            snapshot_name_ffi = ffi.NULL
        else:
            snapshot_name_ffi = ffi.new(&#34;char[]&#34;,snapshot_name.encode())
        recording_name_ffi = ffi.new(&#34;char[]&#34;, recording_name.encode())
        result = self.libpanda.panda_record_begin(recording_name_ffi,snapshot_name_ffi)
        res_string_enum = ffi.string(ffi.cast(&#34;RRCTRL_ret&#34;,result))
        if res_string_enum != &#34;RRCTRL_OK&#34;:
           raise Exception(f&#34;record method failed with RTCTL_ret {res_string_enum} ({result})&#34;) 
    
    def end_record(self):
        &#34;&#34;&#34;Stop active recording.

        Raises:
            Exception: raises exception if there was an error stopping recording.
        &#34;&#34;&#34;
        result = self.libpanda.panda_record_end()
        res_string_enum = ffi.string(ffi.cast(&#34;RRCTRL_ret&#34;,result))
        if res_string_enum != &#34;RRCTRL_OK&#34;:
           raise Exception(f&#34;record method failed with RTCTL_ret {res_string_enum} ({result})&#34;) 


    def run_replay(self, replaypfx):
        &#39;&#39;&#39;
        Load a replay and run it. Starts PANDA execution and returns after end of VM execution.

            Parameters:
                replaypfx: python string path to replay file.
        
            Returns:
                None
        &#39;&#39;&#39;
        if not isfile(replaypfx+&#34;-rr-snp&#34;) or not isfile(replaypfx+&#34;-rr-nondet.log&#34;):
            raise ValueError(&#34;Replay files not present to run replay of {}&#34;.format(replaypfx))

        if debug:
            progress (&#34;Replaying %s&#34; % replaypfx)

        charptr = ffi.new(&#34;char[]&#34;,bytes(replaypfx,&#34;utf-8&#34;))
        self.libpanda.panda_replay_begin(charptr)
        self.run()

    def require(self, name):
        &#39;&#39;&#39;
        Load a C plugin with no arguments. Deprecated. Use load_plugin
        &#39;&#39;&#39;
        self.load_plugin(name, args={})

    def load_plugin(self, name, args={}):
        &#39;&#39;&#39;
        Load a C plugin, optionally with arguments

            Parameters:
                name: python string name of plugin
                args: Dictionary of arguments matching key to value. e.g. {&#34;key&#34;: &#34;value&#34;} sets option key to value.
            
            Returns:
                None.
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Loading plugin %s&#34; % name),

        argstrs_ffi = []
        if isinstance(args, dict):
            for k,v in args.items():
                this_arg_s = &#34;{}={}&#34;.format(k,v)
                this_arg = ffi.new(&#34;char[]&#34;, bytes(this_arg_s, &#34;utf-8&#34;))
                argstrs_ffi.append(this_arg)

            n = len(args.keys())
        elif isinstance(args, list):
            for arg in args:
                this_arg = ffi.new(&#34;char[]&#34;, bytes(arg, &#34;utf-8&#34;))
                argstrs_ffi.append(this_arg)
            n = len(args)

        else:
            raise ValueError(&#34;Arguments to load plugin must be a list or dict of key/value pairs&#34;)

        # First set qemu_path so plugins can load (may be unnecessary after the first time)
        assert(self.panda), &#34;Unknown location of PANDA&#34;
        panda_name_ffi = ffi.new(&#34;char[]&#34;, bytes(self.panda,&#34;utf-8&#34;))
        self.libpanda.panda_set_qemu_path(panda_name_ffi)

        if len(argstrs_ffi):
            plugin_args = argstrs_ffi
        else:
            plugin_args = ffi.NULL

        charptr = ffi.new(&#34;char[]&#34;, bytes(name,&#34;utf-8&#34;))
        self.libpanda.panda_require_from_library(charptr, plugin_args, len(argstrs_ffi))
        self._load_plugin_library(name)
    
    def _procname_changed(self, cpu, name):
        for cb_name, cb in self.registered_callbacks.items():
            if not cb[&#34;procname&#34;]:
                continue
            if name == cb[&#34;procname&#34;] and not cb[&#39;enabled&#39;]:
                self.enable_callback(cb_name)
            if name != cb[&#34;procname&#34;] and cb[&#39;enabled&#39;]:
                self.disable_callback(cb_name)

        self._update_hooks_new_procname(cpu, name)

    def unload_plugin(self, name):
        &#39;&#39;&#39;
        Unload plugin with given name.

            Parameters:
                name: python string name of plugin
        
            Returns:
                None
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Unloading plugin %s&#34; % name),
        name_ffi = ffi.new(&#34;char[]&#34;, bytes(name,&#34;utf-8&#34;))
        self.libpanda.panda_unload_plugin_by_name(name_ffi)

    def unload_plugins(self):
        &#39;&#39;&#39;
        Disable all python plugins and request to unload all c plugins
        at the next main_loop_wait.

        XXX: If called during shutdown/exit, c plugins won&#39;t be unloaded
        because the next main_loop_wait will never happen. Instead, call
        panda.panda_finish directly (which is done at the end of panda.run())
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Disabling all python plugins, unloading all C plugins&#34;)

        # First unload python plugins, should be safe to do anytime
        for name in self.registered_callbacks.keys():
            self.disable_callback(name)

        # Then unload C plugins. May be unsafe to do except from the top of the main loop (taint segfaults otherwise)
        self.queue_main_loop_wait_fn(self.libpanda.panda_unload_plugins)

    def memsavep(self, file_out):
        &#39;&#39;&#39;
        Calls QEMU memsavep on your specified python file.
        &#39;&#39;&#39;
        def initlib():
            ffi.cdef(&#39;&#39;&#39;
            FILE *fdopen(int, const char *);   // from the C &lt;stdio.h&gt;
            int fclose(FILE *);
            &#39;&#39;&#39;, override=True)
        ffi.init_once(initlib, &#34;cinit&#34;)
        
        # this part was largely copied from https://cffi.readthedocs.io/en/latest/ref.html#support-for-file

        file_out.flush()                    # make sure the file is flushed
        newfd = dup(file_out.fileno())   # make a copy of the file descriptor
        fileptr = self.C.fdopen(newfd, b&#34;w&#34;)
        self.libpanda.panda_memsavep(fileptr)
        self.C.fclose(fileptr)

    def physical_memory_read(self, addr, length, fmt=&#39;bytearray&#39;):
        &#39;&#39;&#39;
        Read guest physical memory.

            Parameters:
                addr: python int address
                length: length of array you would like returned
                fmt: format for returned array. Options: &#39;bytearray&#39;, &#39;int&#39;, and &#39;str&#39;

            Returns:
                Buffer based on fmt string
        
            Raises:
                ValueError for two cases: 
                    Memory Access with error value.
                    Format string is incorrect.
        &#39;&#39;&#39;
        return self._memory_read(None, addr, length, physical=True, fmt=fmt)

    def virtual_memory_read(self, env, addr, length, fmt=&#39;bytearray&#39;):
        &#39;&#39;&#39;
        Read guest virtual memory.

            Parameters:
                    env: CPUState structure
                    addr: python int address
                    length: length of array you would like returned
                    fmt: format for returned array. Options: &#39;bytearray&#39;, &#39;int&#39;, and &#39;str&#39;
            
            Returns:
                    Buffer based on fmt string
            
            Raises:
                    ValueError for two cases: 
                        Memory Access with error value.
                        Format string is incorrect.
        &#39;&#39;&#39;
        return self._memory_read(env, addr, length, physical=False, fmt=fmt)

    def _memory_read(self, env, addr, length, physical=False, fmt=&#39;bytearray&#39;):
        &#39;&#39;&#39;
        Read but with an autogen&#39;d buffer
        Supports physical or virtual addresses
        Raises ValueError if read fails
        &#39;&#39;&#39;
        if not hasattr(self, &#34;_memcb&#34;): # XXX: Why do we enable memcbs for memory writes?
            self.enable_memcb()
        buf = ffi.new(&#34;char[]&#34;, length)

        # Force CFFI to parse addr as an unsigned value. Otherwise we get OverflowErrors
        # when it decides that it&#39;s negative
        ptr_typ = f&#39;uint{self.bits}_t&#39;
        addr_u = int(ffi.cast(ptr_typ, addr))

        buf_a = ffi.cast(&#34;char*&#34;, buf)
        length_a = ffi.cast(&#34;int&#34;, length)
        if physical:
            err = self.libpanda.panda_physical_memory_read_external(addr_u, buf_a, length_a)
        else:
            err = self.libpanda.panda_virtual_memory_read_external(env, addr_u, buf_a, length_a)

        if err &lt; 0:
            raise ValueError(f&#34;Memory access failed with err={err}&#34;) # TODO: make a PANDA Exn class

        r = ffi.unpack(buf, length)
        if fmt == &#39;bytearray&#39;:
            return r
        elif fmt==&#39;int&#39;:
            return int.from_bytes(r, byteorder=self.endianness)  # XXX size better be small enough to pack into an int!
        elif fmt==&#39;str&#39;:
            return ffi.string(buf, length)
        elif fmt==&#39;ptrlist&#39;:
            # This one is weird. Chunmk the memory into byte-sequences of (self.bits/8) bytes and flip endianness as approperiate
            # return a list
            bytelen = int(self.bits/8)
            if (length % bytelen != 0):
                raise ValueError(f&#34;Memory of size {length} does not evenly divide into {bytelen} byte chunks&#34;)
            chunks = []
            for start in range(0, length, bytelen):
                data = r[start:start+bytelen]
                int_data = int.from_bytes(data, byteorder=self.endianness)
                chunks.append(int_data)
            return chunks

        else:
            raise ValueError(&#34;fmt={} unsupported&#34;.format(fmt))

    def physical_memory_write(self, addr, buf):
        &#39;&#39;&#39;
        Write guest physical memory.

            Parameters:
                    addr: python int address
                    buf:  byte string to write
        &#39;&#39;&#39;
        return self._memory_write(None, addr, buf, physical=True)

    def virtual_memory_write(self, env, addr, buf):
        &#39;&#39;&#39;
        Write guest virtual memory.
        
            Parameters:
                    env: CPUState structure
                    address: python int address
                    buf: byte string to write
            
            Returns:
                    int: 0 on success. 1 on error.

        &#39;&#39;&#39;
        return self._memory_write(env, addr, buf, physical=False)

    def _memory_write(self, env, addr, buf, physical=False):
        &#39;&#39;&#39;
        Write a bytearray into memory at the specified physical/virtual address
        &#39;&#39;&#39;
        length = len(buf)
        c_buf = ffi.new(&#34;char[]&#34;,buf)
        buf_a = ffi.cast(&#34;char*&#34;, c_buf)
        length_a = ffi.cast(&#34;int&#34;, length)

        if not hasattr(self, &#34;_memcb&#34;): # XXX: Why do we enable memcbs for memory writes?
            self.enable_memcb()

        if physical:
            return self.libpanda.panda_physical_memory_write_external(addr, buf_a, length_a)
        else:
            return self.libpanda.panda_virtual_memory_write_external(env, addr, buf_a, length_a)

    def callstack_callers(self, lim, cpu): # XXX move into new directory, &#39;callstack&#39; ?
        &#39;&#39;&#39;
        Utility function to handle conversion and return get_callers from callstack_instr.
        &#39;&#39;&#39;
        if not &#34;plugin_callstack_instr&#34; in self.plugins:
            progress(&#34;enabling callstack_instr plugin&#34;)
            self.require(&#34;callstack_instr&#34;)

        callers = ffi.new(&#34;uint32_t[%d]&#34; % lim)
        n = self.plugins[&#39;callstack_instr&#39;].get_callers(callers, lim, cpu)
        c = []
        for pc in callers:
            c.append(pc)
        return c

    def _load_plugin_library(self, name):
        if hasattr(self,&#34;__did_load_libpanda&#34;):
            libpanda_path_chr = ffi.new(&#34;char[]&#34;,bytes(self.libpanda_path, &#34;UTF-8&#34;))
            self.__did_load_libpanda = self.libpanda.panda_load_libpanda(libpanda_path_chr)
        if not name in self.plugins.keys():
            assert(isfile(pjoin(*[self.build_dir, self.arch_name+&#34;-softmmu&#34;, &#34;panda/plugins/panda_{}.so&#34;.format(name)])))
            library = ffi.dlopen(pjoin(*[self.build_dir, self.arch_name+&#34;-softmmu&#34;, &#34;panda/plugins/panda_{}.so&#34;.format(name)]))
            self.plugins[name] = library

    def queue_async(self, f, internal=False):
        &#39;&#39;&#39;
        Queues work in the asynchronous work queue.

            Parameters:
                f: A python function with no arguments to be called at a later date
            
            Returns:
                None
        &#39;&#39;&#39;
        self.athread.queue(f, internal=internal)

    def map_memory(self, name, size, address):

        &#39;&#39;&#39;
        Make a new memory region.
        
            Parameters:
                    name: This is an internal reference name for this region. Must be unique.
                    size: number of bytes the region should be.
                    address: start address of region
        &#39;&#39;&#39;

        name_c = ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
        size = ceil(size/1024)*1024 # Must be page-aligned
        return self.libpanda.map_memory(name_c, size, address)

    def read_str(self, cpu, ptr):
        &#39;&#39;&#39;
        Helper to read a null-terminated string from guest memory given a pointer and CPU state
        May return an exception if the call to panda.virtual_memory_read fails (e.g., if you pass a
        pointer to an unmapped page)
        &#39;&#39;&#39;
        r = b&#34;&#34;
        while True:
            next_char = self.virtual_memory_read(cpu, ptr, 1) # If this raises an exn, don&#39;t mask it
            if next_char == b&#34;\x00&#34;:
                break
            r += next_char
            ptr += 1
        return r.decode(&#34;utf8&#34;, &#34;ignore&#34;)

    def to_unsigned_guest(self, x):
        &#39;&#39;&#39;
        Convert a singed python int to an unsigned int32/unsigned int64
        depending on guest bit-size
        &#39;&#39;&#39;
        import ctypes
        if self.bits == 32:
            return ctypes.c_uint32(x).value
        elif self.bits == 64:
            return ctypes.c_uint64(x).value
        else:
            raise ValueError(&#34;Unsupported number of bits&#34;)

    def from_unsigned_guest(self, x):
        &#39;&#39;&#39;
        Convert an unsigned int32/unsigned int64 from the guest
        (depending on guest bit-size) to a (signed) python int
        &#39;&#39;&#39;
        if x &gt;= 2**(self.bits-1): # If highest bit is set, it&#39;s negative
            return (x - 2**self.bits)
        else: # Else it&#39;s positive
            return x

    def queue_blocking(self, func, queue=True):
        &#34;&#34;&#34;
        Decorator to mark a function as `blocking`, and by default queue it to run asynchronously

        ```
        @panda.queue_blocking
        def do_something():
            panda.revert_sync(&#39;root&#39;)
            print(panda.run_serial_cmd(&#39;whoami&#39;))
            panda.end_analysis()
        ```

        is equivalent to

        ```
        @blocking
        def run_whoami():
            panda.revert_sync(&#39;root&#39;)
            print(panda.run_serial_cmd(&#39;whoami&#39;))
            panda.end_analysis()

        panda.queue_async(run_whoami)
        ```

        &#34;&#34;&#34;
        f = blocking(func)
        if queue:
            self.queue_async(f)
        return f


    ########################## LIBPANDA FUNCTIONS ########################
    # Methods that directly pass data to/from PANDA with no extra logic beyond argument reformatting.
    def set_pandalog(self, name):
        &#39;&#39;&#39;
        Enable recording to a pandalog (plog) named `name`

            Parameters:
                name: file to output data to
            
            Returns:
                None
        &#39;&#39;&#39;
        charptr = ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
        self.libpanda.panda_start_pandalog(charptr)

    def enable_memcb(self):
        &#39;&#39;&#39;
        Enable memory callbacks. Must be called for memory callbacks to work.
        pypanda enables this automatically with some callbacks.
        &#39;&#39;&#39;
        self._memcb = True
        self.libpanda.panda_enable_memcb()
    
    def disable_memcb(self):
        &#39;&#39;&#39;
        Disable memory callbacks. Must be enabled for memory callbacks to work.
        pypanda enables this automatically with some callbacks.
        &#39;&#39;&#39;
        self._memcb = False
        self.libpanda.panda_disable_memcb()

    def virt_to_phys(self, env, addr):
        &#39;&#39;&#39;
        Convert virtual address to physical address.

            Parameters:
                env: CPUState struct
                addr (int): virtual address to convert
            
            Return:
                physical address as python int
        &#39;&#39;&#39;
        return self.libpanda.panda_virt_to_phys_external(env, addr)

    def enable_plugin(self, handle):
        &#39;&#39;&#39;
        Enable plugin.

            Parameters:
                handle: pointer to handle returned by plugin
            
            Return:
                None
        &#39;&#39;&#39;
        self.libpanda.panda_enable_plugin(handle)

    def disable_plugin(self, handle):
        &#39;&#39;&#39;
        Disable plugin.

            Parameters:
                handle: pointer to handle returned by plugin
            
            Return:
                None
        &#39;&#39;&#39;
        self.libpanda.panda_disable_plugin(handle)

    def enable_llvm(self):
        &#39;&#39;&#39;
        Enables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend. 
        &#39;&#39;&#39;
        self.libpanda.panda_enable_llvm()

    def disable_llvm(self):
        &#39;&#39;&#39;
        Disables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend. 
        &#39;&#39;&#39;
        self.libpanda.panda_disable_llvm()

    def enable_llvm_helpers(self):
        &#39;&#39;&#39;
        Enables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend. 
        &#39;&#39;&#39;
        self.libpanda.panda_enable_llvm_helpers()

    def disable_llvm_helpers(self):
        &#39;&#39;&#39;
        Disables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend. 
        &#39;&#39;&#39;
        self.libpanda.panda_disable_llvm_helpers()

    def flush_tb(self):
        &#39;&#39;&#39;
        This function requests that the translation block cache be flushed as soon as possible. If running with translation block chaining turned off (e.g. when in LLVM mode or replay mode), this will happen when the current translation block is done executing.
        Flushing the translation block cache is additionally necessary if the plugin makes changes to the way code is translated. For example, by using panda_enable_precise_pc.
        &#39;&#39;&#39;
        return self.libpanda.panda_flush_tb()

    def enable_precise_pc(self):
        &#39;&#39;&#39;
        By default, QEMU does not update the program counter after every instruction.
        This function enables precise tracking of the program counter. After enabling precise PC tracking, the program counter will be available in env-&gt;panda_guest_pc and can be assumed to accurately reflect the guest state.
        &#39;&#39;&#39;
        self.libpanda.panda_enable_precise_pc()

    def disable_precise_pc(self):
        &#39;&#39;&#39;
        By default, QEMU does not update the program counter after every instruction.
        This function disables precise tracking of the program counter.
        &#39;&#39;&#39;
        self.libpanda.panda_disable_precise_pc()

    def in_kernel(self, cpustate):
        &#39;&#39;&#39;
        Returns true if the processor is in the privilege level corresponding to executing kernel code for any of the PANDA supported architectures.
        &#39;&#39;&#39;
        return self.libpanda.panda_in_kernel_external(cpustate)

    def g_malloc0(self, size):
        &#39;&#39;&#39;
        Helper function to call glib malloc

            Parameters:
                size: size to call with malloc
            
            Returns:
                buffer of that size from malloc
        &#39;&#39;&#39;
        return self.libpanda.g_malloc0(size)

    def current_sp(self, cpustate):
        &#39;&#39;&#39;
        Get current stack pointer

            Parameters:
                cpustate: CPUState struct

            Return:
                integer value of stack pointer
        &#39;&#39;&#39;
        return self.libpanda.panda_current_sp_external(cpustate)

    def current_pc(self, cpustate):
        &#39;&#39;&#39;
        Get current program counter

            Parameters:
                cpustate: CPUState struct

            Return:
                integer value of current program counter

            .. Deprecated:: Use panda.arch.get_pc(cpu) instead
        &#39;&#39;&#39;
        return self.libpanda.panda_current_pc(cpustate)


    def current_asid(self, cpustate):
        &#39;&#39;&#39;
        Get current Application Specific ID
            
            Parameters:
                cpustate: CPUState struct

            Return:
                integer value of current ASID
        &#39;&#39;&#39;
        return self.libpanda.panda_current_asid(cpustate)

    def disas2(self, code, size):
        &#39;&#39;&#39;
        Call panda_disas to diasassemble an amount of code at a pointer.
        FIXME: seem to not match up to PANDA definition
        &#39;&#39;&#39;
        self.libpanda.panda_disas(code, size)

    def cleanup(self):
        &#39;&#39;&#39;
        Unload all plugins and close pandalog.
        &#39;&#39;&#39;
        self.libpanda.panda_cleanup()

    def was_aborted(self):
        &#39;&#39;&#39;
        Returns true if panda was aborted.
        &#39;&#39;&#39;
        return self.libpanda.panda_was_aborted()

    def get_cpu(self):
        &#39;&#39;&#39;
        This function returns first_cpu CPUState object from QEMU.
        XXX: You rarely want this
        &#39;&#39;&#39;
        return self.libpanda.get_cpu()

    def garray_len(self, garray):
        &#39;&#39;&#39;
        Convenience function to get array length of glibc array.
        &#39;&#39;&#39;
        return self.libpanda.garray_len(garray)

    def panda_finish(self):
        &#39;&#39;&#39;
        Final stage call to underlying panda_finish with initialization.
        &#39;&#39;&#39;
        return self.libpanda.panda_finish()

    def rr_get_guest_instr_count(self):
        &#39;&#39;&#39;
        Returns record/replay guest instruction count.
        &#39;&#39;&#39;
        return self.libpanda.rr_get_guest_instr_count_external()

    ################### LIBQEMU Functions ############
    #Methods that directly pass data to/from QEMU with no extra logic beyond argument reformatting.
    #All QEMU function can be directly accessed by Python. These are here for convenience.
    # It&#39;s usally better to find a function name and look at the QEMU source for these functions.

    def drive_get(self, blocktype, bus, unit):
        &#39;&#39;&#39;
        Gets DriveInfo struct from user specified information.

            Parameters:
                blocktype: BlockInterfaceType structure
                bus: integer bus
                unit: integer unit
            
            Return:
                DriveInfo struct
        &#39;&#39;&#39;
        return self.libpanda.drive_get(blocktype,bus,unit)

    def sysbus_create_varargs(self, name, addr):
        &#39;&#39;&#39;
        Returns DeviceState struct from user specified information
        Calls sysbus_create_varargs QEMU function.

            Parameters:
                name: python string
                addr: python integer representing hwaddr
            
            Return:
                DeviceState struct
        &#39;&#39;&#39;
        return self.libpanda.sysbus_create_varargs(name,addr,ffi.NULL)

    def cpu_class_by_name(self, name, cpu_model):
        &#39;&#39;&#39;
        Gets cpu class from name.
        Calls cpu_class_by_name QEMU function.

            Parameters:
                name: typename from python string
                cpu_model: string specified cpu model

            Returns:
                ObjectClass struct
        &#39;&#39;&#39;
        return self.libpanda.cpu_class_by_name(name, cpu_model)

    def object_class_by_name(self, name):
        &#39;&#39;&#39;
        Returns class as ObjectClass from name specified.
        Calls object_class_by_name QEMU function.

            Parameters:
                name: string defined by user
            
            Returns:
                struct as specified by name
        &#39;&#39;&#39;
        return self.libpanda.object_class_by_name(name)

    def object_property_set_bool(self, obj, value, name):
        &#39;&#39;&#39;
        Writes a bool value to a property.
        Calls object_property_set_bool QEMU function.

            Parameters:
                value: the value to be written to the property
                name: the name of the property
                errp: returns an error if this function fails

            Returns:
                None
        &#39;&#39;&#39;
        return self.libpanda.object_property_set_bool(obj,value,name,self.libpanda.error_abort)

    def object_class_get_name(self, objclass):
        &#39;&#39;&#39;
        Gets String QOM typename from object class.
        Calls object_class_get_name QEMU function.

            Parameters:
                objclass: class to obtain the QOM typename for.

            Returns: 
                String QOM typename for klass.
        &#39;&#39;&#39;
        return self.libpanda.object_class_get_name(objclass)

    def object_new(self, name):
        &#39;&#39;&#39;
        Creates a new object from typename.
        This function will initialize a new object using heap allocated memory.
        The returned object has a reference count of 1, and will be freed when
        the last reference is dropped.
        Calls object_new QEMU function.
            
            Parameters:
                name: The name of the type of the object to instantiate.
            
            Returns: 
                The newly allocated and instantiated object.
        &#39;&#39;&#39;
        return self.libpanda.object_new(name)

    def object_property_get_bool(self, obj, name):
        &#39;&#39;&#39;
        Pull boolean from object.
        Calls object_property_get_bool QEMU function.

            Parameters:
                obj: the object
                name: the name of the property
            
            Returns: 
                the value of the property, converted to a boolean, or NULL if an error occurs (including when the property value is not a bool).
        &#39;&#39;&#39;
        return self.libpanda.object_property_get_bool(obj,name,self.libpanda.error_abort)

    def object_property_set_int(self,obj, value, name):
        &#39;&#39;&#39;
        Set integer in QEMU object. Writes an integer value to a property.   
        Calls object_property_set_int QEMU function.
        
            Parameters:
                value: the value to be written to the property
                name: the name of the property
            
            Returns:
                None
        &#39;&#39;&#39;
        return self.libpanda.object_property_set_int(obj, value, name, self.libpanda.error_abort)

    def object_property_get_int(self, obj, name):
        &#39;&#39;&#39;
        Gets integer in QEMU object. Reads an integer value from this property.   
        Calls object_property_get_int QEMU function.

            Paramaters:
                obj: the object
                name: the name of the property
            
            Returns: 
                the value of the property, converted to an integer, or negative if an error occurs (including when the property value is not an integer).
        &#39;&#39;&#39;
        return self.libpanda.object_property_get_int(obj, name, self.libpanda.error_abort)

    def object_property_set_link(self, obj, val, name):
        &#39;&#39;&#39;
        Writes an object&#39;s canonical path to a property.
        Calls object_property_set_link QEMU function.

            Parameters:
                value: the value to be written to the property
                name: the name of the property
                errp: returns an error if this function fails

            Returns:
                None
        &#39;&#39;&#39;
        return self.libpanda.object_property_set_link(obj,val,name,self.libpanda.error_abort)

    def object_property_get_link(self, obj, name):
        &#39;&#39;&#39;
        Reads an object&#39;s canonical path to a property.
        Calls object_property_get_link QEMU function.
    
            Parameters:
                obj: the object
                name: the name of the property
                errp: returns an error if this function fails
            
            Returns:
                the value of the property, resolved from a path to an Object, or NULL if an error occurs (including when the property value is not a string or not a valid object path).
        &#39;&#39;&#39;
        return self.libpanda.object_property_get_link(obj,name,self.libpanda.error_abort)

    def object_property_find(self, obj, name):
        &#39;&#39;&#39;
        Look up a property for an object and return its #ObjectProperty if found.
        Calls object_property_find QEMU function.

            Parameters:
                obj: the object
                name: the name of the property
                errp: returns an error if this function fails
            
            Returns:
                struct ObjectProperty pointer
        &#39;&#39;&#39;
        return self.libpanda.object_property_find(obj,name,ffi.NULL)

    def memory_region_allocate_system_memory(self, mr, obj, name, ram_size):
        &#39;&#39;&#39;
        Allocates Memory region by user specificiation.
        Calls memory_region_allocation_system_memory QEMU function.

            Parameters:
                mr: MemoryRegion struct
                obj: Object struct
                name: string of region name
                ram_size: int of ram size
            
            Returns:
                None
        &#39;&#39;&#39;
        return self.libpanda.memory_region_allocate_system_memory(mr, obj, name, ram_size)

    def memory_region_add_subregion(self, mr, offset, sr):
        &#39;&#39;&#39;
        Calls memory_region_add_subregion from QEMU.
        memory_region_add_subregion: Add a subregion to a container.
        
        Adds a subregion at @offset.  The subregion may not overlap with other
        subregions (except for those explicitly marked as overlapping).  A region
        may only be added once as a subregion (unless removed with
        memory_region_del_subregion()); use memory_region_init_alias() if you
        want a region to be a subregion in multiple locations.
        
            Parameters:
                mr: the region to contain the new subregion; must be a container initialized with memory_region_init().
                offset: the offset relative to @mr where @subregion is added.
                subregion: the subregion to be added.
            
            Returns: 
                None
        &#39;&#39;&#39;
        return self.libpanda.memory_region_add_subregion(mr,offset,sr)

    def memory_region_init_ram_from_file(self, mr, owner, name, size, share, path):
        &#39;&#39;&#39;
        Calls memory_region_init_ram_from_file from QEMU.
        memory_region_init_ram_from_file:  Initialize RAM memory region with a mmap-ed backend.
        
            Parameters:
                mr: the #MemoryRegion to be initialized.
                owner: the object that tracks the region&#39;s reference count
                name: the name of the region.
                size: size of the region.
                share: %true if memory must be mmaped with the MAP_SHARED flag
                path: the path in which to allocate the RAM.
                errp: pointer to Error*, to store an error if it happens.
            
            Returns:
                None
        &#39;&#39;&#39;
        return self.libpanda.memory_region_init_ram_from_file(mr, owner, name, size, share, path, self.libpanda.error_fatal)

    def create_internal_gic(self, vbi, irqs, gic_vers):
        return self.libpanda.create_internal_gic(vbi, irqs, gic_vers)

    def create_one_flash(self, name, flashbase, flashsize, filename, mr):
        return self.libpanda.create_one_flash(name, flashbase, flashsize, filename, mr)

    def create_external_gic(self, vbi, irqs, gic_vers, secure):
        return self.libpanda.create_external_gic(vbi, irqs, gic_vers, secure)

    def create_virtio_devices(self, vbi, pic):
        return self.libpanda.create_virtio_devices(vbi, pic)

    def arm_load_kernel(self, cpu, bootinfo):
        return self.libpanda.arm_load_kernel(cpu, bootinfo)

    def error_report(self, s):
        return self.libpanda.error_report(s)

    def get_system_memory(self):
        return self.libpanda.get_system_memory()

    def lookup_gic(self,n):
        return self.libpanda.lookup_gic(n)

    ##################### OSI FUNCTIONS ###########
    #Convenience functions to interact with the Operating System Instrospection (OSI) class of plugins.

    def set_os_name(self, os_name):
        &#34;&#34;&#34;
        Set OS target. Equivalent to &#34;-os&#34; flag on the command line. Matches the form of:
        
            &#34;windows[-_]32[-_]xpsp[23]&#34;,
            &#34;windows[-_]32[-_]7&#34;,
            &#34;windows[-_]32[-_]2000&#34;,
            &#34;linux[-_]32[-_].+&#34;,
            &#34;linux[-_]64[-_].+&#34;,

            Parameters:
                os_name: string matching the format for the os flag.
            
            Returns:
                None
        &#34;&#34;&#34;
        os_name_new = ffi.new(&#34;char[]&#34;, bytes(os_name, &#34;utf-8&#34;))
        self.libpanda.panda_set_os_name(os_name_new)


    def get_mappings(self, cpu):
        &#39;&#39;&#39;
        Get all active memory mappings in the system.

            Requires: OSI

            Parameters:
                cpu: CPUState struct

            Returns:
                Iterator of `OsiModule` structures
        &#39;&#39;&#39;
        current = self.plugins[&#39;osi&#39;].get_current_process(cpu)
        maps = self.plugins[&#39;osi&#39;].get_mappings(cpu, current)
        map_len = self.garray_len(maps)
        return GArrayIterator(self.plugins[&#39;osi&#39;].get_one_module, maps, map_len, self.plugins[&#39;osi&#39;].cleanup_garray)

    def get_processes(self, cpu):
        &#39;&#39;&#39;
        Get all running processes in the system. Includes kernel modules on Linux.

            Requires: OSI

            Parameters:
                cpu: CPUState struct

            Returns:
                Iterator of `OsiProc` structures
        &#39;&#39;&#39;
        processes = self.plugins[&#39;osi&#39;].get_processes(cpu)
        processes_len = self.garray_len(processes)
        return GArrayIterator(self.plugins[&#39;osi&#39;].get_one_proc, processes, processes_len, self.plugins[&#39;osi&#39;].cleanup_garray)

    def get_processes_dict(self, cpu):
        &#39;&#39;&#39;
        Get all running processes for the system at this moment in time as a dictionary.

        The dictionary maps proceses by their PID. Each mapping returns a dictionary containing the process name, its pid,
        and its parent pid (ppid).

            Requires: OSI

            Parameters:
                cpu: CPUState struct

            Returns:
                Dictionary as described above.
        &#39;&#39;&#39;

        procs = {} #pid: {name: X, pid: Y, parent_pid: Z})

        for proc in self.get_processes(cpu):
            assert(proc != ffi.NULL)
            assert(proc.pid not in procs)
            procs[proc.pid] = {&#34;name&#34;: ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;), &#39;pid&#39;: proc.pid, &#39;parent_pid&#39;: proc.ppid}
            assert(not (proc.pid != 0 and proc.pid == proc.ppid)) # No cycles allowed other than at 0
        return procs

    def get_process_name(self, cpu):
        &#39;&#39;&#39;
        Get the name of the current process. May return None if OSI cannot identify the current process
        &#39;&#39;&#39;
        proc = self.plugins[&#39;osi&#39;].get_current_process(cpu)
        if proc == ffi.NULL or proc.name == ffi.NULL:
            return None

        procname = ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;)
        return ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;)


    ################## PYPERIPHERAL FUNCTIONS #####################
    # Pyperipherals are objects which handle mmio read/writes using the PANDA callback infrastructure.
    # Under the hood, they use the cb_unassigned_io_read/cb_unassigned_io_write callbacks.
    # A python peripheral itself is an object which exposes the following functions:
    #     write_memory(self, address, size, value)
    #     read_memory(self, address, size)
    # And has at least the following attributes:
    #     address
    #     size

    # One example for such a python object are avatar2&#39;s AvatarPeripheral.
    def _addr_to_pyperipheral(self, address):
        &#34;&#34;&#34;
        Returns the python peripheral for a given address, or None if no
        peripheral is registered for that address
        &#34;&#34;&#34;

        for pp in self.pyperipherals:
            if pp.address &lt;= address &lt; pp.address + pp.size:
                return pp
        return None

    def _validate_object(self, object):
        # This function makes sure that the object exposes the right interfaces

        if not hasattr(object, &#34;address&#34;) or not isinstance(object.address, int):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing or non-int `address` attribute&#34;
                ).format(str(object.__repr__()))
            )

        if not hasattr(object, &#34;size&#34;) or not isinstance(object.size, int):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing or non-int `address` attribute&#34;
                ).format(object.__repr__())
            )

        if not hasattr(object, &#34;read_memory&#34;):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing read_memory function&#34;
                ).format(object.__repr__())
            )

        params = list(signature(object.read_memory).parameters)
        if params[0] != &#34;address&#34; or params[1] != &#34;size&#34;:
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Invalid function signature for read_memory&#34;
                ).format(object.__repr__())
            )

        if not hasattr(object, &#34;write_memory&#34;):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing write_memory function&#34;
                ).format(object.__repr__())
            )

        params = list(signature(object.write_memory).parameters)
        if params[0] != &#34;address&#34; or params[1] != &#34;size&#34; or params[2] != &#34;value&#34;:
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Invalid function signature for write_memory&#34;
                ).format(object.__repr__())
            )

        # Ensure object is not overlapping with any other pyperipheral
        if (
            self._addr_to_pyperipheral(object.address) is not None
            or self._addr_to_pyperipheral(object.address + object.size) is not None
        ):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34; &#34;Overlapping memories!&#34;
                ).format(object.__repr__())
            )

        return True

    def pyperiph_read_cb(self, cpu, pc, physaddr, size, val_ptr):
        pp = self._addr_to_pyperipheral(physaddr)
        if pp is None:
            return False

        val = pp.read_memory(physaddr, size)
        buf = ffi.buffer(val_ptr, size)

        fmt = &#34;{}{}&#34;.format(self._end2fmt[self.endianness], self._num2fmt[size])

        pack_into(fmt, buf, 0, val)

        return True

    def pyperiph_write_cb(self, cpu, pc, physaddr, size, val):
        pp = self._addr_to_pyperipheral(physaddr)
        if pp is None:
            return False

        pp.write_memory(physaddr, size, val)
        return True

    def register_pyperipheral(self, object):
        &#34;&#34;&#34;
        Registers a python peripheral, and the necessary attributes to the
        panda-object, if not present yet.
        &#34;&#34;&#34;

        # if we are the first pyperipheral, register the pp-dict
        if not hasattr(self, &#34;pyperipherals&#34;):
            self.pyperipherals = []
            self.pyperipherals_registered_cb = False
            self._num2fmt = {1: &#34;B&#34;, 2: &#34;H&#34;, 4: &#34;I&#34;, 8: &#34;Q&#34;}
            self._end2fmt = {&#34;little&#34;: &#34;&lt;&#34;, &#34;big&#34;: &#34;&gt;&#34;}

        self._validate_object(object)

        if self.pyperipherals_registered_cb is False:
            self.register_callback(
                self.callback.unassigned_io_read,
                self.callback.unassigned_io_read(self.pyperiph_read_cb),
                &#34;pyperipheral_read_callback&#34;,
            )

            self.register_callback(
                self.callback.unassigned_io_write,
                self.callback.unassigned_io_write(self.pyperiph_write_cb),
                &#34;pyperipheral_write_callback&#34;,
            )

            self.pyperipherals_registered_cb = True

        self.pyperipherals.append(object)

    def unregister_pyperipheral(self, pyperiph):
        &#34;&#34;&#34;
        deregisters a python peripheral.
        The pyperiph parameter can be either an object, or an address
        Returns true if the pyperipheral was successfully removed, else false.
        &#34;&#34;&#34;

        if isinstance(pyperiph, int) is True:
            pp = self._addr_to_pyperipheral(pyperiph)
            if pp is None:
                return False
        else:
            if pyperiph not in self.pyperipherals:
                return False
            pp = pyperiph

        self.pyperipherals.remove(pp)

        # If we dont have any pyperipherals left, unregister callbacks
        if len(self.pyperipherals) == 0:
            self.disable_callback(&#34;pyperipheral_read_callback&#34;, forever=True)
            self.disable_callback(&#34;pyperipheral_write_callback&#34;, forever=True)
            self.pyperipherals_registered_cb = False
        return True

    ############## TAINT FUNCTIONS ###############
    # Convenience methods for interacting with the taint subsystem.
    def taint_enable(self, cont=True):
        &#34;&#34;&#34;
        Inform python that taint is enabled.
        &#34;&#34;&#34;
        if not self.taint_enabled:
            progress(&#34;taint not enabled -- enabling&#34;)
            self.vm_stop()
            self.require(&#34;taint2&#34;)
#            self.queue_main_loop_wait_fn(self.require, [&#34;taint2&#34;])
            self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_enable_taint, [])
            if cont:
                self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])
            self.taint_enabled = True

    # label all bytes in this register.
    # or at least four of them
    def taint_label_reg(self, reg_num, label):
        self.taint_enable(cont=False)
        #if debug:
        #    progress(&#34;taint_reg reg=%d label=%d&#34; % (reg_num, label))

        # XXX must ensure labeling is done in a before_block_invalidate that rets 1
        #     or some other safe way where the main_loop_wait code will always be run
        #self.stop()
        for i in range(self.register_size):
            self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_label_reg, [reg_num, i, label])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])

    def taint_label_ram(self, addr, label):
        self.taint_enable(cont=False)
        #if debug:
            #progress(&#34;taint_ram addr=0x%x label=%d&#34; % (addr, label))

        # XXX must ensure labeling is done in a before_block_invalidate that rets 1
        #     or some other safe way where the main_loop_wait code will always be run
        #self.stop()
        self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_label_ram, [addr, label])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])

    # returns true if any bytes in this register have any taint labels
    def taint_check_reg(self, reg_num):
        if not self.taint_enabled: return False
#        if debug:
#            progress(&#34;taint_check_reg %d&#34; % (reg_num))
        for offset in range(self.register_size):
            if self.plugins[&#39;taint2&#39;].taint2_query_reg(reg_num, offset) &gt; 0:
                return True

    # returns true if this physical address is tainted
    def taint_check_ram(self, addr):
        if not self.taint_enabled: return False
        if self.plugins[&#39;taint2&#39;].taint2_query_ram(addr) &gt; 0:
            return True

    def taint_get_reg(self, reg_num):
        &#39;&#39;&#39;
        Returns array of results, one for each byte in this register
        None if no taint.  QueryResult struct otherwise
        &#39;&#39;&#39;
        if not self.taint_enabled: return None
        if debug:
            progress(&#34;taint_get_reg %d&#34; % (reg_num)) 
        res = []
        for offset in range(self.register_size): 
            if self.plugins[&#39;taint2&#39;].taint2_query_reg(reg_num, offset) &gt; 0:
                query_res = ffi.new(&#34;QueryResult *&#34;)
                self.plugins[&#39;taint2&#39;].taint2_query_reg_full(reg_num, offset, query_res)
                tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;])
                res.append(tq)
            else:
                res.append(None)
        return res

    # returns array of results, one for each byte in this register
    # None if no taint.  QueryResult struct otherwise
    def taint_get_ram(self, addr):
        if not self.taint_enabled: return None
        if self.plugins[&#39;taint2&#39;].taint2_query_ram(addr) &gt; 0:
            query_res = ffi.new(&#34;QueryResult *&#34;)
            self.plugins[&#39;taint2&#39;].taint2_query_ram_full(addr, query_res)
            tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;])
            return tq
        else:
            return None

    # returns true if this laddr is tainted
    def taint_check_laddr(self, addr, off):
        if not self.taint_enabled: return False
        if self.plugins[&#39;taint2&#39;].taint2_query_laddr(addr, off) &gt; 0:
            return True

    # returns array of results, one for each byte in this laddr
    # None if no taint.  QueryResult struct otherwise
    def taint_get_laddr(self, addr, offset):
        if not self.taint_enabled: return None
        if self.plugins[&#39;taint2&#39;].taint2_query_laddr(addr, offset) &gt; 0:
            query_res = ffi.new(&#34;QueryResult *&#34;)
            self.plugins[&#39;taint2&#39;].taint2_query_laddr_full(addr, offset, query_res)
            tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;])
            return tq
        else:
            return None

    ############ Volatility mixins
    &#34;&#34;&#34;
    Utilities to integrate Volatility with PANDA. Highly experimental.
    &#34;&#34;&#34;

    def make_panda_file_handler(self, debug=False):
        &#39;&#39;&#39;
        Constructs a file and file handler that volatility can&#39;t ignore to back by PANDA physical memory
        &#39;&#39;&#39;
        from urllib.request import BaseHandler
        if &#39;PandaFileHandler&#39; in globals():  # already initialized
            return
        panda = self

        class PandaFile(object):
            def __init__(self, length, panda):
                self.pos = 0
                self.length = length
                self.closed = False
                self.mode = &#34;rb&#34;
                self.name = &#34;/tmp/panda.panda&#34;
                self.panda = panda
                self.classname = type(self).__name__

            def readable(self):
                return self.closed

            def read(self, size=1):
                if self.panda.bits == 32 and self.panda.arch_name == &#34;i386&#34;:
                    data = self.panda.physical_memory_read(
                        self.pos &amp; 0xfffffff, size)
                else:
                    data = self.panda.physical_memory_read(self.pos, size)
                if debug:
                    print(self.classname+&#34;: Reading &#34; +
                          str(size)+&#34; bytes from &#34;+hex(self.pos))
                self.pos += size
                return data

            def peek(self, size=1):
                return self.panda.physical_memory_read(self.pos, size)

            def seek(self, pos, whence=0):
                if whence == 0:
                    self.pos = pos
                elif whence == 1:
                    self.pos += pos
                else:
                    self.pos = self.length - pos
                if self.pos &gt; self.length:
                    print(self.classname+&#34;: We&#39;ve gone off the deep end&#34;)
                if debug:
                    print(self.classname+&#34; Seeking to address &#34;+hex(self.pos))

            def tell(self):
                return self.pos

            def close(self):
                self.closed = True

        class PandaFileHandler(BaseHandler):
            def default_open(self, req):
                if &#39;panda.panda&#39; in req.full_url:
                    length = panda.libpanda.ram_size
                    if length &gt; 0xc0000000:
                        length += 0x40000000  # 3GB hole
                    if debug:
                        print(type(self).__name__ +
                              &#34;: initializing PandaFile with length=&#34;+hex(length))
                    return PandaFile(length=length, panda=panda)
                else:
                    return None

            def file_close(self):
                return True

        globals()[&#34;PandaFileHandler&#34;] = PandaFileHandler

    def get_volatility_symbols(self, debug=False):
        try:
            from .volatility_cli_classes import CommandLineMoreEfficient
            from volatility.framework import contexts
            from volatility.framework.layers.linear import LinearlyMappedLayer
            from volatility.framework.automagic import linux
        except ImportError:
            print(&#34;Warning: Failed to import volatility&#34;)
            return None
        if &#34;linux&#34; in self.os_type:
            if not hasattr(self, &#34;_vmlinux&#34;):
                self.make_panda_file_handler(debug=debug)
                constructed_original = CommandLineMoreEfficient().run()
                linux.LinuxUtilities.aslr_mask_symbol_table(
                    constructed_original.context, constructed_original.config[&#39;vmlinux&#39;], constructed_original.config[&#39;primary&#39;])
                self._vmlinux = contexts.Module(
                    constructed_original.context, constructed_original.config[&#39;vmlinux&#39;], constructed_original.config[&#39;primary&#39;], 0)
            else:
                LinearlyMappedLayer.read.cache_clear()  # smearing technique
            return self._vmlinux
        else:
            print(&#34;Unsupported.&#34;)
            return None

    def run_volatility(self, plugin, debug=False):
        try:
            from .volatility_cli_classes import CommandLineRunFullCommand, StringTextRenderer
        except ImportError:
            print(&#34;Warning: Failed to import volatility&#34;)
            return None
        self.make_panda_file_handler(debug=debug)
        cmd = CommandLineRunFullCommand().run(&#34;-q -f panda.panda &#34; + plugin)
        output = StringTextRenderer().render(cmd.run())
        return output

    ########## BLOCKING MIXINS ############
    &#39;&#39;&#39;
    Utilities to provide blocking interactions with PANDA. This includes serial and monitor interactions as well as file copy to the guest.
    XXX: Do not call any of the following from the main thread- they depend on the CPU loop running
    &#39;&#39;&#39;
    @blocking
    def stop_run(self):
        &#39;&#39;&#39;
        From a blocking thread, request vl.c loop to break. Returns control flow in main thread.
        In other words, once this is called, panda.run() will finish and your main thread will continue.
        If you also want to unload plugins, use end_analysis instead

        XXX: This doesn&#39;t work in replay mode
        &#39;&#39;&#39;
        self.libpanda.panda_break_vl_loop_req = True

    @blocking
    def run_serial_cmd(self, cmd, no_timeout=False, timeout=30):
        self.running.wait() # Can only run serial when guest is running
        self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
        if no_timeout:
            result = self.serial_console.expect(timeout=9999)
        else:
            result = self.serial_console.expect(timeout=timeout)
        return result

    @blocking
    def run_serial_cmd_async(self, cmd, delay=1):
        &#39;&#39;&#39;
        Type a command and press enter in the guest. Return immediately. No results available
        Only use this if you know what you&#39;re doing!
        &#39;&#39;&#39;
        self.running.wait() # Can only run serial when guest is running
        self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
        if delay:
            sleep(delay) # Ensure it has a chance to run

    @blocking
    def type_serial_cmd(self, cmd):
        #Can send message into socket without guest running (no self.running.wait())
        self.serial_console.send(cmd.encode(&#34;utf8&#34;)) # send, not sendline

    def finish_serial_cmd(self):
        result = self.serial_console.send_eol()
        result = self.serial_console.expect()
        return result

    @blocking
    def run_monitor_cmd(self, cmd):
        self.monitor_console.sendline(cmd.encode(&#34;utf8&#34;))
        result = self.monitor_console.expect()
        return result

    @blocking
    def revert_sync(self, snapshot_name):
        result = self.run_monitor_cmd(&#34;loadvm {}&#34;.format(snapshot_name))
        if result.startswith(&#34;Length mismatch&#34;):
            raise RuntimeError(&#34;QEMU machine&#39;s RAM size doesn&#39;t match snapshot RAM size!&#34;)
        return result

    @blocking
    def delvm_sync(self, snapshot_name):
        self.run_monitor_cmd(&#34;delvm {}&#34;.format(snapshot_name))

    @blocking
    def copy_to_guest(self, copy_directory, iso_name=None):
        if not iso_name: iso_name = copy_directory + &#39;.iso&#39;
        progress(&#34;Creating ISO {}...&#34;.format(iso_name))

        make_iso(copy_directory, iso_name)

        copy_directory = path.split(copy_directory)[-1] # Get dirname

        # 1) we insert the CD drive TODO: the cd-drive name should be a config option, see the values in qcow.py
        self.run_monitor_cmd(&#34;change ide1-cd0 \&#34;{}\&#34;&#34;.format(iso_name))

        # 2) run setup script
        # setup_sh: 
        #   Make sure cdrom didn&#39;t automount
        #   Make sure guest path mirrors host path
        #   if there is a setup.sh script in the directory,
        #   then run that setup.sh script first (good for scripts that need to
        #   prep guest environment before script runs)
        setup_sh = &#34;mkdir -p {mount_dir}; while ! mount /dev/cdrom {mount_dir}; do sleep 0.3; &#34; \
               &#34; umount /dev/cdrom; done; {mount_dir}/setup.sh &amp;&gt; /dev/null || true &#34; \
               .format(mount_dir = (shlex_quote(copy_directory)))
        progress(&#34;setup_sh = [%s] &#34; % setup_sh)
        progress(self.run_serial_cmd(setup_sh))

    @blocking
    def record_cmd(self, guest_command, copy_directory=None, iso_name=None, setup_command=None, recording_name=&#34;recording&#34;, snap_name=&#34;root&#34;, ignore_errors=False):
        &#39;&#39;&#39;
        Take a recording as follows:
            0) Revert to the specified snapshot name if one is set. By default &#39;root&#39;. Set to `None` if you have already set up the guest and are ready to record with no revert
            1) Create an ISO of files that need to be copied into the guest if copy_directory is specified. Copy them in
            2) Run the setup_command in the guest, if provided
            3) Type the command you wish to record but do not press enter to begin execution. This avoids the recording capturing the command being typed
            4) Begin the recording (name controlled by recording_name)
            5) Press enter in the guest to begin the command. Wait until it finishes.
            6) End the recording
        &#39;&#39;&#39;
        # 0) Revert to the specified snapshot
        if snap_name is not None:
            self.revert_sync(snap_name) # Can&#39;t use self.revert because that would would run async and we&#39;d keep going before the revert happens

        # 1) Make copy_directory into an iso and copy it into the guest - It will end up at the exact same path
        if copy_directory: # If there&#39;s a directory, build an ISO and put it in the cddrive
            # Make iso
            self.copy_to_guest(copy_directory, iso_name)

        # 2) Run setup_command, if provided before we start the recording (good place to CD or install, etc)
        if setup_command:
            print(f&#34;Running setup command {setup_command}&#34;)
            r = self.run_serial_cmd(setup_command)
            print(f&#34;Setup command results: {r}&#34;)

        # 3) type commmand (note we type command, start recording, finish command)
        self.type_serial_cmd(guest_command)

        # 4) start recording
        self.run_monitor_cmd(&#34;begin_record {}&#34;.format(recording_name))

        # 5) finish command
        result = self.finish_serial_cmd()

        if debug:
            progress(&#34;Result of `{}`:&#34;.format(guest_command))
            print(&#34;\t&#34;+&#34;\n\t&#34;.join(result.split(&#34;\n&#34;))+&#34;\n&#34;)

        if &#34;No such file or directory&#34; in result and not ignore_errors:
            print(&#34;Bad output running command: {}&#34;.format(result))
            raise RuntimeError(&#34;Command not found while taking recording&#34;)

        if &#34;cannot execute binary file&#34; in result and not ignore_errors:
            print(&#34;Bad output running command: {}&#34;.format(result))
            raise RuntimeError(&#34;Could not execute binary while taking recording&#34;)

        # 6) End recording
        self.run_monitor_cmd(&#34;end_record&#34;)

        print(&#34;Finished recording&#34;)

    @blocking
    def interact(self, confirm_quit=True):
        &#39;&#39;&#39;
        Expose console interactively until user types pandaquit
        Must be run in blocking thread.

        TODO: This should probably repace self.serial_console with something
        that directly renders output to the user. Then we don&#39;t have to handle
        buffering and other problems. But we will need to re-enable the serial_console
        interface after this returns
        &#39;&#39;&#39;
        print(&#34;PANDA: entering interactive mode. Type pandaquit to exit&#34;)
        prompt = self.expect_prompt.decode(&#34;utf8&#34;) if self.expect_prompt  else &#34;$ &#34;
        if not prompt.endswith(&#34; &#34;): prompt += &#34; &#34;
        while True:
            cmd = input(prompt) # TODO: Strip all control characters - Ctrl-L breaks things
            if cmd.strip() == &#39;pandaquit&#39;:
                if confirm_quit:
                    q = input(&#34;PANDA: Quitting interactive mode. Are you sure? (y/n) &#34;)
                    if len(q) and q.lower()[0] == &#39;y&#39;:
                        break
                    else:
                        continue
                else: # No confirm - just break
                    break
            r = self.run_serial_cmd(cmd) # XXX: may timeout
            print(r)

    @blocking
    def do_panda_finish(self):
        &#39;&#39;&#39;
        Call panda_finish. Note this isn&#39;t really blocking - the
        guest should have exited by now, but queue this after
        (blocking) shutdown commands in our internal async queue
        so it must also be labeled as blocking.
        &#39;&#39;&#39;
#        assert (not self.running.is_set()), &#34;Can&#39;t finish while still running&#34;
        self.panda_finish()

    ################## CALLBACK FUNCTIONS ################
    # Mixin for handling callbacks and generation of decorators that allow users to register their own callbacks
    # such as panda.cb_before_block_exec()
    def register_cb_decorators(self):
        &#39;&#39;&#39;
        Setup callbacks and generate self.cb_XYZ functions for cb decorators
        XXX Don&#39;t add any other methods with names starting with &#39;cb_&#39;
        Callbacks can be called as @panda.cb_XYZ in which case they&#39;ll take default arguments and be named the same as the decorated function
        Or they can be called as @panda.cb_XYZ(name=&#39;A&#39;, procname=&#39;B&#39;, enabled=True). Defaults: name is function name, procname=None, enabled=True unless procname set
        &#39;&#39;&#39;
        for cb_name, pandatype in zip(self.callback._fields, self.callback):
            def closure(closed_cb_name, closed_pandatype): # Closure on cb_name and pandatype
                def f(*args, **kwargs):
                    if len(args): # Called as @panda.cb_XYZ without ()s- no arguments to decorator but we get the function name instead
                        # Call our decorator with only a name argument ON the function itself
                        fun = args[0]
                        return self._generated_callback(closed_pandatype, **{&#34;name&#34;: fun.__name__})(fun)
                    else:
                        # Otherwise, we were called as @panda.cb_XYZ() with potential args - Just return the decorator and it&#39;s applied to the function
                        return self._generated_callback(closed_pandatype, *args, **kwargs)
                return f

            setattr(self, &#39;cb_&#39;+cb_name, closure(cb_name, pandatype))

    def _generated_callback(self, pandatype, name=None, procname=None, enabled=True):
        &#39;&#39;&#39;
        Actual implementation of self.cb_XYZ. pandatype is pcb.XYZ
        name must uniquely describe a callback
        if procname is specified, callback will only be enabled when that asid is running (requires OSI support)
        &#39;&#39;&#39;

        if procname:
            enabled = False # Process won&#39;t be running at time 0 (probably)
            self._register_internal_asid_changed_cb()

        def decorator(fun):
            local_name = name  # We need a new varaible otherwise we have scoping issues with _generated_callback&#39;s name
            if name is None:
                local_name = fun.__name__
            
            # 0 works for all callbacks except void. We check later on
            # to see if we need to return None otherwise we return 0
            return_from_exception = 0

            def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
                try:
                    r = fun(*args, **kwargs)
                    #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                    #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    self.callback_exit_exception = e
                    self.end_analysis()
                    return return_from_exception

            cast_rc = pandatype(_run_and_catch)
            cast_rc_string = str(ffi.typeof(cast_rc))
            return_from_exception = 0
            if &#34;void(*)(&#34; in cast_rc_string:
                return_from_exception = None

            self.register_callback(pandatype, cast_rc, local_name, enabled=enabled, procname=procname)
            def wrapper(*args, **kw):
                return _run_and_catch(*args, **kw)
            return wrapper
        return decorator

    def _register_internal_asid_changed_cb(self):
        &#39;&#39;&#39;
        Call this function if you need procname filtering for callbacks. It enables
        an internal callback on asid_changed (and sometimes an after_block_exec cb)
        which will deteremine when the process name changes and enable/disable other callbacks
        that filter on process name.
        &#39;&#39;&#39;
        if self._registered_asid_changed_internal_cb: # Already registered these callbacks
            return

        @self.ppp(&#34;syscalls2&#34;, &#34;on_sys_brk_enter&#34;)
        def on_sys_brk_enter(cpu, pc, brk):
            name = self.get_process_name(cpu)
            asid = self.libpanda.panda_current_asid(cpu)
            if self.asid_mapping.get(asid, None) != name:
                self.asid_mapping[asid] = name
                self._procname_changed(cpu, name)

        @self.callback.after_block_exec
        def __get_pending_procname_change(cpu, tb, exit_code):
            if exit_code: # Didn&#39;t actually execute block
                return None
            if not self.in_kernel(cpu): # Once we&#39;re out of kernel code, grab procname
                process = self.plugins[&#39;osi&#39;].get_current_process(cpu)
                if process != ffi.NULL:
                    name = ffi.string(process.name).decode(&#34;utf8&#34;, &#34;ignore&#34;)
                else:
                    return None # Couldn&#39;t figure out the process
                asid = self.libpanda.panda_current_asid(cpu)
                self.asid_mapping[asid] = name
                self._procname_changed(cpu, name)
                self.disable_callback(&#39;__get_pending_procname_change&#39;) # Disabled to begin


        # Local function def
        @self.callback.asid_changed
        def __asid_changed(cpustate, old_asid, new_asid):
            &#39;&#39;&#39;
            When the ASID changes, check if we know its procname (in self.asid_mapping),
            if so, call panda._procname_changed(cpu, name). Otherwise, we enable __get_pending_procname_change CB, which
            waits until the procname changes. Then we grab the new procname, update self.asid_mapping and call
            panda._procname_changed(cpu, name)
            &#39;&#39;&#39;
            if old_asid == new_asid:
                return 0

            if new_asid not in self.asid_mapping: # We don&#39;t know this ASID-&gt;procname - turn on __get_pending_procname_change
                if not self.is_callback_enabled(&#39;__get_pending_procname_change&#39;):
                    self.enable_callback(&#39;__get_pending_procname_change&#39;)
            else: # We do know this ASID-&gt;procname, just call procname_changed
                self._procname_changed(cpustate, self.asid_mapping[new_asid])

            return 0

        self.register_callback(self.callback.asid_changed, __asid_changed, &#34;__asid_changed&#34;) # Always call on ASID change

        # This internal callback is only enabled on-demand (later) when we need to figure out ASID-&gt;procname mappings
        self.register_callback(self.callback.after_block_exec, __get_pending_procname_change, &#34;__get_pending_procname_change&#34;, enabled=False)

        self._registered_asid_changed_internal_cb = True

    def register_callback(self, callback, function, name, enabled=True, procname=None):
        # CB   = self.callback.main_loop_wait
        # func = main_loop_wait_cb
        # name = main_loop_wait

        if name in self.registered_callbacks:
            print(f&#34;Warning: replacing existing callback &#39;{name}&#39; since it was re-registered&#34;)
            self.delete_callback(name)

        cb = self.callback_dictionary[callback]

        # Generate a unique handle for each callback type using the number of previously registered CBs of that type added to a constant
        handle = ffi.cast(&#39;void *&#39;, 0x8888 + 100*len([x for x in self.registered_callbacks.values() if x[&#39;callback&#39;] == cb]))

        # XXX: We should have another layer of indirection here so we can catch
        #      exceptions raised during execution of the CB and abort analysis
        pcb = ffi.new(&#34;panda_cb *&#34;, {cb.name:function})

        if debug:
            progress(&#34;Registered function &#39;{}&#39; to run on callback {}&#34;.format(name, cb.name))

        self.libpanda.panda_register_callback_helper(handle, cb.number, pcb)
        self.registered_callbacks[name] = {&#34;procname&#34;: procname, &#34;enabled&#34;: True, &#34;callback&#34;: cb,
                           &#34;handle&#34;: handle, &#34;pcb&#34;: pcb, &#34;function&#34;: function} # XXX: if function is not saved here it gets GC&#39;d and everything breaks! Watch out!

        if not enabled: # Note the registered_callbacks dict starts with enabled true and then we update it to false as necessary here
            self.disable_callback(name)

        if &#34;block&#34; in cb.name:
            if not self.disabled_tb_chaining:
                print(&#34;Warning: disabling TB chaining to support {} callback&#34;.format(cb.name))
                self.disable_tb_chaining()


    def is_callback_enabled(self, name):
        if name not in self.registered_callbacks.keys():
            raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))
        return self.registered_callbacks[name][&#39;enabled&#39;]

    def enable_internal_callbacks(self):
        &#39;&#39;&#39;
        Enable all our internal callbacks that start with __ such as __main_loop_wait
        and __asid_changed. Important in case user has done a panda.end_analysis()
        and then (re)called run
        &#39;&#39;&#39;
        for name in self.registered_callbacks.keys():
            if name.startswith(&#34;__&#34;) and not self.registered_callbacks[name][&#39;enabled&#39;]:
                self.enable_callback(name)

    def enable_all_callbacks(self):
        &#39;&#39;&#39;
        Enable all python callbacks that have been disabled
        &#39;&#39;&#39;
        for name in self.registered_callbacks.keys():
            self.enable_callback(name)

    def enable_callback(self, name):
        &#39;&#39;&#39;
        Enable a panda plugin using its handle and cb.number as a unique ID
        &#39;&#39;&#39;
        if name not in self.registered_callbacks.keys():
            raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))

        self.registered_callbacks[name][&#39;enabled&#39;] = True
        handle = self.registered_callbacks[name][&#39;handle&#39;]
        cb = self.registered_callbacks[name][&#39;callback&#39;]
        pcb = self.registered_callbacks[name][&#39;pcb&#39;]
        #progress(&#34;Enabling callback &#39;{}&#39; on &#39;{}&#39; handle = {}&#34;.format(name, cb.name, handle))
        self.libpanda.panda_enable_callback_helper(handle, cb.number, pcb)

    def disable_callback(self, name, forever=False):
        &#39;&#39;&#39;
        Disable a panda plugin using its handle and cb.number as a unique ID
        If forever is specified, we&#39;ll never reenable the call- useful when
        you want to really turn off something with a procname filter.
        &#39;&#39;&#39;
        if name not in self.registered_callbacks.keys():
            raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))
        self.registered_callbacks[name][&#39;enabled&#39;] = False
        handle = self.registered_callbacks[name][&#39;handle&#39;]
        cb = self.registered_callbacks[name][&#39;callback&#39;]
        pcb = self.registered_callbacks[name][&#39;pcb&#39;]
        #progress(&#34;Disabling callback &#39;{}&#39; on &#39;{}&#39; handle={}&#34;.format(name, cb.name, handle))
        self.libpanda.panda_disable_callback_helper(handle, cb.number, pcb)

        if forever:
            del self.registered_callbacks[name]

    def delete_callback(self, name):
        &#39;&#39;&#39;
        Completely delete a registered panda callback by name
        &#39;&#39;&#39;
        if name not in self.registered_callbacks.keys():
            raise ValueError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))

        handle = self.registered_callbacks[name][&#39;handle&#39;]
        self.libpanda.panda_unregister_callbacks(handle)
        del self.registered_callbacks[name][&#39;handle&#39;]

    ###########################
    ### PPP-style callbacks ###
    ###########################

    def ppp(self, plugin_name, attr, name=None):
        &#39;&#39;&#39;
        Decorator for plugin-to-plugin interface. Note this isn&#39;t in decorators.py
        becuase it uses the panda object.

        Example usage to register my_run with syscalls2 as a &#39;on_sys_open_return&#39;
        @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;)
        def my_fun(cpu, pc, filename, flags, mode):
            ...
        &#39;&#39;&#39;

        if plugin_name not in self.plugins: # Could automatically load it?
            print(f&#34;PPP automatically loaded plugin {plugin_name}&#34;)

        if not hasattr(self, &#34;ppp_registered_cbs&#34;):
            self.ppp_registered_cbs = {}
            # We use this to traak fn_names-&gt;fn_pointers so we can later disable by name

            # XXX: if  we don&#39;t save the cffi generated callbacks somewhere in Python,
            # they may get garbage collected even though the c-code could still has a
            # reference to them  which will lead to a crash. If we stop using this to track
            # function names, we need to keep it or something similar to ensure the reference
            # count remains &gt;0 in python

        def decorator(fun):
            local_name = name  # We need a new varaible otherwise we have scoping issues, maybe
            if local_name is None:
                local_name = fun.__name__
            
            def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
                try:
                    r = fun(*args, **kwargs)
                    #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                    #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    self.callback_exit_exception = e
                    self.end_analysis()
                    # this works in all current callback cases. CFFI auto-converts to void, bool, int, and int32_t

            f = ffi.callback(attr+&#34;_t&#34;)(_run_and_catch)  # Wrap the python fn in a c-callback.
            if local_name == &#34;&lt;lambda&gt;&#34;:
                local_name = f&#34;&lt;lambda_{self.lambda_cnt}&gt;&#34;
                self.lambda_cnt += 1

            if local_name in self.ppp_registered_cbs:
                print(f&#34;Warning: replacing existing PPP callback &#39;{name}&#39; since it was re-registered&#34;)
                self.disable_ppp(local_name)

            assert (local_name not in self.ppp_registered_cbs), f&#34;Two callbacks with conflicting name: {local_name}&#34;

            # Ensure function isn&#39;t garbage collected, and keep the name-&gt;(fn, plugin_name, attr) map for disabling
            self.ppp_registered_cbs[local_name] = (f, plugin_name, attr)

            eval(f&#34;self.plugins[&#39;{plugin_name}&#39;].ppp_add_cb_{attr}&#34;)(f) # All PPP  cbs start with this string. XXX insecure eval
            return f
        return decorator


    def disable_ppp(self, name):
        &#39;&#39;&#39;
        Disable a ppp-style callback by name.
        Unlike regular panda callbacks which can be enabled/disabled/deleted, PPP callbacks are only enabled/deleted (which we call disabled)

        Example usage to register my_run with syscalls2 as a &#39;on_sys_open_return&#39; and then disable:
        ```
        @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;)
        def my_fun(cpu, pc, filename, flags, mode):
            ...

        panda.disable_ppp(&#34;my_fun&#34;)
        ```

        -- OR --

        ```
        @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;, name=&#34;custom&#34;)
        def my_fun(cpu, pc, filename, flags, mode):
            ...
        ```

        panda.disable_ppp(&#34;custom&#34;)
        &#39;&#39;&#39;

        (f, plugin_name, attr) = self.ppp_registered_cbs[name]
        eval(f&#34;self.plugins[&#39;{plugin_name}&#39;].ppp_remove_cb_{attr}&#34;)(f) # All PPP cbs start with this string. XXX insecure eval
        del self.ppp_registered_cbs[name] # It&#39;s now safe to be garbage collected

    ########## GDB MIXINS ##############
    &#34;&#34;&#34;
    Provides the ability to interact with a QEMU attached gdb session by setting and clearing breakpoints. Experimental.
    &#34;&#34;&#34;

    def set_breakpoint(self, cpu, pc):
        &#39;&#39;&#39;
        Set a GDB breakpoint such that when the guest hits PC, execution is paused and an attached
        GDB instance can introspect on guest memory. Requires starting panda with -s, at least for now
        &#39;&#39;&#39;
        BP_GDB = 0x10
        self.libpanda.cpu_breakpoint_insert(cpu, pc, BP_GDB, ffi.NULL)

    def clear_breakpoint(self, cpu, pc):
        &#39;&#39;&#39;
        Remove a breakpoint
        &#39;&#39;&#39;
        BP_GDB = 0x10
        self.libpanda.cpu_breakpoint_remove(cpu, pc, BP_GDB)

    ############# HOOKING MIXINS ###############
    def update_hook(self,hook_name,addr):
        &#39;&#39;&#39;
        Update hook to point to a different addres and enable it
        &#39;&#39;&#39;
        if hook_name in self.named_hooks:
            hook = self.named_hooks[hook_name]
            #print(f&#34;Updating hook {hook_name} at 0x{hook.target_addr:x}&#34;)
            if addr != hook.target_addr:
                hook.target_addr = addr
                self.plugins[&#39;hooks&#39;].enable_hook(hook.hook_cb, hook.target_addr)
            self.enable_hook(hook_name)

        else:
            raise ValueError(f&#34;Unknown hook {hook_name}&#34;)

    def enable_hook(self,hook_name):
        &#39;&#39;&#39;
        Set hook status to active.        
        &#39;&#39;&#39;
        if hook_name in self.named_hooks:
            hook = self.named_hooks[hook_name]
            if not hook.is_enabled:
                hook.is_enabled = True
                #print(f&#34;Enabling hook {hook_name} at 0x{hook.target_addr:x}&#34;)
                self.plugins[&#39;hooks&#39;].enable_hook(hook.hook_cb, hook.target_addr)
        else:
            raise ValueError(f&#34;Unknown hook {hook_name}&#34;)

    def disable_hook(self,hook_name):
        &#39;&#39;&#39;
        Set hook status to inactive.
        &#39;&#39;&#39;
        if hook_name in self.named_hooks:
            hook = self.named_hooks[hook_name]
            if hook.is_enabled:
                hook.is_enabled = False
                self.plugins[&#39;hooks&#39;].disable_hook(hook.hook_cb)
        else:
            raise ValueError(f&#34;Unknown hook {hook_name}&#34;)

    def _update_hooks_new_procname(self, cpu, name):
        &#39;&#39;&#39;
        Uses user-defined information to update the state of hooks based on things such as libraryname, procname and whether 
        or not the hook points to kernel space.
        &#39;&#39;&#39;
        for h in self.hook_list:
            if h.is_kernel:
                continue

            if h.program_name:
                if (h.program_name != name):
                    if h.is_enabled:
                        self.disable_hook(name)
                    continue

                if h.library_name is None:
                    if h.is_enabled:
                        self.enable_hook(h)
                    continue

            if h.library_name:
                asid = self.libpanda.panda_current_asid(cpu)
                lowest_matching_addr = 0

                if lowest_matching_addr == 0:
                    libs = self.get_mappings(cpu)
                    if libs == ffi.NULL:
                        continue
                    for lib in libs:
                        if lib.file != ffi.NULL:
                            filename = ffi.string(lib.file).decode(&#34;utf8&#34;, &#34;ignore&#34;)
                            if h.library_name in filename:
                                if (lowest_matching_addr == 0) or (lib.base &lt; lowest_matching_addr):
                                    lowest_matching_addr = lib.base

                if lowest_matching_addr:
                    self.update_hook(h, lowest_matching_addr + h.target_library_offset)
                else:
                    self.disable_hook(name)

    def _register_mmap_cb(self):
        if self._registered_mmap_cb:
            return

        @self.ppp(&#34;syscalls2&#34;, &#34;on_do_mmap2_return&#34;)
        def on_do_mmap2_return(cpu, pc, addr, length, prot, flags, fd, pgoff):
            self._update_hooks_new_procname(cpu, self.get_process_name(cpu))

    def hook(self, addr, enabled=True, kernel=True, libraryname=None, procname=None, name=None):
        &#39;&#39;&#39;
        Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
        the function will be called with args (CPUState, TranslationBlock)
        &#39;&#39;&#39;
        if procname:
            self._register_internal_asid_changed_cb()

        if libraryname:
            self._register_mmap_cb()

        def decorator(fun):
            # Ultimately, our hook resolves as a before_block_exec so we must match its args
            hook_cb_type = self.callback.before_block_exec # (CPUState, TranslationBlock)

            if &#39;hooks&#39; not in self.plugins:
                # Enable hooks plugin on first request
                self.load_plugin(&#34;hooks&#34;)

            if debug:
                print(&#34;Registering breakpoint at 0x{:x} -&gt; {} == {}&#34;.format(addr, fun, &#39;cdata_cb&#39;))

            # Inform the plugin that it has a new breakpoint at addr
            hook_cb_passed = hook_cb_type(fun)
            self.plugins[&#39;hooks&#39;].add_hook(addr, hook_cb_passed)
            hook_to_add = Hook(is_enabled=enabled,is_kernel=kernel,target_addr=addr,library_name=libraryname,program_name=procname,hook_cb=None, target_library_offset=None)
            if libraryname: 
                hook_to_add.target_library_offset = addr
                hook_to_add.target_addr = 0
                hook_to_add.hook_cb = hook_cb_passed
            else:
                hook_to_add.hook_cb = hook_cb_passed
            self.hook_list.append(hook_to_add)
            if not hasattr(self, &#34;named_hooks&#34;):
                self.named_hooks = {}
            local_name = name if name else fun.__name__ # XXX: weird scoping
            self.named_hooks[local_name] = hook_to_add

            if libraryname or procname or not enabled:
                self.disable_hook(local_name)

            @hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
            def wrapper(*args, **kw):
                return fun(*args, **kw)

            return wrapper
        return decorator



    &#34;&#34;&#34;
    Provides the ability to interact with the hooks2 plugin and receive callbacks based on user-provided criteria.
    &#34;&#34;&#34;

    def enable_hook2(self,hook_name):
        &#39;&#39;&#39;
        Set hook status to active.        
        &#39;&#39;&#39;
        if hook_name in self.hook_list2:
            self.plugins[&#39;hooks2&#39;].enable_hooks2(self.hook_list2[hook_name])
        else:
            print(&#34;ERROR: Your hook name was not in the hook list&#34;)

    def disable_hook2(self,hook_name):
        &#39;&#39;&#39;
        Set hook status to inactive.
        &#39;&#39;&#39;
        if hook_name in self.hook_list2:
            self.plugins[&#39;hooks2&#39;].disable_hooks2(self.hook_list2[hook_name])
        else:
            print(&#34;ERROR: Your hook name was not in the hook list&#34;)

    def hook2(self,name, kernel=True, procname=ffi.NULL, libname=ffi.NULL, trace_start=0, trace_stop=0, range_begin=0, range_end=0):
        if procname != ffi.NULL:
            procname = ffi.new(&#34;char[]&#34;,bytes(procname,&#34;utf-8&#34;))
        if libname != ffi.NULL:
            libname = ffi.new(&#34;char[]&#34;,bytes(libname,&#34;utf-8&#34;))
        &#39;&#39;&#39;
        Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
        the function will be called with args (CPUState, TranslationBlock)
        &#39;&#39;&#39;
        def decorator(fun):
            # Ultimately, our hook resolves as a before_block_exec_invalidate_opt callback so we must match its args
            hook_cb_type = ffi.callback(&#34;bool (CPUState*, TranslationBlock*, void*)&#34;)
            # Inform the plugin that it has a new breakpoint at addr
            
            hook_cb_passed = hook_cb_type(fun)
            if not hasattr(self, &#34;hook_gc_list&#34;):
                self.hook_gc_list = [hook_cb_passed]
            else:
                self.hook_gc_list.append(hook_cb_passed)

            # I don&#39;t know what this is/does
            cb_data = ffi.NULL
            hook_number = self.plugins[&#39;hooks2&#39;].add_hooks2(hook_cb_passed, cb_data, kernel, \
                procname, libname, trace_start, trace_stop, range_begin,range_end)
            
            self.hook_list2[name] = hook_number

            @hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
            def wrapper(*args, **kw):
                return fun(*args, **kw)

            return wrapper
        return decorator
    
    def hook2_single_insn(self, name, pc, kernel=False, procname=ffi.NULL, libname=ffi.NULL):
        return self.hook(name, kernel=kernel, procname=procname,libname=libname,range_begin=pc, range_end=pc)

# vim: expandtab:tabstop=4:</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pandare.panda.Panda"><code class="flex name class">
<span>class <span class="ident">Panda</span></span>
<span>(</span><span>arch='i386', mem='128M', expect_prompt=None, os_version=None, qcow=None, os='linux', generic=None, raw_monitor=False, extra_args=[])</span>
</code></dt>
<dd>
<div class="desc"><p>This is the object used to interact with PANDA. Initializing it creates a virtual machine to interact with.</p>
<pre><code>Parameters:
    arch : architecture string (e.g. "i386", "x86_64", "arm", "mips", "mipsel")
    mem : size of memory for machine (e.g. "128M", "1G")
    expect_prompt : Regular expression describing the prompt exposed by the guest 
        on a serial console. Used so we know when a running command has finished 
        with its output.
    os_version : analagous to -os string.
    qcow : qcow file to load as a path
    os : type of OS (e.g. "linux")
    generic : specify a generic qcow to use and set other arguments. Supported 
        values: arm/ppc/x86_64/i386. Will download qcow automatically
    raw_monitor : When set, don't specify a -monitor. arg Allows for use of 
        -nographic in args with ctrl-A+C for interactive qemu prompt.
    extra_args : extra arguments to pass to PANDA as either a string or an 
        array. (e.g. "-nographic" or ["-nographic", "-net", "none"])
</code></pre>
<p>Note that multiple PANDA objects cannot coexist in the same Python instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Panda():
    &#39;&#39;&#39;
    This is the object used to interact with PANDA. Initializing it creates a virtual machine to interact with.

        Parameters:
            arch : architecture string (e.g. &#34;i386&#34;, &#34;x86_64&#34;, &#34;arm&#34;, &#34;mips&#34;, &#34;mipsel&#34;)
            mem : size of memory for machine (e.g. &#34;128M&#34;, &#34;1G&#34;)
            expect_prompt : Regular expression describing the prompt exposed by the guest 
                on a serial console. Used so we know when a running command has finished 
                with its output.
            os_version : analagous to -os string.
            qcow : qcow file to load as a path
            os : type of OS (e.g. &#34;linux&#34;)
            generic : specify a generic qcow to use and set other arguments. Supported 
                values: arm/ppc/x86_64/i386. Will download qcow automatically
            raw_monitor : When set, don&#39;t specify a -monitor. arg Allows for use of 
                -nographic in args with ctrl-A+C for interactive qemu prompt.
            extra_args : extra arguments to pass to PANDA as either a string or an 
                array. (e.g. &#34;-nographic&#34; or [&#34;-nographic&#34;, &#34;-net&#34;, &#34;none&#34;])

    Note that multiple PANDA objects cannot coexist in the same Python instance.
    &#39;&#39;&#39;
    def __init__(self, arch=&#34;i386&#34;, mem=&#34;128M&#34;,
            expect_prompt=None, # Regular expression describing the prompt exposed by the guest on a serial console. Used so we know when a running command has finished with its output
            os_version=None,
            qcow=None, # Qcow file to load
            os=&#34;linux&#34;,
            generic=None, # Helper: specify a generic qcow to use and set other arguments. Supported values: arm/ppc/x86_64/i386. Will download qcow automatically
            raw_monitor = False, # When set, don&#39;t specify a -monitor. arg Allows for use of -nographic in args with ctrl-A+C for interactive qemu prompt.
            extra_args=[]):
        self.arch_name = arch
        self.mem = mem
        self.os = os_version
        self.os_type = os
        self.qcow = qcow
        self.plugins = plugin_list(self)
        self.expect_prompt = expect_prompt
        self.lambda_cnt = 0
        self.arch = None
        &#34;&#34;&#34;
        A reference to an auto-instantiated `pandare.arch.PandaArch` subclass (e.g., `pandare.arch.X86Arch`)
        &#34;&#34;&#34;

        if isinstance(extra_args, str): # Extra args can be a string or array
            extra_args = extra_args.split()

        # If specified use a generic (x86_64, i386, arm, ppc) qcow from mit and ignore
        if generic:                                 # other args. See details in images.py
            print(&#34;using generic &#34; +str(generic))
            q = Qcows.get_qcow_info(generic)
            self.arch_name     = q.arch
            self.os       = q.os
            self.mem      = q.default_mem # Might clobber a specified argument, but required if you want snapshots
            self.qcow     = Qcows.get_qcow(generic)
            self.expect_prompt = q.prompt
            if q.extra_args:
                extra_args.extend(q.extra_args.split(&#34; &#34;))

        if self.qcow: # Otherwise we shuld be able to do a replay with no qcow but this is probably broken
            if not (exists(self.qcow)):
                print(&#34;Missing qcow &#39;{}&#39; Please go create that qcow and give it to the PANDA maintainers&#34;.format(self.qcow))

        # panda.arch is a subclass with architecture-specific functions

        if self.arch_name == &#34;i386&#34;:
            self.arch = X86Arch(self)
        elif self.arch_name == &#34;x86_64&#34;:
            self.arch = X86_64Arch(self)
        elif self.arch_name == &#34;arm&#34;:
            self.arch = ArmArch(self)
        elif self.arch_name in [&#34;mips&#34;, &#34;mipsel&#34;]:
            self.arch = MipsArch(self)
        else:
            raise ValueError(f&#34;Unsupported architecture {self.arch_name}&#34;)
        self.bits, self.endianness, self.register_size = self.arch._determine_bits()

        self.build_dir  = self._find_build_dir()
        environ[&#34;PANDA_DIR&#34;] = self.build_dir
        self.libpanda_path = pjoin(self.build_dir, &#34;{0}-softmmu/libpanda-{0}.so&#34;.format(self.arch_name))
        self.panda = self.libpanda_path # Necessary for realpath to work inside core-panda, may cause issues?

        self.ffi = self._do_types_import()
        self.libpanda = self.ffi.dlopen(self.libpanda_path)
        self.C = ffi.dlopen(None)

        # set OS name if we have one
        if self.os:
            self.set_os_name(self.os)

        # Setup argv for panda
        self.panda_args = [self.panda]
        biospath = realpath(pjoin(self.build_dir, &#34;pc-bios&#34;)) # XXX: necessary for network drivers for arm, so &#39;pc-bios&#39; is a misleading name
        self.panda_args.append(&#34;-L&#34;)
        self.panda_args.append(biospath)

        if self.qcow:
            self.panda_args.append(self.qcow)

        self.panda_args += extra_args

        # Configure memory options
        self.panda_args.extend([&#39;-m&#39;, self.mem])

        # Configure serial - if we have an expect_prompt set. Otherwise how can we know what guest cmds are outputting?
        if self.expect_prompt:
            self.serial_file = NamedTemporaryFile(prefix=&#34;pypanda_s&#34;).name
            self.serial_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            self.serial_console = Expect(expectation=self.expect_prompt, quiet=True, consume_first=False)
            self.panda_args.extend([&#39;-serial&#39;, &#39;unix:{},server,nowait&#39;.format(self.serial_file)])
        else:
            self.serial_file = None
            self.serial_socket = None
            self.serial_console = None

        # Configure monitor - Always enabled for now
        self.monitor_file = NamedTemporaryFile(prefix=&#34;pypanda_m&#34;).name
        self.monitor_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.raw_monitor = raw_monitor
        if not self.raw_monitor:
            self.monitor_console = Expect(expectation=rb&#34;(qemu)&#34;, quiet=True, consume_first=True)
            self.panda_args.extend([&#39;-monitor&#39;, &#39;unix:{},server,nowait&#39;.format(self.monitor_file)])

        self.running = threading.Event()
        self.started = threading.Event()
        self.athread = AsyncThread(self.started) # athread manages actions that need to occur outside qemu&#39;s CPU loop

        # Callbacks
        self.register_cb_decorators()
        self.registered_callbacks = {} # name -&gt; {procname: &#34;bash&#34;, enabled: False, callback: None}

        # Register asid_changed CB if and only if a callback requires procname
        self._registered_asid_changed_internal_cb = False
        self._registered_mmap_cb = False

        self._initialized_panda = False
        self.disabled_tb_chaining = False
        self.taint_enabled = False
        self.hook_list = []
        self.hook_list2 = {}

        # Asid stuff
        self.current_asid_name = None
        self.asid_mapping = {}

        # Shutdown stuff
        self.exception = None # When set to an exn, we&#39;ll raise and exit

        # main_loop_wait functions and callbacks
        self.main_loop_wait_fnargs = [] # [(fn, args), ...]
        progress (&#34;Panda args: [&#34; + (&#34; &#34;.join(self.panda_args)) + &#34;]&#34;)
    # /__init__

    def _do_types_import(self):
        # Import objects from panda_datatypes which are configured by the environment variables
        # Store these objects in self.callback and self.callback_dictionary
        global ffi
        from importlib import import_module
        panda_arch_support = import_module(f&#34;.autogen.panda_{self.arch_name}_{self.bits}&#34;,package=&#39;pandare&#39;)
        ffi = panda_arch_support.ffi
        self.ffi = ffi
        set_ffi(ffi)
        from .autogen.panda_datatypes import pcb, C, callback_dictionary # XXX: What is C and do we need it?
        self.callback_dictionary = callback_dictionary
        self.callback = pcb
        return ffi

    def _initialize_panda(self):
        &#39;&#39;&#39;
        After initializing the class, the user has a chance to do something
        (TODO: what? register callbacks? It&#39;s something important...) before we finish initializing
        &#39;&#39;&#39;
        self.libpanda._panda_set_library_mode(True)

        cenvp = ffi.new(&#34;char**&#34;, ffi.new(&#34;char[]&#34;, b&#34;&#34;))
        len_cargs = ffi.cast(&#34;int&#34;, len(self.panda_args))
        panda_args_ffi = [ffi.new(&#34;char[]&#34;, bytes(str(i),&#34;utf-8&#34;)) for i in self.panda_args]
        self.libpanda.panda_init(len_cargs, panda_args_ffi, cenvp)

        # Now we&#39;ve run qemu init so we can connect to the sockets for the monitor and serial
        if self.serial_console and not self.serial_console.is_connected():
            self.serial_socket.connect(self.serial_file)
            self.serial_console.connect(self.serial_socket)
        if not self.raw_monitor and not self.monitor_console.is_connected():
            self.monitor_socket.connect(self.monitor_file)
            self.monitor_console.connect(self.monitor_socket)

        # Register __main_loop_wait_callback
        self.register_callback(self.callback.main_loop_wait,
                self.callback.main_loop_wait(self.__main_loop_wait_cb), &#39;__main_loop_wait&#39;)

        self._initialized_panda = True


    def __main_loop_wait_cb(self):
        &#39;&#39;&#39;
        __main_loop_wait_cb is called at the start of the main cpu loop in qemu.
        This is a fairly safe place to call into qemu internals but watch out for deadlocks caused
        by your request blocking on the guest&#39;s execution. Here any functions in main_loop_wait_fnargs will be called
        &#39;&#39;&#39;
        try:
            # Then run any and all requested commands
            if len(self.main_loop_wait_fnargs) == 0: return
            #progress(&#34;Entering main_loop_wait_cb&#34;)
            for fnargs in self.main_loop_wait_fnargs:
                (fn, args) = fnargs
                ret = fn(*args)
            self.main_loop_wait_fnargs = []
        except KeyboardInterrupt:
            self.end_analysis()

    def _find_build_dir(self):
        &#39;&#39;&#39;
        Find build directory containing ARCH-softmmu/libpanda-ARCH.so and ARCH-softmmu/panda/plugins/
        1) check relative to file (in the case of installed packages)
        2) Check in../ ../../../build/
        3) raise RuntimeError
        &#39;&#39;&#39;
        archs = [&#39;i386&#39;, &#39;x86_64&#39;, &#39;arm&#39;, &#39;ppc&#39;]
        python_package = pjoin(*[dirname(__file__), &#34;data&#34;])
        local_build = realpath(pjoin(dirname(__file__), &#34;../../../../build&#34;))
        path_end = &#34;{0}-softmmu/libpanda-{0}.so&#34;.format(self.arch_name)

        pot_paths = [python_package, local_build]
        for potential_path in pot_paths:
            if isfile(pjoin(potential_path, path_end)):
                print(&#34;Loading libpanda from {}&#34;.format(potential_path))
                return potential_path

        searched_paths = &#34;\n&#34;.join([&#34;\t&#34;+p for p in  pot_paths])
        raise RuntimeError((&#34;Couldn&#39;t find libpanda-{}.so.\n&#34;
                            &#34;Did you built PANDA for this architecture?\n&#34;
                            &#34;Searched paths:\n{}&#34;
                           ).format(self.arch_name, searched_paths))


    def queue_main_loop_wait_fn(self, fn, args=[]):
        &#39;&#39;&#39;
        Queue a function to run at the next main loop
        fn is a function we want to run, args are arguments to apss to it
        &#39;&#39;&#39;
        self.main_loop_wait_fnargs.append((fn, args))

    def exit_cpu_loop(self):
        &#39;&#39;&#39;
        Stop cpu execution at nearest juncture.
        &#39;&#39;&#39;
        self.libpanda.panda_exit_loop = True

    def revert_async(self, snapshot_name): # In the next main loop, revert
        &#39;&#39;&#39;
        Request a snapshot revert, eventually. This is fairly dangerous
        because you don&#39;t know when it finishes. You should be using revert_sync
        from a blocking function instead
        &#39;&#39;&#39;
        print(&#34;WARNING: panda.revert_async may be deprecated in the near future&#34;)
        if debug:
            progress (&#34;Loading snapshot &#34; + snapshot_name)

        # Stop guest, queue up revert, then continue
        timer_start = time()
        self.vm_stop()
        charptr = ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
        self.queue_main_loop_wait_fn(self.libpanda.panda_revert, [charptr])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont)
        if debug:
            self.queue_main_loop_wait_fn(self.finish_timer, [timer_start, &#34;Loaded snapshot&#34;])

    def reset(self): 
        &#34;&#34;&#34;In the next main loop, reset to boot&#34;&#34;&#34;
        if debug:
            progress (&#34;Resetting machine to start state&#34;)

        # Stop guest, queue up revert, then continue
        self.vm_stop()
        self.queue_main_loop_wait_fn(self.libpanda.panda_reset)
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont)

    def cont(self):
        &#39;&#39;&#39; Continue execution (run after vm_stop) &#39;&#39;&#39;
        self.libpanda.panda_cont()
        self.running.set()

    def vm_stop(self, code=4):
        &#39;&#39;&#39; Stop execution, default code means RUN_STATE_PAUSED &#39;&#39;&#39;
        self.libpanda.panda_stop(code)

    def snap(self, snapshot_name):
        &#39;&#39;&#39; Create snapshot with specified name &#39;&#39;&#39;
        if debug:
            progress (&#34;Creating snapshot &#34; + snapshot_name)

        # Stop guest execution, queue up a snapshot, then continue
        timer_start = time()
        self.vm_stop()
        charptr = ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
        self.queue_main_loop_wait_fn(self.libpanda.panda_snap, [charptr])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont)
        if debug:
            self.queue_main_loop_wait_fn(self.finish_timer, [timer_start, &#34;Saved snapshot&#34;])

    def delvm(self, snapshot_name):
        &#39;&#39;&#39; Delete snapshot with specified name &#39;&#39;&#39;
        if debug:
            progress (&#34;Deleting snapshot &#34; + snapshot_name)

        # Stop guest, queue up delete, then continue
        self.vm_stop()
        charptr = ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
        self.queue_main_loop_wait_fn(self.libpanda.panda_delvm, [charptr])

    def finish_timer(self, start, msg):
        &#39;&#39;&#39; Print how long some (main_loop_wait) task took &#39;&#39;&#39;
        t = time() - start
        print(&#34;{} in {1:.08f} seconds&#34;.format(msg, t))


    def enable_tb_chaining(self):
        &#39;&#39;&#39; This function enables translation block chaining in QEMU &#39;&#39;&#39;
        if debug:
            progress(&#34;Enabling TB chaining&#34;)
        self.disabled_tb_chaining = False
        self.libpanda.panda_enable_tb_chaining()

    def disable_tb_chaining(self):
        &#39;&#39;&#39; This function disables translation block chaining in QEMU &#39;&#39;&#39;
        if not self.disabled_tb_chaining:
            if debug:
                progress(&#34;Disabling TB chaining&#34;)
            self.disabled_tb_chaining = True
            self.libpanda.panda_disable_tb_chaining()
    
    def setup_internal_signal_handler(self):
       # ffi.cdef(&#34;void panda_setup_signal_handling(void (*f) (int,void*,void*));&#34;,override=True)
        @ffi.callback(&#34;void(int,void*,void*)&#34;)
        def SigHandler(SIG,a,b):
            from signal import SIGINT, SIGHUP, SIGTERM
            if SIG == SIGINT:
                self.end_run_raise_signal = KeyboardInterrupt
                self.end_analysis()
            elif SIG == SIGHUP:
                self.end_run_raise_signal = KeyboardInterrupt
                self.end_analysis()
            elif SIG == SIGTERM:
                self.end_run_raise_signal = KeyboardInterrupt
                self.end_analysis()
            else:
                print(f&#34;PyPanda Signal handler received unhandled signal {SIG}&#34;)
        
        self.__sighandler = SigHandler
        self.libpanda.panda_setup_signal_handling(self.__sighandler)

    
    def run(self):
        &#39;&#39;&#39;
        This function starts our running PANDA instance from Python. At termination this function returns and the script continues to run after it.
        
        This function starts execution of the guest. It blocks until guest finishes.
        It also initializes panda object, clears main_loop_wait fns, and sets up internal callbacks.
        &#39;&#39;&#39;

        if len(self.main_loop_wait_fnargs):
            if debug:
                print(&#34;Clearing prior main_loop_wait fns:&#34;, self.main_loop_wait_fnargs)
            self.main_loop_wait_fnargs = [] # [(fn, args), ...]

        if debug:
            progress (&#34;Running&#34;)

        if not self._initialized_panda:
            self._initialize_panda()

        if not self.started.is_set():
            self.started.set()

        # Ensure our internal CBs are always enabled
        self.enable_internal_callbacks()
        self.setup_internal_signal_handler()
        self.running.set()
        self.libpanda.panda_run() # Give control to panda
        self.running.clear() # Back from panda&#39;s execution (due to shutdown or monitor quit)
        self.libpanda.panda_unload_plugins() # Unload c plugins - should be safe now since exec has stopped
        if hasattr(self, &#34;end_run_raise_signal&#34;):
            raise self.end_run_raise_signal
        if hasattr(self, &#34;callback_exit_exception&#34;):
            raise self.callback_exit_exception
            

    def end_analysis(self):
        &#39;&#39;&#39;
        Stop running machine.

        Call from any thread to unload all plugins and stop all queued functions.
        If called from async thread or a callback, it will also unblock panda.run()

        Note here we use the async class&#39;s internal thread to process these
        without needing to wait for tasks in the main async thread
        &#39;&#39;&#39;
        self.unload_plugins()
        if self.running.is_set():
            # If we were running, stop the execution and check if we crashed
            self.queue_async(self.stop_run, internal=True)
    
    def record(self, recording_name, snapshot_name=None):
        &#34;&#34;&#34;Begins active recording with name provided.

        Args:
            recording_name (string): name of recording to save.
            snapshot_name (string, optional): Before recording starts restore to this snapshot name. Defaults to None.

        Raises:
            Exception: raises exception if there was an error starting recording.
        &#34;&#34;&#34;
        if snapshot_name == None:
            snapshot_name_ffi = ffi.NULL
        else:
            snapshot_name_ffi = ffi.new(&#34;char[]&#34;,snapshot_name.encode())
        recording_name_ffi = ffi.new(&#34;char[]&#34;, recording_name.encode())
        result = self.libpanda.panda_record_begin(recording_name_ffi,snapshot_name_ffi)
        res_string_enum = ffi.string(ffi.cast(&#34;RRCTRL_ret&#34;,result))
        if res_string_enum != &#34;RRCTRL_OK&#34;:
           raise Exception(f&#34;record method failed with RTCTL_ret {res_string_enum} ({result})&#34;) 
    
    def end_record(self):
        &#34;&#34;&#34;Stop active recording.

        Raises:
            Exception: raises exception if there was an error stopping recording.
        &#34;&#34;&#34;
        result = self.libpanda.panda_record_end()
        res_string_enum = ffi.string(ffi.cast(&#34;RRCTRL_ret&#34;,result))
        if res_string_enum != &#34;RRCTRL_OK&#34;:
           raise Exception(f&#34;record method failed with RTCTL_ret {res_string_enum} ({result})&#34;) 


    def run_replay(self, replaypfx):
        &#39;&#39;&#39;
        Load a replay and run it. Starts PANDA execution and returns after end of VM execution.

            Parameters:
                replaypfx: python string path to replay file.
        
            Returns:
                None
        &#39;&#39;&#39;
        if not isfile(replaypfx+&#34;-rr-snp&#34;) or not isfile(replaypfx+&#34;-rr-nondet.log&#34;):
            raise ValueError(&#34;Replay files not present to run replay of {}&#34;.format(replaypfx))

        if debug:
            progress (&#34;Replaying %s&#34; % replaypfx)

        charptr = ffi.new(&#34;char[]&#34;,bytes(replaypfx,&#34;utf-8&#34;))
        self.libpanda.panda_replay_begin(charptr)
        self.run()

    def require(self, name):
        &#39;&#39;&#39;
        Load a C plugin with no arguments. Deprecated. Use load_plugin
        &#39;&#39;&#39;
        self.load_plugin(name, args={})

    def load_plugin(self, name, args={}):
        &#39;&#39;&#39;
        Load a C plugin, optionally with arguments

            Parameters:
                name: python string name of plugin
                args: Dictionary of arguments matching key to value. e.g. {&#34;key&#34;: &#34;value&#34;} sets option key to value.
            
            Returns:
                None.
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Loading plugin %s&#34; % name),

        argstrs_ffi = []
        if isinstance(args, dict):
            for k,v in args.items():
                this_arg_s = &#34;{}={}&#34;.format(k,v)
                this_arg = ffi.new(&#34;char[]&#34;, bytes(this_arg_s, &#34;utf-8&#34;))
                argstrs_ffi.append(this_arg)

            n = len(args.keys())
        elif isinstance(args, list):
            for arg in args:
                this_arg = ffi.new(&#34;char[]&#34;, bytes(arg, &#34;utf-8&#34;))
                argstrs_ffi.append(this_arg)
            n = len(args)

        else:
            raise ValueError(&#34;Arguments to load plugin must be a list or dict of key/value pairs&#34;)

        # First set qemu_path so plugins can load (may be unnecessary after the first time)
        assert(self.panda), &#34;Unknown location of PANDA&#34;
        panda_name_ffi = ffi.new(&#34;char[]&#34;, bytes(self.panda,&#34;utf-8&#34;))
        self.libpanda.panda_set_qemu_path(panda_name_ffi)

        if len(argstrs_ffi):
            plugin_args = argstrs_ffi
        else:
            plugin_args = ffi.NULL

        charptr = ffi.new(&#34;char[]&#34;, bytes(name,&#34;utf-8&#34;))
        self.libpanda.panda_require_from_library(charptr, plugin_args, len(argstrs_ffi))
        self._load_plugin_library(name)
    
    def _procname_changed(self, cpu, name):
        for cb_name, cb in self.registered_callbacks.items():
            if not cb[&#34;procname&#34;]:
                continue
            if name == cb[&#34;procname&#34;] and not cb[&#39;enabled&#39;]:
                self.enable_callback(cb_name)
            if name != cb[&#34;procname&#34;] and cb[&#39;enabled&#39;]:
                self.disable_callback(cb_name)

        self._update_hooks_new_procname(cpu, name)

    def unload_plugin(self, name):
        &#39;&#39;&#39;
        Unload plugin with given name.

            Parameters:
                name: python string name of plugin
        
            Returns:
                None
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Unloading plugin %s&#34; % name),
        name_ffi = ffi.new(&#34;char[]&#34;, bytes(name,&#34;utf-8&#34;))
        self.libpanda.panda_unload_plugin_by_name(name_ffi)

    def unload_plugins(self):
        &#39;&#39;&#39;
        Disable all python plugins and request to unload all c plugins
        at the next main_loop_wait.

        XXX: If called during shutdown/exit, c plugins won&#39;t be unloaded
        because the next main_loop_wait will never happen. Instead, call
        panda.panda_finish directly (which is done at the end of panda.run())
        &#39;&#39;&#39;
        if debug:
            progress (&#34;Disabling all python plugins, unloading all C plugins&#34;)

        # First unload python plugins, should be safe to do anytime
        for name in self.registered_callbacks.keys():
            self.disable_callback(name)

        # Then unload C plugins. May be unsafe to do except from the top of the main loop (taint segfaults otherwise)
        self.queue_main_loop_wait_fn(self.libpanda.panda_unload_plugins)

    def memsavep(self, file_out):
        &#39;&#39;&#39;
        Calls QEMU memsavep on your specified python file.
        &#39;&#39;&#39;
        def initlib():
            ffi.cdef(&#39;&#39;&#39;
            FILE *fdopen(int, const char *);   // from the C &lt;stdio.h&gt;
            int fclose(FILE *);
            &#39;&#39;&#39;, override=True)
        ffi.init_once(initlib, &#34;cinit&#34;)
        
        # this part was largely copied from https://cffi.readthedocs.io/en/latest/ref.html#support-for-file

        file_out.flush()                    # make sure the file is flushed
        newfd = dup(file_out.fileno())   # make a copy of the file descriptor
        fileptr = self.C.fdopen(newfd, b&#34;w&#34;)
        self.libpanda.panda_memsavep(fileptr)
        self.C.fclose(fileptr)

    def physical_memory_read(self, addr, length, fmt=&#39;bytearray&#39;):
        &#39;&#39;&#39;
        Read guest physical memory.

            Parameters:
                addr: python int address
                length: length of array you would like returned
                fmt: format for returned array. Options: &#39;bytearray&#39;, &#39;int&#39;, and &#39;str&#39;

            Returns:
                Buffer based on fmt string
        
            Raises:
                ValueError for two cases: 
                    Memory Access with error value.
                    Format string is incorrect.
        &#39;&#39;&#39;
        return self._memory_read(None, addr, length, physical=True, fmt=fmt)

    def virtual_memory_read(self, env, addr, length, fmt=&#39;bytearray&#39;):
        &#39;&#39;&#39;
        Read guest virtual memory.

            Parameters:
                    env: CPUState structure
                    addr: python int address
                    length: length of array you would like returned
                    fmt: format for returned array. Options: &#39;bytearray&#39;, &#39;int&#39;, and &#39;str&#39;
            
            Returns:
                    Buffer based on fmt string
            
            Raises:
                    ValueError for two cases: 
                        Memory Access with error value.
                        Format string is incorrect.
        &#39;&#39;&#39;
        return self._memory_read(env, addr, length, physical=False, fmt=fmt)

    def _memory_read(self, env, addr, length, physical=False, fmt=&#39;bytearray&#39;):
        &#39;&#39;&#39;
        Read but with an autogen&#39;d buffer
        Supports physical or virtual addresses
        Raises ValueError if read fails
        &#39;&#39;&#39;
        if not hasattr(self, &#34;_memcb&#34;): # XXX: Why do we enable memcbs for memory writes?
            self.enable_memcb()
        buf = ffi.new(&#34;char[]&#34;, length)

        # Force CFFI to parse addr as an unsigned value. Otherwise we get OverflowErrors
        # when it decides that it&#39;s negative
        ptr_typ = f&#39;uint{self.bits}_t&#39;
        addr_u = int(ffi.cast(ptr_typ, addr))

        buf_a = ffi.cast(&#34;char*&#34;, buf)
        length_a = ffi.cast(&#34;int&#34;, length)
        if physical:
            err = self.libpanda.panda_physical_memory_read_external(addr_u, buf_a, length_a)
        else:
            err = self.libpanda.panda_virtual_memory_read_external(env, addr_u, buf_a, length_a)

        if err &lt; 0:
            raise ValueError(f&#34;Memory access failed with err={err}&#34;) # TODO: make a PANDA Exn class

        r = ffi.unpack(buf, length)
        if fmt == &#39;bytearray&#39;:
            return r
        elif fmt==&#39;int&#39;:
            return int.from_bytes(r, byteorder=self.endianness)  # XXX size better be small enough to pack into an int!
        elif fmt==&#39;str&#39;:
            return ffi.string(buf, length)
        elif fmt==&#39;ptrlist&#39;:
            # This one is weird. Chunmk the memory into byte-sequences of (self.bits/8) bytes and flip endianness as approperiate
            # return a list
            bytelen = int(self.bits/8)
            if (length % bytelen != 0):
                raise ValueError(f&#34;Memory of size {length} does not evenly divide into {bytelen} byte chunks&#34;)
            chunks = []
            for start in range(0, length, bytelen):
                data = r[start:start+bytelen]
                int_data = int.from_bytes(data, byteorder=self.endianness)
                chunks.append(int_data)
            return chunks

        else:
            raise ValueError(&#34;fmt={} unsupported&#34;.format(fmt))

    def physical_memory_write(self, addr, buf):
        &#39;&#39;&#39;
        Write guest physical memory.

            Parameters:
                    addr: python int address
                    buf:  byte string to write
        &#39;&#39;&#39;
        return self._memory_write(None, addr, buf, physical=True)

    def virtual_memory_write(self, env, addr, buf):
        &#39;&#39;&#39;
        Write guest virtual memory.
        
            Parameters:
                    env: CPUState structure
                    address: python int address
                    buf: byte string to write
            
            Returns:
                    int: 0 on success. 1 on error.

        &#39;&#39;&#39;
        return self._memory_write(env, addr, buf, physical=False)

    def _memory_write(self, env, addr, buf, physical=False):
        &#39;&#39;&#39;
        Write a bytearray into memory at the specified physical/virtual address
        &#39;&#39;&#39;
        length = len(buf)
        c_buf = ffi.new(&#34;char[]&#34;,buf)
        buf_a = ffi.cast(&#34;char*&#34;, c_buf)
        length_a = ffi.cast(&#34;int&#34;, length)

        if not hasattr(self, &#34;_memcb&#34;): # XXX: Why do we enable memcbs for memory writes?
            self.enable_memcb()

        if physical:
            return self.libpanda.panda_physical_memory_write_external(addr, buf_a, length_a)
        else:
            return self.libpanda.panda_virtual_memory_write_external(env, addr, buf_a, length_a)

    def callstack_callers(self, lim, cpu): # XXX move into new directory, &#39;callstack&#39; ?
        &#39;&#39;&#39;
        Utility function to handle conversion and return get_callers from callstack_instr.
        &#39;&#39;&#39;
        if not &#34;plugin_callstack_instr&#34; in self.plugins:
            progress(&#34;enabling callstack_instr plugin&#34;)
            self.require(&#34;callstack_instr&#34;)

        callers = ffi.new(&#34;uint32_t[%d]&#34; % lim)
        n = self.plugins[&#39;callstack_instr&#39;].get_callers(callers, lim, cpu)
        c = []
        for pc in callers:
            c.append(pc)
        return c

    def _load_plugin_library(self, name):
        if hasattr(self,&#34;__did_load_libpanda&#34;):
            libpanda_path_chr = ffi.new(&#34;char[]&#34;,bytes(self.libpanda_path, &#34;UTF-8&#34;))
            self.__did_load_libpanda = self.libpanda.panda_load_libpanda(libpanda_path_chr)
        if not name in self.plugins.keys():
            assert(isfile(pjoin(*[self.build_dir, self.arch_name+&#34;-softmmu&#34;, &#34;panda/plugins/panda_{}.so&#34;.format(name)])))
            library = ffi.dlopen(pjoin(*[self.build_dir, self.arch_name+&#34;-softmmu&#34;, &#34;panda/plugins/panda_{}.so&#34;.format(name)]))
            self.plugins[name] = library

    def queue_async(self, f, internal=False):
        &#39;&#39;&#39;
        Queues work in the asynchronous work queue.

            Parameters:
                f: A python function with no arguments to be called at a later date
            
            Returns:
                None
        &#39;&#39;&#39;
        self.athread.queue(f, internal=internal)

    def map_memory(self, name, size, address):

        &#39;&#39;&#39;
        Make a new memory region.
        
            Parameters:
                    name: This is an internal reference name for this region. Must be unique.
                    size: number of bytes the region should be.
                    address: start address of region
        &#39;&#39;&#39;

        name_c = ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
        size = ceil(size/1024)*1024 # Must be page-aligned
        return self.libpanda.map_memory(name_c, size, address)

    def read_str(self, cpu, ptr):
        &#39;&#39;&#39;
        Helper to read a null-terminated string from guest memory given a pointer and CPU state
        May return an exception if the call to panda.virtual_memory_read fails (e.g., if you pass a
        pointer to an unmapped page)
        &#39;&#39;&#39;
        r = b&#34;&#34;
        while True:
            next_char = self.virtual_memory_read(cpu, ptr, 1) # If this raises an exn, don&#39;t mask it
            if next_char == b&#34;\x00&#34;:
                break
            r += next_char
            ptr += 1
        return r.decode(&#34;utf8&#34;, &#34;ignore&#34;)

    def to_unsigned_guest(self, x):
        &#39;&#39;&#39;
        Convert a singed python int to an unsigned int32/unsigned int64
        depending on guest bit-size
        &#39;&#39;&#39;
        import ctypes
        if self.bits == 32:
            return ctypes.c_uint32(x).value
        elif self.bits == 64:
            return ctypes.c_uint64(x).value
        else:
            raise ValueError(&#34;Unsupported number of bits&#34;)

    def from_unsigned_guest(self, x):
        &#39;&#39;&#39;
        Convert an unsigned int32/unsigned int64 from the guest
        (depending on guest bit-size) to a (signed) python int
        &#39;&#39;&#39;
        if x &gt;= 2**(self.bits-1): # If highest bit is set, it&#39;s negative
            return (x - 2**self.bits)
        else: # Else it&#39;s positive
            return x

    def queue_blocking(self, func, queue=True):
        &#34;&#34;&#34;
        Decorator to mark a function as `blocking`, and by default queue it to run asynchronously

        ```
        @panda.queue_blocking
        def do_something():
            panda.revert_sync(&#39;root&#39;)
            print(panda.run_serial_cmd(&#39;whoami&#39;))
            panda.end_analysis()
        ```

        is equivalent to

        ```
        @blocking
        def run_whoami():
            panda.revert_sync(&#39;root&#39;)
            print(panda.run_serial_cmd(&#39;whoami&#39;))
            panda.end_analysis()

        panda.queue_async(run_whoami)
        ```

        &#34;&#34;&#34;
        f = blocking(func)
        if queue:
            self.queue_async(f)
        return f


    ########################## LIBPANDA FUNCTIONS ########################
    # Methods that directly pass data to/from PANDA with no extra logic beyond argument reformatting.
    def set_pandalog(self, name):
        &#39;&#39;&#39;
        Enable recording to a pandalog (plog) named `name`

            Parameters:
                name: file to output data to
            
            Returns:
                None
        &#39;&#39;&#39;
        charptr = ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
        self.libpanda.panda_start_pandalog(charptr)

    def enable_memcb(self):
        &#39;&#39;&#39;
        Enable memory callbacks. Must be called for memory callbacks to work.
        pypanda enables this automatically with some callbacks.
        &#39;&#39;&#39;
        self._memcb = True
        self.libpanda.panda_enable_memcb()
    
    def disable_memcb(self):
        &#39;&#39;&#39;
        Disable memory callbacks. Must be enabled for memory callbacks to work.
        pypanda enables this automatically with some callbacks.
        &#39;&#39;&#39;
        self._memcb = False
        self.libpanda.panda_disable_memcb()

    def virt_to_phys(self, env, addr):
        &#39;&#39;&#39;
        Convert virtual address to physical address.

            Parameters:
                env: CPUState struct
                addr (int): virtual address to convert
            
            Return:
                physical address as python int
        &#39;&#39;&#39;
        return self.libpanda.panda_virt_to_phys_external(env, addr)

    def enable_plugin(self, handle):
        &#39;&#39;&#39;
        Enable plugin.

            Parameters:
                handle: pointer to handle returned by plugin
            
            Return:
                None
        &#39;&#39;&#39;
        self.libpanda.panda_enable_plugin(handle)

    def disable_plugin(self, handle):
        &#39;&#39;&#39;
        Disable plugin.

            Parameters:
                handle: pointer to handle returned by plugin
            
            Return:
                None
        &#39;&#39;&#39;
        self.libpanda.panda_disable_plugin(handle)

    def enable_llvm(self):
        &#39;&#39;&#39;
        Enables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend. 
        &#39;&#39;&#39;
        self.libpanda.panda_enable_llvm()

    def disable_llvm(self):
        &#39;&#39;&#39;
        Disables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend. 
        &#39;&#39;&#39;
        self.libpanda.panda_disable_llvm()

    def enable_llvm_helpers(self):
        &#39;&#39;&#39;
        Enables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend. 
        &#39;&#39;&#39;
        self.libpanda.panda_enable_llvm_helpers()

    def disable_llvm_helpers(self):
        &#39;&#39;&#39;
        Disables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend. 
        &#39;&#39;&#39;
        self.libpanda.panda_disable_llvm_helpers()

    def flush_tb(self):
        &#39;&#39;&#39;
        This function requests that the translation block cache be flushed as soon as possible. If running with translation block chaining turned off (e.g. when in LLVM mode or replay mode), this will happen when the current translation block is done executing.
        Flushing the translation block cache is additionally necessary if the plugin makes changes to the way code is translated. For example, by using panda_enable_precise_pc.
        &#39;&#39;&#39;
        return self.libpanda.panda_flush_tb()

    def enable_precise_pc(self):
        &#39;&#39;&#39;
        By default, QEMU does not update the program counter after every instruction.
        This function enables precise tracking of the program counter. After enabling precise PC tracking, the program counter will be available in env-&gt;panda_guest_pc and can be assumed to accurately reflect the guest state.
        &#39;&#39;&#39;
        self.libpanda.panda_enable_precise_pc()

    def disable_precise_pc(self):
        &#39;&#39;&#39;
        By default, QEMU does not update the program counter after every instruction.
        This function disables precise tracking of the program counter.
        &#39;&#39;&#39;
        self.libpanda.panda_disable_precise_pc()

    def in_kernel(self, cpustate):
        &#39;&#39;&#39;
        Returns true if the processor is in the privilege level corresponding to executing kernel code for any of the PANDA supported architectures.
        &#39;&#39;&#39;
        return self.libpanda.panda_in_kernel_external(cpustate)

    def g_malloc0(self, size):
        &#39;&#39;&#39;
        Helper function to call glib malloc

            Parameters:
                size: size to call with malloc
            
            Returns:
                buffer of that size from malloc
        &#39;&#39;&#39;
        return self.libpanda.g_malloc0(size)

    def current_sp(self, cpustate):
        &#39;&#39;&#39;
        Get current stack pointer

            Parameters:
                cpustate: CPUState struct

            Return:
                integer value of stack pointer
        &#39;&#39;&#39;
        return self.libpanda.panda_current_sp_external(cpustate)

    def current_pc(self, cpustate):
        &#39;&#39;&#39;
        Get current program counter

            Parameters:
                cpustate: CPUState struct

            Return:
                integer value of current program counter

            .. Deprecated:: Use panda.arch.get_pc(cpu) instead
        &#39;&#39;&#39;
        return self.libpanda.panda_current_pc(cpustate)


    def current_asid(self, cpustate):
        &#39;&#39;&#39;
        Get current Application Specific ID
            
            Parameters:
                cpustate: CPUState struct

            Return:
                integer value of current ASID
        &#39;&#39;&#39;
        return self.libpanda.panda_current_asid(cpustate)

    def disas2(self, code, size):
        &#39;&#39;&#39;
        Call panda_disas to diasassemble an amount of code at a pointer.
        FIXME: seem to not match up to PANDA definition
        &#39;&#39;&#39;
        self.libpanda.panda_disas(code, size)

    def cleanup(self):
        &#39;&#39;&#39;
        Unload all plugins and close pandalog.
        &#39;&#39;&#39;
        self.libpanda.panda_cleanup()

    def was_aborted(self):
        &#39;&#39;&#39;
        Returns true if panda was aborted.
        &#39;&#39;&#39;
        return self.libpanda.panda_was_aborted()

    def get_cpu(self):
        &#39;&#39;&#39;
        This function returns first_cpu CPUState object from QEMU.
        XXX: You rarely want this
        &#39;&#39;&#39;
        return self.libpanda.get_cpu()

    def garray_len(self, garray):
        &#39;&#39;&#39;
        Convenience function to get array length of glibc array.
        &#39;&#39;&#39;
        return self.libpanda.garray_len(garray)

    def panda_finish(self):
        &#39;&#39;&#39;
        Final stage call to underlying panda_finish with initialization.
        &#39;&#39;&#39;
        return self.libpanda.panda_finish()

    def rr_get_guest_instr_count(self):
        &#39;&#39;&#39;
        Returns record/replay guest instruction count.
        &#39;&#39;&#39;
        return self.libpanda.rr_get_guest_instr_count_external()

    ################### LIBQEMU Functions ############
    #Methods that directly pass data to/from QEMU with no extra logic beyond argument reformatting.
    #All QEMU function can be directly accessed by Python. These are here for convenience.
    # It&#39;s usally better to find a function name and look at the QEMU source for these functions.

    def drive_get(self, blocktype, bus, unit):
        &#39;&#39;&#39;
        Gets DriveInfo struct from user specified information.

            Parameters:
                blocktype: BlockInterfaceType structure
                bus: integer bus
                unit: integer unit
            
            Return:
                DriveInfo struct
        &#39;&#39;&#39;
        return self.libpanda.drive_get(blocktype,bus,unit)

    def sysbus_create_varargs(self, name, addr):
        &#39;&#39;&#39;
        Returns DeviceState struct from user specified information
        Calls sysbus_create_varargs QEMU function.

            Parameters:
                name: python string
                addr: python integer representing hwaddr
            
            Return:
                DeviceState struct
        &#39;&#39;&#39;
        return self.libpanda.sysbus_create_varargs(name,addr,ffi.NULL)

    def cpu_class_by_name(self, name, cpu_model):
        &#39;&#39;&#39;
        Gets cpu class from name.
        Calls cpu_class_by_name QEMU function.

            Parameters:
                name: typename from python string
                cpu_model: string specified cpu model

            Returns:
                ObjectClass struct
        &#39;&#39;&#39;
        return self.libpanda.cpu_class_by_name(name, cpu_model)

    def object_class_by_name(self, name):
        &#39;&#39;&#39;
        Returns class as ObjectClass from name specified.
        Calls object_class_by_name QEMU function.

            Parameters:
                name: string defined by user
            
            Returns:
                struct as specified by name
        &#39;&#39;&#39;
        return self.libpanda.object_class_by_name(name)

    def object_property_set_bool(self, obj, value, name):
        &#39;&#39;&#39;
        Writes a bool value to a property.
        Calls object_property_set_bool QEMU function.

            Parameters:
                value: the value to be written to the property
                name: the name of the property
                errp: returns an error if this function fails

            Returns:
                None
        &#39;&#39;&#39;
        return self.libpanda.object_property_set_bool(obj,value,name,self.libpanda.error_abort)

    def object_class_get_name(self, objclass):
        &#39;&#39;&#39;
        Gets String QOM typename from object class.
        Calls object_class_get_name QEMU function.

            Parameters:
                objclass: class to obtain the QOM typename for.

            Returns: 
                String QOM typename for klass.
        &#39;&#39;&#39;
        return self.libpanda.object_class_get_name(objclass)

    def object_new(self, name):
        &#39;&#39;&#39;
        Creates a new object from typename.
        This function will initialize a new object using heap allocated memory.
        The returned object has a reference count of 1, and will be freed when
        the last reference is dropped.
        Calls object_new QEMU function.
            
            Parameters:
                name: The name of the type of the object to instantiate.
            
            Returns: 
                The newly allocated and instantiated object.
        &#39;&#39;&#39;
        return self.libpanda.object_new(name)

    def object_property_get_bool(self, obj, name):
        &#39;&#39;&#39;
        Pull boolean from object.
        Calls object_property_get_bool QEMU function.

            Parameters:
                obj: the object
                name: the name of the property
            
            Returns: 
                the value of the property, converted to a boolean, or NULL if an error occurs (including when the property value is not a bool).
        &#39;&#39;&#39;
        return self.libpanda.object_property_get_bool(obj,name,self.libpanda.error_abort)

    def object_property_set_int(self,obj, value, name):
        &#39;&#39;&#39;
        Set integer in QEMU object. Writes an integer value to a property.   
        Calls object_property_set_int QEMU function.
        
            Parameters:
                value: the value to be written to the property
                name: the name of the property
            
            Returns:
                None
        &#39;&#39;&#39;
        return self.libpanda.object_property_set_int(obj, value, name, self.libpanda.error_abort)

    def object_property_get_int(self, obj, name):
        &#39;&#39;&#39;
        Gets integer in QEMU object. Reads an integer value from this property.   
        Calls object_property_get_int QEMU function.

            Paramaters:
                obj: the object
                name: the name of the property
            
            Returns: 
                the value of the property, converted to an integer, or negative if an error occurs (including when the property value is not an integer).
        &#39;&#39;&#39;
        return self.libpanda.object_property_get_int(obj, name, self.libpanda.error_abort)

    def object_property_set_link(self, obj, val, name):
        &#39;&#39;&#39;
        Writes an object&#39;s canonical path to a property.
        Calls object_property_set_link QEMU function.

            Parameters:
                value: the value to be written to the property
                name: the name of the property
                errp: returns an error if this function fails

            Returns:
                None
        &#39;&#39;&#39;
        return self.libpanda.object_property_set_link(obj,val,name,self.libpanda.error_abort)

    def object_property_get_link(self, obj, name):
        &#39;&#39;&#39;
        Reads an object&#39;s canonical path to a property.
        Calls object_property_get_link QEMU function.
    
            Parameters:
                obj: the object
                name: the name of the property
                errp: returns an error if this function fails
            
            Returns:
                the value of the property, resolved from a path to an Object, or NULL if an error occurs (including when the property value is not a string or not a valid object path).
        &#39;&#39;&#39;
        return self.libpanda.object_property_get_link(obj,name,self.libpanda.error_abort)

    def object_property_find(self, obj, name):
        &#39;&#39;&#39;
        Look up a property for an object and return its #ObjectProperty if found.
        Calls object_property_find QEMU function.

            Parameters:
                obj: the object
                name: the name of the property
                errp: returns an error if this function fails
            
            Returns:
                struct ObjectProperty pointer
        &#39;&#39;&#39;
        return self.libpanda.object_property_find(obj,name,ffi.NULL)

    def memory_region_allocate_system_memory(self, mr, obj, name, ram_size):
        &#39;&#39;&#39;
        Allocates Memory region by user specificiation.
        Calls memory_region_allocation_system_memory QEMU function.

            Parameters:
                mr: MemoryRegion struct
                obj: Object struct
                name: string of region name
                ram_size: int of ram size
            
            Returns:
                None
        &#39;&#39;&#39;
        return self.libpanda.memory_region_allocate_system_memory(mr, obj, name, ram_size)

    def memory_region_add_subregion(self, mr, offset, sr):
        &#39;&#39;&#39;
        Calls memory_region_add_subregion from QEMU.
        memory_region_add_subregion: Add a subregion to a container.
        
        Adds a subregion at @offset.  The subregion may not overlap with other
        subregions (except for those explicitly marked as overlapping).  A region
        may only be added once as a subregion (unless removed with
        memory_region_del_subregion()); use memory_region_init_alias() if you
        want a region to be a subregion in multiple locations.
        
            Parameters:
                mr: the region to contain the new subregion; must be a container initialized with memory_region_init().
                offset: the offset relative to @mr where @subregion is added.
                subregion: the subregion to be added.
            
            Returns: 
                None
        &#39;&#39;&#39;
        return self.libpanda.memory_region_add_subregion(mr,offset,sr)

    def memory_region_init_ram_from_file(self, mr, owner, name, size, share, path):
        &#39;&#39;&#39;
        Calls memory_region_init_ram_from_file from QEMU.
        memory_region_init_ram_from_file:  Initialize RAM memory region with a mmap-ed backend.
        
            Parameters:
                mr: the #MemoryRegion to be initialized.
                owner: the object that tracks the region&#39;s reference count
                name: the name of the region.
                size: size of the region.
                share: %true if memory must be mmaped with the MAP_SHARED flag
                path: the path in which to allocate the RAM.
                errp: pointer to Error*, to store an error if it happens.
            
            Returns:
                None
        &#39;&#39;&#39;
        return self.libpanda.memory_region_init_ram_from_file(mr, owner, name, size, share, path, self.libpanda.error_fatal)

    def create_internal_gic(self, vbi, irqs, gic_vers):
        return self.libpanda.create_internal_gic(vbi, irqs, gic_vers)

    def create_one_flash(self, name, flashbase, flashsize, filename, mr):
        return self.libpanda.create_one_flash(name, flashbase, flashsize, filename, mr)

    def create_external_gic(self, vbi, irqs, gic_vers, secure):
        return self.libpanda.create_external_gic(vbi, irqs, gic_vers, secure)

    def create_virtio_devices(self, vbi, pic):
        return self.libpanda.create_virtio_devices(vbi, pic)

    def arm_load_kernel(self, cpu, bootinfo):
        return self.libpanda.arm_load_kernel(cpu, bootinfo)

    def error_report(self, s):
        return self.libpanda.error_report(s)

    def get_system_memory(self):
        return self.libpanda.get_system_memory()

    def lookup_gic(self,n):
        return self.libpanda.lookup_gic(n)

    ##################### OSI FUNCTIONS ###########
    #Convenience functions to interact with the Operating System Instrospection (OSI) class of plugins.

    def set_os_name(self, os_name):
        &#34;&#34;&#34;
        Set OS target. Equivalent to &#34;-os&#34; flag on the command line. Matches the form of:
        
            &#34;windows[-_]32[-_]xpsp[23]&#34;,
            &#34;windows[-_]32[-_]7&#34;,
            &#34;windows[-_]32[-_]2000&#34;,
            &#34;linux[-_]32[-_].+&#34;,
            &#34;linux[-_]64[-_].+&#34;,

            Parameters:
                os_name: string matching the format for the os flag.
            
            Returns:
                None
        &#34;&#34;&#34;
        os_name_new = ffi.new(&#34;char[]&#34;, bytes(os_name, &#34;utf-8&#34;))
        self.libpanda.panda_set_os_name(os_name_new)


    def get_mappings(self, cpu):
        &#39;&#39;&#39;
        Get all active memory mappings in the system.

            Requires: OSI

            Parameters:
                cpu: CPUState struct

            Returns:
                Iterator of `OsiModule` structures
        &#39;&#39;&#39;
        current = self.plugins[&#39;osi&#39;].get_current_process(cpu)
        maps = self.plugins[&#39;osi&#39;].get_mappings(cpu, current)
        map_len = self.garray_len(maps)
        return GArrayIterator(self.plugins[&#39;osi&#39;].get_one_module, maps, map_len, self.plugins[&#39;osi&#39;].cleanup_garray)

    def get_processes(self, cpu):
        &#39;&#39;&#39;
        Get all running processes in the system. Includes kernel modules on Linux.

            Requires: OSI

            Parameters:
                cpu: CPUState struct

            Returns:
                Iterator of `OsiProc` structures
        &#39;&#39;&#39;
        processes = self.plugins[&#39;osi&#39;].get_processes(cpu)
        processes_len = self.garray_len(processes)
        return GArrayIterator(self.plugins[&#39;osi&#39;].get_one_proc, processes, processes_len, self.plugins[&#39;osi&#39;].cleanup_garray)

    def get_processes_dict(self, cpu):
        &#39;&#39;&#39;
        Get all running processes for the system at this moment in time as a dictionary.

        The dictionary maps proceses by their PID. Each mapping returns a dictionary containing the process name, its pid,
        and its parent pid (ppid).

            Requires: OSI

            Parameters:
                cpu: CPUState struct

            Returns:
                Dictionary as described above.
        &#39;&#39;&#39;

        procs = {} #pid: {name: X, pid: Y, parent_pid: Z})

        for proc in self.get_processes(cpu):
            assert(proc != ffi.NULL)
            assert(proc.pid not in procs)
            procs[proc.pid] = {&#34;name&#34;: ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;), &#39;pid&#39;: proc.pid, &#39;parent_pid&#39;: proc.ppid}
            assert(not (proc.pid != 0 and proc.pid == proc.ppid)) # No cycles allowed other than at 0
        return procs

    def get_process_name(self, cpu):
        &#39;&#39;&#39;
        Get the name of the current process. May return None if OSI cannot identify the current process
        &#39;&#39;&#39;
        proc = self.plugins[&#39;osi&#39;].get_current_process(cpu)
        if proc == ffi.NULL or proc.name == ffi.NULL:
            return None

        procname = ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;)
        return ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;)


    ################## PYPERIPHERAL FUNCTIONS #####################
    # Pyperipherals are objects which handle mmio read/writes using the PANDA callback infrastructure.
    # Under the hood, they use the cb_unassigned_io_read/cb_unassigned_io_write callbacks.
    # A python peripheral itself is an object which exposes the following functions:
    #     write_memory(self, address, size, value)
    #     read_memory(self, address, size)
    # And has at least the following attributes:
    #     address
    #     size

    # One example for such a python object are avatar2&#39;s AvatarPeripheral.
    def _addr_to_pyperipheral(self, address):
        &#34;&#34;&#34;
        Returns the python peripheral for a given address, or None if no
        peripheral is registered for that address
        &#34;&#34;&#34;

        for pp in self.pyperipherals:
            if pp.address &lt;= address &lt; pp.address + pp.size:
                return pp
        return None

    def _validate_object(self, object):
        # This function makes sure that the object exposes the right interfaces

        if not hasattr(object, &#34;address&#34;) or not isinstance(object.address, int):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing or non-int `address` attribute&#34;
                ).format(str(object.__repr__()))
            )

        if not hasattr(object, &#34;size&#34;) or not isinstance(object.size, int):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing or non-int `address` attribute&#34;
                ).format(object.__repr__())
            )

        if not hasattr(object, &#34;read_memory&#34;):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing read_memory function&#34;
                ).format(object.__repr__())
            )

        params = list(signature(object.read_memory).parameters)
        if params[0] != &#34;address&#34; or params[1] != &#34;size&#34;:
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Invalid function signature for read_memory&#34;
                ).format(object.__repr__())
            )

        if not hasattr(object, &#34;write_memory&#34;):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Missing write_memory function&#34;
                ).format(object.__repr__())
            )

        params = list(signature(object.write_memory).parameters)
        if params[0] != &#34;address&#34; or params[1] != &#34;size&#34; or params[2] != &#34;value&#34;:
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34;
                    &#34;Invalid function signature for write_memory&#34;
                ).format(object.__repr__())
            )

        # Ensure object is not overlapping with any other pyperipheral
        if (
            self._addr_to_pyperipheral(object.address) is not None
            or self._addr_to_pyperipheral(object.address + object.size) is not None
        ):
            raise RuntimeError(
                (
                    &#34;Registering PyPeripheral {} failed:\n&#34; &#34;Overlapping memories!&#34;
                ).format(object.__repr__())
            )

        return True

    def pyperiph_read_cb(self, cpu, pc, physaddr, size, val_ptr):
        pp = self._addr_to_pyperipheral(physaddr)
        if pp is None:
            return False

        val = pp.read_memory(physaddr, size)
        buf = ffi.buffer(val_ptr, size)

        fmt = &#34;{}{}&#34;.format(self._end2fmt[self.endianness], self._num2fmt[size])

        pack_into(fmt, buf, 0, val)

        return True

    def pyperiph_write_cb(self, cpu, pc, physaddr, size, val):
        pp = self._addr_to_pyperipheral(physaddr)
        if pp is None:
            return False

        pp.write_memory(physaddr, size, val)
        return True

    def register_pyperipheral(self, object):
        &#34;&#34;&#34;
        Registers a python peripheral, and the necessary attributes to the
        panda-object, if not present yet.
        &#34;&#34;&#34;

        # if we are the first pyperipheral, register the pp-dict
        if not hasattr(self, &#34;pyperipherals&#34;):
            self.pyperipherals = []
            self.pyperipherals_registered_cb = False
            self._num2fmt = {1: &#34;B&#34;, 2: &#34;H&#34;, 4: &#34;I&#34;, 8: &#34;Q&#34;}
            self._end2fmt = {&#34;little&#34;: &#34;&lt;&#34;, &#34;big&#34;: &#34;&gt;&#34;}

        self._validate_object(object)

        if self.pyperipherals_registered_cb is False:
            self.register_callback(
                self.callback.unassigned_io_read,
                self.callback.unassigned_io_read(self.pyperiph_read_cb),
                &#34;pyperipheral_read_callback&#34;,
            )

            self.register_callback(
                self.callback.unassigned_io_write,
                self.callback.unassigned_io_write(self.pyperiph_write_cb),
                &#34;pyperipheral_write_callback&#34;,
            )

            self.pyperipherals_registered_cb = True

        self.pyperipherals.append(object)

    def unregister_pyperipheral(self, pyperiph):
        &#34;&#34;&#34;
        deregisters a python peripheral.
        The pyperiph parameter can be either an object, or an address
        Returns true if the pyperipheral was successfully removed, else false.
        &#34;&#34;&#34;

        if isinstance(pyperiph, int) is True:
            pp = self._addr_to_pyperipheral(pyperiph)
            if pp is None:
                return False
        else:
            if pyperiph not in self.pyperipherals:
                return False
            pp = pyperiph

        self.pyperipherals.remove(pp)

        # If we dont have any pyperipherals left, unregister callbacks
        if len(self.pyperipherals) == 0:
            self.disable_callback(&#34;pyperipheral_read_callback&#34;, forever=True)
            self.disable_callback(&#34;pyperipheral_write_callback&#34;, forever=True)
            self.pyperipherals_registered_cb = False
        return True

    ############## TAINT FUNCTIONS ###############
    # Convenience methods for interacting with the taint subsystem.
    def taint_enable(self, cont=True):
        &#34;&#34;&#34;
        Inform python that taint is enabled.
        &#34;&#34;&#34;
        if not self.taint_enabled:
            progress(&#34;taint not enabled -- enabling&#34;)
            self.vm_stop()
            self.require(&#34;taint2&#34;)
#            self.queue_main_loop_wait_fn(self.require, [&#34;taint2&#34;])
            self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_enable_taint, [])
            if cont:
                self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])
            self.taint_enabled = True

    # label all bytes in this register.
    # or at least four of them
    def taint_label_reg(self, reg_num, label):
        self.taint_enable(cont=False)
        #if debug:
        #    progress(&#34;taint_reg reg=%d label=%d&#34; % (reg_num, label))

        # XXX must ensure labeling is done in a before_block_invalidate that rets 1
        #     or some other safe way where the main_loop_wait code will always be run
        #self.stop()
        for i in range(self.register_size):
            self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_label_reg, [reg_num, i, label])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])

    def taint_label_ram(self, addr, label):
        self.taint_enable(cont=False)
        #if debug:
            #progress(&#34;taint_ram addr=0x%x label=%d&#34; % (addr, label))

        # XXX must ensure labeling is done in a before_block_invalidate that rets 1
        #     or some other safe way where the main_loop_wait code will always be run
        #self.stop()
        self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_label_ram, [addr, label])
        self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])

    # returns true if any bytes in this register have any taint labels
    def taint_check_reg(self, reg_num):
        if not self.taint_enabled: return False
#        if debug:
#            progress(&#34;taint_check_reg %d&#34; % (reg_num))
        for offset in range(self.register_size):
            if self.plugins[&#39;taint2&#39;].taint2_query_reg(reg_num, offset) &gt; 0:
                return True

    # returns true if this physical address is tainted
    def taint_check_ram(self, addr):
        if not self.taint_enabled: return False
        if self.plugins[&#39;taint2&#39;].taint2_query_ram(addr) &gt; 0:
            return True

    def taint_get_reg(self, reg_num):
        &#39;&#39;&#39;
        Returns array of results, one for each byte in this register
        None if no taint.  QueryResult struct otherwise
        &#39;&#39;&#39;
        if not self.taint_enabled: return None
        if debug:
            progress(&#34;taint_get_reg %d&#34; % (reg_num)) 
        res = []
        for offset in range(self.register_size): 
            if self.plugins[&#39;taint2&#39;].taint2_query_reg(reg_num, offset) &gt; 0:
                query_res = ffi.new(&#34;QueryResult *&#34;)
                self.plugins[&#39;taint2&#39;].taint2_query_reg_full(reg_num, offset, query_res)
                tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;])
                res.append(tq)
            else:
                res.append(None)
        return res

    # returns array of results, one for each byte in this register
    # None if no taint.  QueryResult struct otherwise
    def taint_get_ram(self, addr):
        if not self.taint_enabled: return None
        if self.plugins[&#39;taint2&#39;].taint2_query_ram(addr) &gt; 0:
            query_res = ffi.new(&#34;QueryResult *&#34;)
            self.plugins[&#39;taint2&#39;].taint2_query_ram_full(addr, query_res)
            tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;])
            return tq
        else:
            return None

    # returns true if this laddr is tainted
    def taint_check_laddr(self, addr, off):
        if not self.taint_enabled: return False
        if self.plugins[&#39;taint2&#39;].taint2_query_laddr(addr, off) &gt; 0:
            return True

    # returns array of results, one for each byte in this laddr
    # None if no taint.  QueryResult struct otherwise
    def taint_get_laddr(self, addr, offset):
        if not self.taint_enabled: return None
        if self.plugins[&#39;taint2&#39;].taint2_query_laddr(addr, offset) &gt; 0:
            query_res = ffi.new(&#34;QueryResult *&#34;)
            self.plugins[&#39;taint2&#39;].taint2_query_laddr_full(addr, offset, query_res)
            tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;])
            return tq
        else:
            return None

    ############ Volatility mixins
    &#34;&#34;&#34;
    Utilities to integrate Volatility with PANDA. Highly experimental.
    &#34;&#34;&#34;

    def make_panda_file_handler(self, debug=False):
        &#39;&#39;&#39;
        Constructs a file and file handler that volatility can&#39;t ignore to back by PANDA physical memory
        &#39;&#39;&#39;
        from urllib.request import BaseHandler
        if &#39;PandaFileHandler&#39; in globals():  # already initialized
            return
        panda = self

        class PandaFile(object):
            def __init__(self, length, panda):
                self.pos = 0
                self.length = length
                self.closed = False
                self.mode = &#34;rb&#34;
                self.name = &#34;/tmp/panda.panda&#34;
                self.panda = panda
                self.classname = type(self).__name__

            def readable(self):
                return self.closed

            def read(self, size=1):
                if self.panda.bits == 32 and self.panda.arch_name == &#34;i386&#34;:
                    data = self.panda.physical_memory_read(
                        self.pos &amp; 0xfffffff, size)
                else:
                    data = self.panda.physical_memory_read(self.pos, size)
                if debug:
                    print(self.classname+&#34;: Reading &#34; +
                          str(size)+&#34; bytes from &#34;+hex(self.pos))
                self.pos += size
                return data

            def peek(self, size=1):
                return self.panda.physical_memory_read(self.pos, size)

            def seek(self, pos, whence=0):
                if whence == 0:
                    self.pos = pos
                elif whence == 1:
                    self.pos += pos
                else:
                    self.pos = self.length - pos
                if self.pos &gt; self.length:
                    print(self.classname+&#34;: We&#39;ve gone off the deep end&#34;)
                if debug:
                    print(self.classname+&#34; Seeking to address &#34;+hex(self.pos))

            def tell(self):
                return self.pos

            def close(self):
                self.closed = True

        class PandaFileHandler(BaseHandler):
            def default_open(self, req):
                if &#39;panda.panda&#39; in req.full_url:
                    length = panda.libpanda.ram_size
                    if length &gt; 0xc0000000:
                        length += 0x40000000  # 3GB hole
                    if debug:
                        print(type(self).__name__ +
                              &#34;: initializing PandaFile with length=&#34;+hex(length))
                    return PandaFile(length=length, panda=panda)
                else:
                    return None

            def file_close(self):
                return True

        globals()[&#34;PandaFileHandler&#34;] = PandaFileHandler

    def get_volatility_symbols(self, debug=False):
        try:
            from .volatility_cli_classes import CommandLineMoreEfficient
            from volatility.framework import contexts
            from volatility.framework.layers.linear import LinearlyMappedLayer
            from volatility.framework.automagic import linux
        except ImportError:
            print(&#34;Warning: Failed to import volatility&#34;)
            return None
        if &#34;linux&#34; in self.os_type:
            if not hasattr(self, &#34;_vmlinux&#34;):
                self.make_panda_file_handler(debug=debug)
                constructed_original = CommandLineMoreEfficient().run()
                linux.LinuxUtilities.aslr_mask_symbol_table(
                    constructed_original.context, constructed_original.config[&#39;vmlinux&#39;], constructed_original.config[&#39;primary&#39;])
                self._vmlinux = contexts.Module(
                    constructed_original.context, constructed_original.config[&#39;vmlinux&#39;], constructed_original.config[&#39;primary&#39;], 0)
            else:
                LinearlyMappedLayer.read.cache_clear()  # smearing technique
            return self._vmlinux
        else:
            print(&#34;Unsupported.&#34;)
            return None

    def run_volatility(self, plugin, debug=False):
        try:
            from .volatility_cli_classes import CommandLineRunFullCommand, StringTextRenderer
        except ImportError:
            print(&#34;Warning: Failed to import volatility&#34;)
            return None
        self.make_panda_file_handler(debug=debug)
        cmd = CommandLineRunFullCommand().run(&#34;-q -f panda.panda &#34; + plugin)
        output = StringTextRenderer().render(cmd.run())
        return output

    ########## BLOCKING MIXINS ############
    &#39;&#39;&#39;
    Utilities to provide blocking interactions with PANDA. This includes serial and monitor interactions as well as file copy to the guest.
    XXX: Do not call any of the following from the main thread- they depend on the CPU loop running
    &#39;&#39;&#39;
    @blocking
    def stop_run(self):
        &#39;&#39;&#39;
        From a blocking thread, request vl.c loop to break. Returns control flow in main thread.
        In other words, once this is called, panda.run() will finish and your main thread will continue.
        If you also want to unload plugins, use end_analysis instead

        XXX: This doesn&#39;t work in replay mode
        &#39;&#39;&#39;
        self.libpanda.panda_break_vl_loop_req = True

    @blocking
    def run_serial_cmd(self, cmd, no_timeout=False, timeout=30):
        self.running.wait() # Can only run serial when guest is running
        self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
        if no_timeout:
            result = self.serial_console.expect(timeout=9999)
        else:
            result = self.serial_console.expect(timeout=timeout)
        return result

    @blocking
    def run_serial_cmd_async(self, cmd, delay=1):
        &#39;&#39;&#39;
        Type a command and press enter in the guest. Return immediately. No results available
        Only use this if you know what you&#39;re doing!
        &#39;&#39;&#39;
        self.running.wait() # Can only run serial when guest is running
        self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
        if delay:
            sleep(delay) # Ensure it has a chance to run

    @blocking
    def type_serial_cmd(self, cmd):
        #Can send message into socket without guest running (no self.running.wait())
        self.serial_console.send(cmd.encode(&#34;utf8&#34;)) # send, not sendline

    def finish_serial_cmd(self):
        result = self.serial_console.send_eol()
        result = self.serial_console.expect()
        return result

    @blocking
    def run_monitor_cmd(self, cmd):
        self.monitor_console.sendline(cmd.encode(&#34;utf8&#34;))
        result = self.monitor_console.expect()
        return result

    @blocking
    def revert_sync(self, snapshot_name):
        result = self.run_monitor_cmd(&#34;loadvm {}&#34;.format(snapshot_name))
        if result.startswith(&#34;Length mismatch&#34;):
            raise RuntimeError(&#34;QEMU machine&#39;s RAM size doesn&#39;t match snapshot RAM size!&#34;)
        return result

    @blocking
    def delvm_sync(self, snapshot_name):
        self.run_monitor_cmd(&#34;delvm {}&#34;.format(snapshot_name))

    @blocking
    def copy_to_guest(self, copy_directory, iso_name=None):
        if not iso_name: iso_name = copy_directory + &#39;.iso&#39;
        progress(&#34;Creating ISO {}...&#34;.format(iso_name))

        make_iso(copy_directory, iso_name)

        copy_directory = path.split(copy_directory)[-1] # Get dirname

        # 1) we insert the CD drive TODO: the cd-drive name should be a config option, see the values in qcow.py
        self.run_monitor_cmd(&#34;change ide1-cd0 \&#34;{}\&#34;&#34;.format(iso_name))

        # 2) run setup script
        # setup_sh: 
        #   Make sure cdrom didn&#39;t automount
        #   Make sure guest path mirrors host path
        #   if there is a setup.sh script in the directory,
        #   then run that setup.sh script first (good for scripts that need to
        #   prep guest environment before script runs)
        setup_sh = &#34;mkdir -p {mount_dir}; while ! mount /dev/cdrom {mount_dir}; do sleep 0.3; &#34; \
               &#34; umount /dev/cdrom; done; {mount_dir}/setup.sh &amp;&gt; /dev/null || true &#34; \
               .format(mount_dir = (shlex_quote(copy_directory)))
        progress(&#34;setup_sh = [%s] &#34; % setup_sh)
        progress(self.run_serial_cmd(setup_sh))

    @blocking
    def record_cmd(self, guest_command, copy_directory=None, iso_name=None, setup_command=None, recording_name=&#34;recording&#34;, snap_name=&#34;root&#34;, ignore_errors=False):
        &#39;&#39;&#39;
        Take a recording as follows:
            0) Revert to the specified snapshot name if one is set. By default &#39;root&#39;. Set to `None` if you have already set up the guest and are ready to record with no revert
            1) Create an ISO of files that need to be copied into the guest if copy_directory is specified. Copy them in
            2) Run the setup_command in the guest, if provided
            3) Type the command you wish to record but do not press enter to begin execution. This avoids the recording capturing the command being typed
            4) Begin the recording (name controlled by recording_name)
            5) Press enter in the guest to begin the command. Wait until it finishes.
            6) End the recording
        &#39;&#39;&#39;
        # 0) Revert to the specified snapshot
        if snap_name is not None:
            self.revert_sync(snap_name) # Can&#39;t use self.revert because that would would run async and we&#39;d keep going before the revert happens

        # 1) Make copy_directory into an iso and copy it into the guest - It will end up at the exact same path
        if copy_directory: # If there&#39;s a directory, build an ISO and put it in the cddrive
            # Make iso
            self.copy_to_guest(copy_directory, iso_name)

        # 2) Run setup_command, if provided before we start the recording (good place to CD or install, etc)
        if setup_command:
            print(f&#34;Running setup command {setup_command}&#34;)
            r = self.run_serial_cmd(setup_command)
            print(f&#34;Setup command results: {r}&#34;)

        # 3) type commmand (note we type command, start recording, finish command)
        self.type_serial_cmd(guest_command)

        # 4) start recording
        self.run_monitor_cmd(&#34;begin_record {}&#34;.format(recording_name))

        # 5) finish command
        result = self.finish_serial_cmd()

        if debug:
            progress(&#34;Result of `{}`:&#34;.format(guest_command))
            print(&#34;\t&#34;+&#34;\n\t&#34;.join(result.split(&#34;\n&#34;))+&#34;\n&#34;)

        if &#34;No such file or directory&#34; in result and not ignore_errors:
            print(&#34;Bad output running command: {}&#34;.format(result))
            raise RuntimeError(&#34;Command not found while taking recording&#34;)

        if &#34;cannot execute binary file&#34; in result and not ignore_errors:
            print(&#34;Bad output running command: {}&#34;.format(result))
            raise RuntimeError(&#34;Could not execute binary while taking recording&#34;)

        # 6) End recording
        self.run_monitor_cmd(&#34;end_record&#34;)

        print(&#34;Finished recording&#34;)

    @blocking
    def interact(self, confirm_quit=True):
        &#39;&#39;&#39;
        Expose console interactively until user types pandaquit
        Must be run in blocking thread.

        TODO: This should probably repace self.serial_console with something
        that directly renders output to the user. Then we don&#39;t have to handle
        buffering and other problems. But we will need to re-enable the serial_console
        interface after this returns
        &#39;&#39;&#39;
        print(&#34;PANDA: entering interactive mode. Type pandaquit to exit&#34;)
        prompt = self.expect_prompt.decode(&#34;utf8&#34;) if self.expect_prompt  else &#34;$ &#34;
        if not prompt.endswith(&#34; &#34;): prompt += &#34; &#34;
        while True:
            cmd = input(prompt) # TODO: Strip all control characters - Ctrl-L breaks things
            if cmd.strip() == &#39;pandaquit&#39;:
                if confirm_quit:
                    q = input(&#34;PANDA: Quitting interactive mode. Are you sure? (y/n) &#34;)
                    if len(q) and q.lower()[0] == &#39;y&#39;:
                        break
                    else:
                        continue
                else: # No confirm - just break
                    break
            r = self.run_serial_cmd(cmd) # XXX: may timeout
            print(r)

    @blocking
    def do_panda_finish(self):
        &#39;&#39;&#39;
        Call panda_finish. Note this isn&#39;t really blocking - the
        guest should have exited by now, but queue this after
        (blocking) shutdown commands in our internal async queue
        so it must also be labeled as blocking.
        &#39;&#39;&#39;
#        assert (not self.running.is_set()), &#34;Can&#39;t finish while still running&#34;
        self.panda_finish()

    ################## CALLBACK FUNCTIONS ################
    # Mixin for handling callbacks and generation of decorators that allow users to register their own callbacks
    # such as panda.cb_before_block_exec()
    def register_cb_decorators(self):
        &#39;&#39;&#39;
        Setup callbacks and generate self.cb_XYZ functions for cb decorators
        XXX Don&#39;t add any other methods with names starting with &#39;cb_&#39;
        Callbacks can be called as @panda.cb_XYZ in which case they&#39;ll take default arguments and be named the same as the decorated function
        Or they can be called as @panda.cb_XYZ(name=&#39;A&#39;, procname=&#39;B&#39;, enabled=True). Defaults: name is function name, procname=None, enabled=True unless procname set
        &#39;&#39;&#39;
        for cb_name, pandatype in zip(self.callback._fields, self.callback):
            def closure(closed_cb_name, closed_pandatype): # Closure on cb_name and pandatype
                def f(*args, **kwargs):
                    if len(args): # Called as @panda.cb_XYZ without ()s- no arguments to decorator but we get the function name instead
                        # Call our decorator with only a name argument ON the function itself
                        fun = args[0]
                        return self._generated_callback(closed_pandatype, **{&#34;name&#34;: fun.__name__})(fun)
                    else:
                        # Otherwise, we were called as @panda.cb_XYZ() with potential args - Just return the decorator and it&#39;s applied to the function
                        return self._generated_callback(closed_pandatype, *args, **kwargs)
                return f

            setattr(self, &#39;cb_&#39;+cb_name, closure(cb_name, pandatype))

    def _generated_callback(self, pandatype, name=None, procname=None, enabled=True):
        &#39;&#39;&#39;
        Actual implementation of self.cb_XYZ. pandatype is pcb.XYZ
        name must uniquely describe a callback
        if procname is specified, callback will only be enabled when that asid is running (requires OSI support)
        &#39;&#39;&#39;

        if procname:
            enabled = False # Process won&#39;t be running at time 0 (probably)
            self._register_internal_asid_changed_cb()

        def decorator(fun):
            local_name = name  # We need a new varaible otherwise we have scoping issues with _generated_callback&#39;s name
            if name is None:
                local_name = fun.__name__
            
            # 0 works for all callbacks except void. We check later on
            # to see if we need to return None otherwise we return 0
            return_from_exception = 0

            def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
                try:
                    r = fun(*args, **kwargs)
                    #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                    #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    self.callback_exit_exception = e
                    self.end_analysis()
                    return return_from_exception

            cast_rc = pandatype(_run_and_catch)
            cast_rc_string = str(ffi.typeof(cast_rc))
            return_from_exception = 0
            if &#34;void(*)(&#34; in cast_rc_string:
                return_from_exception = None

            self.register_callback(pandatype, cast_rc, local_name, enabled=enabled, procname=procname)
            def wrapper(*args, **kw):
                return _run_and_catch(*args, **kw)
            return wrapper
        return decorator

    def _register_internal_asid_changed_cb(self):
        &#39;&#39;&#39;
        Call this function if you need procname filtering for callbacks. It enables
        an internal callback on asid_changed (and sometimes an after_block_exec cb)
        which will deteremine when the process name changes and enable/disable other callbacks
        that filter on process name.
        &#39;&#39;&#39;
        if self._registered_asid_changed_internal_cb: # Already registered these callbacks
            return

        @self.ppp(&#34;syscalls2&#34;, &#34;on_sys_brk_enter&#34;)
        def on_sys_brk_enter(cpu, pc, brk):
            name = self.get_process_name(cpu)
            asid = self.libpanda.panda_current_asid(cpu)
            if self.asid_mapping.get(asid, None) != name:
                self.asid_mapping[asid] = name
                self._procname_changed(cpu, name)

        @self.callback.after_block_exec
        def __get_pending_procname_change(cpu, tb, exit_code):
            if exit_code: # Didn&#39;t actually execute block
                return None
            if not self.in_kernel(cpu): # Once we&#39;re out of kernel code, grab procname
                process = self.plugins[&#39;osi&#39;].get_current_process(cpu)
                if process != ffi.NULL:
                    name = ffi.string(process.name).decode(&#34;utf8&#34;, &#34;ignore&#34;)
                else:
                    return None # Couldn&#39;t figure out the process
                asid = self.libpanda.panda_current_asid(cpu)
                self.asid_mapping[asid] = name
                self._procname_changed(cpu, name)
                self.disable_callback(&#39;__get_pending_procname_change&#39;) # Disabled to begin


        # Local function def
        @self.callback.asid_changed
        def __asid_changed(cpustate, old_asid, new_asid):
            &#39;&#39;&#39;
            When the ASID changes, check if we know its procname (in self.asid_mapping),
            if so, call panda._procname_changed(cpu, name). Otherwise, we enable __get_pending_procname_change CB, which
            waits until the procname changes. Then we grab the new procname, update self.asid_mapping and call
            panda._procname_changed(cpu, name)
            &#39;&#39;&#39;
            if old_asid == new_asid:
                return 0

            if new_asid not in self.asid_mapping: # We don&#39;t know this ASID-&gt;procname - turn on __get_pending_procname_change
                if not self.is_callback_enabled(&#39;__get_pending_procname_change&#39;):
                    self.enable_callback(&#39;__get_pending_procname_change&#39;)
            else: # We do know this ASID-&gt;procname, just call procname_changed
                self._procname_changed(cpustate, self.asid_mapping[new_asid])

            return 0

        self.register_callback(self.callback.asid_changed, __asid_changed, &#34;__asid_changed&#34;) # Always call on ASID change

        # This internal callback is only enabled on-demand (later) when we need to figure out ASID-&gt;procname mappings
        self.register_callback(self.callback.after_block_exec, __get_pending_procname_change, &#34;__get_pending_procname_change&#34;, enabled=False)

        self._registered_asid_changed_internal_cb = True

    def register_callback(self, callback, function, name, enabled=True, procname=None):
        # CB   = self.callback.main_loop_wait
        # func = main_loop_wait_cb
        # name = main_loop_wait

        if name in self.registered_callbacks:
            print(f&#34;Warning: replacing existing callback &#39;{name}&#39; since it was re-registered&#34;)
            self.delete_callback(name)

        cb = self.callback_dictionary[callback]

        # Generate a unique handle for each callback type using the number of previously registered CBs of that type added to a constant
        handle = ffi.cast(&#39;void *&#39;, 0x8888 + 100*len([x for x in self.registered_callbacks.values() if x[&#39;callback&#39;] == cb]))

        # XXX: We should have another layer of indirection here so we can catch
        #      exceptions raised during execution of the CB and abort analysis
        pcb = ffi.new(&#34;panda_cb *&#34;, {cb.name:function})

        if debug:
            progress(&#34;Registered function &#39;{}&#39; to run on callback {}&#34;.format(name, cb.name))

        self.libpanda.panda_register_callback_helper(handle, cb.number, pcb)
        self.registered_callbacks[name] = {&#34;procname&#34;: procname, &#34;enabled&#34;: True, &#34;callback&#34;: cb,
                           &#34;handle&#34;: handle, &#34;pcb&#34;: pcb, &#34;function&#34;: function} # XXX: if function is not saved here it gets GC&#39;d and everything breaks! Watch out!

        if not enabled: # Note the registered_callbacks dict starts with enabled true and then we update it to false as necessary here
            self.disable_callback(name)

        if &#34;block&#34; in cb.name:
            if not self.disabled_tb_chaining:
                print(&#34;Warning: disabling TB chaining to support {} callback&#34;.format(cb.name))
                self.disable_tb_chaining()


    def is_callback_enabled(self, name):
        if name not in self.registered_callbacks.keys():
            raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))
        return self.registered_callbacks[name][&#39;enabled&#39;]

    def enable_internal_callbacks(self):
        &#39;&#39;&#39;
        Enable all our internal callbacks that start with __ such as __main_loop_wait
        and __asid_changed. Important in case user has done a panda.end_analysis()
        and then (re)called run
        &#39;&#39;&#39;
        for name in self.registered_callbacks.keys():
            if name.startswith(&#34;__&#34;) and not self.registered_callbacks[name][&#39;enabled&#39;]:
                self.enable_callback(name)

    def enable_all_callbacks(self):
        &#39;&#39;&#39;
        Enable all python callbacks that have been disabled
        &#39;&#39;&#39;
        for name in self.registered_callbacks.keys():
            self.enable_callback(name)

    def enable_callback(self, name):
        &#39;&#39;&#39;
        Enable a panda plugin using its handle and cb.number as a unique ID
        &#39;&#39;&#39;
        if name not in self.registered_callbacks.keys():
            raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))

        self.registered_callbacks[name][&#39;enabled&#39;] = True
        handle = self.registered_callbacks[name][&#39;handle&#39;]
        cb = self.registered_callbacks[name][&#39;callback&#39;]
        pcb = self.registered_callbacks[name][&#39;pcb&#39;]
        #progress(&#34;Enabling callback &#39;{}&#39; on &#39;{}&#39; handle = {}&#34;.format(name, cb.name, handle))
        self.libpanda.panda_enable_callback_helper(handle, cb.number, pcb)

    def disable_callback(self, name, forever=False):
        &#39;&#39;&#39;
        Disable a panda plugin using its handle and cb.number as a unique ID
        If forever is specified, we&#39;ll never reenable the call- useful when
        you want to really turn off something with a procname filter.
        &#39;&#39;&#39;
        if name not in self.registered_callbacks.keys():
            raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))
        self.registered_callbacks[name][&#39;enabled&#39;] = False
        handle = self.registered_callbacks[name][&#39;handle&#39;]
        cb = self.registered_callbacks[name][&#39;callback&#39;]
        pcb = self.registered_callbacks[name][&#39;pcb&#39;]
        #progress(&#34;Disabling callback &#39;{}&#39; on &#39;{}&#39; handle={}&#34;.format(name, cb.name, handle))
        self.libpanda.panda_disable_callback_helper(handle, cb.number, pcb)

        if forever:
            del self.registered_callbacks[name]

    def delete_callback(self, name):
        &#39;&#39;&#39;
        Completely delete a registered panda callback by name
        &#39;&#39;&#39;
        if name not in self.registered_callbacks.keys():
            raise ValueError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))

        handle = self.registered_callbacks[name][&#39;handle&#39;]
        self.libpanda.panda_unregister_callbacks(handle)
        del self.registered_callbacks[name][&#39;handle&#39;]

    ###########################
    ### PPP-style callbacks ###
    ###########################

    def ppp(self, plugin_name, attr, name=None):
        &#39;&#39;&#39;
        Decorator for plugin-to-plugin interface. Note this isn&#39;t in decorators.py
        becuase it uses the panda object.

        Example usage to register my_run with syscalls2 as a &#39;on_sys_open_return&#39;
        @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;)
        def my_fun(cpu, pc, filename, flags, mode):
            ...
        &#39;&#39;&#39;

        if plugin_name not in self.plugins: # Could automatically load it?
            print(f&#34;PPP automatically loaded plugin {plugin_name}&#34;)

        if not hasattr(self, &#34;ppp_registered_cbs&#34;):
            self.ppp_registered_cbs = {}
            # We use this to traak fn_names-&gt;fn_pointers so we can later disable by name

            # XXX: if  we don&#39;t save the cffi generated callbacks somewhere in Python,
            # they may get garbage collected even though the c-code could still has a
            # reference to them  which will lead to a crash. If we stop using this to track
            # function names, we need to keep it or something similar to ensure the reference
            # count remains &gt;0 in python

        def decorator(fun):
            local_name = name  # We need a new varaible otherwise we have scoping issues, maybe
            if local_name is None:
                local_name = fun.__name__
            
            def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
                try:
                    r = fun(*args, **kwargs)
                    #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                    #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                    return r
                except Exception as e:
                    # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                    # machine exits.
                    self.callback_exit_exception = e
                    self.end_analysis()
                    # this works in all current callback cases. CFFI auto-converts to void, bool, int, and int32_t

            f = ffi.callback(attr+&#34;_t&#34;)(_run_and_catch)  # Wrap the python fn in a c-callback.
            if local_name == &#34;&lt;lambda&gt;&#34;:
                local_name = f&#34;&lt;lambda_{self.lambda_cnt}&gt;&#34;
                self.lambda_cnt += 1

            if local_name in self.ppp_registered_cbs:
                print(f&#34;Warning: replacing existing PPP callback &#39;{name}&#39; since it was re-registered&#34;)
                self.disable_ppp(local_name)

            assert (local_name not in self.ppp_registered_cbs), f&#34;Two callbacks with conflicting name: {local_name}&#34;

            # Ensure function isn&#39;t garbage collected, and keep the name-&gt;(fn, plugin_name, attr) map for disabling
            self.ppp_registered_cbs[local_name] = (f, plugin_name, attr)

            eval(f&#34;self.plugins[&#39;{plugin_name}&#39;].ppp_add_cb_{attr}&#34;)(f) # All PPP  cbs start with this string. XXX insecure eval
            return f
        return decorator


    def disable_ppp(self, name):
        &#39;&#39;&#39;
        Disable a ppp-style callback by name.
        Unlike regular panda callbacks which can be enabled/disabled/deleted, PPP callbacks are only enabled/deleted (which we call disabled)

        Example usage to register my_run with syscalls2 as a &#39;on_sys_open_return&#39; and then disable:
        ```
        @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;)
        def my_fun(cpu, pc, filename, flags, mode):
            ...

        panda.disable_ppp(&#34;my_fun&#34;)
        ```

        -- OR --

        ```
        @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;, name=&#34;custom&#34;)
        def my_fun(cpu, pc, filename, flags, mode):
            ...
        ```

        panda.disable_ppp(&#34;custom&#34;)
        &#39;&#39;&#39;

        (f, plugin_name, attr) = self.ppp_registered_cbs[name]
        eval(f&#34;self.plugins[&#39;{plugin_name}&#39;].ppp_remove_cb_{attr}&#34;)(f) # All PPP cbs start with this string. XXX insecure eval
        del self.ppp_registered_cbs[name] # It&#39;s now safe to be garbage collected

    ########## GDB MIXINS ##############
    &#34;&#34;&#34;
    Provides the ability to interact with a QEMU attached gdb session by setting and clearing breakpoints. Experimental.
    &#34;&#34;&#34;

    def set_breakpoint(self, cpu, pc):
        &#39;&#39;&#39;
        Set a GDB breakpoint such that when the guest hits PC, execution is paused and an attached
        GDB instance can introspect on guest memory. Requires starting panda with -s, at least for now
        &#39;&#39;&#39;
        BP_GDB = 0x10
        self.libpanda.cpu_breakpoint_insert(cpu, pc, BP_GDB, ffi.NULL)

    def clear_breakpoint(self, cpu, pc):
        &#39;&#39;&#39;
        Remove a breakpoint
        &#39;&#39;&#39;
        BP_GDB = 0x10
        self.libpanda.cpu_breakpoint_remove(cpu, pc, BP_GDB)

    ############# HOOKING MIXINS ###############
    def update_hook(self,hook_name,addr):
        &#39;&#39;&#39;
        Update hook to point to a different addres and enable it
        &#39;&#39;&#39;
        if hook_name in self.named_hooks:
            hook = self.named_hooks[hook_name]
            #print(f&#34;Updating hook {hook_name} at 0x{hook.target_addr:x}&#34;)
            if addr != hook.target_addr:
                hook.target_addr = addr
                self.plugins[&#39;hooks&#39;].enable_hook(hook.hook_cb, hook.target_addr)
            self.enable_hook(hook_name)

        else:
            raise ValueError(f&#34;Unknown hook {hook_name}&#34;)

    def enable_hook(self,hook_name):
        &#39;&#39;&#39;
        Set hook status to active.        
        &#39;&#39;&#39;
        if hook_name in self.named_hooks:
            hook = self.named_hooks[hook_name]
            if not hook.is_enabled:
                hook.is_enabled = True
                #print(f&#34;Enabling hook {hook_name} at 0x{hook.target_addr:x}&#34;)
                self.plugins[&#39;hooks&#39;].enable_hook(hook.hook_cb, hook.target_addr)
        else:
            raise ValueError(f&#34;Unknown hook {hook_name}&#34;)

    def disable_hook(self,hook_name):
        &#39;&#39;&#39;
        Set hook status to inactive.
        &#39;&#39;&#39;
        if hook_name in self.named_hooks:
            hook = self.named_hooks[hook_name]
            if hook.is_enabled:
                hook.is_enabled = False
                self.plugins[&#39;hooks&#39;].disable_hook(hook.hook_cb)
        else:
            raise ValueError(f&#34;Unknown hook {hook_name}&#34;)

    def _update_hooks_new_procname(self, cpu, name):
        &#39;&#39;&#39;
        Uses user-defined information to update the state of hooks based on things such as libraryname, procname and whether 
        or not the hook points to kernel space.
        &#39;&#39;&#39;
        for h in self.hook_list:
            if h.is_kernel:
                continue

            if h.program_name:
                if (h.program_name != name):
                    if h.is_enabled:
                        self.disable_hook(name)
                    continue

                if h.library_name is None:
                    if h.is_enabled:
                        self.enable_hook(h)
                    continue

            if h.library_name:
                asid = self.libpanda.panda_current_asid(cpu)
                lowest_matching_addr = 0

                if lowest_matching_addr == 0:
                    libs = self.get_mappings(cpu)
                    if libs == ffi.NULL:
                        continue
                    for lib in libs:
                        if lib.file != ffi.NULL:
                            filename = ffi.string(lib.file).decode(&#34;utf8&#34;, &#34;ignore&#34;)
                            if h.library_name in filename:
                                if (lowest_matching_addr == 0) or (lib.base &lt; lowest_matching_addr):
                                    lowest_matching_addr = lib.base

                if lowest_matching_addr:
                    self.update_hook(h, lowest_matching_addr + h.target_library_offset)
                else:
                    self.disable_hook(name)

    def _register_mmap_cb(self):
        if self._registered_mmap_cb:
            return

        @self.ppp(&#34;syscalls2&#34;, &#34;on_do_mmap2_return&#34;)
        def on_do_mmap2_return(cpu, pc, addr, length, prot, flags, fd, pgoff):
            self._update_hooks_new_procname(cpu, self.get_process_name(cpu))

    def hook(self, addr, enabled=True, kernel=True, libraryname=None, procname=None, name=None):
        &#39;&#39;&#39;
        Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
        the function will be called with args (CPUState, TranslationBlock)
        &#39;&#39;&#39;
        if procname:
            self._register_internal_asid_changed_cb()

        if libraryname:
            self._register_mmap_cb()

        def decorator(fun):
            # Ultimately, our hook resolves as a before_block_exec so we must match its args
            hook_cb_type = self.callback.before_block_exec # (CPUState, TranslationBlock)

            if &#39;hooks&#39; not in self.plugins:
                # Enable hooks plugin on first request
                self.load_plugin(&#34;hooks&#34;)

            if debug:
                print(&#34;Registering breakpoint at 0x{:x} -&gt; {} == {}&#34;.format(addr, fun, &#39;cdata_cb&#39;))

            # Inform the plugin that it has a new breakpoint at addr
            hook_cb_passed = hook_cb_type(fun)
            self.plugins[&#39;hooks&#39;].add_hook(addr, hook_cb_passed)
            hook_to_add = Hook(is_enabled=enabled,is_kernel=kernel,target_addr=addr,library_name=libraryname,program_name=procname,hook_cb=None, target_library_offset=None)
            if libraryname: 
                hook_to_add.target_library_offset = addr
                hook_to_add.target_addr = 0
                hook_to_add.hook_cb = hook_cb_passed
            else:
                hook_to_add.hook_cb = hook_cb_passed
            self.hook_list.append(hook_to_add)
            if not hasattr(self, &#34;named_hooks&#34;):
                self.named_hooks = {}
            local_name = name if name else fun.__name__ # XXX: weird scoping
            self.named_hooks[local_name] = hook_to_add

            if libraryname or procname or not enabled:
                self.disable_hook(local_name)

            @hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
            def wrapper(*args, **kw):
                return fun(*args, **kw)

            return wrapper
        return decorator



    &#34;&#34;&#34;
    Provides the ability to interact with the hooks2 plugin and receive callbacks based on user-provided criteria.
    &#34;&#34;&#34;

    def enable_hook2(self,hook_name):
        &#39;&#39;&#39;
        Set hook status to active.        
        &#39;&#39;&#39;
        if hook_name in self.hook_list2:
            self.plugins[&#39;hooks2&#39;].enable_hooks2(self.hook_list2[hook_name])
        else:
            print(&#34;ERROR: Your hook name was not in the hook list&#34;)

    def disable_hook2(self,hook_name):
        &#39;&#39;&#39;
        Set hook status to inactive.
        &#39;&#39;&#39;
        if hook_name in self.hook_list2:
            self.plugins[&#39;hooks2&#39;].disable_hooks2(self.hook_list2[hook_name])
        else:
            print(&#34;ERROR: Your hook name was not in the hook list&#34;)

    def hook2(self,name, kernel=True, procname=ffi.NULL, libname=ffi.NULL, trace_start=0, trace_stop=0, range_begin=0, range_end=0):
        if procname != ffi.NULL:
            procname = ffi.new(&#34;char[]&#34;,bytes(procname,&#34;utf-8&#34;))
        if libname != ffi.NULL:
            libname = ffi.new(&#34;char[]&#34;,bytes(libname,&#34;utf-8&#34;))
        &#39;&#39;&#39;
        Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
        the function will be called with args (CPUState, TranslationBlock)
        &#39;&#39;&#39;
        def decorator(fun):
            # Ultimately, our hook resolves as a before_block_exec_invalidate_opt callback so we must match its args
            hook_cb_type = ffi.callback(&#34;bool (CPUState*, TranslationBlock*, void*)&#34;)
            # Inform the plugin that it has a new breakpoint at addr
            
            hook_cb_passed = hook_cb_type(fun)
            if not hasattr(self, &#34;hook_gc_list&#34;):
                self.hook_gc_list = [hook_cb_passed]
            else:
                self.hook_gc_list.append(hook_cb_passed)

            # I don&#39;t know what this is/does
            cb_data = ffi.NULL
            hook_number = self.plugins[&#39;hooks2&#39;].add_hooks2(hook_cb_passed, cb_data, kernel, \
                procname, libname, trace_start, trace_stop, range_begin,range_end)
            
            self.hook_list2[name] = hook_number

            @hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
            def wrapper(*args, **kw):
                return fun(*args, **kw)

            return wrapper
        return decorator
    
    def hook2_single_insn(self, name, pc, kernel=False, procname=ffi.NULL, libname=ffi.NULL):
        return self.hook(name, kernel=kernel, procname=procname,libname=libname,range_begin=pc, range_end=pc)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pandare.panda.Panda.arch"><code class="name">var <span class="ident">arch</span></code></dt>
<dd>
<div class="desc"><p>A reference to an auto-instantiated <code><a title="pandare.arch.PandaArch" href="arch.html#pandare.arch.PandaArch">PandaArch</a></code> subclass (e.g., <code><a title="pandare.arch.X86Arch" href="arch.html#pandare.arch.X86Arch">X86Arch</a></code>)</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pandare.panda.Panda.arm_load_kernel"><code class="name flex">
<span>def <span class="ident">arm_load_kernel</span></span>(<span>self, cpu, bootinfo)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arm_load_kernel(self, cpu, bootinfo):
    return self.libpanda.arm_load_kernel(cpu, bootinfo)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.callstack_callers"><code class="name flex">
<span>def <span class="ident">callstack_callers</span></span>(<span>self, lim, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function to handle conversion and return get_callers from callstack_instr.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def callstack_callers(self, lim, cpu): # XXX move into new directory, &#39;callstack&#39; ?
    &#39;&#39;&#39;
    Utility function to handle conversion and return get_callers from callstack_instr.
    &#39;&#39;&#39;
    if not &#34;plugin_callstack_instr&#34; in self.plugins:
        progress(&#34;enabling callstack_instr plugin&#34;)
        self.require(&#34;callstack_instr&#34;)

    callers = ffi.new(&#34;uint32_t[%d]&#34; % lim)
    n = self.plugins[&#39;callstack_instr&#39;].get_callers(callers, lim, cpu)
    c = []
    for pc in callers:
        c.append(pc)
    return c</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Unload all plugins and close pandalog.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup(self):
    &#39;&#39;&#39;
    Unload all plugins and close pandalog.
    &#39;&#39;&#39;
    self.libpanda.panda_cleanup()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.clear_breakpoint"><code class="name flex">
<span>def <span class="ident">clear_breakpoint</span></span>(<span>self, cpu, pc)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a breakpoint</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_breakpoint(self, cpu, pc):
    &#39;&#39;&#39;
    Remove a breakpoint
    &#39;&#39;&#39;
    BP_GDB = 0x10
    self.libpanda.cpu_breakpoint_remove(cpu, pc, BP_GDB)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.cont"><code class="name flex">
<span>def <span class="ident">cont</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Continue execution (run after vm_stop)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cont(self):
    &#39;&#39;&#39; Continue execution (run after vm_stop) &#39;&#39;&#39;
    self.libpanda.panda_cont()
    self.running.set()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.copy_to_guest"><code class="name flex">
<span>def <span class="ident">copy_to_guest</span></span>(<span>self, copy_directory, iso_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def copy_to_guest(self, copy_directory, iso_name=None):
    if not iso_name: iso_name = copy_directory + &#39;.iso&#39;
    progress(&#34;Creating ISO {}...&#34;.format(iso_name))

    make_iso(copy_directory, iso_name)

    copy_directory = path.split(copy_directory)[-1] # Get dirname

    # 1) we insert the CD drive TODO: the cd-drive name should be a config option, see the values in qcow.py
    self.run_monitor_cmd(&#34;change ide1-cd0 \&#34;{}\&#34;&#34;.format(iso_name))

    # 2) run setup script
    # setup_sh: 
    #   Make sure cdrom didn&#39;t automount
    #   Make sure guest path mirrors host path
    #   if there is a setup.sh script in the directory,
    #   then run that setup.sh script first (good for scripts that need to
    #   prep guest environment before script runs)
    setup_sh = &#34;mkdir -p {mount_dir}; while ! mount /dev/cdrom {mount_dir}; do sleep 0.3; &#34; \
           &#34; umount /dev/cdrom; done; {mount_dir}/setup.sh &amp;&gt; /dev/null || true &#34; \
           .format(mount_dir = (shlex_quote(copy_directory)))
    progress(&#34;setup_sh = [%s] &#34; % setup_sh)
    progress(self.run_serial_cmd(setup_sh))</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.cpu_class_by_name"><code class="name flex">
<span>def <span class="ident">cpu_class_by_name</span></span>(<span>self, name, cpu_model)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets cpu class from name.
Calls cpu_class_by_name QEMU function.</p>
<pre><code>Parameters:
    name: typename from python string
    cpu_model: string specified cpu model

Returns:
    ObjectClass struct
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cpu_class_by_name(self, name, cpu_model):
    &#39;&#39;&#39;
    Gets cpu class from name.
    Calls cpu_class_by_name QEMU function.

        Parameters:
            name: typename from python string
            cpu_model: string specified cpu model

        Returns:
            ObjectClass struct
    &#39;&#39;&#39;
    return self.libpanda.cpu_class_by_name(name, cpu_model)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.create_external_gic"><code class="name flex">
<span>def <span class="ident">create_external_gic</span></span>(<span>self, vbi, irqs, gic_vers, secure)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_external_gic(self, vbi, irqs, gic_vers, secure):
    return self.libpanda.create_external_gic(vbi, irqs, gic_vers, secure)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.create_internal_gic"><code class="name flex">
<span>def <span class="ident">create_internal_gic</span></span>(<span>self, vbi, irqs, gic_vers)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_internal_gic(self, vbi, irqs, gic_vers):
    return self.libpanda.create_internal_gic(vbi, irqs, gic_vers)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.create_one_flash"><code class="name flex">
<span>def <span class="ident">create_one_flash</span></span>(<span>self, name, flashbase, flashsize, filename, mr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_one_flash(self, name, flashbase, flashsize, filename, mr):
    return self.libpanda.create_one_flash(name, flashbase, flashsize, filename, mr)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.create_virtio_devices"><code class="name flex">
<span>def <span class="ident">create_virtio_devices</span></span>(<span>self, vbi, pic)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_virtio_devices(self, vbi, pic):
    return self.libpanda.create_virtio_devices(vbi, pic)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.current_asid"><code class="name flex">
<span>def <span class="ident">current_asid</span></span>(<span>self, cpustate)</span>
</code></dt>
<dd>
<div class="desc"><p>Get current Application Specific ID</p>
<pre><code>Parameters:
    cpustate: CPUState struct

Return:
    integer value of current ASID
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def current_asid(self, cpustate):
    &#39;&#39;&#39;
    Get current Application Specific ID
        
        Parameters:
            cpustate: CPUState struct

        Return:
            integer value of current ASID
    &#39;&#39;&#39;
    return self.libpanda.panda_current_asid(cpustate)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.current_pc"><code class="name flex">
<span>def <span class="ident">current_pc</span></span>(<span>self, cpustate)</span>
</code></dt>
<dd>
<div class="desc"><p>Get current program counter</p>
<pre><code>Parameters:
    cpustate: CPUState struct

Return:
    integer value of current program counter

!!! Deprecated "Deprecated:&amp;ensp;Use panda.arch.get_pc(cpu) instead"
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def current_pc(self, cpustate):
    &#39;&#39;&#39;
    Get current program counter

        Parameters:
            cpustate: CPUState struct

        Return:
            integer value of current program counter

        .. Deprecated:: Use panda.arch.get_pc(cpu) instead
    &#39;&#39;&#39;
    return self.libpanda.panda_current_pc(cpustate)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.current_sp"><code class="name flex">
<span>def <span class="ident">current_sp</span></span>(<span>self, cpustate)</span>
</code></dt>
<dd>
<div class="desc"><p>Get current stack pointer</p>
<pre><code>Parameters:
    cpustate: CPUState struct

Return:
    integer value of stack pointer
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def current_sp(self, cpustate):
    &#39;&#39;&#39;
    Get current stack pointer

        Parameters:
            cpustate: CPUState struct

        Return:
            integer value of stack pointer
    &#39;&#39;&#39;
    return self.libpanda.panda_current_sp_external(cpustate)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.delete_callback"><code class="name flex">
<span>def <span class="ident">delete_callback</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Completely delete a registered panda callback by name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_callback(self, name):
    &#39;&#39;&#39;
    Completely delete a registered panda callback by name
    &#39;&#39;&#39;
    if name not in self.registered_callbacks.keys():
        raise ValueError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))

    handle = self.registered_callbacks[name][&#39;handle&#39;]
    self.libpanda.panda_unregister_callbacks(handle)
    del self.registered_callbacks[name][&#39;handle&#39;]</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.delvm"><code class="name flex">
<span>def <span class="ident">delvm</span></span>(<span>self, snapshot_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete snapshot with specified name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delvm(self, snapshot_name):
    &#39;&#39;&#39; Delete snapshot with specified name &#39;&#39;&#39;
    if debug:
        progress (&#34;Deleting snapshot &#34; + snapshot_name)

    # Stop guest, queue up delete, then continue
    self.vm_stop()
    charptr = ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
    self.queue_main_loop_wait_fn(self.libpanda.panda_delvm, [charptr])</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.delvm_sync"><code class="name flex">
<span>def <span class="ident">delvm_sync</span></span>(<span>self, snapshot_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def delvm_sync(self, snapshot_name):
    self.run_monitor_cmd(&#34;delvm {}&#34;.format(snapshot_name))</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_callback"><code class="name flex">
<span>def <span class="ident">disable_callback</span></span>(<span>self, name, forever=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable a panda plugin using its handle and cb.number as a unique ID
If forever is specified, we'll never reenable the call- useful when
you want to really turn off something with a procname filter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_callback(self, name, forever=False):
    &#39;&#39;&#39;
    Disable a panda plugin using its handle and cb.number as a unique ID
    If forever is specified, we&#39;ll never reenable the call- useful when
    you want to really turn off something with a procname filter.
    &#39;&#39;&#39;
    if name not in self.registered_callbacks.keys():
        raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))
    self.registered_callbacks[name][&#39;enabled&#39;] = False
    handle = self.registered_callbacks[name][&#39;handle&#39;]
    cb = self.registered_callbacks[name][&#39;callback&#39;]
    pcb = self.registered_callbacks[name][&#39;pcb&#39;]
    #progress(&#34;Disabling callback &#39;{}&#39; on &#39;{}&#39; handle={}&#34;.format(name, cb.name, handle))
    self.libpanda.panda_disable_callback_helper(handle, cb.number, pcb)

    if forever:
        del self.registered_callbacks[name]</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_hook"><code class="name flex">
<span>def <span class="ident">disable_hook</span></span>(<span>self, hook_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set hook status to inactive.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_hook(self,hook_name):
    &#39;&#39;&#39;
    Set hook status to inactive.
    &#39;&#39;&#39;
    if hook_name in self.named_hooks:
        hook = self.named_hooks[hook_name]
        if hook.is_enabled:
            hook.is_enabled = False
            self.plugins[&#39;hooks&#39;].disable_hook(hook.hook_cb)
    else:
        raise ValueError(f&#34;Unknown hook {hook_name}&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_hook2"><code class="name flex">
<span>def <span class="ident">disable_hook2</span></span>(<span>self, hook_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set hook status to inactive.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_hook2(self,hook_name):
    &#39;&#39;&#39;
    Set hook status to inactive.
    &#39;&#39;&#39;
    if hook_name in self.hook_list2:
        self.plugins[&#39;hooks2&#39;].disable_hooks2(self.hook_list2[hook_name])
    else:
        print(&#34;ERROR: Your hook name was not in the hook list&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_llvm"><code class="name flex">
<span>def <span class="ident">disable_llvm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_llvm(self):
    &#39;&#39;&#39;
    Disables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend. 
    &#39;&#39;&#39;
    self.libpanda.panda_disable_llvm()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_llvm_helpers"><code class="name flex">
<span>def <span class="ident">disable_llvm_helpers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_llvm_helpers(self):
    &#39;&#39;&#39;
    Disables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend. 
    &#39;&#39;&#39;
    self.libpanda.panda_disable_llvm_helpers()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_memcb"><code class="name flex">
<span>def <span class="ident">disable_memcb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable memory callbacks. Must be enabled for memory callbacks to work.
pypanda enables this automatically with some callbacks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_memcb(self):
    &#39;&#39;&#39;
    Disable memory callbacks. Must be enabled for memory callbacks to work.
    pypanda enables this automatically with some callbacks.
    &#39;&#39;&#39;
    self._memcb = False
    self.libpanda.panda_disable_memcb()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_plugin"><code class="name flex">
<span>def <span class="ident">disable_plugin</span></span>(<span>self, handle)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable plugin.</p>
<pre><code>Parameters:
    handle: pointer to handle returned by plugin

Return:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_plugin(self, handle):
    &#39;&#39;&#39;
    Disable plugin.

        Parameters:
            handle: pointer to handle returned by plugin
        
        Return:
            None
    &#39;&#39;&#39;
    self.libpanda.panda_disable_plugin(handle)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_ppp"><code class="name flex">
<span>def <span class="ident">disable_ppp</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable a ppp-style callback by name.
Unlike regular panda callbacks which can be enabled/disabled/deleted, PPP callbacks are only enabled/deleted (which we call disabled)</p>
<p>Example usage to register my_run with syscalls2 as a 'on_sys_open_return' and then disable:</p>
<pre><code>@ppp(&quot;syscalls2&quot;, &quot;on_sys_open_return&quot;)
def my_fun(cpu, pc, filename, flags, mode):
    ...

panda.disable_ppp(&quot;my_fun&quot;)
</code></pre>
<p>&ndash; OR &ndash;</p>
<pre><code>@ppp(&quot;syscalls2&quot;, &quot;on_sys_open_return&quot;, name=&quot;custom&quot;)
def my_fun(cpu, pc, filename, flags, mode):
    ...
</code></pre>
<p>panda.disable_ppp("custom")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_ppp(self, name):
    &#39;&#39;&#39;
    Disable a ppp-style callback by name.
    Unlike regular panda callbacks which can be enabled/disabled/deleted, PPP callbacks are only enabled/deleted (which we call disabled)

    Example usage to register my_run with syscalls2 as a &#39;on_sys_open_return&#39; and then disable:
    ```
    @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;)
    def my_fun(cpu, pc, filename, flags, mode):
        ...

    panda.disable_ppp(&#34;my_fun&#34;)
    ```

    -- OR --

    ```
    @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;, name=&#34;custom&#34;)
    def my_fun(cpu, pc, filename, flags, mode):
        ...
    ```

    panda.disable_ppp(&#34;custom&#34;)
    &#39;&#39;&#39;

    (f, plugin_name, attr) = self.ppp_registered_cbs[name]
    eval(f&#34;self.plugins[&#39;{plugin_name}&#39;].ppp_remove_cb_{attr}&#34;)(f) # All PPP cbs start with this string. XXX insecure eval
    del self.ppp_registered_cbs[name] # It&#39;s now safe to be garbage collected</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_precise_pc"><code class="name flex">
<span>def <span class="ident">disable_precise_pc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>By default, QEMU does not update the program counter after every instruction.
This function disables precise tracking of the program counter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_precise_pc(self):
    &#39;&#39;&#39;
    By default, QEMU does not update the program counter after every instruction.
    This function disables precise tracking of the program counter.
    &#39;&#39;&#39;
    self.libpanda.panda_disable_precise_pc()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disable_tb_chaining"><code class="name flex">
<span>def <span class="ident">disable_tb_chaining</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function disables translation block chaining in QEMU</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_tb_chaining(self):
    &#39;&#39;&#39; This function disables translation block chaining in QEMU &#39;&#39;&#39;
    if not self.disabled_tb_chaining:
        if debug:
            progress(&#34;Disabling TB chaining&#34;)
        self.disabled_tb_chaining = True
        self.libpanda.panda_disable_tb_chaining()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.disas2"><code class="name flex">
<span>def <span class="ident">disas2</span></span>(<span>self, code, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Call panda_disas to diasassemble an amount of code at a pointer.
FIXME: seem to not match up to PANDA definition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disas2(self, code, size):
    &#39;&#39;&#39;
    Call panda_disas to diasassemble an amount of code at a pointer.
    FIXME: seem to not match up to PANDA definition
    &#39;&#39;&#39;
    self.libpanda.panda_disas(code, size)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.do_panda_finish"><code class="name flex">
<span>def <span class="ident">do_panda_finish</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Call panda_finish. Note this isn't really blocking - the
guest should have exited by now, but queue this after
(blocking) shutdown commands in our internal async queue
so it must also be labeled as blocking.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @blocking
    def do_panda_finish(self):
        &#39;&#39;&#39;
        Call panda_finish. Note this isn&#39;t really blocking - the
        guest should have exited by now, but queue this after
        (blocking) shutdown commands in our internal async queue
        so it must also be labeled as blocking.
        &#39;&#39;&#39;
#        assert (not self.running.is_set()), &#34;Can&#39;t finish while still running&#34;
        self.panda_finish()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.drive_get"><code class="name flex">
<span>def <span class="ident">drive_get</span></span>(<span>self, blocktype, bus, unit)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets DriveInfo struct from user specified information.</p>
<pre><code>Parameters:
    blocktype: BlockInterfaceType structure
    bus: integer bus
    unit: integer unit

Return:
    DriveInfo struct
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drive_get(self, blocktype, bus, unit):
    &#39;&#39;&#39;
    Gets DriveInfo struct from user specified information.

        Parameters:
            blocktype: BlockInterfaceType structure
            bus: integer bus
            unit: integer unit
        
        Return:
            DriveInfo struct
    &#39;&#39;&#39;
    return self.libpanda.drive_get(blocktype,bus,unit)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_all_callbacks"><code class="name flex">
<span>def <span class="ident">enable_all_callbacks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable all python callbacks that have been disabled</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_all_callbacks(self):
    &#39;&#39;&#39;
    Enable all python callbacks that have been disabled
    &#39;&#39;&#39;
    for name in self.registered_callbacks.keys():
        self.enable_callback(name)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_callback"><code class="name flex">
<span>def <span class="ident">enable_callback</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable a panda plugin using its handle and cb.number as a unique ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_callback(self, name):
    &#39;&#39;&#39;
    Enable a panda plugin using its handle and cb.number as a unique ID
    &#39;&#39;&#39;
    if name not in self.registered_callbacks.keys():
        raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))

    self.registered_callbacks[name][&#39;enabled&#39;] = True
    handle = self.registered_callbacks[name][&#39;handle&#39;]
    cb = self.registered_callbacks[name][&#39;callback&#39;]
    pcb = self.registered_callbacks[name][&#39;pcb&#39;]
    #progress(&#34;Enabling callback &#39;{}&#39; on &#39;{}&#39; handle = {}&#34;.format(name, cb.name, handle))
    self.libpanda.panda_enable_callback_helper(handle, cb.number, pcb)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_hook"><code class="name flex">
<span>def <span class="ident">enable_hook</span></span>(<span>self, hook_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set hook status to active.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_hook(self,hook_name):
    &#39;&#39;&#39;
    Set hook status to active.        
    &#39;&#39;&#39;
    if hook_name in self.named_hooks:
        hook = self.named_hooks[hook_name]
        if not hook.is_enabled:
            hook.is_enabled = True
            #print(f&#34;Enabling hook {hook_name} at 0x{hook.target_addr:x}&#34;)
            self.plugins[&#39;hooks&#39;].enable_hook(hook.hook_cb, hook.target_addr)
    else:
        raise ValueError(f&#34;Unknown hook {hook_name}&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_hook2"><code class="name flex">
<span>def <span class="ident">enable_hook2</span></span>(<span>self, hook_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set hook status to active.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_hook2(self,hook_name):
    &#39;&#39;&#39;
    Set hook status to active.        
    &#39;&#39;&#39;
    if hook_name in self.hook_list2:
        self.plugins[&#39;hooks2&#39;].enable_hooks2(self.hook_list2[hook_name])
    else:
        print(&#34;ERROR: Your hook name was not in the hook list&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_internal_callbacks"><code class="name flex">
<span>def <span class="ident">enable_internal_callbacks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable all our internal callbacks that start with __ such as __main_loop_wait
and __asid_changed. Important in case user has done a panda.end_analysis()
and then (re)called run</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_internal_callbacks(self):
    &#39;&#39;&#39;
    Enable all our internal callbacks that start with __ such as __main_loop_wait
    and __asid_changed. Important in case user has done a panda.end_analysis()
    and then (re)called run
    &#39;&#39;&#39;
    for name in self.registered_callbacks.keys():
        if name.startswith(&#34;__&#34;) and not self.registered_callbacks[name][&#39;enabled&#39;]:
            self.enable_callback(name)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_llvm"><code class="name flex">
<span>def <span class="ident">enable_llvm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_llvm(self):
    &#39;&#39;&#39;
    Enables the use of the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend. 
    &#39;&#39;&#39;
    self.libpanda.panda_enable_llvm()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_llvm_helpers"><code class="name flex">
<span>def <span class="ident">enable_llvm_helpers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_llvm_helpers(self):
    &#39;&#39;&#39;
    Enables the use of Helpers for the LLVM JIT in replacement of the TCG (QEMU intermediate language and compiler) backend. 
    &#39;&#39;&#39;
    self.libpanda.panda_enable_llvm_helpers()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_memcb"><code class="name flex">
<span>def <span class="ident">enable_memcb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable memory callbacks. Must be called for memory callbacks to work.
pypanda enables this automatically with some callbacks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_memcb(self):
    &#39;&#39;&#39;
    Enable memory callbacks. Must be called for memory callbacks to work.
    pypanda enables this automatically with some callbacks.
    &#39;&#39;&#39;
    self._memcb = True
    self.libpanda.panda_enable_memcb()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_plugin"><code class="name flex">
<span>def <span class="ident">enable_plugin</span></span>(<span>self, handle)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable plugin.</p>
<pre><code>Parameters:
    handle: pointer to handle returned by plugin

Return:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_plugin(self, handle):
    &#39;&#39;&#39;
    Enable plugin.

        Parameters:
            handle: pointer to handle returned by plugin
        
        Return:
            None
    &#39;&#39;&#39;
    self.libpanda.panda_enable_plugin(handle)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_precise_pc"><code class="name flex">
<span>def <span class="ident">enable_precise_pc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>By default, QEMU does not update the program counter after every instruction.
This function enables precise tracking of the program counter. After enabling precise PC tracking, the program counter will be available in env-&gt;panda_guest_pc and can be assumed to accurately reflect the guest state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_precise_pc(self):
    &#39;&#39;&#39;
    By default, QEMU does not update the program counter after every instruction.
    This function enables precise tracking of the program counter. After enabling precise PC tracking, the program counter will be available in env-&gt;panda_guest_pc and can be assumed to accurately reflect the guest state.
    &#39;&#39;&#39;
    self.libpanda.panda_enable_precise_pc()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.enable_tb_chaining"><code class="name flex">
<span>def <span class="ident">enable_tb_chaining</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function enables translation block chaining in QEMU</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_tb_chaining(self):
    &#39;&#39;&#39; This function enables translation block chaining in QEMU &#39;&#39;&#39;
    if debug:
        progress(&#34;Enabling TB chaining&#34;)
    self.disabled_tb_chaining = False
    self.libpanda.panda_enable_tb_chaining()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.end_analysis"><code class="name flex">
<span>def <span class="ident">end_analysis</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop running machine.</p>
<p>Call from any thread to unload all plugins and stop all queued functions.
If called from async thread or a callback, it will also unblock panda.run()</p>
<p>Note here we use the async class's internal thread to process these
without needing to wait for tasks in the main async thread</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_analysis(self):
    &#39;&#39;&#39;
    Stop running machine.

    Call from any thread to unload all plugins and stop all queued functions.
    If called from async thread or a callback, it will also unblock panda.run()

    Note here we use the async class&#39;s internal thread to process these
    without needing to wait for tasks in the main async thread
    &#39;&#39;&#39;
    self.unload_plugins()
    if self.running.is_set():
        # If we were running, stop the execution and check if we crashed
        self.queue_async(self.stop_run, internal=True)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.end_record"><code class="name flex">
<span>def <span class="ident">end_record</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop active recording.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>raises exception if there was an error stopping recording.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_record(self):
    &#34;&#34;&#34;Stop active recording.

    Raises:
        Exception: raises exception if there was an error stopping recording.
    &#34;&#34;&#34;
    result = self.libpanda.panda_record_end()
    res_string_enum = ffi.string(ffi.cast(&#34;RRCTRL_ret&#34;,result))
    if res_string_enum != &#34;RRCTRL_OK&#34;:
       raise Exception(f&#34;record method failed with RTCTL_ret {res_string_enum} ({result})&#34;) </code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.error_report"><code class="name flex">
<span>def <span class="ident">error_report</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_report(self, s):
    return self.libpanda.error_report(s)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.exit_cpu_loop"><code class="name flex">
<span>def <span class="ident">exit_cpu_loop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop cpu execution at nearest juncture.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit_cpu_loop(self):
    &#39;&#39;&#39;
    Stop cpu execution at nearest juncture.
    &#39;&#39;&#39;
    self.libpanda.panda_exit_loop = True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.finish_serial_cmd"><code class="name flex">
<span>def <span class="ident">finish_serial_cmd</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish_serial_cmd(self):
    result = self.serial_console.send_eol()
    result = self.serial_console.expect()
    return result</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.finish_timer"><code class="name flex">
<span>def <span class="ident">finish_timer</span></span>(<span>self, start, msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Print how long some (main_loop_wait) task took</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish_timer(self, start, msg):
    &#39;&#39;&#39; Print how long some (main_loop_wait) task took &#39;&#39;&#39;
    t = time() - start
    print(&#34;{} in {1:.08f} seconds&#34;.format(msg, t))</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.flush_tb"><code class="name flex">
<span>def <span class="ident">flush_tb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function requests that the translation block cache be flushed as soon as possible. If running with translation block chaining turned off (e.g. when in LLVM mode or replay mode), this will happen when the current translation block is done executing.
Flushing the translation block cache is additionally necessary if the plugin makes changes to the way code is translated. For example, by using panda_enable_precise_pc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush_tb(self):
    &#39;&#39;&#39;
    This function requests that the translation block cache be flushed as soon as possible. If running with translation block chaining turned off (e.g. when in LLVM mode or replay mode), this will happen when the current translation block is done executing.
    Flushing the translation block cache is additionally necessary if the plugin makes changes to the way code is translated. For example, by using panda_enable_precise_pc.
    &#39;&#39;&#39;
    return self.libpanda.panda_flush_tb()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.from_unsigned_guest"><code class="name flex">
<span>def <span class="ident">from_unsigned_guest</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an unsigned int32/unsigned int64 from the guest
(depending on guest bit-size) to a (signed) python int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_unsigned_guest(self, x):
    &#39;&#39;&#39;
    Convert an unsigned int32/unsigned int64 from the guest
    (depending on guest bit-size) to a (signed) python int
    &#39;&#39;&#39;
    if x &gt;= 2**(self.bits-1): # If highest bit is set, it&#39;s negative
        return (x - 2**self.bits)
    else: # Else it&#39;s positive
        return x</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.g_malloc0"><code class="name flex">
<span>def <span class="ident">g_malloc0</span></span>(<span>self, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to call glib malloc</p>
<pre><code>Parameters:
    size: size to call with malloc

Returns:
    buffer of that size from malloc
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g_malloc0(self, size):
    &#39;&#39;&#39;
    Helper function to call glib malloc

        Parameters:
            size: size to call with malloc
        
        Returns:
            buffer of that size from malloc
    &#39;&#39;&#39;
    return self.libpanda.g_malloc0(size)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.garray_len"><code class="name flex">
<span>def <span class="ident">garray_len</span></span>(<span>self, garray)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience function to get array length of glibc array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def garray_len(self, garray):
    &#39;&#39;&#39;
    Convenience function to get array length of glibc array.
    &#39;&#39;&#39;
    return self.libpanda.garray_len(garray)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.get_cpu"><code class="name flex">
<span>def <span class="ident">get_cpu</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function returns first_cpu CPUState object from QEMU.
XXX: You rarely want this</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cpu(self):
    &#39;&#39;&#39;
    This function returns first_cpu CPUState object from QEMU.
    XXX: You rarely want this
    &#39;&#39;&#39;
    return self.libpanda.get_cpu()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.get_mappings"><code class="name flex">
<span>def <span class="ident">get_mappings</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all active memory mappings in the system.</p>
<pre><code>Requires: OSI

Parameters:
    cpu: CPUState struct

Returns:
    Iterator of &lt;code&gt;OsiModule&lt;/code&gt; structures
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mappings(self, cpu):
    &#39;&#39;&#39;
    Get all active memory mappings in the system.

        Requires: OSI

        Parameters:
            cpu: CPUState struct

        Returns:
            Iterator of `OsiModule` structures
    &#39;&#39;&#39;
    current = self.plugins[&#39;osi&#39;].get_current_process(cpu)
    maps = self.plugins[&#39;osi&#39;].get_mappings(cpu, current)
    map_len = self.garray_len(maps)
    return GArrayIterator(self.plugins[&#39;osi&#39;].get_one_module, maps, map_len, self.plugins[&#39;osi&#39;].cleanup_garray)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.get_process_name"><code class="name flex">
<span>def <span class="ident">get_process_name</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the name of the current process. May return None if OSI cannot identify the current process</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_process_name(self, cpu):
    &#39;&#39;&#39;
    Get the name of the current process. May return None if OSI cannot identify the current process
    &#39;&#39;&#39;
    proc = self.plugins[&#39;osi&#39;].get_current_process(cpu)
    if proc == ffi.NULL or proc.name == ffi.NULL:
        return None

    procname = ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;)
    return ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.get_processes"><code class="name flex">
<span>def <span class="ident">get_processes</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all running processes in the system. Includes kernel modules on Linux.</p>
<pre><code>Requires: OSI

Parameters:
    cpu: CPUState struct

Returns:
    Iterator of &lt;code&gt;OsiProc&lt;/code&gt; structures
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_processes(self, cpu):
    &#39;&#39;&#39;
    Get all running processes in the system. Includes kernel modules on Linux.

        Requires: OSI

        Parameters:
            cpu: CPUState struct

        Returns:
            Iterator of `OsiProc` structures
    &#39;&#39;&#39;
    processes = self.plugins[&#39;osi&#39;].get_processes(cpu)
    processes_len = self.garray_len(processes)
    return GArrayIterator(self.plugins[&#39;osi&#39;].get_one_proc, processes, processes_len, self.plugins[&#39;osi&#39;].cleanup_garray)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.get_processes_dict"><code class="name flex">
<span>def <span class="ident">get_processes_dict</span></span>(<span>self, cpu)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all running processes for the system at this moment in time as a dictionary.</p>
<p>The dictionary maps proceses by their PID. Each mapping returns a dictionary containing the process name, its pid,
and its parent pid (ppid).</p>
<pre><code>Requires: OSI

Parameters:
    cpu: CPUState struct

Returns:
    Dictionary as described above.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_processes_dict(self, cpu):
    &#39;&#39;&#39;
    Get all running processes for the system at this moment in time as a dictionary.

    The dictionary maps proceses by their PID. Each mapping returns a dictionary containing the process name, its pid,
    and its parent pid (ppid).

        Requires: OSI

        Parameters:
            cpu: CPUState struct

        Returns:
            Dictionary as described above.
    &#39;&#39;&#39;

    procs = {} #pid: {name: X, pid: Y, parent_pid: Z})

    for proc in self.get_processes(cpu):
        assert(proc != ffi.NULL)
        assert(proc.pid not in procs)
        procs[proc.pid] = {&#34;name&#34;: ffi.string(proc.name).decode(&#39;utf8&#39;, &#39;ignore&#39;), &#39;pid&#39;: proc.pid, &#39;parent_pid&#39;: proc.ppid}
        assert(not (proc.pid != 0 and proc.pid == proc.ppid)) # No cycles allowed other than at 0
    return procs</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.get_system_memory"><code class="name flex">
<span>def <span class="ident">get_system_memory</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_system_memory(self):
    return self.libpanda.get_system_memory()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.get_volatility_symbols"><code class="name flex">
<span>def <span class="ident">get_volatility_symbols</span></span>(<span>self, debug=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_volatility_symbols(self, debug=False):
    try:
        from .volatility_cli_classes import CommandLineMoreEfficient
        from volatility.framework import contexts
        from volatility.framework.layers.linear import LinearlyMappedLayer
        from volatility.framework.automagic import linux
    except ImportError:
        print(&#34;Warning: Failed to import volatility&#34;)
        return None
    if &#34;linux&#34; in self.os_type:
        if not hasattr(self, &#34;_vmlinux&#34;):
            self.make_panda_file_handler(debug=debug)
            constructed_original = CommandLineMoreEfficient().run()
            linux.LinuxUtilities.aslr_mask_symbol_table(
                constructed_original.context, constructed_original.config[&#39;vmlinux&#39;], constructed_original.config[&#39;primary&#39;])
            self._vmlinux = contexts.Module(
                constructed_original.context, constructed_original.config[&#39;vmlinux&#39;], constructed_original.config[&#39;primary&#39;], 0)
        else:
            LinearlyMappedLayer.read.cache_clear()  # smearing technique
        return self._vmlinux
    else:
        print(&#34;Unsupported.&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.hook"><code class="name flex">
<span>def <span class="ident">hook</span></span>(<span>self, addr, enabled=True, kernel=True, libraryname=None, procname=None, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
the function will be called with args (CPUState, TranslationBlock)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook(self, addr, enabled=True, kernel=True, libraryname=None, procname=None, name=None):
    &#39;&#39;&#39;
    Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
    the function will be called with args (CPUState, TranslationBlock)
    &#39;&#39;&#39;
    if procname:
        self._register_internal_asid_changed_cb()

    if libraryname:
        self._register_mmap_cb()

    def decorator(fun):
        # Ultimately, our hook resolves as a before_block_exec so we must match its args
        hook_cb_type = self.callback.before_block_exec # (CPUState, TranslationBlock)

        if &#39;hooks&#39; not in self.plugins:
            # Enable hooks plugin on first request
            self.load_plugin(&#34;hooks&#34;)

        if debug:
            print(&#34;Registering breakpoint at 0x{:x} -&gt; {} == {}&#34;.format(addr, fun, &#39;cdata_cb&#39;))

        # Inform the plugin that it has a new breakpoint at addr
        hook_cb_passed = hook_cb_type(fun)
        self.plugins[&#39;hooks&#39;].add_hook(addr, hook_cb_passed)
        hook_to_add = Hook(is_enabled=enabled,is_kernel=kernel,target_addr=addr,library_name=libraryname,program_name=procname,hook_cb=None, target_library_offset=None)
        if libraryname: 
            hook_to_add.target_library_offset = addr
            hook_to_add.target_addr = 0
            hook_to_add.hook_cb = hook_cb_passed
        else:
            hook_to_add.hook_cb = hook_cb_passed
        self.hook_list.append(hook_to_add)
        if not hasattr(self, &#34;named_hooks&#34;):
            self.named_hooks = {}
        local_name = name if name else fun.__name__ # XXX: weird scoping
        self.named_hooks[local_name] = hook_to_add

        if libraryname or procname or not enabled:
            self.disable_hook(local_name)

        @hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
        def wrapper(*args, **kw):
            return fun(*args, **kw)

        return wrapper
    return decorator</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.hook2"><code class="name flex">
<span>def <span class="ident">hook2</span></span>(<span>self, name, kernel=True, procname=&lt;cdata &#x27;void *&#x27; NULL&gt;, libname=&lt;cdata &#x27;void *&#x27; NULL&gt;, trace_start=0, trace_stop=0, range_begin=0, range_end=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook2(self,name, kernel=True, procname=ffi.NULL, libname=ffi.NULL, trace_start=0, trace_stop=0, range_begin=0, range_end=0):
    if procname != ffi.NULL:
        procname = ffi.new(&#34;char[]&#34;,bytes(procname,&#34;utf-8&#34;))
    if libname != ffi.NULL:
        libname = ffi.new(&#34;char[]&#34;,bytes(libname,&#34;utf-8&#34;))
    &#39;&#39;&#39;
    Decorate a function to setup a hook: when a guest goes to execute a basic block beginning with addr,
    the function will be called with args (CPUState, TranslationBlock)
    &#39;&#39;&#39;
    def decorator(fun):
        # Ultimately, our hook resolves as a before_block_exec_invalidate_opt callback so we must match its args
        hook_cb_type = ffi.callback(&#34;bool (CPUState*, TranslationBlock*, void*)&#34;)
        # Inform the plugin that it has a new breakpoint at addr
        
        hook_cb_passed = hook_cb_type(fun)
        if not hasattr(self, &#34;hook_gc_list&#34;):
            self.hook_gc_list = [hook_cb_passed]
        else:
            self.hook_gc_list.append(hook_cb_passed)

        # I don&#39;t know what this is/does
        cb_data = ffi.NULL
        hook_number = self.plugins[&#39;hooks2&#39;].add_hooks2(hook_cb_passed, cb_data, kernel, \
            procname, libname, trace_start, trace_stop, range_begin,range_end)
        
        self.hook_list2[name] = hook_number

        @hook_cb_type # Make CFFI know it&#39;s a callback. Different from _generated_callback for some reason?
        def wrapper(*args, **kw):
            return fun(*args, **kw)

        return wrapper
    return decorator</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.hook2_single_insn"><code class="name flex">
<span>def <span class="ident">hook2_single_insn</span></span>(<span>self, name, pc, kernel=False, procname=&lt;cdata &#x27;void *&#x27; NULL&gt;, libname=&lt;cdata &#x27;void *&#x27; NULL&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hook2_single_insn(self, name, pc, kernel=False, procname=ffi.NULL, libname=ffi.NULL):
    return self.hook(name, kernel=kernel, procname=procname,libname=libname,range_begin=pc, range_end=pc)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.in_kernel"><code class="name flex">
<span>def <span class="ident">in_kernel</span></span>(<span>self, cpustate)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the processor is in the privilege level corresponding to executing kernel code for any of the PANDA supported architectures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_kernel(self, cpustate):
    &#39;&#39;&#39;
    Returns true if the processor is in the privilege level corresponding to executing kernel code for any of the PANDA supported architectures.
    &#39;&#39;&#39;
    return self.libpanda.panda_in_kernel_external(cpustate)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.interact"><code class="name flex">
<span>def <span class="ident">interact</span></span>(<span>self, confirm_quit=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Expose console interactively until user types pandaquit
Must be run in blocking thread.</p>
<p>TODO: This should probably repace self.serial_console with something
that directly renders output to the user. Then we don't have to handle
buffering and other problems. But we will need to re-enable the serial_console
interface after this returns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def interact(self, confirm_quit=True):
    &#39;&#39;&#39;
    Expose console interactively until user types pandaquit
    Must be run in blocking thread.

    TODO: This should probably repace self.serial_console with something
    that directly renders output to the user. Then we don&#39;t have to handle
    buffering and other problems. But we will need to re-enable the serial_console
    interface after this returns
    &#39;&#39;&#39;
    print(&#34;PANDA: entering interactive mode. Type pandaquit to exit&#34;)
    prompt = self.expect_prompt.decode(&#34;utf8&#34;) if self.expect_prompt  else &#34;$ &#34;
    if not prompt.endswith(&#34; &#34;): prompt += &#34; &#34;
    while True:
        cmd = input(prompt) # TODO: Strip all control characters - Ctrl-L breaks things
        if cmd.strip() == &#39;pandaquit&#39;:
            if confirm_quit:
                q = input(&#34;PANDA: Quitting interactive mode. Are you sure? (y/n) &#34;)
                if len(q) and q.lower()[0] == &#39;y&#39;:
                    break
                else:
                    continue
            else: # No confirm - just break
                break
        r = self.run_serial_cmd(cmd) # XXX: may timeout
        print(r)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.is_callback_enabled"><code class="name flex">
<span>def <span class="ident">is_callback_enabled</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_callback_enabled(self, name):
    if name not in self.registered_callbacks.keys():
        raise RuntimeError(&#34;No callback has been registered with name &#39;{}&#39;&#34;.format(name))
    return self.registered_callbacks[name][&#39;enabled&#39;]</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.load_plugin"><code class="name flex">
<span>def <span class="ident">load_plugin</span></span>(<span>self, name, args={})</span>
</code></dt>
<dd>
<div class="desc"><p>Load a C plugin, optionally with arguments</p>
<pre><code>Parameters:
    name: python string name of plugin
    args: Dictionary of arguments matching key to value. e.g. {"key": "value"} sets option key to value.

Returns:
    None.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_plugin(self, name, args={}):
    &#39;&#39;&#39;
    Load a C plugin, optionally with arguments

        Parameters:
            name: python string name of plugin
            args: Dictionary of arguments matching key to value. e.g. {&#34;key&#34;: &#34;value&#34;} sets option key to value.
        
        Returns:
            None.
    &#39;&#39;&#39;
    if debug:
        progress (&#34;Loading plugin %s&#34; % name),

    argstrs_ffi = []
    if isinstance(args, dict):
        for k,v in args.items():
            this_arg_s = &#34;{}={}&#34;.format(k,v)
            this_arg = ffi.new(&#34;char[]&#34;, bytes(this_arg_s, &#34;utf-8&#34;))
            argstrs_ffi.append(this_arg)

        n = len(args.keys())
    elif isinstance(args, list):
        for arg in args:
            this_arg = ffi.new(&#34;char[]&#34;, bytes(arg, &#34;utf-8&#34;))
            argstrs_ffi.append(this_arg)
        n = len(args)

    else:
        raise ValueError(&#34;Arguments to load plugin must be a list or dict of key/value pairs&#34;)

    # First set qemu_path so plugins can load (may be unnecessary after the first time)
    assert(self.panda), &#34;Unknown location of PANDA&#34;
    panda_name_ffi = ffi.new(&#34;char[]&#34;, bytes(self.panda,&#34;utf-8&#34;))
    self.libpanda.panda_set_qemu_path(panda_name_ffi)

    if len(argstrs_ffi):
        plugin_args = argstrs_ffi
    else:
        plugin_args = ffi.NULL

    charptr = ffi.new(&#34;char[]&#34;, bytes(name,&#34;utf-8&#34;))
    self.libpanda.panda_require_from_library(charptr, plugin_args, len(argstrs_ffi))
    self._load_plugin_library(name)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.lookup_gic"><code class="name flex">
<span>def <span class="ident">lookup_gic</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lookup_gic(self,n):
    return self.libpanda.lookup_gic(n)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.make_panda_file_handler"><code class="name flex">
<span>def <span class="ident">make_panda_file_handler</span></span>(<span>self, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Constructs a file and file handler that volatility can't ignore to back by PANDA physical memory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_panda_file_handler(self, debug=False):
    &#39;&#39;&#39;
    Constructs a file and file handler that volatility can&#39;t ignore to back by PANDA physical memory
    &#39;&#39;&#39;
    from urllib.request import BaseHandler
    if &#39;PandaFileHandler&#39; in globals():  # already initialized
        return
    panda = self

    class PandaFile(object):
        def __init__(self, length, panda):
            self.pos = 0
            self.length = length
            self.closed = False
            self.mode = &#34;rb&#34;
            self.name = &#34;/tmp/panda.panda&#34;
            self.panda = panda
            self.classname = type(self).__name__

        def readable(self):
            return self.closed

        def read(self, size=1):
            if self.panda.bits == 32 and self.panda.arch_name == &#34;i386&#34;:
                data = self.panda.physical_memory_read(
                    self.pos &amp; 0xfffffff, size)
            else:
                data = self.panda.physical_memory_read(self.pos, size)
            if debug:
                print(self.classname+&#34;: Reading &#34; +
                      str(size)+&#34; bytes from &#34;+hex(self.pos))
            self.pos += size
            return data

        def peek(self, size=1):
            return self.panda.physical_memory_read(self.pos, size)

        def seek(self, pos, whence=0):
            if whence == 0:
                self.pos = pos
            elif whence == 1:
                self.pos += pos
            else:
                self.pos = self.length - pos
            if self.pos &gt; self.length:
                print(self.classname+&#34;: We&#39;ve gone off the deep end&#34;)
            if debug:
                print(self.classname+&#34; Seeking to address &#34;+hex(self.pos))

        def tell(self):
            return self.pos

        def close(self):
            self.closed = True

    class PandaFileHandler(BaseHandler):
        def default_open(self, req):
            if &#39;panda.panda&#39; in req.full_url:
                length = panda.libpanda.ram_size
                if length &gt; 0xc0000000:
                    length += 0x40000000  # 3GB hole
                if debug:
                    print(type(self).__name__ +
                          &#34;: initializing PandaFile with length=&#34;+hex(length))
                return PandaFile(length=length, panda=panda)
            else:
                return None

        def file_close(self):
            return True

    globals()[&#34;PandaFileHandler&#34;] = PandaFileHandler</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.map_memory"><code class="name flex">
<span>def <span class="ident">map_memory</span></span>(<span>self, name, size, address)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a new memory region.</p>
<pre><code>Parameters:
        name: This is an internal reference name for this region. Must be unique.
        size: number of bytes the region should be.
        address: start address of region
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_memory(self, name, size, address):

    &#39;&#39;&#39;
    Make a new memory region.
    
        Parameters:
                name: This is an internal reference name for this region. Must be unique.
                size: number of bytes the region should be.
                address: start address of region
    &#39;&#39;&#39;

    name_c = ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
    size = ceil(size/1024)*1024 # Must be page-aligned
    return self.libpanda.map_memory(name_c, size, address)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.memory_region_add_subregion"><code class="name flex">
<span>def <span class="ident">memory_region_add_subregion</span></span>(<span>self, mr, offset, sr)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls memory_region_add_subregion from QEMU.
memory_region_add_subregion: Add a subregion to a container.</p>
<p>Adds a subregion at @offset.
The subregion may not overlap with other
subregions (except for those explicitly marked as overlapping).
A region
may only be added once as a subregion (unless removed with
memory_region_del_subregion()); use memory_region_init_alias() if you
want a region to be a subregion in multiple locations.</p>
<pre><code>Parameters:
    mr: the region to contain the new subregion; must be a container initialized with memory_region_init().
    offset: the offset relative to @mr where @subregion is added.
    subregion: the subregion to be added.

Returns: 
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memory_region_add_subregion(self, mr, offset, sr):
    &#39;&#39;&#39;
    Calls memory_region_add_subregion from QEMU.
    memory_region_add_subregion: Add a subregion to a container.
    
    Adds a subregion at @offset.  The subregion may not overlap with other
    subregions (except for those explicitly marked as overlapping).  A region
    may only be added once as a subregion (unless removed with
    memory_region_del_subregion()); use memory_region_init_alias() if you
    want a region to be a subregion in multiple locations.
    
        Parameters:
            mr: the region to contain the new subregion; must be a container initialized with memory_region_init().
            offset: the offset relative to @mr where @subregion is added.
            subregion: the subregion to be added.
        
        Returns: 
            None
    &#39;&#39;&#39;
    return self.libpanda.memory_region_add_subregion(mr,offset,sr)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.memory_region_allocate_system_memory"><code class="name flex">
<span>def <span class="ident">memory_region_allocate_system_memory</span></span>(<span>self, mr, obj, name, ram_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Allocates Memory region by user specificiation.
Calls memory_region_allocation_system_memory QEMU function.</p>
<pre><code>Parameters:
    mr: MemoryRegion struct
    obj: Object struct
    name: string of region name
    ram_size: int of ram size

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memory_region_allocate_system_memory(self, mr, obj, name, ram_size):
    &#39;&#39;&#39;
    Allocates Memory region by user specificiation.
    Calls memory_region_allocation_system_memory QEMU function.

        Parameters:
            mr: MemoryRegion struct
            obj: Object struct
            name: string of region name
            ram_size: int of ram size
        
        Returns:
            None
    &#39;&#39;&#39;
    return self.libpanda.memory_region_allocate_system_memory(mr, obj, name, ram_size)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.memory_region_init_ram_from_file"><code class="name flex">
<span>def <span class="ident">memory_region_init_ram_from_file</span></span>(<span>self, mr, owner, name, size, share, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls memory_region_init_ram_from_file from QEMU.
memory_region_init_ram_from_file:
Initialize RAM memory region with a mmap-ed backend.</p>
<pre><code>Parameters:
    mr: the #MemoryRegion to be initialized.
    owner: the object that tracks the region's reference count
    name: the name of the region.
    size: size of the region.
    share: %true if memory must be mmaped with the MAP_SHARED flag
    path: the path in which to allocate the RAM.
    errp: pointer to Error*, to store an error if it happens.

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memory_region_init_ram_from_file(self, mr, owner, name, size, share, path):
    &#39;&#39;&#39;
    Calls memory_region_init_ram_from_file from QEMU.
    memory_region_init_ram_from_file:  Initialize RAM memory region with a mmap-ed backend.
    
        Parameters:
            mr: the #MemoryRegion to be initialized.
            owner: the object that tracks the region&#39;s reference count
            name: the name of the region.
            size: size of the region.
            share: %true if memory must be mmaped with the MAP_SHARED flag
            path: the path in which to allocate the RAM.
            errp: pointer to Error*, to store an error if it happens.
        
        Returns:
            None
    &#39;&#39;&#39;
    return self.libpanda.memory_region_init_ram_from_file(mr, owner, name, size, share, path, self.libpanda.error_fatal)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.memsavep"><code class="name flex">
<span>def <span class="ident">memsavep</span></span>(<span>self, file_out)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls QEMU memsavep on your specified python file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memsavep(self, file_out):
    &#39;&#39;&#39;
    Calls QEMU memsavep on your specified python file.
    &#39;&#39;&#39;
    def initlib():
        ffi.cdef(&#39;&#39;&#39;
        FILE *fdopen(int, const char *);   // from the C &lt;stdio.h&gt;
        int fclose(FILE *);
        &#39;&#39;&#39;, override=True)
    ffi.init_once(initlib, &#34;cinit&#34;)
    
    # this part was largely copied from https://cffi.readthedocs.io/en/latest/ref.html#support-for-file

    file_out.flush()                    # make sure the file is flushed
    newfd = dup(file_out.fileno())   # make a copy of the file descriptor
    fileptr = self.C.fdopen(newfd, b&#34;w&#34;)
    self.libpanda.panda_memsavep(fileptr)
    self.C.fclose(fileptr)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_class_by_name"><code class="name flex">
<span>def <span class="ident">object_class_by_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns class as ObjectClass from name specified.
Calls object_class_by_name QEMU function.</p>
<pre><code>Parameters:
    name: string defined by user

Returns:
    struct as specified by name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_class_by_name(self, name):
    &#39;&#39;&#39;
    Returns class as ObjectClass from name specified.
    Calls object_class_by_name QEMU function.

        Parameters:
            name: string defined by user
        
        Returns:
            struct as specified by name
    &#39;&#39;&#39;
    return self.libpanda.object_class_by_name(name)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_class_get_name"><code class="name flex">
<span>def <span class="ident">object_class_get_name</span></span>(<span>self, objclass)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets String QOM typename from object class.
Calls object_class_get_name QEMU function.</p>
<pre><code>Parameters:
    objclass: class to obtain the QOM typename for.

Returns: 
    String QOM typename for klass.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_class_get_name(self, objclass):
    &#39;&#39;&#39;
    Gets String QOM typename from object class.
    Calls object_class_get_name QEMU function.

        Parameters:
            objclass: class to obtain the QOM typename for.

        Returns: 
            String QOM typename for klass.
    &#39;&#39;&#39;
    return self.libpanda.object_class_get_name(objclass)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_new"><code class="name flex">
<span>def <span class="ident">object_new</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new object from typename.
This function will initialize a new object using heap allocated memory.
The returned object has a reference count of 1, and will be freed when
the last reference is dropped.
Calls object_new QEMU function.</p>
<pre><code>Parameters:
    name: The name of the type of the object to instantiate.

Returns: 
    The newly allocated and instantiated object.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_new(self, name):
    &#39;&#39;&#39;
    Creates a new object from typename.
    This function will initialize a new object using heap allocated memory.
    The returned object has a reference count of 1, and will be freed when
    the last reference is dropped.
    Calls object_new QEMU function.
        
        Parameters:
            name: The name of the type of the object to instantiate.
        
        Returns: 
            The newly allocated and instantiated object.
    &#39;&#39;&#39;
    return self.libpanda.object_new(name)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_property_find"><code class="name flex">
<span>def <span class="ident">object_property_find</span></span>(<span>self, obj, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Look up a property for an object and return its #ObjectProperty if found.
Calls object_property_find QEMU function.</p>
<pre><code>Parameters:
    obj: the object
    name: the name of the property
    errp: returns an error if this function fails

Returns:
    struct ObjectProperty pointer
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_find(self, obj, name):
    &#39;&#39;&#39;
    Look up a property for an object and return its #ObjectProperty if found.
    Calls object_property_find QEMU function.

        Parameters:
            obj: the object
            name: the name of the property
            errp: returns an error if this function fails
        
        Returns:
            struct ObjectProperty pointer
    &#39;&#39;&#39;
    return self.libpanda.object_property_find(obj,name,ffi.NULL)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_property_get_bool"><code class="name flex">
<span>def <span class="ident">object_property_get_bool</span></span>(<span>self, obj, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Pull boolean from object.
Calls object_property_get_bool QEMU function.</p>
<pre><code>Parameters:
    obj: the object
    name: the name of the property

Returns: 
    the value of the property, converted to a boolean, or NULL if an error occurs (including when the property value is not a bool).
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_get_bool(self, obj, name):
    &#39;&#39;&#39;
    Pull boolean from object.
    Calls object_property_get_bool QEMU function.

        Parameters:
            obj: the object
            name: the name of the property
        
        Returns: 
            the value of the property, converted to a boolean, or NULL if an error occurs (including when the property value is not a bool).
    &#39;&#39;&#39;
    return self.libpanda.object_property_get_bool(obj,name,self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_property_get_int"><code class="name flex">
<span>def <span class="ident">object_property_get_int</span></span>(<span>self, obj, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets integer in QEMU object. Reads an integer value from this property. <br>
Calls object_property_get_int QEMU function.</p>
<pre><code>Paramaters:
    obj: the object
    name: the name of the property

Returns: 
    the value of the property, converted to an integer, or negative if an error occurs (including when the property value is not an integer).
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_get_int(self, obj, name):
    &#39;&#39;&#39;
    Gets integer in QEMU object. Reads an integer value from this property.   
    Calls object_property_get_int QEMU function.

        Paramaters:
            obj: the object
            name: the name of the property
        
        Returns: 
            the value of the property, converted to an integer, or negative if an error occurs (including when the property value is not an integer).
    &#39;&#39;&#39;
    return self.libpanda.object_property_get_int(obj, name, self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_property_get_link"><code class="name flex">
<span>def <span class="ident">object_property_get_link</span></span>(<span>self, obj, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads an object's canonical path to a property.
Calls object_property_get_link QEMU function.</p>
<pre><code>Parameters:
    obj: the object
    name: the name of the property
    errp: returns an error if this function fails

Returns:
    the value of the property, resolved from a path to an Object, or NULL if an error occurs (including when the property value is not a string or not a valid object path).
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_get_link(self, obj, name):
    &#39;&#39;&#39;
    Reads an object&#39;s canonical path to a property.
    Calls object_property_get_link QEMU function.

        Parameters:
            obj: the object
            name: the name of the property
            errp: returns an error if this function fails
        
        Returns:
            the value of the property, resolved from a path to an Object, or NULL if an error occurs (including when the property value is not a string or not a valid object path).
    &#39;&#39;&#39;
    return self.libpanda.object_property_get_link(obj,name,self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_property_set_bool"><code class="name flex">
<span>def <span class="ident">object_property_set_bool</span></span>(<span>self, obj, value, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a bool value to a property.
Calls object_property_set_bool QEMU function.</p>
<pre><code>Parameters:
    value: the value to be written to the property
    name: the name of the property
    errp: returns an error if this function fails

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_set_bool(self, obj, value, name):
    &#39;&#39;&#39;
    Writes a bool value to a property.
    Calls object_property_set_bool QEMU function.

        Parameters:
            value: the value to be written to the property
            name: the name of the property
            errp: returns an error if this function fails

        Returns:
            None
    &#39;&#39;&#39;
    return self.libpanda.object_property_set_bool(obj,value,name,self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_property_set_int"><code class="name flex">
<span>def <span class="ident">object_property_set_int</span></span>(<span>self, obj, value, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set integer in QEMU object. Writes an integer value to a property. <br>
Calls object_property_set_int QEMU function.</p>
<pre><code>Parameters:
    value: the value to be written to the property
    name: the name of the property

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_set_int(self,obj, value, name):
    &#39;&#39;&#39;
    Set integer in QEMU object. Writes an integer value to a property.   
    Calls object_property_set_int QEMU function.
    
        Parameters:
            value: the value to be written to the property
            name: the name of the property
        
        Returns:
            None
    &#39;&#39;&#39;
    return self.libpanda.object_property_set_int(obj, value, name, self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.object_property_set_link"><code class="name flex">
<span>def <span class="ident">object_property_set_link</span></span>(<span>self, obj, val, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes an object's canonical path to a property.
Calls object_property_set_link QEMU function.</p>
<pre><code>Parameters:
    value: the value to be written to the property
    name: the name of the property
    errp: returns an error if this function fails

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_property_set_link(self, obj, val, name):
    &#39;&#39;&#39;
    Writes an object&#39;s canonical path to a property.
    Calls object_property_set_link QEMU function.

        Parameters:
            value: the value to be written to the property
            name: the name of the property
            errp: returns an error if this function fails

        Returns:
            None
    &#39;&#39;&#39;
    return self.libpanda.object_property_set_link(obj,val,name,self.libpanda.error_abort)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.panda_finish"><code class="name flex">
<span>def <span class="ident">panda_finish</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Final stage call to underlying panda_finish with initialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def panda_finish(self):
    &#39;&#39;&#39;
    Final stage call to underlying panda_finish with initialization.
    &#39;&#39;&#39;
    return self.libpanda.panda_finish()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.physical_memory_read"><code class="name flex">
<span>def <span class="ident">physical_memory_read</span></span>(<span>self, addr, length, fmt='bytearray')</span>
</code></dt>
<dd>
<div class="desc"><p>Read guest physical memory.</p>
<pre><code>Parameters:
    addr: python int address
    length: length of array you would like returned
    fmt: format for returned array. Options: 'bytearray', 'int', and 'str'

Returns:
    Buffer based on fmt string

Raises:
    ValueError for two cases: 
        Memory Access with error value.
        Format string is incorrect.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def physical_memory_read(self, addr, length, fmt=&#39;bytearray&#39;):
    &#39;&#39;&#39;
    Read guest physical memory.

        Parameters:
            addr: python int address
            length: length of array you would like returned
            fmt: format for returned array. Options: &#39;bytearray&#39;, &#39;int&#39;, and &#39;str&#39;

        Returns:
            Buffer based on fmt string
    
        Raises:
            ValueError for two cases: 
                Memory Access with error value.
                Format string is incorrect.
    &#39;&#39;&#39;
    return self._memory_read(None, addr, length, physical=True, fmt=fmt)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.physical_memory_write"><code class="name flex">
<span>def <span class="ident">physical_memory_write</span></span>(<span>self, addr, buf)</span>
</code></dt>
<dd>
<div class="desc"><p>Write guest physical memory.</p>
<pre><code>Parameters:
        addr: python int address
        buf:  byte string to write
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def physical_memory_write(self, addr, buf):
    &#39;&#39;&#39;
    Write guest physical memory.

        Parameters:
                addr: python int address
                buf:  byte string to write
    &#39;&#39;&#39;
    return self._memory_write(None, addr, buf, physical=True)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.ppp"><code class="name flex">
<span>def <span class="ident">ppp</span></span>(<span>self, plugin_name, attr, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator for plugin-to-plugin interface. Note this isn't in decorators.py
becuase it uses the panda object.</p>
<p>Example usage to register my_run with syscalls2 as a 'on_sys_open_return'
@ppp("syscalls2", "on_sys_open_return")
def my_fun(cpu, pc, filename, flags, mode):
&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ppp(self, plugin_name, attr, name=None):
    &#39;&#39;&#39;
    Decorator for plugin-to-plugin interface. Note this isn&#39;t in decorators.py
    becuase it uses the panda object.

    Example usage to register my_run with syscalls2 as a &#39;on_sys_open_return&#39;
    @ppp(&#34;syscalls2&#34;, &#34;on_sys_open_return&#34;)
    def my_fun(cpu, pc, filename, flags, mode):
        ...
    &#39;&#39;&#39;

    if plugin_name not in self.plugins: # Could automatically load it?
        print(f&#34;PPP automatically loaded plugin {plugin_name}&#34;)

    if not hasattr(self, &#34;ppp_registered_cbs&#34;):
        self.ppp_registered_cbs = {}
        # We use this to traak fn_names-&gt;fn_pointers so we can later disable by name

        # XXX: if  we don&#39;t save the cffi generated callbacks somewhere in Python,
        # they may get garbage collected even though the c-code could still has a
        # reference to them  which will lead to a crash. If we stop using this to track
        # function names, we need to keep it or something similar to ensure the reference
        # count remains &gt;0 in python

    def decorator(fun):
        local_name = name  # We need a new varaible otherwise we have scoping issues, maybe
        if local_name is None:
            local_name = fun.__name__
        
        def _run_and_catch(*args, **kwargs): # Run function but if it raises an exception, stop panda and raise it
            try:
                r = fun(*args, **kwargs)
                #print(pandatype, type(r)) # XXX Can we use pandatype to determine requried return and assert if incorrect
                #assert(isinstance(r, int)), &#34;Invalid return type?&#34;
                return r
            except Exception as e:
                # exceptions wont work in our thread. Therefore we print it here and then throw it after the
                # machine exits.
                self.callback_exit_exception = e
                self.end_analysis()
                # this works in all current callback cases. CFFI auto-converts to void, bool, int, and int32_t

        f = ffi.callback(attr+&#34;_t&#34;)(_run_and_catch)  # Wrap the python fn in a c-callback.
        if local_name == &#34;&lt;lambda&gt;&#34;:
            local_name = f&#34;&lt;lambda_{self.lambda_cnt}&gt;&#34;
            self.lambda_cnt += 1

        if local_name in self.ppp_registered_cbs:
            print(f&#34;Warning: replacing existing PPP callback &#39;{name}&#39; since it was re-registered&#34;)
            self.disable_ppp(local_name)

        assert (local_name not in self.ppp_registered_cbs), f&#34;Two callbacks with conflicting name: {local_name}&#34;

        # Ensure function isn&#39;t garbage collected, and keep the name-&gt;(fn, plugin_name, attr) map for disabling
        self.ppp_registered_cbs[local_name] = (f, plugin_name, attr)

        eval(f&#34;self.plugins[&#39;{plugin_name}&#39;].ppp_add_cb_{attr}&#34;)(f) # All PPP  cbs start with this string. XXX insecure eval
        return f
    return decorator</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.pyperiph_read_cb"><code class="name flex">
<span>def <span class="ident">pyperiph_read_cb</span></span>(<span>self, cpu, pc, physaddr, size, val_ptr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pyperiph_read_cb(self, cpu, pc, physaddr, size, val_ptr):
    pp = self._addr_to_pyperipheral(physaddr)
    if pp is None:
        return False

    val = pp.read_memory(physaddr, size)
    buf = ffi.buffer(val_ptr, size)

    fmt = &#34;{}{}&#34;.format(self._end2fmt[self.endianness], self._num2fmt[size])

    pack_into(fmt, buf, 0, val)

    return True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.pyperiph_write_cb"><code class="name flex">
<span>def <span class="ident">pyperiph_write_cb</span></span>(<span>self, cpu, pc, physaddr, size, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pyperiph_write_cb(self, cpu, pc, physaddr, size, val):
    pp = self._addr_to_pyperipheral(physaddr)
    if pp is None:
        return False

    pp.write_memory(physaddr, size, val)
    return True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.queue_async"><code class="name flex">
<span>def <span class="ident">queue_async</span></span>(<span>self, f, internal=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Queues work in the asynchronous work queue.</p>
<pre><code>Parameters:
    f: A python function with no arguments to be called at a later date

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_async(self, f, internal=False):
    &#39;&#39;&#39;
    Queues work in the asynchronous work queue.

        Parameters:
            f: A python function with no arguments to be called at a later date
        
        Returns:
            None
    &#39;&#39;&#39;
    self.athread.queue(f, internal=internal)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.queue_blocking"><code class="name flex">
<span>def <span class="ident">queue_blocking</span></span>(<span>self, func, queue=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to mark a function as <code>blocking</code>, and by default queue it to run asynchronously</p>
<pre><code>@panda.queue_blocking
def do_something():
    panda.revert_sync('root')
    print(panda.run_serial_cmd('whoami'))
    panda.end_analysis()
</code></pre>
<p>is equivalent to</p>
<pre><code>@blocking
def run_whoami():
    panda.revert_sync('root')
    print(panda.run_serial_cmd('whoami'))
    panda.end_analysis()

panda.queue_async(run_whoami)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_blocking(self, func, queue=True):
    &#34;&#34;&#34;
    Decorator to mark a function as `blocking`, and by default queue it to run asynchronously

    ```
    @panda.queue_blocking
    def do_something():
        panda.revert_sync(&#39;root&#39;)
        print(panda.run_serial_cmd(&#39;whoami&#39;))
        panda.end_analysis()
    ```

    is equivalent to

    ```
    @blocking
    def run_whoami():
        panda.revert_sync(&#39;root&#39;)
        print(panda.run_serial_cmd(&#39;whoami&#39;))
        panda.end_analysis()

    panda.queue_async(run_whoami)
    ```

    &#34;&#34;&#34;
    f = blocking(func)
    if queue:
        self.queue_async(f)
    return f</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.queue_main_loop_wait_fn"><code class="name flex">
<span>def <span class="ident">queue_main_loop_wait_fn</span></span>(<span>self, fn, args=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Queue a function to run at the next main loop
fn is a function we want to run, args are arguments to apss to it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_main_loop_wait_fn(self, fn, args=[]):
    &#39;&#39;&#39;
    Queue a function to run at the next main loop
    fn is a function we want to run, args are arguments to apss to it
    &#39;&#39;&#39;
    self.main_loop_wait_fnargs.append((fn, args))</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.read_str"><code class="name flex">
<span>def <span class="ident">read_str</span></span>(<span>self, cpu, ptr)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper to read a null-terminated string from guest memory given a pointer and CPU state
May return an exception if the call to panda.virtual_memory_read fails (e.g., if you pass a
pointer to an unmapped page)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_str(self, cpu, ptr):
    &#39;&#39;&#39;
    Helper to read a null-terminated string from guest memory given a pointer and CPU state
    May return an exception if the call to panda.virtual_memory_read fails (e.g., if you pass a
    pointer to an unmapped page)
    &#39;&#39;&#39;
    r = b&#34;&#34;
    while True:
        next_char = self.virtual_memory_read(cpu, ptr, 1) # If this raises an exn, don&#39;t mask it
        if next_char == b&#34;\x00&#34;:
            break
        r += next_char
        ptr += 1
    return r.decode(&#34;utf8&#34;, &#34;ignore&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.record"><code class="name flex">
<span>def <span class="ident">record</span></span>(<span>self, recording_name, snapshot_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Begins active recording with name provided.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>recording_name</code></strong> :&ensp;<code>string</code></dt>
<dd>name of recording to save.</dd>
<dt><strong><code>snapshot_name</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Before recording starts restore to this snapshot name. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>raises exception if there was an error starting recording.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def record(self, recording_name, snapshot_name=None):
    &#34;&#34;&#34;Begins active recording with name provided.

    Args:
        recording_name (string): name of recording to save.
        snapshot_name (string, optional): Before recording starts restore to this snapshot name. Defaults to None.

    Raises:
        Exception: raises exception if there was an error starting recording.
    &#34;&#34;&#34;
    if snapshot_name == None:
        snapshot_name_ffi = ffi.NULL
    else:
        snapshot_name_ffi = ffi.new(&#34;char[]&#34;,snapshot_name.encode())
    recording_name_ffi = ffi.new(&#34;char[]&#34;, recording_name.encode())
    result = self.libpanda.panda_record_begin(recording_name_ffi,snapshot_name_ffi)
    res_string_enum = ffi.string(ffi.cast(&#34;RRCTRL_ret&#34;,result))
    if res_string_enum != &#34;RRCTRL_OK&#34;:
       raise Exception(f&#34;record method failed with RTCTL_ret {res_string_enum} ({result})&#34;) </code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.record_cmd"><code class="name flex">
<span>def <span class="ident">record_cmd</span></span>(<span>self, guest_command, copy_directory=None, iso_name=None, setup_command=None, recording_name='recording', snap_name='root', ignore_errors=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Take a recording as follows:
0) Revert to the specified snapshot name if one is set. By default 'root'. Set to <code>None</code> if you have already set up the guest and are ready to record with no revert
1) Create an ISO of files that need to be copied into the guest if copy_directory is specified. Copy them in
2) Run the setup_command in the guest, if provided
3) Type the command you wish to record but do not press enter to begin execution. This avoids the recording capturing the command being typed
4) Begin the recording (name controlled by recording_name)
5) Press enter in the guest to begin the command. Wait until it finishes.
6) End the recording</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def record_cmd(self, guest_command, copy_directory=None, iso_name=None, setup_command=None, recording_name=&#34;recording&#34;, snap_name=&#34;root&#34;, ignore_errors=False):
    &#39;&#39;&#39;
    Take a recording as follows:
        0) Revert to the specified snapshot name if one is set. By default &#39;root&#39;. Set to `None` if you have already set up the guest and are ready to record with no revert
        1) Create an ISO of files that need to be copied into the guest if copy_directory is specified. Copy them in
        2) Run the setup_command in the guest, if provided
        3) Type the command you wish to record but do not press enter to begin execution. This avoids the recording capturing the command being typed
        4) Begin the recording (name controlled by recording_name)
        5) Press enter in the guest to begin the command. Wait until it finishes.
        6) End the recording
    &#39;&#39;&#39;
    # 0) Revert to the specified snapshot
    if snap_name is not None:
        self.revert_sync(snap_name) # Can&#39;t use self.revert because that would would run async and we&#39;d keep going before the revert happens

    # 1) Make copy_directory into an iso and copy it into the guest - It will end up at the exact same path
    if copy_directory: # If there&#39;s a directory, build an ISO and put it in the cddrive
        # Make iso
        self.copy_to_guest(copy_directory, iso_name)

    # 2) Run setup_command, if provided before we start the recording (good place to CD or install, etc)
    if setup_command:
        print(f&#34;Running setup command {setup_command}&#34;)
        r = self.run_serial_cmd(setup_command)
        print(f&#34;Setup command results: {r}&#34;)

    # 3) type commmand (note we type command, start recording, finish command)
    self.type_serial_cmd(guest_command)

    # 4) start recording
    self.run_monitor_cmd(&#34;begin_record {}&#34;.format(recording_name))

    # 5) finish command
    result = self.finish_serial_cmd()

    if debug:
        progress(&#34;Result of `{}`:&#34;.format(guest_command))
        print(&#34;\t&#34;+&#34;\n\t&#34;.join(result.split(&#34;\n&#34;))+&#34;\n&#34;)

    if &#34;No such file or directory&#34; in result and not ignore_errors:
        print(&#34;Bad output running command: {}&#34;.format(result))
        raise RuntimeError(&#34;Command not found while taking recording&#34;)

    if &#34;cannot execute binary file&#34; in result and not ignore_errors:
        print(&#34;Bad output running command: {}&#34;.format(result))
        raise RuntimeError(&#34;Could not execute binary while taking recording&#34;)

    # 6) End recording
    self.run_monitor_cmd(&#34;end_record&#34;)

    print(&#34;Finished recording&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.register_callback"><code class="name flex">
<span>def <span class="ident">register_callback</span></span>(<span>self, callback, function, name, enabled=True, procname=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_callback(self, callback, function, name, enabled=True, procname=None):
    # CB   = self.callback.main_loop_wait
    # func = main_loop_wait_cb
    # name = main_loop_wait

    if name in self.registered_callbacks:
        print(f&#34;Warning: replacing existing callback &#39;{name}&#39; since it was re-registered&#34;)
        self.delete_callback(name)

    cb = self.callback_dictionary[callback]

    # Generate a unique handle for each callback type using the number of previously registered CBs of that type added to a constant
    handle = ffi.cast(&#39;void *&#39;, 0x8888 + 100*len([x for x in self.registered_callbacks.values() if x[&#39;callback&#39;] == cb]))

    # XXX: We should have another layer of indirection here so we can catch
    #      exceptions raised during execution of the CB and abort analysis
    pcb = ffi.new(&#34;panda_cb *&#34;, {cb.name:function})

    if debug:
        progress(&#34;Registered function &#39;{}&#39; to run on callback {}&#34;.format(name, cb.name))

    self.libpanda.panda_register_callback_helper(handle, cb.number, pcb)
    self.registered_callbacks[name] = {&#34;procname&#34;: procname, &#34;enabled&#34;: True, &#34;callback&#34;: cb,
                       &#34;handle&#34;: handle, &#34;pcb&#34;: pcb, &#34;function&#34;: function} # XXX: if function is not saved here it gets GC&#39;d and everything breaks! Watch out!

    if not enabled: # Note the registered_callbacks dict starts with enabled true and then we update it to false as necessary here
        self.disable_callback(name)

    if &#34;block&#34; in cb.name:
        if not self.disabled_tb_chaining:
            print(&#34;Warning: disabling TB chaining to support {} callback&#34;.format(cb.name))
            self.disable_tb_chaining()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.register_cb_decorators"><code class="name flex">
<span>def <span class="ident">register_cb_decorators</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Setup callbacks and generate self.cb_XYZ functions for cb decorators
XXX Don't add any other methods with names starting with 'cb_'
Callbacks can be called as @panda.cb_XYZ in which case they'll take default arguments and be named the same as the decorated function
Or they can be called as @panda.cb_XYZ(name='A', procname='B', enabled=True). Defaults: name is function name, procname=None, enabled=True unless procname set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_cb_decorators(self):
    &#39;&#39;&#39;
    Setup callbacks and generate self.cb_XYZ functions for cb decorators
    XXX Don&#39;t add any other methods with names starting with &#39;cb_&#39;
    Callbacks can be called as @panda.cb_XYZ in which case they&#39;ll take default arguments and be named the same as the decorated function
    Or they can be called as @panda.cb_XYZ(name=&#39;A&#39;, procname=&#39;B&#39;, enabled=True). Defaults: name is function name, procname=None, enabled=True unless procname set
    &#39;&#39;&#39;
    for cb_name, pandatype in zip(self.callback._fields, self.callback):
        def closure(closed_cb_name, closed_pandatype): # Closure on cb_name and pandatype
            def f(*args, **kwargs):
                if len(args): # Called as @panda.cb_XYZ without ()s- no arguments to decorator but we get the function name instead
                    # Call our decorator with only a name argument ON the function itself
                    fun = args[0]
                    return self._generated_callback(closed_pandatype, **{&#34;name&#34;: fun.__name__})(fun)
                else:
                    # Otherwise, we were called as @panda.cb_XYZ() with potential args - Just return the decorator and it&#39;s applied to the function
                    return self._generated_callback(closed_pandatype, *args, **kwargs)
            return f

        setattr(self, &#39;cb_&#39;+cb_name, closure(cb_name, pandatype))</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.register_pyperipheral"><code class="name flex">
<span>def <span class="ident">register_pyperipheral</span></span>(<span>self, object)</span>
</code></dt>
<dd>
<div class="desc"><p>Registers a python peripheral, and the necessary attributes to the
panda-object, if not present yet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_pyperipheral(self, object):
    &#34;&#34;&#34;
    Registers a python peripheral, and the necessary attributes to the
    panda-object, if not present yet.
    &#34;&#34;&#34;

    # if we are the first pyperipheral, register the pp-dict
    if not hasattr(self, &#34;pyperipherals&#34;):
        self.pyperipherals = []
        self.pyperipherals_registered_cb = False
        self._num2fmt = {1: &#34;B&#34;, 2: &#34;H&#34;, 4: &#34;I&#34;, 8: &#34;Q&#34;}
        self._end2fmt = {&#34;little&#34;: &#34;&lt;&#34;, &#34;big&#34;: &#34;&gt;&#34;}

    self._validate_object(object)

    if self.pyperipherals_registered_cb is False:
        self.register_callback(
            self.callback.unassigned_io_read,
            self.callback.unassigned_io_read(self.pyperiph_read_cb),
            &#34;pyperipheral_read_callback&#34;,
        )

        self.register_callback(
            self.callback.unassigned_io_write,
            self.callback.unassigned_io_write(self.pyperiph_write_cb),
            &#34;pyperipheral_write_callback&#34;,
        )

        self.pyperipherals_registered_cb = True

    self.pyperipherals.append(object)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.require"><code class="name flex">
<span>def <span class="ident">require</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a C plugin with no arguments. Deprecated. Use load_plugin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def require(self, name):
    &#39;&#39;&#39;
    Load a C plugin with no arguments. Deprecated. Use load_plugin
    &#39;&#39;&#39;
    self.load_plugin(name, args={})</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>In the next main loop, reset to boot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self): 
    &#34;&#34;&#34;In the next main loop, reset to boot&#34;&#34;&#34;
    if debug:
        progress (&#34;Resetting machine to start state&#34;)

    # Stop guest, queue up revert, then continue
    self.vm_stop()
    self.queue_main_loop_wait_fn(self.libpanda.panda_reset)
    self.queue_main_loop_wait_fn(self.libpanda.panda_cont)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.revert_async"><code class="name flex">
<span>def <span class="ident">revert_async</span></span>(<span>self, snapshot_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Request a snapshot revert, eventually. This is fairly dangerous
because you don't know when it finishes. You should be using revert_sync
from a blocking function instead</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def revert_async(self, snapshot_name): # In the next main loop, revert
    &#39;&#39;&#39;
    Request a snapshot revert, eventually. This is fairly dangerous
    because you don&#39;t know when it finishes. You should be using revert_sync
    from a blocking function instead
    &#39;&#39;&#39;
    print(&#34;WARNING: panda.revert_async may be deprecated in the near future&#34;)
    if debug:
        progress (&#34;Loading snapshot &#34; + snapshot_name)

    # Stop guest, queue up revert, then continue
    timer_start = time()
    self.vm_stop()
    charptr = ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
    self.queue_main_loop_wait_fn(self.libpanda.panda_revert, [charptr])
    self.queue_main_loop_wait_fn(self.libpanda.panda_cont)
    if debug:
        self.queue_main_loop_wait_fn(self.finish_timer, [timer_start, &#34;Loaded snapshot&#34;])</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.revert_sync"><code class="name flex">
<span>def <span class="ident">revert_sync</span></span>(<span>self, snapshot_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def revert_sync(self, snapshot_name):
    result = self.run_monitor_cmd(&#34;loadvm {}&#34;.format(snapshot_name))
    if result.startswith(&#34;Length mismatch&#34;):
        raise RuntimeError(&#34;QEMU machine&#39;s RAM size doesn&#39;t match snapshot RAM size!&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.rr_get_guest_instr_count"><code class="name flex">
<span>def <span class="ident">rr_get_guest_instr_count</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns record/replay guest instruction count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rr_get_guest_instr_count(self):
    &#39;&#39;&#39;
    Returns record/replay guest instruction count.
    &#39;&#39;&#39;
    return self.libpanda.rr_get_guest_instr_count_external()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function starts our running PANDA instance from Python. At termination this function returns and the script continues to run after it.</p>
<p>This function starts execution of the guest. It blocks until guest finishes.
It also initializes panda object, clears main_loop_wait fns, and sets up internal callbacks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#39;&#39;&#39;
    This function starts our running PANDA instance from Python. At termination this function returns and the script continues to run after it.
    
    This function starts execution of the guest. It blocks until guest finishes.
    It also initializes panda object, clears main_loop_wait fns, and sets up internal callbacks.
    &#39;&#39;&#39;

    if len(self.main_loop_wait_fnargs):
        if debug:
            print(&#34;Clearing prior main_loop_wait fns:&#34;, self.main_loop_wait_fnargs)
        self.main_loop_wait_fnargs = [] # [(fn, args), ...]

    if debug:
        progress (&#34;Running&#34;)

    if not self._initialized_panda:
        self._initialize_panda()

    if not self.started.is_set():
        self.started.set()

    # Ensure our internal CBs are always enabled
    self.enable_internal_callbacks()
    self.setup_internal_signal_handler()
    self.running.set()
    self.libpanda.panda_run() # Give control to panda
    self.running.clear() # Back from panda&#39;s execution (due to shutdown or monitor quit)
    self.libpanda.panda_unload_plugins() # Unload c plugins - should be safe now since exec has stopped
    if hasattr(self, &#34;end_run_raise_signal&#34;):
        raise self.end_run_raise_signal
    if hasattr(self, &#34;callback_exit_exception&#34;):
        raise self.callback_exit_exception</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.run_monitor_cmd"><code class="name flex">
<span>def <span class="ident">run_monitor_cmd</span></span>(<span>self, cmd)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def run_monitor_cmd(self, cmd):
    self.monitor_console.sendline(cmd.encode(&#34;utf8&#34;))
    result = self.monitor_console.expect()
    return result</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.run_replay"><code class="name flex">
<span>def <span class="ident">run_replay</span></span>(<span>self, replaypfx)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a replay and run it. Starts PANDA execution and returns after end of VM execution.</p>
<pre><code>Parameters:
    replaypfx: python string path to replay file.

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_replay(self, replaypfx):
    &#39;&#39;&#39;
    Load a replay and run it. Starts PANDA execution and returns after end of VM execution.

        Parameters:
            replaypfx: python string path to replay file.
    
        Returns:
            None
    &#39;&#39;&#39;
    if not isfile(replaypfx+&#34;-rr-snp&#34;) or not isfile(replaypfx+&#34;-rr-nondet.log&#34;):
        raise ValueError(&#34;Replay files not present to run replay of {}&#34;.format(replaypfx))

    if debug:
        progress (&#34;Replaying %s&#34; % replaypfx)

    charptr = ffi.new(&#34;char[]&#34;,bytes(replaypfx,&#34;utf-8&#34;))
    self.libpanda.panda_replay_begin(charptr)
    self.run()</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.run_serial_cmd"><code class="name flex">
<span>def <span class="ident">run_serial_cmd</span></span>(<span>self, cmd, no_timeout=False, timeout=30)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def run_serial_cmd(self, cmd, no_timeout=False, timeout=30):
    self.running.wait() # Can only run serial when guest is running
    self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
    if no_timeout:
        result = self.serial_console.expect(timeout=9999)
    else:
        result = self.serial_console.expect(timeout=timeout)
    return result</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.run_serial_cmd_async"><code class="name flex">
<span>def <span class="ident">run_serial_cmd_async</span></span>(<span>self, cmd, delay=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Type a command and press enter in the guest. Return immediately. No results available
Only use this if you know what you're doing!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def run_serial_cmd_async(self, cmd, delay=1):
    &#39;&#39;&#39;
    Type a command and press enter in the guest. Return immediately. No results available
    Only use this if you know what you&#39;re doing!
    &#39;&#39;&#39;
    self.running.wait() # Can only run serial when guest is running
    self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
    if delay:
        sleep(delay) # Ensure it has a chance to run</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.run_volatility"><code class="name flex">
<span>def <span class="ident">run_volatility</span></span>(<span>self, plugin, debug=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_volatility(self, plugin, debug=False):
    try:
        from .volatility_cli_classes import CommandLineRunFullCommand, StringTextRenderer
    except ImportError:
        print(&#34;Warning: Failed to import volatility&#34;)
        return None
    self.make_panda_file_handler(debug=debug)
    cmd = CommandLineRunFullCommand().run(&#34;-q -f panda.panda &#34; + plugin)
    output = StringTextRenderer().render(cmd.run())
    return output</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.set_breakpoint"><code class="name flex">
<span>def <span class="ident">set_breakpoint</span></span>(<span>self, cpu, pc)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a GDB breakpoint such that when the guest hits PC, execution is paused and an attached
GDB instance can introspect on guest memory. Requires starting panda with -s, at least for now</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_breakpoint(self, cpu, pc):
    &#39;&#39;&#39;
    Set a GDB breakpoint such that when the guest hits PC, execution is paused and an attached
    GDB instance can introspect on guest memory. Requires starting panda with -s, at least for now
    &#39;&#39;&#39;
    BP_GDB = 0x10
    self.libpanda.cpu_breakpoint_insert(cpu, pc, BP_GDB, ffi.NULL)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.set_os_name"><code class="name flex">
<span>def <span class="ident">set_os_name</span></span>(<span>self, os_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set OS target. Equivalent to "-os" flag on the command line. Matches the form of:</p>
<pre><code>"windows[-_]32[-_]xpsp[23]",
"windows[-_]32[-_]7",
"windows[-_]32[-_]2000",
"linux[-_]32[-_].+",
"linux[-_]64[-_].+",

Parameters:
    os_name: string matching the format for the os flag.

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_os_name(self, os_name):
    &#34;&#34;&#34;
    Set OS target. Equivalent to &#34;-os&#34; flag on the command line. Matches the form of:
    
        &#34;windows[-_]32[-_]xpsp[23]&#34;,
        &#34;windows[-_]32[-_]7&#34;,
        &#34;windows[-_]32[-_]2000&#34;,
        &#34;linux[-_]32[-_].+&#34;,
        &#34;linux[-_]64[-_].+&#34;,

        Parameters:
            os_name: string matching the format for the os flag.
        
        Returns:
            None
    &#34;&#34;&#34;
    os_name_new = ffi.new(&#34;char[]&#34;, bytes(os_name, &#34;utf-8&#34;))
    self.libpanda.panda_set_os_name(os_name_new)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.set_pandalog"><code class="name flex">
<span>def <span class="ident">set_pandalog</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable recording to a pandalog (plog) named <code>name</code></p>
<pre><code>Parameters:
    name: file to output data to

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pandalog(self, name):
    &#39;&#39;&#39;
    Enable recording to a pandalog (plog) named `name`

        Parameters:
            name: file to output data to
        
        Returns:
            None
    &#39;&#39;&#39;
    charptr = ffi.new(&#34;char[]&#34;, bytes(name, &#34;utf-8&#34;))
    self.libpanda.panda_start_pandalog(charptr)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.setup_internal_signal_handler"><code class="name flex">
<span>def <span class="ident">setup_internal_signal_handler</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_internal_signal_handler(self):
   # ffi.cdef(&#34;void panda_setup_signal_handling(void (*f) (int,void*,void*));&#34;,override=True)
    @ffi.callback(&#34;void(int,void*,void*)&#34;)
    def SigHandler(SIG,a,b):
        from signal import SIGINT, SIGHUP, SIGTERM
        if SIG == SIGINT:
            self.end_run_raise_signal = KeyboardInterrupt
            self.end_analysis()
        elif SIG == SIGHUP:
            self.end_run_raise_signal = KeyboardInterrupt
            self.end_analysis()
        elif SIG == SIGTERM:
            self.end_run_raise_signal = KeyboardInterrupt
            self.end_analysis()
        else:
            print(f&#34;PyPanda Signal handler received unhandled signal {SIG}&#34;)
    
    self.__sighandler = SigHandler
    self.libpanda.panda_setup_signal_handling(self.__sighandler)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.snap"><code class="name flex">
<span>def <span class="ident">snap</span></span>(<span>self, snapshot_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Create snapshot with specified name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def snap(self, snapshot_name):
    &#39;&#39;&#39; Create snapshot with specified name &#39;&#39;&#39;
    if debug:
        progress (&#34;Creating snapshot &#34; + snapshot_name)

    # Stop guest execution, queue up a snapshot, then continue
    timer_start = time()
    self.vm_stop()
    charptr = ffi.new(&#34;char[]&#34;, bytes(snapshot_name, &#34;utf-8&#34;))
    self.queue_main_loop_wait_fn(self.libpanda.panda_snap, [charptr])
    self.queue_main_loop_wait_fn(self.libpanda.panda_cont)
    if debug:
        self.queue_main_loop_wait_fn(self.finish_timer, [timer_start, &#34;Saved snapshot&#34;])</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.stop_run"><code class="name flex">
<span>def <span class="ident">stop_run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>From a blocking thread, request vl.c loop to break. Returns control flow in main thread.
In other words, once this is called, panda.run() will finish and your main thread will continue.
If you also want to unload plugins, use end_analysis instead</p>
<p>XXX: This doesn't work in replay mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def stop_run(self):
    &#39;&#39;&#39;
    From a blocking thread, request vl.c loop to break. Returns control flow in main thread.
    In other words, once this is called, panda.run() will finish and your main thread will continue.
    If you also want to unload plugins, use end_analysis instead

    XXX: This doesn&#39;t work in replay mode
    &#39;&#39;&#39;
    self.libpanda.panda_break_vl_loop_req = True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.sysbus_create_varargs"><code class="name flex">
<span>def <span class="ident">sysbus_create_varargs</span></span>(<span>self, name, addr)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns DeviceState struct from user specified information
Calls sysbus_create_varargs QEMU function.</p>
<pre><code>Parameters:
    name: python string
    addr: python integer representing hwaddr

Return:
    DeviceState struct
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sysbus_create_varargs(self, name, addr):
    &#39;&#39;&#39;
    Returns DeviceState struct from user specified information
    Calls sysbus_create_varargs QEMU function.

        Parameters:
            name: python string
            addr: python integer representing hwaddr
        
        Return:
            DeviceState struct
    &#39;&#39;&#39;
    return self.libpanda.sysbus_create_varargs(name,addr,ffi.NULL)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_check_laddr"><code class="name flex">
<span>def <span class="ident">taint_check_laddr</span></span>(<span>self, addr, off)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_check_laddr(self, addr, off):
    if not self.taint_enabled: return False
    if self.plugins[&#39;taint2&#39;].taint2_query_laddr(addr, off) &gt; 0:
        return True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_check_ram"><code class="name flex">
<span>def <span class="ident">taint_check_ram</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_check_ram(self, addr):
    if not self.taint_enabled: return False
    if self.plugins[&#39;taint2&#39;].taint2_query_ram(addr) &gt; 0:
        return True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_check_reg"><code class="name flex">
<span>def <span class="ident">taint_check_reg</span></span>(<span>self, reg_num)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def taint_check_reg(self, reg_num):
        if not self.taint_enabled: return False
#        if debug:
#            progress(&#34;taint_check_reg %d&#34; % (reg_num))
        for offset in range(self.register_size):
            if self.plugins[&#39;taint2&#39;].taint2_query_reg(reg_num, offset) &gt; 0:
                return True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_enable"><code class="name flex">
<span>def <span class="ident">taint_enable</span></span>(<span>self, cont=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Inform python that taint is enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def taint_enable(self, cont=True):
        &#34;&#34;&#34;
        Inform python that taint is enabled.
        &#34;&#34;&#34;
        if not self.taint_enabled:
            progress(&#34;taint not enabled -- enabling&#34;)
            self.vm_stop()
            self.require(&#34;taint2&#34;)
#            self.queue_main_loop_wait_fn(self.require, [&#34;taint2&#34;])
            self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_enable_taint, [])
            if cont:
                self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])
            self.taint_enabled = True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_get_laddr"><code class="name flex">
<span>def <span class="ident">taint_get_laddr</span></span>(<span>self, addr, offset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_get_laddr(self, addr, offset):
    if not self.taint_enabled: return None
    if self.plugins[&#39;taint2&#39;].taint2_query_laddr(addr, offset) &gt; 0:
        query_res = ffi.new(&#34;QueryResult *&#34;)
        self.plugins[&#39;taint2&#39;].taint2_query_laddr_full(addr, offset, query_res)
        tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;])
        return tq
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_get_ram"><code class="name flex">
<span>def <span class="ident">taint_get_ram</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_get_ram(self, addr):
    if not self.taint_enabled: return None
    if self.plugins[&#39;taint2&#39;].taint2_query_ram(addr) &gt; 0:
        query_res = ffi.new(&#34;QueryResult *&#34;)
        self.plugins[&#39;taint2&#39;].taint2_query_ram_full(addr, query_res)
        tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;])
        return tq
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_get_reg"><code class="name flex">
<span>def <span class="ident">taint_get_reg</span></span>(<span>self, reg_num)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns array of results, one for each byte in this register
None if no taint.
QueryResult struct otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_get_reg(self, reg_num):
    &#39;&#39;&#39;
    Returns array of results, one for each byte in this register
    None if no taint.  QueryResult struct otherwise
    &#39;&#39;&#39;
    if not self.taint_enabled: return None
    if debug:
        progress(&#34;taint_get_reg %d&#34; % (reg_num)) 
    res = []
    for offset in range(self.register_size): 
        if self.plugins[&#39;taint2&#39;].taint2_query_reg(reg_num, offset) &gt; 0:
            query_res = ffi.new(&#34;QueryResult *&#34;)
            self.plugins[&#39;taint2&#39;].taint2_query_reg_full(reg_num, offset, query_res)
            tq = TaintQuery(query_res, self.plugins[&#39;taint2&#39;])
            res.append(tq)
        else:
            res.append(None)
    return res</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_label_ram"><code class="name flex">
<span>def <span class="ident">taint_label_ram</span></span>(<span>self, addr, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_label_ram(self, addr, label):
    self.taint_enable(cont=False)
    #if debug:
        #progress(&#34;taint_ram addr=0x%x label=%d&#34; % (addr, label))

    # XXX must ensure labeling is done in a before_block_invalidate that rets 1
    #     or some other safe way where the main_loop_wait code will always be run
    #self.stop()
    self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_label_ram, [addr, label])
    self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.taint_label_reg"><code class="name flex">
<span>def <span class="ident">taint_label_reg</span></span>(<span>self, reg_num, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taint_label_reg(self, reg_num, label):
    self.taint_enable(cont=False)
    #if debug:
    #    progress(&#34;taint_reg reg=%d label=%d&#34; % (reg_num, label))

    # XXX must ensure labeling is done in a before_block_invalidate that rets 1
    #     or some other safe way where the main_loop_wait code will always be run
    #self.stop()
    for i in range(self.register_size):
        self.queue_main_loop_wait_fn(self.plugins[&#39;taint2&#39;].taint2_label_reg, [reg_num, i, label])
    self.queue_main_loop_wait_fn(self.libpanda.panda_cont, [])</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.to_unsigned_guest"><code class="name flex">
<span>def <span class="ident">to_unsigned_guest</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a singed python int to an unsigned int32/unsigned int64
depending on guest bit-size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_unsigned_guest(self, x):
    &#39;&#39;&#39;
    Convert a singed python int to an unsigned int32/unsigned int64
    depending on guest bit-size
    &#39;&#39;&#39;
    import ctypes
    if self.bits == 32:
        return ctypes.c_uint32(x).value
    elif self.bits == 64:
        return ctypes.c_uint64(x).value
    else:
        raise ValueError(&#34;Unsupported number of bits&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.type_serial_cmd"><code class="name flex">
<span>def <span class="ident">type_serial_cmd</span></span>(<span>self, cmd)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@blocking
def type_serial_cmd(self, cmd):
    #Can send message into socket without guest running (no self.running.wait())
    self.serial_console.send(cmd.encode(&#34;utf8&#34;)) # send, not sendline</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.unload_plugin"><code class="name flex">
<span>def <span class="ident">unload_plugin</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Unload plugin with given name.</p>
<pre><code>Parameters:
    name: python string name of plugin

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unload_plugin(self, name):
    &#39;&#39;&#39;
    Unload plugin with given name.

        Parameters:
            name: python string name of plugin
    
        Returns:
            None
    &#39;&#39;&#39;
    if debug:
        progress (&#34;Unloading plugin %s&#34; % name),
    name_ffi = ffi.new(&#34;char[]&#34;, bytes(name,&#34;utf-8&#34;))
    self.libpanda.panda_unload_plugin_by_name(name_ffi)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.unload_plugins"><code class="name flex">
<span>def <span class="ident">unload_plugins</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable all python plugins and request to unload all c plugins
at the next main_loop_wait.</p>
<p>XXX: If called during shutdown/exit, c plugins won't be unloaded
because the next main_loop_wait will never happen. Instead, call
panda.panda_finish directly (which is done at the end of panda.run())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unload_plugins(self):
    &#39;&#39;&#39;
    Disable all python plugins and request to unload all c plugins
    at the next main_loop_wait.

    XXX: If called during shutdown/exit, c plugins won&#39;t be unloaded
    because the next main_loop_wait will never happen. Instead, call
    panda.panda_finish directly (which is done at the end of panda.run())
    &#39;&#39;&#39;
    if debug:
        progress (&#34;Disabling all python plugins, unloading all C plugins&#34;)

    # First unload python plugins, should be safe to do anytime
    for name in self.registered_callbacks.keys():
        self.disable_callback(name)

    # Then unload C plugins. May be unsafe to do except from the top of the main loop (taint segfaults otherwise)
    self.queue_main_loop_wait_fn(self.libpanda.panda_unload_plugins)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.unregister_pyperipheral"><code class="name flex">
<span>def <span class="ident">unregister_pyperipheral</span></span>(<span>self, pyperiph)</span>
</code></dt>
<dd>
<div class="desc"><p>deregisters a python peripheral.
The pyperiph parameter can be either an object, or an address
Returns true if the pyperipheral was successfully removed, else false.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister_pyperipheral(self, pyperiph):
    &#34;&#34;&#34;
    deregisters a python peripheral.
    The pyperiph parameter can be either an object, or an address
    Returns true if the pyperipheral was successfully removed, else false.
    &#34;&#34;&#34;

    if isinstance(pyperiph, int) is True:
        pp = self._addr_to_pyperipheral(pyperiph)
        if pp is None:
            return False
    else:
        if pyperiph not in self.pyperipherals:
            return False
        pp = pyperiph

    self.pyperipherals.remove(pp)

    # If we dont have any pyperipherals left, unregister callbacks
    if len(self.pyperipherals) == 0:
        self.disable_callback(&#34;pyperipheral_read_callback&#34;, forever=True)
        self.disable_callback(&#34;pyperipheral_write_callback&#34;, forever=True)
        self.pyperipherals_registered_cb = False
    return True</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.update_hook"><code class="name flex">
<span>def <span class="ident">update_hook</span></span>(<span>self, hook_name, addr)</span>
</code></dt>
<dd>
<div class="desc"><p>Update hook to point to a different addres and enable it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_hook(self,hook_name,addr):
    &#39;&#39;&#39;
    Update hook to point to a different addres and enable it
    &#39;&#39;&#39;
    if hook_name in self.named_hooks:
        hook = self.named_hooks[hook_name]
        #print(f&#34;Updating hook {hook_name} at 0x{hook.target_addr:x}&#34;)
        if addr != hook.target_addr:
            hook.target_addr = addr
            self.plugins[&#39;hooks&#39;].enable_hook(hook.hook_cb, hook.target_addr)
        self.enable_hook(hook_name)

    else:
        raise ValueError(f&#34;Unknown hook {hook_name}&#34;)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.virt_to_phys"><code class="name flex">
<span>def <span class="ident">virt_to_phys</span></span>(<span>self, env, addr)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert virtual address to physical address.</p>
<pre><code>Parameters:
    env: CPUState struct
    addr (int): virtual address to convert

Return:
    physical address as python int
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def virt_to_phys(self, env, addr):
    &#39;&#39;&#39;
    Convert virtual address to physical address.

        Parameters:
            env: CPUState struct
            addr (int): virtual address to convert
        
        Return:
            physical address as python int
    &#39;&#39;&#39;
    return self.libpanda.panda_virt_to_phys_external(env, addr)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.virtual_memory_read"><code class="name flex">
<span>def <span class="ident">virtual_memory_read</span></span>(<span>self, env, addr, length, fmt='bytearray')</span>
</code></dt>
<dd>
<div class="desc"><p>Read guest virtual memory.</p>
<pre><code>Parameters:
        env: CPUState structure
        addr: python int address
        length: length of array you would like returned
        fmt: format for returned array. Options: 'bytearray', 'int', and 'str'

Returns:
        Buffer based on fmt string

Raises:
        ValueError for two cases: 
            Memory Access with error value.
            Format string is incorrect.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def virtual_memory_read(self, env, addr, length, fmt=&#39;bytearray&#39;):
    &#39;&#39;&#39;
    Read guest virtual memory.

        Parameters:
                env: CPUState structure
                addr: python int address
                length: length of array you would like returned
                fmt: format for returned array. Options: &#39;bytearray&#39;, &#39;int&#39;, and &#39;str&#39;
        
        Returns:
                Buffer based on fmt string
        
        Raises:
                ValueError for two cases: 
                    Memory Access with error value.
                    Format string is incorrect.
    &#39;&#39;&#39;
    return self._memory_read(env, addr, length, physical=False, fmt=fmt)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.virtual_memory_write"><code class="name flex">
<span>def <span class="ident">virtual_memory_write</span></span>(<span>self, env, addr, buf)</span>
</code></dt>
<dd>
<div class="desc"><p>Write guest virtual memory.</p>
<pre><code>Parameters:
        env: CPUState structure
        address: python int address
        buf: byte string to write

Returns:
        int: 0 on success. 1 on error.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def virtual_memory_write(self, env, addr, buf):
    &#39;&#39;&#39;
    Write guest virtual memory.
    
        Parameters:
                env: CPUState structure
                address: python int address
                buf: byte string to write
        
        Returns:
                int: 0 on success. 1 on error.

    &#39;&#39;&#39;
    return self._memory_write(env, addr, buf, physical=False)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.vm_stop"><code class="name flex">
<span>def <span class="ident">vm_stop</span></span>(<span>self, code=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop execution, default code means RUN_STATE_PAUSED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vm_stop(self, code=4):
    &#39;&#39;&#39; Stop execution, default code means RUN_STATE_PAUSED &#39;&#39;&#39;
    self.libpanda.panda_stop(code)</code></pre>
</details>
</dd>
<dt id="pandare.panda.Panda.was_aborted"><code class="name flex">
<span>def <span class="ident">was_aborted</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if panda was aborted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def was_aborted(self):
    &#39;&#39;&#39;
    Returns true if panda was aborted.
    &#39;&#39;&#39;
    return self.libpanda.panda_was_aborted()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pandare" href="index.html">pandare</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pandare.panda.Panda" href="#pandare.panda.Panda">Panda</a></code></h4>
<ul class="">
<li><code><a title="pandare.panda.Panda.arch" href="#pandare.panda.Panda.arch">arch</a></code></li>
<li><code><a title="pandare.panda.Panda.arm_load_kernel" href="#pandare.panda.Panda.arm_load_kernel">arm_load_kernel</a></code></li>
<li><code><a title="pandare.panda.Panda.callstack_callers" href="#pandare.panda.Panda.callstack_callers">callstack_callers</a></code></li>
<li><code><a title="pandare.panda.Panda.cleanup" href="#pandare.panda.Panda.cleanup">cleanup</a></code></li>
<li><code><a title="pandare.panda.Panda.clear_breakpoint" href="#pandare.panda.Panda.clear_breakpoint">clear_breakpoint</a></code></li>
<li><code><a title="pandare.panda.Panda.cont" href="#pandare.panda.Panda.cont">cont</a></code></li>
<li><code><a title="pandare.panda.Panda.copy_to_guest" href="#pandare.panda.Panda.copy_to_guest">copy_to_guest</a></code></li>
<li><code><a title="pandare.panda.Panda.cpu_class_by_name" href="#pandare.panda.Panda.cpu_class_by_name">cpu_class_by_name</a></code></li>
<li><code><a title="pandare.panda.Panda.create_external_gic" href="#pandare.panda.Panda.create_external_gic">create_external_gic</a></code></li>
<li><code><a title="pandare.panda.Panda.create_internal_gic" href="#pandare.panda.Panda.create_internal_gic">create_internal_gic</a></code></li>
<li><code><a title="pandare.panda.Panda.create_one_flash" href="#pandare.panda.Panda.create_one_flash">create_one_flash</a></code></li>
<li><code><a title="pandare.panda.Panda.create_virtio_devices" href="#pandare.panda.Panda.create_virtio_devices">create_virtio_devices</a></code></li>
<li><code><a title="pandare.panda.Panda.current_asid" href="#pandare.panda.Panda.current_asid">current_asid</a></code></li>
<li><code><a title="pandare.panda.Panda.current_pc" href="#pandare.panda.Panda.current_pc">current_pc</a></code></li>
<li><code><a title="pandare.panda.Panda.current_sp" href="#pandare.panda.Panda.current_sp">current_sp</a></code></li>
<li><code><a title="pandare.panda.Panda.delete_callback" href="#pandare.panda.Panda.delete_callback">delete_callback</a></code></li>
<li><code><a title="pandare.panda.Panda.delvm" href="#pandare.panda.Panda.delvm">delvm</a></code></li>
<li><code><a title="pandare.panda.Panda.delvm_sync" href="#pandare.panda.Panda.delvm_sync">delvm_sync</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_callback" href="#pandare.panda.Panda.disable_callback">disable_callback</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_hook" href="#pandare.panda.Panda.disable_hook">disable_hook</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_hook2" href="#pandare.panda.Panda.disable_hook2">disable_hook2</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_llvm" href="#pandare.panda.Panda.disable_llvm">disable_llvm</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_llvm_helpers" href="#pandare.panda.Panda.disable_llvm_helpers">disable_llvm_helpers</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_memcb" href="#pandare.panda.Panda.disable_memcb">disable_memcb</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_plugin" href="#pandare.panda.Panda.disable_plugin">disable_plugin</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_ppp" href="#pandare.panda.Panda.disable_ppp">disable_ppp</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_precise_pc" href="#pandare.panda.Panda.disable_precise_pc">disable_precise_pc</a></code></li>
<li><code><a title="pandare.panda.Panda.disable_tb_chaining" href="#pandare.panda.Panda.disable_tb_chaining">disable_tb_chaining</a></code></li>
<li><code><a title="pandare.panda.Panda.disas2" href="#pandare.panda.Panda.disas2">disas2</a></code></li>
<li><code><a title="pandare.panda.Panda.do_panda_finish" href="#pandare.panda.Panda.do_panda_finish">do_panda_finish</a></code></li>
<li><code><a title="pandare.panda.Panda.drive_get" href="#pandare.panda.Panda.drive_get">drive_get</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_all_callbacks" href="#pandare.panda.Panda.enable_all_callbacks">enable_all_callbacks</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_callback" href="#pandare.panda.Panda.enable_callback">enable_callback</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_hook" href="#pandare.panda.Panda.enable_hook">enable_hook</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_hook2" href="#pandare.panda.Panda.enable_hook2">enable_hook2</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_internal_callbacks" href="#pandare.panda.Panda.enable_internal_callbacks">enable_internal_callbacks</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_llvm" href="#pandare.panda.Panda.enable_llvm">enable_llvm</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_llvm_helpers" href="#pandare.panda.Panda.enable_llvm_helpers">enable_llvm_helpers</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_memcb" href="#pandare.panda.Panda.enable_memcb">enable_memcb</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_plugin" href="#pandare.panda.Panda.enable_plugin">enable_plugin</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_precise_pc" href="#pandare.panda.Panda.enable_precise_pc">enable_precise_pc</a></code></li>
<li><code><a title="pandare.panda.Panda.enable_tb_chaining" href="#pandare.panda.Panda.enable_tb_chaining">enable_tb_chaining</a></code></li>
<li><code><a title="pandare.panda.Panda.end_analysis" href="#pandare.panda.Panda.end_analysis">end_analysis</a></code></li>
<li><code><a title="pandare.panda.Panda.end_record" href="#pandare.panda.Panda.end_record">end_record</a></code></li>
<li><code><a title="pandare.panda.Panda.error_report" href="#pandare.panda.Panda.error_report">error_report</a></code></li>
<li><code><a title="pandare.panda.Panda.exit_cpu_loop" href="#pandare.panda.Panda.exit_cpu_loop">exit_cpu_loop</a></code></li>
<li><code><a title="pandare.panda.Panda.finish_serial_cmd" href="#pandare.panda.Panda.finish_serial_cmd">finish_serial_cmd</a></code></li>
<li><code><a title="pandare.panda.Panda.finish_timer" href="#pandare.panda.Panda.finish_timer">finish_timer</a></code></li>
<li><code><a title="pandare.panda.Panda.flush_tb" href="#pandare.panda.Panda.flush_tb">flush_tb</a></code></li>
<li><code><a title="pandare.panda.Panda.from_unsigned_guest" href="#pandare.panda.Panda.from_unsigned_guest">from_unsigned_guest</a></code></li>
<li><code><a title="pandare.panda.Panda.g_malloc0" href="#pandare.panda.Panda.g_malloc0">g_malloc0</a></code></li>
<li><code><a title="pandare.panda.Panda.garray_len" href="#pandare.panda.Panda.garray_len">garray_len</a></code></li>
<li><code><a title="pandare.panda.Panda.get_cpu" href="#pandare.panda.Panda.get_cpu">get_cpu</a></code></li>
<li><code><a title="pandare.panda.Panda.get_mappings" href="#pandare.panda.Panda.get_mappings">get_mappings</a></code></li>
<li><code><a title="pandare.panda.Panda.get_process_name" href="#pandare.panda.Panda.get_process_name">get_process_name</a></code></li>
<li><code><a title="pandare.panda.Panda.get_processes" href="#pandare.panda.Panda.get_processes">get_processes</a></code></li>
<li><code><a title="pandare.panda.Panda.get_processes_dict" href="#pandare.panda.Panda.get_processes_dict">get_processes_dict</a></code></li>
<li><code><a title="pandare.panda.Panda.get_system_memory" href="#pandare.panda.Panda.get_system_memory">get_system_memory</a></code></li>
<li><code><a title="pandare.panda.Panda.get_volatility_symbols" href="#pandare.panda.Panda.get_volatility_symbols">get_volatility_symbols</a></code></li>
<li><code><a title="pandare.panda.Panda.hook" href="#pandare.panda.Panda.hook">hook</a></code></li>
<li><code><a title="pandare.panda.Panda.hook2" href="#pandare.panda.Panda.hook2">hook2</a></code></li>
<li><code><a title="pandare.panda.Panda.hook2_single_insn" href="#pandare.panda.Panda.hook2_single_insn">hook2_single_insn</a></code></li>
<li><code><a title="pandare.panda.Panda.in_kernel" href="#pandare.panda.Panda.in_kernel">in_kernel</a></code></li>
<li><code><a title="pandare.panda.Panda.interact" href="#pandare.panda.Panda.interact">interact</a></code></li>
<li><code><a title="pandare.panda.Panda.is_callback_enabled" href="#pandare.panda.Panda.is_callback_enabled">is_callback_enabled</a></code></li>
<li><code><a title="pandare.panda.Panda.load_plugin" href="#pandare.panda.Panda.load_plugin">load_plugin</a></code></li>
<li><code><a title="pandare.panda.Panda.lookup_gic" href="#pandare.panda.Panda.lookup_gic">lookup_gic</a></code></li>
<li><code><a title="pandare.panda.Panda.make_panda_file_handler" href="#pandare.panda.Panda.make_panda_file_handler">make_panda_file_handler</a></code></li>
<li><code><a title="pandare.panda.Panda.map_memory" href="#pandare.panda.Panda.map_memory">map_memory</a></code></li>
<li><code><a title="pandare.panda.Panda.memory_region_add_subregion" href="#pandare.panda.Panda.memory_region_add_subregion">memory_region_add_subregion</a></code></li>
<li><code><a title="pandare.panda.Panda.memory_region_allocate_system_memory" href="#pandare.panda.Panda.memory_region_allocate_system_memory">memory_region_allocate_system_memory</a></code></li>
<li><code><a title="pandare.panda.Panda.memory_region_init_ram_from_file" href="#pandare.panda.Panda.memory_region_init_ram_from_file">memory_region_init_ram_from_file</a></code></li>
<li><code><a title="pandare.panda.Panda.memsavep" href="#pandare.panda.Panda.memsavep">memsavep</a></code></li>
<li><code><a title="pandare.panda.Panda.object_class_by_name" href="#pandare.panda.Panda.object_class_by_name">object_class_by_name</a></code></li>
<li><code><a title="pandare.panda.Panda.object_class_get_name" href="#pandare.panda.Panda.object_class_get_name">object_class_get_name</a></code></li>
<li><code><a title="pandare.panda.Panda.object_new" href="#pandare.panda.Panda.object_new">object_new</a></code></li>
<li><code><a title="pandare.panda.Panda.object_property_find" href="#pandare.panda.Panda.object_property_find">object_property_find</a></code></li>
<li><code><a title="pandare.panda.Panda.object_property_get_bool" href="#pandare.panda.Panda.object_property_get_bool">object_property_get_bool</a></code></li>
<li><code><a title="pandare.panda.Panda.object_property_get_int" href="#pandare.panda.Panda.object_property_get_int">object_property_get_int</a></code></li>
<li><code><a title="pandare.panda.Panda.object_property_get_link" href="#pandare.panda.Panda.object_property_get_link">object_property_get_link</a></code></li>
<li><code><a title="pandare.panda.Panda.object_property_set_bool" href="#pandare.panda.Panda.object_property_set_bool">object_property_set_bool</a></code></li>
<li><code><a title="pandare.panda.Panda.object_property_set_int" href="#pandare.panda.Panda.object_property_set_int">object_property_set_int</a></code></li>
<li><code><a title="pandare.panda.Panda.object_property_set_link" href="#pandare.panda.Panda.object_property_set_link">object_property_set_link</a></code></li>
<li><code><a title="pandare.panda.Panda.panda_finish" href="#pandare.panda.Panda.panda_finish">panda_finish</a></code></li>
<li><code><a title="pandare.panda.Panda.physical_memory_read" href="#pandare.panda.Panda.physical_memory_read">physical_memory_read</a></code></li>
<li><code><a title="pandare.panda.Panda.physical_memory_write" href="#pandare.panda.Panda.physical_memory_write">physical_memory_write</a></code></li>
<li><code><a title="pandare.panda.Panda.ppp" href="#pandare.panda.Panda.ppp">ppp</a></code></li>
<li><code><a title="pandare.panda.Panda.pyperiph_read_cb" href="#pandare.panda.Panda.pyperiph_read_cb">pyperiph_read_cb</a></code></li>
<li><code><a title="pandare.panda.Panda.pyperiph_write_cb" href="#pandare.panda.Panda.pyperiph_write_cb">pyperiph_write_cb</a></code></li>
<li><code><a title="pandare.panda.Panda.queue_async" href="#pandare.panda.Panda.queue_async">queue_async</a></code></li>
<li><code><a title="pandare.panda.Panda.queue_blocking" href="#pandare.panda.Panda.queue_blocking">queue_blocking</a></code></li>
<li><code><a title="pandare.panda.Panda.queue_main_loop_wait_fn" href="#pandare.panda.Panda.queue_main_loop_wait_fn">queue_main_loop_wait_fn</a></code></li>
<li><code><a title="pandare.panda.Panda.read_str" href="#pandare.panda.Panda.read_str">read_str</a></code></li>
<li><code><a title="pandare.panda.Panda.record" href="#pandare.panda.Panda.record">record</a></code></li>
<li><code><a title="pandare.panda.Panda.record_cmd" href="#pandare.panda.Panda.record_cmd">record_cmd</a></code></li>
<li><code><a title="pandare.panda.Panda.register_callback" href="#pandare.panda.Panda.register_callback">register_callback</a></code></li>
<li><code><a title="pandare.panda.Panda.register_cb_decorators" href="#pandare.panda.Panda.register_cb_decorators">register_cb_decorators</a></code></li>
<li><code><a title="pandare.panda.Panda.register_pyperipheral" href="#pandare.panda.Panda.register_pyperipheral">register_pyperipheral</a></code></li>
<li><code><a title="pandare.panda.Panda.require" href="#pandare.panda.Panda.require">require</a></code></li>
<li><code><a title="pandare.panda.Panda.reset" href="#pandare.panda.Panda.reset">reset</a></code></li>
<li><code><a title="pandare.panda.Panda.revert_async" href="#pandare.panda.Panda.revert_async">revert_async</a></code></li>
<li><code><a title="pandare.panda.Panda.revert_sync" href="#pandare.panda.Panda.revert_sync">revert_sync</a></code></li>
<li><code><a title="pandare.panda.Panda.rr_get_guest_instr_count" href="#pandare.panda.Panda.rr_get_guest_instr_count">rr_get_guest_instr_count</a></code></li>
<li><code><a title="pandare.panda.Panda.run" href="#pandare.panda.Panda.run">run</a></code></li>
<li><code><a title="pandare.panda.Panda.run_monitor_cmd" href="#pandare.panda.Panda.run_monitor_cmd">run_monitor_cmd</a></code></li>
<li><code><a title="pandare.panda.Panda.run_replay" href="#pandare.panda.Panda.run_replay">run_replay</a></code></li>
<li><code><a title="pandare.panda.Panda.run_serial_cmd" href="#pandare.panda.Panda.run_serial_cmd">run_serial_cmd</a></code></li>
<li><code><a title="pandare.panda.Panda.run_serial_cmd_async" href="#pandare.panda.Panda.run_serial_cmd_async">run_serial_cmd_async</a></code></li>
<li><code><a title="pandare.panda.Panda.run_volatility" href="#pandare.panda.Panda.run_volatility">run_volatility</a></code></li>
<li><code><a title="pandare.panda.Panda.set_breakpoint" href="#pandare.panda.Panda.set_breakpoint">set_breakpoint</a></code></li>
<li><code><a title="pandare.panda.Panda.set_os_name" href="#pandare.panda.Panda.set_os_name">set_os_name</a></code></li>
<li><code><a title="pandare.panda.Panda.set_pandalog" href="#pandare.panda.Panda.set_pandalog">set_pandalog</a></code></li>
<li><code><a title="pandare.panda.Panda.setup_internal_signal_handler" href="#pandare.panda.Panda.setup_internal_signal_handler">setup_internal_signal_handler</a></code></li>
<li><code><a title="pandare.panda.Panda.snap" href="#pandare.panda.Panda.snap">snap</a></code></li>
<li><code><a title="pandare.panda.Panda.stop_run" href="#pandare.panda.Panda.stop_run">stop_run</a></code></li>
<li><code><a title="pandare.panda.Panda.sysbus_create_varargs" href="#pandare.panda.Panda.sysbus_create_varargs">sysbus_create_varargs</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_check_laddr" href="#pandare.panda.Panda.taint_check_laddr">taint_check_laddr</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_check_ram" href="#pandare.panda.Panda.taint_check_ram">taint_check_ram</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_check_reg" href="#pandare.panda.Panda.taint_check_reg">taint_check_reg</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_enable" href="#pandare.panda.Panda.taint_enable">taint_enable</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_get_laddr" href="#pandare.panda.Panda.taint_get_laddr">taint_get_laddr</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_get_ram" href="#pandare.panda.Panda.taint_get_ram">taint_get_ram</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_get_reg" href="#pandare.panda.Panda.taint_get_reg">taint_get_reg</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_label_ram" href="#pandare.panda.Panda.taint_label_ram">taint_label_ram</a></code></li>
<li><code><a title="pandare.panda.Panda.taint_label_reg" href="#pandare.panda.Panda.taint_label_reg">taint_label_reg</a></code></li>
<li><code><a title="pandare.panda.Panda.to_unsigned_guest" href="#pandare.panda.Panda.to_unsigned_guest">to_unsigned_guest</a></code></li>
<li><code><a title="pandare.panda.Panda.type_serial_cmd" href="#pandare.panda.Panda.type_serial_cmd">type_serial_cmd</a></code></li>
<li><code><a title="pandare.panda.Panda.unload_plugin" href="#pandare.panda.Panda.unload_plugin">unload_plugin</a></code></li>
<li><code><a title="pandare.panda.Panda.unload_plugins" href="#pandare.panda.Panda.unload_plugins">unload_plugins</a></code></li>
<li><code><a title="pandare.panda.Panda.unregister_pyperipheral" href="#pandare.panda.Panda.unregister_pyperipheral">unregister_pyperipheral</a></code></li>
<li><code><a title="pandare.panda.Panda.update_hook" href="#pandare.panda.Panda.update_hook">update_hook</a></code></li>
<li><code><a title="pandare.panda.Panda.virt_to_phys" href="#pandare.panda.Panda.virt_to_phys">virt_to_phys</a></code></li>
<li><code><a title="pandare.panda.Panda.virtual_memory_read" href="#pandare.panda.Panda.virtual_memory_read">virtual_memory_read</a></code></li>
<li><code><a title="pandare.panda.Panda.virtual_memory_write" href="#pandare.panda.Panda.virtual_memory_write">virtual_memory_write</a></code></li>
<li><code><a title="pandare.panda.Panda.vm_stop" href="#pandare.panda.Panda.vm_stop">vm_stop</a></code></li>
<li><code><a title="pandare.panda.Panda.was_aborted" href="#pandare.panda.Panda.was_aborted">was_aborted</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>