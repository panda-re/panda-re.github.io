<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>panda.volatility_cli_classes API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>panda.volatility_cli_classes</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from io import StringIO
from volatility.framework.renderers import format_hints
import datetime
from volatility.cli.text_renderer import CLIRenderer, optional, hex_bytes_as_text, display_disassembly
from urllib.request import BaseHandler, pathname2url
import volatility.plugins
import volatility.symbols
from volatility import framework
from volatility.cli import MuteProgress, PrintedProgress
from volatility.cli.volargparse import HelpfulSubparserAction
from volatility.framework import automagic, constants, contexts, exceptions, interfaces, plugins, renderers, configuration
from volatility.framework.automagic import linux
from volatility.framework.layers.linear import LinearlyMappedLayer
from volatility.framework.objects import utility
from .ffi_importer import ffi
import argparse
import shlex
import inspect
import json
import logging
import os
import sys
from typing import Any, Dict, Type, Union
from urllib import parse, request

import volatility.plugins
import volatility.symbols
from volatility import framework
from volatility.cli import text_renderer
from volatility.framework import renderers
from volatility.framework import automagic, constants, contexts, exceptions, interfaces, plugins, configuration
from volatility.framework.configuration import requirements
from volatility.framework.layers.linear import LinearlyMappedLayer

from typing import Callable, Iterable, List, Any

from volatility.framework import renderers, interfaces, contexts
from volatility.framework.automagic import linux
from volatility.framework.configuration import requirements
from volatility.framework.objects import utility

from volatility.framework.automagic.stacker import LayerStacker


import logging
import sys
import traceback
from typing import List, Optional, Tuple

from volatility import framework
from volatility.framework import interfaces, constants, import_files
from volatility.framework.automagic import construct_layers
from volatility.framework.configuration import requirements
from volatility.framework.layers import physical
import urllib
import pdb

&#39;&#39;&#39;
We are faking running this from the command line and running this programmatically.

Why? Because it&#39;s easier to do it this way than ask the people at volatility to modify
their project.
&#39;&#39;&#39;


class CommandLineMoreEfficient(interfaces.plugins.FileConsumerInterface):
    &#34;&#34;&#34;Constructs a command-line interface object for users to run plugins.&#34;&#34;&#34;

    def __init__(self):
        self.output_dir = None

    def run(self):
        # we aren&#39;t really doing logging, but you can change these numbers to get more details
        vollog = logging.getLogger(__name__)
        vollog = logging.getLogger()
       # vollog.setLevel(1000)
        console = logging.StreamHandler()
        #console.setLevel(logging.WARNING)
        formatter = logging.Formatter(
            &#39;%(levelname)-8s %(name)-12s: %(message)s&#39;)
        console.setFormatter(formatter)
        vollog.addHandler(console)
        volatility.framework.require_interface_version(1, 0, 0)
        # also change here for log level
        #console.setLevel(1000)
        constants.PARALLELISM = constants.Parallelism.Off
        ctx = contexts.Context()  # Construct a blank context
        failures = framework.import_files(volatility.plugins,
                                          True)  # Will not log as console&#39;s default level is WARNING
        automagics = automagic.available(ctx)
        plugin_list = framework.list_plugins()
        seen_automagics = set()
        configurables_list = {}
        for amagic in automagics:
            if amagic in seen_automagics:
                continue
            seen_automagics.add(amagic)
            if isinstance(amagic, interfaces.configuration.ConfigurableInterface):
                configurables_list[amagic.__class__.__name__] = amagic

        plugin_name = &#34;linux.pstree.PsTree&#34;  # we&#39;re just &#34;kinda&#34; running a plugin
        plugin = plugin_list[plugin_name]
        base_config_path = &#34;plugins&#34;
        plugin_config_path = interfaces.configuration.path_join(
            base_config_path, plugin.__name__)

        # It should be up to the UI to determine which automagics to run, so this is before BACK TO THE FRAMEWORK
        automagics = automagic.choose_automagic(automagics, plugin)
        # this is our fake file that represents QEMU memory
        single_location = &#34;file:&#34; + pathname2url(&#34;/panda.panda&#34;)
        ctx.config[&#39;automagic.LayerStacker.single_location&#39;] = single_location
        constructed = plugins.construct_plugin(
                ctx, automagics, plugin, base_config_path, MuteProgress(), self)
        return constructed


class CommandLineRunFullCommand(interfaces.plugins.FileConsumerInterface):
    &#34;&#34;&#34;Constructs a command-line interface object for users to run plugins.&#34;&#34;&#34;

    def __init__(self):
        self.output_dir = None

    def run(self, argstring):
        # Make sure we log everything

        vollog = logging.getLogger()
        #vollog.setLevel(1)
        # Trim the console down by default
        console = logging.StreamHandler()
        #console.setLevel(logging.FATAL)
        formatter = logging.Formatter(
            &#39;%(levelname)-8s %(name)-12s: %(message)s&#39;)
        console.setFormatter(formatter)
        vollog.addHandler(console)
        # Make sure we log everything
        vollog = logging.getLogger()
        #vollog.setLevel(1)
        # Trim the console down by default
        console = logging.StreamHandler()
        #console.setLevel(logging.WARNING)
        formatter = logging.Formatter(
            &#39;%(levelname)-8s %(name)-12s: %(message)s&#39;)
        console.setFormatter(formatter)
        vollog.addHandler(console)
        arg_arr = shlex.split(argstring)
        &#34;&#34;&#34;Executes the command line module, taking the system arguments,
            determining the plugin to run and then running it.&#34;&#34;&#34;
        sys.stdout.write(&#34;Volatility 3 Framework {}\n&#34;.format(
            constants.PACKAGE_VERSION))

        volatility.framework.require_interface_version(1, 0, 0)

        renderers = dict([(x.name.lower(), x)
                          for x in framework.class_subclasses(text_renderer.CLIRenderer)])

        parser = argparse.ArgumentParser(
            prog=&#39;volatility&#39;, description=&#34;An open-source memory forensics framework&#34;)
        parser.add_argument(&#34;-c&#34;,
                            &#34;--config&#34;,
                            help=&#34;Load the configuration from a json file&#34;,
                            default=None,
                            type=str)
        parser.add_argument(&#34;--parallelism&#34;,
                            help=&#34;Enables parallelism (defaults to processes if no argument given)&#34;,
                            nargs=&#39;?&#39;,
                            choices=[&#39;processes&#39;, &#39;threads&#39;, &#39;off&#39;],
                            const=&#39;processes&#39;,
                            default=None,
                            type=str)
        parser.add_argument(&#34;-e&#34;,
                            &#34;--extend&#34;,
                            help=&#34;Extend the configuration with a new (or changed) setting&#34;,
                            default=None,
                            action=&#39;append&#39;)
        parser.add_argument(&#34;-p&#34;,
                            &#34;--plugin-dirs&#34;,
                            help=&#34;Semi-colon separated list of paths to find plugins&#34;,
                            default=&#34;&#34;,
                            type=str)
        parser.add_argument(&#34;-s&#34;,
                            &#34;--symbol-dirs&#34;,
                            help=&#34;Semi-colon separated list of paths to find symbols&#34;,
                            default=&#34;&#34;,
                            type=str)
        parser.add_argument(
            &#34;-v&#34;, &#34;--verbosity&#34;, help=&#34;Increase output verbosity&#34;, default=0, action=&#34;count&#34;)
        parser.add_argument(&#34;-l&#34;,
                            &#34;--log&#34;,
                            help=&#34;Log output to a file as well as the console&#34;,
                            default=None,
                            type=str)
        parser.add_argument(&#34;-o&#34;,
                            &#34;--output-dir&#34;,
                            help=&#34;Directory in which to output any generated files&#34;,
                            default=os.path.abspath(os.path.join(
                                os.path.dirname(__file__), &#39;..&#39;, &#39;..&#39;)),
                            type=str)
        parser.add_argument(
            &#34;-q&#34;, &#34;--quiet&#34;, help=&#34;Remove progress feedback&#34;, default=False, action=&#39;store_true&#39;)
        parser.add_argument(&#34;-r&#34;,
                            &#34;--renderer&#34;,
                            metavar=&#39;RENDERER&#39;,
                            help=&#34;Determines how to render the output ({})&#34;.format(
                                &#34;, &#34;.join(list(renderers))),
                            default=&#34;quick&#34;,
                            choices=list(renderers))
        parser.add_argument(&#34;-f&#34;,
                            &#34;--file&#34;,
                            metavar=&#39;FILE&#39;,
                            default=None,
                            type=str,
                            help=&#34;Shorthand for --single-location=file:// if single-location is not defined&#34;)
        parser.add_argument(&#34;--write-config&#34;,
                            help=&#34;Write configuration JSON file out to config.json&#34;,
                            default=False,
                            action=&#39;store_true&#39;)

        # We have to filter out help, otherwise parse_known_args will trigger the help message before having
        # processed the plugin choice or had the plugin subparser added.
        known_args = [arg for arg in arg_arr if arg !=
                      &#39;--help&#39; and arg != &#39;-h&#39;]
        partial_args, _ = parser.parse_known_args(known_args)
        if partial_args.plugin_dirs:
            volatility.plugins.__path__ = [os.path.abspath(p)
                                           for p in partial_args.plugin_dirs.split(&#34;;&#34;)] + constants.PLUGINS_PATH

        if partial_args.symbol_dirs:
            volatility.symbols.__path__ = [os.path.abspath(p)
                                           for p in partial_args.symbol_dirs.split(&#34;;&#34;)] + constants.SYMBOL_BASEPATHS

        if partial_args.log:
            file_logger = logging.FileHandler(partial_args.log)
            #file_logger.setLevel(1)
            file_formatter = logging.Formatter(datefmt=&#39;%y-%m-%d %H:%M:%S&#39;,
                                               fmt=&#39;%(asctime)s %(name)-12s %(levelname)-8s %(message)s&#39;)
            file_logger.setFormatter(file_formatter)
            vollog.addHandler(file_logger)
            vollog.info(&#34;Logging started&#34;)
        if partial_args.verbosity &lt; 3:
            console.setLevel(30 - (partial_args.verbosity * 10))
        else:
            console.setLevel(10 - (partial_args.verbosity - 2))
        #console.setLevel(0)

        vollog.info(&#34;Volatility plugins path: {}&#34;.format(
            volatility.plugins.__path__))
        vollog.info(&#34;Volatility symbols path: {}&#34;.format(
            volatility.symbols.__path__))

        # Set the PARALLELISM
        if partial_args.parallelism == &#39;processes&#39;:
            constants.PARALLELISM = constants.Parallelism.Multiprocessing
        elif partial_args.parallelism == &#39;threading&#39;:
            constants.PARALLELISM = constants.Parallelism.Threading
        else:
            constants.PARALLELISM = constants.Parallelism.Off

        # Do the initialization
        ctx = contexts.Context()  # Construct a blank context
        failures = framework.import_files(volatility.plugins,
                                          True)  # Will not log as console&#39;s default level is WARNING
        if failures:
            parser.epilog = &#34;The following plugins could not be loaded (use -vv to see why): &#34; + \
                &#34;, &#34;.join(sorted(failures))
            vollog.info(parser.epilog)
        automagics = automagic.available(ctx)

        plugin_list = framework.list_plugins()

        seen_automagics = set()
        configurables_list = {}
        for amagic in automagics:
            if amagic in seen_automagics:
                continue
            seen_automagics.add(amagic)
            if isinstance(amagic, interfaces.configuration.ConfigurableInterface):
                self.populate_requirements_argparse(parser, amagic.__class__)
                configurables_list[amagic.__class__.__name__] = amagic

        subparser = parser.add_subparsers(
            title=&#34;Plugins&#34;, dest=&#34;plugin&#34;, action=HelpfulSubparserAction)
        for plugin in sorted(plugin_list):
            plugin_parser = subparser.add_parser(
                plugin, help=plugin_list[plugin].__doc__)
            self.populate_requirements_argparse(
                plugin_parser, plugin_list[plugin])
            configurables_list[plugin] = plugin_list[plugin]

        ###
        # PASS TO UI
        ###
        # Hand the plugin requirements over to the CLI (us) and let it construct the config tree

        # Run the argparser
        args = parser.parse_args(arg_arr)
        print(partial_args.verbosity)
        print(args.plugin, type(args.plugin))
        if args.plugin is None:
            parser.error(&#34;Please select a plugin to run&#34;)

        vollog.log(constants.LOGLEVEL_VVV,
                   &#34;Cache directory used: {}&#34;.format(constants.CACHE_PATH))

        plugin = plugin_list[args.plugin]
        base_config_path = &#34;plugins&#34;
        plugin_config_path = interfaces.configuration.path_join(
            base_config_path, plugin.__name__)

        # Special case the -f argument because people use is so frequently
        # It has to go here so it can be overridden by single-location if it&#39;s defined
        # NOTE: This will *BREAK* if LayerStacker, or the automagic configuration system, changes at all
        ###
        if args.file:
            file_name = os.path.abspath(args.file)
            if not os.path.exists(file_name) and &#34;panda.panda&#34; not in file_name:
                print(&#34;File does not exist: {}&#34;.format(file_name))
            else:
                single_location = &#34;file:&#34; + request.pathname2url(file_name)
                ctx.config[&#39;automagic.LayerStacker.single_location&#39;] = single_location

        # UI fills in the config, here we load it from the config file and do it before we process the CL parameters
        if args.config:
            with open(args.config, &#34;r&#34;) as f:
                json_val = json.load(f)
                ctx.config.splice(
                    plugin_config_path, interfaces.configuration.HierarchicalDict(json_val))

        self.populate_config(ctx, configurables_list, args, plugin_config_path)

        if args.extend:
            for extension in args.extend:
                if &#39;=&#39; not in extension:
                    raise ValueError(
                        &#34;Invalid extension (extensions must be of the format \&#34;conf.path.value=&#39;value&#39;\&#34;)&#34;)
                address, value = extension[:extension.find(&#39;=&#39;)], json.loads(
                    extension[extension.find(&#39;=&#39;) + 1:])
                ctx.config[address] = value

        # It should be up to the UI to determine which automagics to run, so this is before BACK TO THE FRAMEWORK
        automagics = automagic.choose_automagic(automagics, plugin)
        self.output_dir = args.output_dir

        ###
        # BACK TO THE FRAMEWORK
        ###
        try:
            progress_callback = PrintedProgress()
            if args.quiet:
                progress_callback = MuteProgress()

            constructed = plugins.construct_plugin(
                ctx, automagics, plugin, base_config_path, progress_callback, self)
        #       return (ctx, automagics, plugin, base_config_path, progress_callback, self)

            if args.write_config:
                vollog.debug(&#34;Writing out configuration data to config.json&#34;)
                with open(&#34;config.json&#34;, &#34;w&#34;) as f:
                    json.dump(dict(constructed.build_configuration()),
                              f, sort_keys=True, indent=2)
            # return StringTextRenderer().render(constructed.run())
            return constructed
        except exceptions.UnsatisfiedException as excp:
            self.process_exceptions(excp)
            parser.exit(1, &#34;Unable to validate the plugin requirements: {}\n&#34;.format(
                [x for x in excp.unsatisfied]))

    def process_exceptions(self, excp):
        &#34;&#34;&#34;Provide useful feedback if an exception occurs.&#34;&#34;&#34;
        # Add a blank newline
        print(&#34;&#34;)
        translation_failed = False
        symbols_failed = False
        for config_path in excp.unsatisfied:
            translation_failed = translation_failed or isinstance(
                excp.unsatisfied[config_path], configuration.requirements.TranslationLayerRequirement)
            symbols_failed = symbols_failed or isinstance(excp.unsatisfied[config_path],
                                                          configuration.requirements.SymbolTableRequirement)

            print(&#34;Unsatisfied requirement {}: {}&#34;.format(
                config_path, excp.unsatisfied[config_path].description))

        if symbols_failed:
            print(&#34;\nA symbol table requirement was not fulfilled.      Please verify that:\n&#34;
                  &#34;\tYou have the correct symbol file for the requirement\n&#34;
                  &#34;\tThe symbol file is under the correct directory or zip file\n&#34;
                  &#34;\tThe symbol file is named appropriately or contains the correct banner\n&#34;)
        if translation_failed:
            print(&#34;\nA translation layer requirement was not fulfilled.  Please verify that:\n&#34;
                  &#34;\tA file was provided to create this layer (by -f, --single-location or by config)\n&#34;
                  &#34;\tThe file exists and is readable\n&#34;
                  &#34;\tThe necessary symbols are present and identified by volatility&#34;)

    def populate_config(self, context: interfaces.context.ContextInterface,
                        configurables_list: Dict[str, interfaces.configuration.ConfigurableInterface],
                        args: argparse.Namespace, plugin_config_path: str) -&gt; None:
        &#34;&#34;&#34;Populate the context config based on the returned args.

        We have already determined these elements must be descended from ConfigurableInterface

        Args:
                context: The volatility context to operate on
                configurables_list: A dictionary of configurable items that can be configured on the plugin
                args: An object containing the arguments necessary
                plugin_config_path: The path within the context&#39;s config containing the plugin&#39;s configuration
        &#34;&#34;&#34;
        vargs = vars(args)
        for configurable in configurables_list:
            for requirement in configurables_list[configurable].get_requirements():
                value = vargs.get(requirement.name, None)
                if value is not None:
                    if isinstance(requirement, requirements.URIRequirement):
                        if isinstance(value, str):
                            if not parse.urlparse(value).scheme:
                                if not os.path.exists(value):
                                    raise TypeError(
                                        &#34;Non-existant file {} passed to URIRequirement&#34;.format(value))
                                value = &#34;file://&#34; + \
                                    request.pathname2url(
                                        os.path.abspath(value))
                    if isinstance(requirement, requirements.ListRequirement):
                        if not isinstance(value, list):
                            raise TypeError(
                                &#34;Configuration for ListRequirement was not a list&#34;)
                        value = [requirement.element_type(x) for x in value]
                    if not inspect.isclass(configurables_list[configurable]):
                        config_path = configurables_list[configurable].config_path
                    else:
                        # We must be the plugin, so name it appropriately:
                        config_path = plugin_config_path
                    extended_path = interfaces.configuration.path_join(
                        config_path, requirement.name)
                    context.config[extended_path] = value
                    pdb.set_trace()

    def consume_file(self, filedata: interfaces.plugins.FileInterface):
        &#34;&#34;&#34;Consumes a file as produced by a plugin.&#34;&#34;&#34;
        if self.output_dir is None:
            raise ValueError(
                &#34;Output directory has not been correctly specified&#34;)
        os.makedirs(self.output_dir, exist_ok=True)

        pref_name_array = filedata.preferred_filename.split(&#39;.&#39;)
        filename, extension = os.path.join(self.output_dir, &#39;.&#39;.join(
            pref_name_array[:-1])), pref_name_array[-1]
        output_filename = &#34;{}.{}&#34;.format(filename, extension)

        if not os.path.exists(output_filename):
            with open(output_filename, &#34;wb&#34;) as current_file:
                current_file.write(filedata.data.getvalue())
                vollog.log(
                    logging.INFO, &#34;Saved stored plugin file: {}&#34;.format(output_filename))
        else:
            vollog.warning(
                &#34;Refusing to overwrite an existing file: {}&#34;.format(output_filename))

    def populate_requirements_argparse(self, parser: Union[argparse.ArgumentParser, argparse._ArgumentGroup],
                                       configurable: Type[interfaces.configuration.ConfigurableInterface]):
        &#34;&#34;&#34;Adds the plugin&#39;s simple requirements to the provided parser.

        Args:
                parser: The parser to add the plugin&#39;s (simple) requirements to
                configurable: The plugin object to pull the requirements from
        &#34;&#34;&#34;
        if not issubclass(configurable, interfaces.configuration.ConfigurableInterface):
            raise TypeError(
                &#34;Expected ConfigurableInterface type, not: {}&#34;.format(type(configurable)))

        # Construct an argparse group

        for requirement in configurable.get_requirements():
            additional = {}  # type: Dict[str, Any]
            if not isinstance(requirement, interfaces.configuration.RequirementInterface):
                raise TypeError(&#34;Plugin contains requirements that are not RequirementInterfaces: {}&#34;.format(
                    configurable.__name__))
            if isinstance(requirement, interfaces.configuration.SimpleTypeRequirement):
                additional[&#34;type&#34;] = requirement.instance_type
                if isinstance(requirement, requirements.IntRequirement):
                    additional[&#34;type&#34;] = lambda x: int(x, 0)
                if isinstance(requirement, requirements.BooleanRequirement):
                    additional[&#34;action&#34;] = &#34;store_true&#34;
                    if &#34;type&#34; in additional:
                        del additional[&#34;type&#34;]
            elif isinstance(requirement, volatility.framework.configuration.requirements.ListRequirement):
                # This is a trick to generate a list of values
                additional[&#34;type&#34;] = lambda x: x.split(&#39;,&#39;)
            elif isinstance(requirement, volatility.framework.configuration.requirements.ChoiceRequirement):
                additional[&#34;type&#34;] = str
                additional[&#34;choices&#34;] = requirement.choices
            else:
                continue
            parser.add_argument(&#34;--&#34; + requirement.name.replace(&#39;_&#39;, &#39;-&#39;),
                                help=requirement.description,
                                default=requirement.default,
                                dest=requirement.name,
                                required=not requirement.optional,
                                **additional)


class StringTextRenderer(CLIRenderer):
    _type_renderers = {
        format_hints.Bin: optional(lambda x: &#34;0b{:b}&#34;.format(x)),
        format_hints.Hex: optional(lambda x: &#34;0x{:x}&#34;.format(x)),
        format_hints.HexBytes: optional(hex_bytes_as_text),
        interfaces.renderers.Disassembly: optional(display_disassembly),
        bytes: optional(lambda x: &#34; &#34;.join([&#34;{0:2x}&#34;.format(b) for b in x])),
        datetime.datetime: optional(lambda x: x.strftime(&#34;%Y-%m-%d %H:%M:%S.%f %Z&#34;)),
        &#39;default&#39;: optional(lambda x: &#34;{}&#34;.format(x))
    }

    name = &#34;string&#34;

    def get_render_options(self):
        pass

    def render(self, grid: interfaces.renderers.TreeGrid):
        &#34;&#34;&#34;Renders each column immediately to stdout.

        This does not format each line&#39;s width appropriately, it merely tab separates each field

        Args:
            grid: The TreeGrid object to render
        &#34;&#34;&#34;
        # TODO: Docstrings
        # TODO: Improve text output
        outfd = StringIO()  # sys.stdout
        out = []

        line = []

        column_names = []
        for column in grid.columns:
            # Ignore the type because namedtuples don&#39;t realize they have accessible attributes
            # line.append(&#34;{}&#34;.format(column.name))
            column_names.append(&#34;{}&#34;.format(column.name))
        # outfd.write(&#34;\n{}\n&#34;.format(&#34;\t&#34;.join(line)))
        #outfd += &#34;\n{}\n&#34;.format(&#34;\t&#34;.join(line))

        def visitor(node, accumulator):
            accumulator.write(&#34;\n&#34;)
            # Nodes always have a path value, giving them a path_depth of at least 1, we use max just in case
            #accumulator.write(&#34;*&#34; * max(0, node.path_depth - 1) + (&#34;&#34; if (node.path_depth &lt;= 1) else &#34; &#34;))
            #line = []
            line_output = {}
            for column_index in range(len(grid.columns)):
                column = grid.columns[column_index]
                renderer = self._type_renderers.get(
                    column.type, self._type_renderers[&#39;default&#39;])
                # line.append(renderer(node.values[column_index]))
                column_name = column_names[column_index]
                line_output[column_name] = node.values[column_index]

            out.append(line_output)

            # accumulator.write(&#34;{}&#34;.format(&#34;\t&#34;.join(line)))
            # accumulator.flush()
            return accumulator

        if not grid.populated:
            grid.populate(visitor, outfd)
        else:
            grid.visit(node=None, function=visitor, initial_accumulator=outfd)

        # outfd.write(&#34;\n&#34;)
        return out</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="panda.volatility_cli_classes.CommandLineMoreEfficient"><code class="flex name class">
<span>class <span class="ident">CommandLineMoreEfficient</span></span>
</code></dt>
<dd>
<div class="desc"><p>Constructs a command-line interface object for users to run plugins.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommandLineMoreEfficient(interfaces.plugins.FileConsumerInterface):
    &#34;&#34;&#34;Constructs a command-line interface object for users to run plugins.&#34;&#34;&#34;

    def __init__(self):
        self.output_dir = None

    def run(self):
        # we aren&#39;t really doing logging, but you can change these numbers to get more details
        vollog = logging.getLogger(__name__)
        vollog = logging.getLogger()
       # vollog.setLevel(1000)
        console = logging.StreamHandler()
        #console.setLevel(logging.WARNING)
        formatter = logging.Formatter(
            &#39;%(levelname)-8s %(name)-12s: %(message)s&#39;)
        console.setFormatter(formatter)
        vollog.addHandler(console)
        volatility.framework.require_interface_version(1, 0, 0)
        # also change here for log level
        #console.setLevel(1000)
        constants.PARALLELISM = constants.Parallelism.Off
        ctx = contexts.Context()  # Construct a blank context
        failures = framework.import_files(volatility.plugins,
                                          True)  # Will not log as console&#39;s default level is WARNING
        automagics = automagic.available(ctx)
        plugin_list = framework.list_plugins()
        seen_automagics = set()
        configurables_list = {}
        for amagic in automagics:
            if amagic in seen_automagics:
                continue
            seen_automagics.add(amagic)
            if isinstance(amagic, interfaces.configuration.ConfigurableInterface):
                configurables_list[amagic.__class__.__name__] = amagic

        plugin_name = &#34;linux.pstree.PsTree&#34;  # we&#39;re just &#34;kinda&#34; running a plugin
        plugin = plugin_list[plugin_name]
        base_config_path = &#34;plugins&#34;
        plugin_config_path = interfaces.configuration.path_join(
            base_config_path, plugin.__name__)

        # It should be up to the UI to determine which automagics to run, so this is before BACK TO THE FRAMEWORK
        automagics = automagic.choose_automagic(automagics, plugin)
        # this is our fake file that represents QEMU memory
        single_location = &#34;file:&#34; + pathname2url(&#34;/panda.panda&#34;)
        ctx.config[&#39;automagic.LayerStacker.single_location&#39;] = single_location
        constructed = plugins.construct_plugin(
                ctx, automagics, plugin, base_config_path, MuteProgress(), self)
        return constructed</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>volatility.framework.interfaces.plugins.FileConsumerInterface</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="panda.volatility_cli_classes.CommandLineMoreEfficient.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    # we aren&#39;t really doing logging, but you can change these numbers to get more details
    vollog = logging.getLogger(__name__)
    vollog = logging.getLogger()
   # vollog.setLevel(1000)
    console = logging.StreamHandler()
    #console.setLevel(logging.WARNING)
    formatter = logging.Formatter(
        &#39;%(levelname)-8s %(name)-12s: %(message)s&#39;)
    console.setFormatter(formatter)
    vollog.addHandler(console)
    volatility.framework.require_interface_version(1, 0, 0)
    # also change here for log level
    #console.setLevel(1000)
    constants.PARALLELISM = constants.Parallelism.Off
    ctx = contexts.Context()  # Construct a blank context
    failures = framework.import_files(volatility.plugins,
                                      True)  # Will not log as console&#39;s default level is WARNING
    automagics = automagic.available(ctx)
    plugin_list = framework.list_plugins()
    seen_automagics = set()
    configurables_list = {}
    for amagic in automagics:
        if amagic in seen_automagics:
            continue
        seen_automagics.add(amagic)
        if isinstance(amagic, interfaces.configuration.ConfigurableInterface):
            configurables_list[amagic.__class__.__name__] = amagic

    plugin_name = &#34;linux.pstree.PsTree&#34;  # we&#39;re just &#34;kinda&#34; running a plugin
    plugin = plugin_list[plugin_name]
    base_config_path = &#34;plugins&#34;
    plugin_config_path = interfaces.configuration.path_join(
        base_config_path, plugin.__name__)

    # It should be up to the UI to determine which automagics to run, so this is before BACK TO THE FRAMEWORK
    automagics = automagic.choose_automagic(automagics, plugin)
    # this is our fake file that represents QEMU memory
    single_location = &#34;file:&#34; + pathname2url(&#34;/panda.panda&#34;)
    ctx.config[&#39;automagic.LayerStacker.single_location&#39;] = single_location
    constructed = plugins.construct_plugin(
            ctx, automagics, plugin, base_config_path, MuteProgress(), self)
    return constructed</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="panda.volatility_cli_classes.CommandLineRunFullCommand"><code class="flex name class">
<span>class <span class="ident">CommandLineRunFullCommand</span></span>
</code></dt>
<dd>
<div class="desc"><p>Constructs a command-line interface object for users to run plugins.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommandLineRunFullCommand(interfaces.plugins.FileConsumerInterface):
    &#34;&#34;&#34;Constructs a command-line interface object for users to run plugins.&#34;&#34;&#34;

    def __init__(self):
        self.output_dir = None

    def run(self, argstring):
        # Make sure we log everything

        vollog = logging.getLogger()
        #vollog.setLevel(1)
        # Trim the console down by default
        console = logging.StreamHandler()
        #console.setLevel(logging.FATAL)
        formatter = logging.Formatter(
            &#39;%(levelname)-8s %(name)-12s: %(message)s&#39;)
        console.setFormatter(formatter)
        vollog.addHandler(console)
        # Make sure we log everything
        vollog = logging.getLogger()
        #vollog.setLevel(1)
        # Trim the console down by default
        console = logging.StreamHandler()
        #console.setLevel(logging.WARNING)
        formatter = logging.Formatter(
            &#39;%(levelname)-8s %(name)-12s: %(message)s&#39;)
        console.setFormatter(formatter)
        vollog.addHandler(console)
        arg_arr = shlex.split(argstring)
        &#34;&#34;&#34;Executes the command line module, taking the system arguments,
            determining the plugin to run and then running it.&#34;&#34;&#34;
        sys.stdout.write(&#34;Volatility 3 Framework {}\n&#34;.format(
            constants.PACKAGE_VERSION))

        volatility.framework.require_interface_version(1, 0, 0)

        renderers = dict([(x.name.lower(), x)
                          for x in framework.class_subclasses(text_renderer.CLIRenderer)])

        parser = argparse.ArgumentParser(
            prog=&#39;volatility&#39;, description=&#34;An open-source memory forensics framework&#34;)
        parser.add_argument(&#34;-c&#34;,
                            &#34;--config&#34;,
                            help=&#34;Load the configuration from a json file&#34;,
                            default=None,
                            type=str)
        parser.add_argument(&#34;--parallelism&#34;,
                            help=&#34;Enables parallelism (defaults to processes if no argument given)&#34;,
                            nargs=&#39;?&#39;,
                            choices=[&#39;processes&#39;, &#39;threads&#39;, &#39;off&#39;],
                            const=&#39;processes&#39;,
                            default=None,
                            type=str)
        parser.add_argument(&#34;-e&#34;,
                            &#34;--extend&#34;,
                            help=&#34;Extend the configuration with a new (or changed) setting&#34;,
                            default=None,
                            action=&#39;append&#39;)
        parser.add_argument(&#34;-p&#34;,
                            &#34;--plugin-dirs&#34;,
                            help=&#34;Semi-colon separated list of paths to find plugins&#34;,
                            default=&#34;&#34;,
                            type=str)
        parser.add_argument(&#34;-s&#34;,
                            &#34;--symbol-dirs&#34;,
                            help=&#34;Semi-colon separated list of paths to find symbols&#34;,
                            default=&#34;&#34;,
                            type=str)
        parser.add_argument(
            &#34;-v&#34;, &#34;--verbosity&#34;, help=&#34;Increase output verbosity&#34;, default=0, action=&#34;count&#34;)
        parser.add_argument(&#34;-l&#34;,
                            &#34;--log&#34;,
                            help=&#34;Log output to a file as well as the console&#34;,
                            default=None,
                            type=str)
        parser.add_argument(&#34;-o&#34;,
                            &#34;--output-dir&#34;,
                            help=&#34;Directory in which to output any generated files&#34;,
                            default=os.path.abspath(os.path.join(
                                os.path.dirname(__file__), &#39;..&#39;, &#39;..&#39;)),
                            type=str)
        parser.add_argument(
            &#34;-q&#34;, &#34;--quiet&#34;, help=&#34;Remove progress feedback&#34;, default=False, action=&#39;store_true&#39;)
        parser.add_argument(&#34;-r&#34;,
                            &#34;--renderer&#34;,
                            metavar=&#39;RENDERER&#39;,
                            help=&#34;Determines how to render the output ({})&#34;.format(
                                &#34;, &#34;.join(list(renderers))),
                            default=&#34;quick&#34;,
                            choices=list(renderers))
        parser.add_argument(&#34;-f&#34;,
                            &#34;--file&#34;,
                            metavar=&#39;FILE&#39;,
                            default=None,
                            type=str,
                            help=&#34;Shorthand for --single-location=file:// if single-location is not defined&#34;)
        parser.add_argument(&#34;--write-config&#34;,
                            help=&#34;Write configuration JSON file out to config.json&#34;,
                            default=False,
                            action=&#39;store_true&#39;)

        # We have to filter out help, otherwise parse_known_args will trigger the help message before having
        # processed the plugin choice or had the plugin subparser added.
        known_args = [arg for arg in arg_arr if arg !=
                      &#39;--help&#39; and arg != &#39;-h&#39;]
        partial_args, _ = parser.parse_known_args(known_args)
        if partial_args.plugin_dirs:
            volatility.plugins.__path__ = [os.path.abspath(p)
                                           for p in partial_args.plugin_dirs.split(&#34;;&#34;)] + constants.PLUGINS_PATH

        if partial_args.symbol_dirs:
            volatility.symbols.__path__ = [os.path.abspath(p)
                                           for p in partial_args.symbol_dirs.split(&#34;;&#34;)] + constants.SYMBOL_BASEPATHS

        if partial_args.log:
            file_logger = logging.FileHandler(partial_args.log)
            #file_logger.setLevel(1)
            file_formatter = logging.Formatter(datefmt=&#39;%y-%m-%d %H:%M:%S&#39;,
                                               fmt=&#39;%(asctime)s %(name)-12s %(levelname)-8s %(message)s&#39;)
            file_logger.setFormatter(file_formatter)
            vollog.addHandler(file_logger)
            vollog.info(&#34;Logging started&#34;)
        if partial_args.verbosity &lt; 3:
            console.setLevel(30 - (partial_args.verbosity * 10))
        else:
            console.setLevel(10 - (partial_args.verbosity - 2))
        #console.setLevel(0)

        vollog.info(&#34;Volatility plugins path: {}&#34;.format(
            volatility.plugins.__path__))
        vollog.info(&#34;Volatility symbols path: {}&#34;.format(
            volatility.symbols.__path__))

        # Set the PARALLELISM
        if partial_args.parallelism == &#39;processes&#39;:
            constants.PARALLELISM = constants.Parallelism.Multiprocessing
        elif partial_args.parallelism == &#39;threading&#39;:
            constants.PARALLELISM = constants.Parallelism.Threading
        else:
            constants.PARALLELISM = constants.Parallelism.Off

        # Do the initialization
        ctx = contexts.Context()  # Construct a blank context
        failures = framework.import_files(volatility.plugins,
                                          True)  # Will not log as console&#39;s default level is WARNING
        if failures:
            parser.epilog = &#34;The following plugins could not be loaded (use -vv to see why): &#34; + \
                &#34;, &#34;.join(sorted(failures))
            vollog.info(parser.epilog)
        automagics = automagic.available(ctx)

        plugin_list = framework.list_plugins()

        seen_automagics = set()
        configurables_list = {}
        for amagic in automagics:
            if amagic in seen_automagics:
                continue
            seen_automagics.add(amagic)
            if isinstance(amagic, interfaces.configuration.ConfigurableInterface):
                self.populate_requirements_argparse(parser, amagic.__class__)
                configurables_list[amagic.__class__.__name__] = amagic

        subparser = parser.add_subparsers(
            title=&#34;Plugins&#34;, dest=&#34;plugin&#34;, action=HelpfulSubparserAction)
        for plugin in sorted(plugin_list):
            plugin_parser = subparser.add_parser(
                plugin, help=plugin_list[plugin].__doc__)
            self.populate_requirements_argparse(
                plugin_parser, plugin_list[plugin])
            configurables_list[plugin] = plugin_list[plugin]

        ###
        # PASS TO UI
        ###
        # Hand the plugin requirements over to the CLI (us) and let it construct the config tree

        # Run the argparser
        args = parser.parse_args(arg_arr)
        print(partial_args.verbosity)
        print(args.plugin, type(args.plugin))
        if args.plugin is None:
            parser.error(&#34;Please select a plugin to run&#34;)

        vollog.log(constants.LOGLEVEL_VVV,
                   &#34;Cache directory used: {}&#34;.format(constants.CACHE_PATH))

        plugin = plugin_list[args.plugin]
        base_config_path = &#34;plugins&#34;
        plugin_config_path = interfaces.configuration.path_join(
            base_config_path, plugin.__name__)

        # Special case the -f argument because people use is so frequently
        # It has to go here so it can be overridden by single-location if it&#39;s defined
        # NOTE: This will *BREAK* if LayerStacker, or the automagic configuration system, changes at all
        ###
        if args.file:
            file_name = os.path.abspath(args.file)
            if not os.path.exists(file_name) and &#34;panda.panda&#34; not in file_name:
                print(&#34;File does not exist: {}&#34;.format(file_name))
            else:
                single_location = &#34;file:&#34; + request.pathname2url(file_name)
                ctx.config[&#39;automagic.LayerStacker.single_location&#39;] = single_location

        # UI fills in the config, here we load it from the config file and do it before we process the CL parameters
        if args.config:
            with open(args.config, &#34;r&#34;) as f:
                json_val = json.load(f)
                ctx.config.splice(
                    plugin_config_path, interfaces.configuration.HierarchicalDict(json_val))

        self.populate_config(ctx, configurables_list, args, plugin_config_path)

        if args.extend:
            for extension in args.extend:
                if &#39;=&#39; not in extension:
                    raise ValueError(
                        &#34;Invalid extension (extensions must be of the format \&#34;conf.path.value=&#39;value&#39;\&#34;)&#34;)
                address, value = extension[:extension.find(&#39;=&#39;)], json.loads(
                    extension[extension.find(&#39;=&#39;) + 1:])
                ctx.config[address] = value

        # It should be up to the UI to determine which automagics to run, so this is before BACK TO THE FRAMEWORK
        automagics = automagic.choose_automagic(automagics, plugin)
        self.output_dir = args.output_dir

        ###
        # BACK TO THE FRAMEWORK
        ###
        try:
            progress_callback = PrintedProgress()
            if args.quiet:
                progress_callback = MuteProgress()

            constructed = plugins.construct_plugin(
                ctx, automagics, plugin, base_config_path, progress_callback, self)
        #       return (ctx, automagics, plugin, base_config_path, progress_callback, self)

            if args.write_config:
                vollog.debug(&#34;Writing out configuration data to config.json&#34;)
                with open(&#34;config.json&#34;, &#34;w&#34;) as f:
                    json.dump(dict(constructed.build_configuration()),
                              f, sort_keys=True, indent=2)
            # return StringTextRenderer().render(constructed.run())
            return constructed
        except exceptions.UnsatisfiedException as excp:
            self.process_exceptions(excp)
            parser.exit(1, &#34;Unable to validate the plugin requirements: {}\n&#34;.format(
                [x for x in excp.unsatisfied]))

    def process_exceptions(self, excp):
        &#34;&#34;&#34;Provide useful feedback if an exception occurs.&#34;&#34;&#34;
        # Add a blank newline
        print(&#34;&#34;)
        translation_failed = False
        symbols_failed = False
        for config_path in excp.unsatisfied:
            translation_failed = translation_failed or isinstance(
                excp.unsatisfied[config_path], configuration.requirements.TranslationLayerRequirement)
            symbols_failed = symbols_failed or isinstance(excp.unsatisfied[config_path],
                                                          configuration.requirements.SymbolTableRequirement)

            print(&#34;Unsatisfied requirement {}: {}&#34;.format(
                config_path, excp.unsatisfied[config_path].description))

        if symbols_failed:
            print(&#34;\nA symbol table requirement was not fulfilled.      Please verify that:\n&#34;
                  &#34;\tYou have the correct symbol file for the requirement\n&#34;
                  &#34;\tThe symbol file is under the correct directory or zip file\n&#34;
                  &#34;\tThe symbol file is named appropriately or contains the correct banner\n&#34;)
        if translation_failed:
            print(&#34;\nA translation layer requirement was not fulfilled.  Please verify that:\n&#34;
                  &#34;\tA file was provided to create this layer (by -f, --single-location or by config)\n&#34;
                  &#34;\tThe file exists and is readable\n&#34;
                  &#34;\tThe necessary symbols are present and identified by volatility&#34;)

    def populate_config(self, context: interfaces.context.ContextInterface,
                        configurables_list: Dict[str, interfaces.configuration.ConfigurableInterface],
                        args: argparse.Namespace, plugin_config_path: str) -&gt; None:
        &#34;&#34;&#34;Populate the context config based on the returned args.

        We have already determined these elements must be descended from ConfigurableInterface

        Args:
                context: The volatility context to operate on
                configurables_list: A dictionary of configurable items that can be configured on the plugin
                args: An object containing the arguments necessary
                plugin_config_path: The path within the context&#39;s config containing the plugin&#39;s configuration
        &#34;&#34;&#34;
        vargs = vars(args)
        for configurable in configurables_list:
            for requirement in configurables_list[configurable].get_requirements():
                value = vargs.get(requirement.name, None)
                if value is not None:
                    if isinstance(requirement, requirements.URIRequirement):
                        if isinstance(value, str):
                            if not parse.urlparse(value).scheme:
                                if not os.path.exists(value):
                                    raise TypeError(
                                        &#34;Non-existant file {} passed to URIRequirement&#34;.format(value))
                                value = &#34;file://&#34; + \
                                    request.pathname2url(
                                        os.path.abspath(value))
                    if isinstance(requirement, requirements.ListRequirement):
                        if not isinstance(value, list):
                            raise TypeError(
                                &#34;Configuration for ListRequirement was not a list&#34;)
                        value = [requirement.element_type(x) for x in value]
                    if not inspect.isclass(configurables_list[configurable]):
                        config_path = configurables_list[configurable].config_path
                    else:
                        # We must be the plugin, so name it appropriately:
                        config_path = plugin_config_path
                    extended_path = interfaces.configuration.path_join(
                        config_path, requirement.name)
                    context.config[extended_path] = value
                    pdb.set_trace()

    def consume_file(self, filedata: interfaces.plugins.FileInterface):
        &#34;&#34;&#34;Consumes a file as produced by a plugin.&#34;&#34;&#34;
        if self.output_dir is None:
            raise ValueError(
                &#34;Output directory has not been correctly specified&#34;)
        os.makedirs(self.output_dir, exist_ok=True)

        pref_name_array = filedata.preferred_filename.split(&#39;.&#39;)
        filename, extension = os.path.join(self.output_dir, &#39;.&#39;.join(
            pref_name_array[:-1])), pref_name_array[-1]
        output_filename = &#34;{}.{}&#34;.format(filename, extension)

        if not os.path.exists(output_filename):
            with open(output_filename, &#34;wb&#34;) as current_file:
                current_file.write(filedata.data.getvalue())
                vollog.log(
                    logging.INFO, &#34;Saved stored plugin file: {}&#34;.format(output_filename))
        else:
            vollog.warning(
                &#34;Refusing to overwrite an existing file: {}&#34;.format(output_filename))

    def populate_requirements_argparse(self, parser: Union[argparse.ArgumentParser, argparse._ArgumentGroup],
                                       configurable: Type[interfaces.configuration.ConfigurableInterface]):
        &#34;&#34;&#34;Adds the plugin&#39;s simple requirements to the provided parser.

        Args:
                parser: The parser to add the plugin&#39;s (simple) requirements to
                configurable: The plugin object to pull the requirements from
        &#34;&#34;&#34;
        if not issubclass(configurable, interfaces.configuration.ConfigurableInterface):
            raise TypeError(
                &#34;Expected ConfigurableInterface type, not: {}&#34;.format(type(configurable)))

        # Construct an argparse group

        for requirement in configurable.get_requirements():
            additional = {}  # type: Dict[str, Any]
            if not isinstance(requirement, interfaces.configuration.RequirementInterface):
                raise TypeError(&#34;Plugin contains requirements that are not RequirementInterfaces: {}&#34;.format(
                    configurable.__name__))
            if isinstance(requirement, interfaces.configuration.SimpleTypeRequirement):
                additional[&#34;type&#34;] = requirement.instance_type
                if isinstance(requirement, requirements.IntRequirement):
                    additional[&#34;type&#34;] = lambda x: int(x, 0)
                if isinstance(requirement, requirements.BooleanRequirement):
                    additional[&#34;action&#34;] = &#34;store_true&#34;
                    if &#34;type&#34; in additional:
                        del additional[&#34;type&#34;]
            elif isinstance(requirement, volatility.framework.configuration.requirements.ListRequirement):
                # This is a trick to generate a list of values
                additional[&#34;type&#34;] = lambda x: x.split(&#39;,&#39;)
            elif isinstance(requirement, volatility.framework.configuration.requirements.ChoiceRequirement):
                additional[&#34;type&#34;] = str
                additional[&#34;choices&#34;] = requirement.choices
            else:
                continue
            parser.add_argument(&#34;--&#34; + requirement.name.replace(&#39;_&#39;, &#39;-&#39;),
                                help=requirement.description,
                                default=requirement.default,
                                dest=requirement.name,
                                required=not requirement.optional,
                                **additional)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>volatility.framework.interfaces.plugins.FileConsumerInterface</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="panda.volatility_cli_classes.CommandLineRunFullCommand.consume_file"><code class="name flex">
<span>def <span class="ident">consume_file</span></span>(<span>self, filedata:volatility.framework.interfaces.plugins.FileInterface)</span>
</code></dt>
<dd>
<div class="desc"><p>Consumes a file as produced by a plugin.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def consume_file(self, filedata: interfaces.plugins.FileInterface):
    &#34;&#34;&#34;Consumes a file as produced by a plugin.&#34;&#34;&#34;
    if self.output_dir is None:
        raise ValueError(
            &#34;Output directory has not been correctly specified&#34;)
    os.makedirs(self.output_dir, exist_ok=True)

    pref_name_array = filedata.preferred_filename.split(&#39;.&#39;)
    filename, extension = os.path.join(self.output_dir, &#39;.&#39;.join(
        pref_name_array[:-1])), pref_name_array[-1]
    output_filename = &#34;{}.{}&#34;.format(filename, extension)

    if not os.path.exists(output_filename):
        with open(output_filename, &#34;wb&#34;) as current_file:
            current_file.write(filedata.data.getvalue())
            vollog.log(
                logging.INFO, &#34;Saved stored plugin file: {}&#34;.format(output_filename))
    else:
        vollog.warning(
            &#34;Refusing to overwrite an existing file: {}&#34;.format(output_filename))</code></pre>
</details>
</dd>
<dt id="panda.volatility_cli_classes.CommandLineRunFullCommand.populate_config"><code class="name flex">
<span>def <span class="ident">populate_config</span></span>(<span>self, context:volatility.framework.interfaces.context.ContextInterface, configurables_list:Dict[str,volatility.framework.interfaces.configuration.ConfigurableInterface], args:argparse.Namespace, plugin_config_path:str) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Populate the context config based on the returned args.</p>
<p>We have already determined these elements must be descended from ConfigurableInterface</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong></dt>
<dd>The volatility context to operate on</dd>
<dt><strong><code>configurables_list</code></strong></dt>
<dd>A dictionary of configurable items that can be configured on the plugin</dd>
<dt><strong><code>args</code></strong></dt>
<dd>An object containing the arguments necessary</dd>
<dt><strong><code>plugin_config_path</code></strong></dt>
<dd>The path within the context's config containing the plugin's configuration</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_config(self, context: interfaces.context.ContextInterface,
                    configurables_list: Dict[str, interfaces.configuration.ConfigurableInterface],
                    args: argparse.Namespace, plugin_config_path: str) -&gt; None:
    &#34;&#34;&#34;Populate the context config based on the returned args.

    We have already determined these elements must be descended from ConfigurableInterface

    Args:
            context: The volatility context to operate on
            configurables_list: A dictionary of configurable items that can be configured on the plugin
            args: An object containing the arguments necessary
            plugin_config_path: The path within the context&#39;s config containing the plugin&#39;s configuration
    &#34;&#34;&#34;
    vargs = vars(args)
    for configurable in configurables_list:
        for requirement in configurables_list[configurable].get_requirements():
            value = vargs.get(requirement.name, None)
            if value is not None:
                if isinstance(requirement, requirements.URIRequirement):
                    if isinstance(value, str):
                        if not parse.urlparse(value).scheme:
                            if not os.path.exists(value):
                                raise TypeError(
                                    &#34;Non-existant file {} passed to URIRequirement&#34;.format(value))
                            value = &#34;file://&#34; + \
                                request.pathname2url(
                                    os.path.abspath(value))
                if isinstance(requirement, requirements.ListRequirement):
                    if not isinstance(value, list):
                        raise TypeError(
                            &#34;Configuration for ListRequirement was not a list&#34;)
                    value = [requirement.element_type(x) for x in value]
                if not inspect.isclass(configurables_list[configurable]):
                    config_path = configurables_list[configurable].config_path
                else:
                    # We must be the plugin, so name it appropriately:
                    config_path = plugin_config_path
                extended_path = interfaces.configuration.path_join(
                    config_path, requirement.name)
                context.config[extended_path] = value
                pdb.set_trace()</code></pre>
</details>
</dd>
<dt id="panda.volatility_cli_classes.CommandLineRunFullCommand.populate_requirements_argparse"><code class="name flex">
<span>def <span class="ident">populate_requirements_argparse</span></span>(<span>self, parser:Union[argparse.ArgumentParser,argparse._ArgumentGroup], configurable:Type[volatility.framework.interfaces.configuration.ConfigurableInterface])</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the plugin's simple requirements to the provided parser.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parser</code></strong></dt>
<dd>The parser to add the plugin's (simple) requirements to</dd>
<dt><strong><code>configurable</code></strong></dt>
<dd>The plugin object to pull the requirements from</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_requirements_argparse(self, parser: Union[argparse.ArgumentParser, argparse._ArgumentGroup],
                                   configurable: Type[interfaces.configuration.ConfigurableInterface]):
    &#34;&#34;&#34;Adds the plugin&#39;s simple requirements to the provided parser.

    Args:
            parser: The parser to add the plugin&#39;s (simple) requirements to
            configurable: The plugin object to pull the requirements from
    &#34;&#34;&#34;
    if not issubclass(configurable, interfaces.configuration.ConfigurableInterface):
        raise TypeError(
            &#34;Expected ConfigurableInterface type, not: {}&#34;.format(type(configurable)))

    # Construct an argparse group

    for requirement in configurable.get_requirements():
        additional = {}  # type: Dict[str, Any]
        if not isinstance(requirement, interfaces.configuration.RequirementInterface):
            raise TypeError(&#34;Plugin contains requirements that are not RequirementInterfaces: {}&#34;.format(
                configurable.__name__))
        if isinstance(requirement, interfaces.configuration.SimpleTypeRequirement):
            additional[&#34;type&#34;] = requirement.instance_type
            if isinstance(requirement, requirements.IntRequirement):
                additional[&#34;type&#34;] = lambda x: int(x, 0)
            if isinstance(requirement, requirements.BooleanRequirement):
                additional[&#34;action&#34;] = &#34;store_true&#34;
                if &#34;type&#34; in additional:
                    del additional[&#34;type&#34;]
        elif isinstance(requirement, volatility.framework.configuration.requirements.ListRequirement):
            # This is a trick to generate a list of values
            additional[&#34;type&#34;] = lambda x: x.split(&#39;,&#39;)
        elif isinstance(requirement, volatility.framework.configuration.requirements.ChoiceRequirement):
            additional[&#34;type&#34;] = str
            additional[&#34;choices&#34;] = requirement.choices
        else:
            continue
        parser.add_argument(&#34;--&#34; + requirement.name.replace(&#39;_&#39;, &#39;-&#39;),
                            help=requirement.description,
                            default=requirement.default,
                            dest=requirement.name,
                            required=not requirement.optional,
                            **additional)</code></pre>
</details>
</dd>
<dt id="panda.volatility_cli_classes.CommandLineRunFullCommand.process_exceptions"><code class="name flex">
<span>def <span class="ident">process_exceptions</span></span>(<span>self, excp)</span>
</code></dt>
<dd>
<div class="desc"><p>Provide useful feedback if an exception occurs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_exceptions(self, excp):
    &#34;&#34;&#34;Provide useful feedback if an exception occurs.&#34;&#34;&#34;
    # Add a blank newline
    print(&#34;&#34;)
    translation_failed = False
    symbols_failed = False
    for config_path in excp.unsatisfied:
        translation_failed = translation_failed or isinstance(
            excp.unsatisfied[config_path], configuration.requirements.TranslationLayerRequirement)
        symbols_failed = symbols_failed or isinstance(excp.unsatisfied[config_path],
                                                      configuration.requirements.SymbolTableRequirement)

        print(&#34;Unsatisfied requirement {}: {}&#34;.format(
            config_path, excp.unsatisfied[config_path].description))

    if symbols_failed:
        print(&#34;\nA symbol table requirement was not fulfilled.      Please verify that:\n&#34;
              &#34;\tYou have the correct symbol file for the requirement\n&#34;
              &#34;\tThe symbol file is under the correct directory or zip file\n&#34;
              &#34;\tThe symbol file is named appropriately or contains the correct banner\n&#34;)
    if translation_failed:
        print(&#34;\nA translation layer requirement was not fulfilled.  Please verify that:\n&#34;
              &#34;\tA file was provided to create this layer (by -f, --single-location or by config)\n&#34;
              &#34;\tThe file exists and is readable\n&#34;
              &#34;\tThe necessary symbols are present and identified by volatility&#34;)</code></pre>
</details>
</dd>
<dt id="panda.volatility_cli_classes.CommandLineRunFullCommand.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, argstring)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, argstring):
    # Make sure we log everything

    vollog = logging.getLogger()
    #vollog.setLevel(1)
    # Trim the console down by default
    console = logging.StreamHandler()
    #console.setLevel(logging.FATAL)
    formatter = logging.Formatter(
        &#39;%(levelname)-8s %(name)-12s: %(message)s&#39;)
    console.setFormatter(formatter)
    vollog.addHandler(console)
    # Make sure we log everything
    vollog = logging.getLogger()
    #vollog.setLevel(1)
    # Trim the console down by default
    console = logging.StreamHandler()
    #console.setLevel(logging.WARNING)
    formatter = logging.Formatter(
        &#39;%(levelname)-8s %(name)-12s: %(message)s&#39;)
    console.setFormatter(formatter)
    vollog.addHandler(console)
    arg_arr = shlex.split(argstring)
    &#34;&#34;&#34;Executes the command line module, taking the system arguments,
        determining the plugin to run and then running it.&#34;&#34;&#34;
    sys.stdout.write(&#34;Volatility 3 Framework {}\n&#34;.format(
        constants.PACKAGE_VERSION))

    volatility.framework.require_interface_version(1, 0, 0)

    renderers = dict([(x.name.lower(), x)
                      for x in framework.class_subclasses(text_renderer.CLIRenderer)])

    parser = argparse.ArgumentParser(
        prog=&#39;volatility&#39;, description=&#34;An open-source memory forensics framework&#34;)
    parser.add_argument(&#34;-c&#34;,
                        &#34;--config&#34;,
                        help=&#34;Load the configuration from a json file&#34;,
                        default=None,
                        type=str)
    parser.add_argument(&#34;--parallelism&#34;,
                        help=&#34;Enables parallelism (defaults to processes if no argument given)&#34;,
                        nargs=&#39;?&#39;,
                        choices=[&#39;processes&#39;, &#39;threads&#39;, &#39;off&#39;],
                        const=&#39;processes&#39;,
                        default=None,
                        type=str)
    parser.add_argument(&#34;-e&#34;,
                        &#34;--extend&#34;,
                        help=&#34;Extend the configuration with a new (or changed) setting&#34;,
                        default=None,
                        action=&#39;append&#39;)
    parser.add_argument(&#34;-p&#34;,
                        &#34;--plugin-dirs&#34;,
                        help=&#34;Semi-colon separated list of paths to find plugins&#34;,
                        default=&#34;&#34;,
                        type=str)
    parser.add_argument(&#34;-s&#34;,
                        &#34;--symbol-dirs&#34;,
                        help=&#34;Semi-colon separated list of paths to find symbols&#34;,
                        default=&#34;&#34;,
                        type=str)
    parser.add_argument(
        &#34;-v&#34;, &#34;--verbosity&#34;, help=&#34;Increase output verbosity&#34;, default=0, action=&#34;count&#34;)
    parser.add_argument(&#34;-l&#34;,
                        &#34;--log&#34;,
                        help=&#34;Log output to a file as well as the console&#34;,
                        default=None,
                        type=str)
    parser.add_argument(&#34;-o&#34;,
                        &#34;--output-dir&#34;,
                        help=&#34;Directory in which to output any generated files&#34;,
                        default=os.path.abspath(os.path.join(
                            os.path.dirname(__file__), &#39;..&#39;, &#39;..&#39;)),
                        type=str)
    parser.add_argument(
        &#34;-q&#34;, &#34;--quiet&#34;, help=&#34;Remove progress feedback&#34;, default=False, action=&#39;store_true&#39;)
    parser.add_argument(&#34;-r&#34;,
                        &#34;--renderer&#34;,
                        metavar=&#39;RENDERER&#39;,
                        help=&#34;Determines how to render the output ({})&#34;.format(
                            &#34;, &#34;.join(list(renderers))),
                        default=&#34;quick&#34;,
                        choices=list(renderers))
    parser.add_argument(&#34;-f&#34;,
                        &#34;--file&#34;,
                        metavar=&#39;FILE&#39;,
                        default=None,
                        type=str,
                        help=&#34;Shorthand for --single-location=file:// if single-location is not defined&#34;)
    parser.add_argument(&#34;--write-config&#34;,
                        help=&#34;Write configuration JSON file out to config.json&#34;,
                        default=False,
                        action=&#39;store_true&#39;)

    # We have to filter out help, otherwise parse_known_args will trigger the help message before having
    # processed the plugin choice or had the plugin subparser added.
    known_args = [arg for arg in arg_arr if arg !=
                  &#39;--help&#39; and arg != &#39;-h&#39;]
    partial_args, _ = parser.parse_known_args(known_args)
    if partial_args.plugin_dirs:
        volatility.plugins.__path__ = [os.path.abspath(p)
                                       for p in partial_args.plugin_dirs.split(&#34;;&#34;)] + constants.PLUGINS_PATH

    if partial_args.symbol_dirs:
        volatility.symbols.__path__ = [os.path.abspath(p)
                                       for p in partial_args.symbol_dirs.split(&#34;;&#34;)] + constants.SYMBOL_BASEPATHS

    if partial_args.log:
        file_logger = logging.FileHandler(partial_args.log)
        #file_logger.setLevel(1)
        file_formatter = logging.Formatter(datefmt=&#39;%y-%m-%d %H:%M:%S&#39;,
                                           fmt=&#39;%(asctime)s %(name)-12s %(levelname)-8s %(message)s&#39;)
        file_logger.setFormatter(file_formatter)
        vollog.addHandler(file_logger)
        vollog.info(&#34;Logging started&#34;)
    if partial_args.verbosity &lt; 3:
        console.setLevel(30 - (partial_args.verbosity * 10))
    else:
        console.setLevel(10 - (partial_args.verbosity - 2))
    #console.setLevel(0)

    vollog.info(&#34;Volatility plugins path: {}&#34;.format(
        volatility.plugins.__path__))
    vollog.info(&#34;Volatility symbols path: {}&#34;.format(
        volatility.symbols.__path__))

    # Set the PARALLELISM
    if partial_args.parallelism == &#39;processes&#39;:
        constants.PARALLELISM = constants.Parallelism.Multiprocessing
    elif partial_args.parallelism == &#39;threading&#39;:
        constants.PARALLELISM = constants.Parallelism.Threading
    else:
        constants.PARALLELISM = constants.Parallelism.Off

    # Do the initialization
    ctx = contexts.Context()  # Construct a blank context
    failures = framework.import_files(volatility.plugins,
                                      True)  # Will not log as console&#39;s default level is WARNING
    if failures:
        parser.epilog = &#34;The following plugins could not be loaded (use -vv to see why): &#34; + \
            &#34;, &#34;.join(sorted(failures))
        vollog.info(parser.epilog)
    automagics = automagic.available(ctx)

    plugin_list = framework.list_plugins()

    seen_automagics = set()
    configurables_list = {}
    for amagic in automagics:
        if amagic in seen_automagics:
            continue
        seen_automagics.add(amagic)
        if isinstance(amagic, interfaces.configuration.ConfigurableInterface):
            self.populate_requirements_argparse(parser, amagic.__class__)
            configurables_list[amagic.__class__.__name__] = amagic

    subparser = parser.add_subparsers(
        title=&#34;Plugins&#34;, dest=&#34;plugin&#34;, action=HelpfulSubparserAction)
    for plugin in sorted(plugin_list):
        plugin_parser = subparser.add_parser(
            plugin, help=plugin_list[plugin].__doc__)
        self.populate_requirements_argparse(
            plugin_parser, plugin_list[plugin])
        configurables_list[plugin] = plugin_list[plugin]

    ###
    # PASS TO UI
    ###
    # Hand the plugin requirements over to the CLI (us) and let it construct the config tree

    # Run the argparser
    args = parser.parse_args(arg_arr)
    print(partial_args.verbosity)
    print(args.plugin, type(args.plugin))
    if args.plugin is None:
        parser.error(&#34;Please select a plugin to run&#34;)

    vollog.log(constants.LOGLEVEL_VVV,
               &#34;Cache directory used: {}&#34;.format(constants.CACHE_PATH))

    plugin = plugin_list[args.plugin]
    base_config_path = &#34;plugins&#34;
    plugin_config_path = interfaces.configuration.path_join(
        base_config_path, plugin.__name__)

    # Special case the -f argument because people use is so frequently
    # It has to go here so it can be overridden by single-location if it&#39;s defined
    # NOTE: This will *BREAK* if LayerStacker, or the automagic configuration system, changes at all
    ###
    if args.file:
        file_name = os.path.abspath(args.file)
        if not os.path.exists(file_name) and &#34;panda.panda&#34; not in file_name:
            print(&#34;File does not exist: {}&#34;.format(file_name))
        else:
            single_location = &#34;file:&#34; + request.pathname2url(file_name)
            ctx.config[&#39;automagic.LayerStacker.single_location&#39;] = single_location

    # UI fills in the config, here we load it from the config file and do it before we process the CL parameters
    if args.config:
        with open(args.config, &#34;r&#34;) as f:
            json_val = json.load(f)
            ctx.config.splice(
                plugin_config_path, interfaces.configuration.HierarchicalDict(json_val))

    self.populate_config(ctx, configurables_list, args, plugin_config_path)

    if args.extend:
        for extension in args.extend:
            if &#39;=&#39; not in extension:
                raise ValueError(
                    &#34;Invalid extension (extensions must be of the format \&#34;conf.path.value=&#39;value&#39;\&#34;)&#34;)
            address, value = extension[:extension.find(&#39;=&#39;)], json.loads(
                extension[extension.find(&#39;=&#39;) + 1:])
            ctx.config[address] = value

    # It should be up to the UI to determine which automagics to run, so this is before BACK TO THE FRAMEWORK
    automagics = automagic.choose_automagic(automagics, plugin)
    self.output_dir = args.output_dir

    ###
    # BACK TO THE FRAMEWORK
    ###
    try:
        progress_callback = PrintedProgress()
        if args.quiet:
            progress_callback = MuteProgress()

        constructed = plugins.construct_plugin(
            ctx, automagics, plugin, base_config_path, progress_callback, self)
    #       return (ctx, automagics, plugin, base_config_path, progress_callback, self)

        if args.write_config:
            vollog.debug(&#34;Writing out configuration data to config.json&#34;)
            with open(&#34;config.json&#34;, &#34;w&#34;) as f:
                json.dump(dict(constructed.build_configuration()),
                          f, sort_keys=True, indent=2)
        # return StringTextRenderer().render(constructed.run())
        return constructed
    except exceptions.UnsatisfiedException as excp:
        self.process_exceptions(excp)
        parser.exit(1, &#34;Unable to validate the plugin requirements: {}\n&#34;.format(
            [x for x in excp.unsatisfied]))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="panda.volatility_cli_classes.StringTextRenderer"><code class="flex name class">
<span>class <span class="ident">StringTextRenderer</span></span>
<span>(</span><span>options:Union[List[Any],NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to add specific requirements for CLI renderers.</p>
<p>Accepts an options object to configure the renderers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringTextRenderer(CLIRenderer):
    _type_renderers = {
        format_hints.Bin: optional(lambda x: &#34;0b{:b}&#34;.format(x)),
        format_hints.Hex: optional(lambda x: &#34;0x{:x}&#34;.format(x)),
        format_hints.HexBytes: optional(hex_bytes_as_text),
        interfaces.renderers.Disassembly: optional(display_disassembly),
        bytes: optional(lambda x: &#34; &#34;.join([&#34;{0:2x}&#34;.format(b) for b in x])),
        datetime.datetime: optional(lambda x: x.strftime(&#34;%Y-%m-%d %H:%M:%S.%f %Z&#34;)),
        &#39;default&#39;: optional(lambda x: &#34;{}&#34;.format(x))
    }

    name = &#34;string&#34;

    def get_render_options(self):
        pass

    def render(self, grid: interfaces.renderers.TreeGrid):
        &#34;&#34;&#34;Renders each column immediately to stdout.

        This does not format each line&#39;s width appropriately, it merely tab separates each field

        Args:
            grid: The TreeGrid object to render
        &#34;&#34;&#34;
        # TODO: Docstrings
        # TODO: Improve text output
        outfd = StringIO()  # sys.stdout
        out = []

        line = []

        column_names = []
        for column in grid.columns:
            # Ignore the type because namedtuples don&#39;t realize they have accessible attributes
            # line.append(&#34;{}&#34;.format(column.name))
            column_names.append(&#34;{}&#34;.format(column.name))
        # outfd.write(&#34;\n{}\n&#34;.format(&#34;\t&#34;.join(line)))
        #outfd += &#34;\n{}\n&#34;.format(&#34;\t&#34;.join(line))

        def visitor(node, accumulator):
            accumulator.write(&#34;\n&#34;)
            # Nodes always have a path value, giving them a path_depth of at least 1, we use max just in case
            #accumulator.write(&#34;*&#34; * max(0, node.path_depth - 1) + (&#34;&#34; if (node.path_depth &lt;= 1) else &#34; &#34;))
            #line = []
            line_output = {}
            for column_index in range(len(grid.columns)):
                column = grid.columns[column_index]
                renderer = self._type_renderers.get(
                    column.type, self._type_renderers[&#39;default&#39;])
                # line.append(renderer(node.values[column_index]))
                column_name = column_names[column_index]
                line_output[column_name] = node.values[column_index]

            out.append(line_output)

            # accumulator.write(&#34;{}&#34;.format(&#34;\t&#34;.join(line)))
            # accumulator.flush()
            return accumulator

        if not grid.populated:
            grid.populate(visitor, outfd)
        else:
            grid.visit(node=None, function=visitor, initial_accumulator=outfd)

        # outfd.write(&#34;\n&#34;)
        return out</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>volatility.cli.text_renderer.CLIRenderer</li>
<li>volatility.framework.interfaces.renderers.Renderer</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="panda.volatility_cli_classes.StringTextRenderer.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="panda.volatility_cli_classes.StringTextRenderer.get_render_options"><code class="name flex">
<span>def <span class="ident">get_render_options</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of rendering options.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_render_options(self):
    pass</code></pre>
</details>
</dd>
<dt id="panda.volatility_cli_classes.StringTextRenderer.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, grid:volatility.framework.interfaces.renderers.TreeGrid)</span>
</code></dt>
<dd>
<div class="desc"><p>Renders each column immediately to stdout.</p>
<p>This does not format each line's width appropriately, it merely tab separates each field</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid</code></strong></dt>
<dd>The TreeGrid object to render</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, grid: interfaces.renderers.TreeGrid):
    &#34;&#34;&#34;Renders each column immediately to stdout.

    This does not format each line&#39;s width appropriately, it merely tab separates each field

    Args:
        grid: The TreeGrid object to render
    &#34;&#34;&#34;
    # TODO: Docstrings
    # TODO: Improve text output
    outfd = StringIO()  # sys.stdout
    out = []

    line = []

    column_names = []
    for column in grid.columns:
        # Ignore the type because namedtuples don&#39;t realize they have accessible attributes
        # line.append(&#34;{}&#34;.format(column.name))
        column_names.append(&#34;{}&#34;.format(column.name))
    # outfd.write(&#34;\n{}\n&#34;.format(&#34;\t&#34;.join(line)))
    #outfd += &#34;\n{}\n&#34;.format(&#34;\t&#34;.join(line))

    def visitor(node, accumulator):
        accumulator.write(&#34;\n&#34;)
        # Nodes always have a path value, giving them a path_depth of at least 1, we use max just in case
        #accumulator.write(&#34;*&#34; * max(0, node.path_depth - 1) + (&#34;&#34; if (node.path_depth &lt;= 1) else &#34; &#34;))
        #line = []
        line_output = {}
        for column_index in range(len(grid.columns)):
            column = grid.columns[column_index]
            renderer = self._type_renderers.get(
                column.type, self._type_renderers[&#39;default&#39;])
            # line.append(renderer(node.values[column_index]))
            column_name = column_names[column_index]
            line_output[column_name] = node.values[column_index]

        out.append(line_output)

        # accumulator.write(&#34;{}&#34;.format(&#34;\t&#34;.join(line)))
        # accumulator.flush()
        return accumulator

    if not grid.populated:
        grid.populate(visitor, outfd)
    else:
        grid.visit(node=None, function=visitor, initial_accumulator=outfd)

    # outfd.write(&#34;\n&#34;)
    return out</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="panda" href="index.html">panda</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="panda.volatility_cli_classes.CommandLineMoreEfficient" href="#panda.volatility_cli_classes.CommandLineMoreEfficient">CommandLineMoreEfficient</a></code></h4>
<ul class="">
<li><code><a title="panda.volatility_cli_classes.CommandLineMoreEfficient.run" href="#panda.volatility_cli_classes.CommandLineMoreEfficient.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="panda.volatility_cli_classes.CommandLineRunFullCommand" href="#panda.volatility_cli_classes.CommandLineRunFullCommand">CommandLineRunFullCommand</a></code></h4>
<ul class="">
<li><code><a title="panda.volatility_cli_classes.CommandLineRunFullCommand.consume_file" href="#panda.volatility_cli_classes.CommandLineRunFullCommand.consume_file">consume_file</a></code></li>
<li><code><a title="panda.volatility_cli_classes.CommandLineRunFullCommand.populate_config" href="#panda.volatility_cli_classes.CommandLineRunFullCommand.populate_config">populate_config</a></code></li>
<li><code><a title="panda.volatility_cli_classes.CommandLineRunFullCommand.populate_requirements_argparse" href="#panda.volatility_cli_classes.CommandLineRunFullCommand.populate_requirements_argparse">populate_requirements_argparse</a></code></li>
<li><code><a title="panda.volatility_cli_classes.CommandLineRunFullCommand.process_exceptions" href="#panda.volatility_cli_classes.CommandLineRunFullCommand.process_exceptions">process_exceptions</a></code></li>
<li><code><a title="panda.volatility_cli_classes.CommandLineRunFullCommand.run" href="#panda.volatility_cli_classes.CommandLineRunFullCommand.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="panda.volatility_cli_classes.StringTextRenderer" href="#panda.volatility_cli_classes.StringTextRenderer">StringTextRenderer</a></code></h4>
<ul class="">
<li><code><a title="panda.volatility_cli_classes.StringTextRenderer.get_render_options" href="#panda.volatility_cli_classes.StringTextRenderer.get_render_options">get_render_options</a></code></li>
<li><code><a title="panda.volatility_cli_classes.StringTextRenderer.name" href="#panda.volatility_cli_classes.StringTextRenderer.name">name</a></code></li>
<li><code><a title="panda.volatility_cli_classes.StringTextRenderer.render" href="#panda.volatility_cli_classes.StringTextRenderer.render">render</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>